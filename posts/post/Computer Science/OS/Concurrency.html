<!DOCTYPE html>
<html lang="en">
	<head>
		<meta charset="utf-8" />
		<link rel="icon" href="/favicon.png" />
		<meta name="viewport" content="width=device-width, initial-scale=1" />

		
		<link href="../../../../_app/immutable/assets/0.CWEFMGw7.css" rel="stylesheet">
		<link href="../../../../_app/immutable/assets/CodeBlockWrapper.DOA6KAmR.css" rel="stylesheet">
		<link rel="modulepreload" href="../../../../_app/immutable/entry/start.CEIBvBpx.js">
		<link rel="modulepreload" href="../../../../_app/immutable/chunks/CMmviHso.js">
		<link rel="modulepreload" href="../../../../_app/immutable/chunks/CVx5jffJ.js">
		<link rel="modulepreload" href="../../../../_app/immutable/chunks/DIeogL5L.js">
		<link rel="modulepreload" href="../../../../_app/immutable/chunks/DMgF1Uhx.js">
		<link rel="modulepreload" href="../../../../_app/immutable/chunks/D0iwhpLH.js">
		<link rel="modulepreload" href="../../../../_app/immutable/chunks/ByF348JK.js">
		<link rel="modulepreload" href="../../../../_app/immutable/entry/app.DrSGtxGh.js">
		<link rel="modulepreload" href="../../../../_app/immutable/chunks/Dp1pzeXC.js">
		<link rel="modulepreload" href="../../../../_app/immutable/chunks/D_kqQSo5.js">
		<link rel="modulepreload" href="../../../../_app/immutable/chunks/2cXyNWGb.js">
		<link rel="modulepreload" href="../../../../_app/immutable/chunks/Bzak7iHL.js">
		<link rel="modulepreload" href="../../../../_app/immutable/chunks/Ca2j7qFz.js">
		<link rel="modulepreload" href="../../../../_app/immutable/chunks/BmVC6lTd.js">
		<link rel="modulepreload" href="../../../../_app/immutable/chunks/BnZK2-eX.js">
		<link rel="modulepreload" href="../../../../_app/immutable/chunks/C0t2u1D1.js">
		<link rel="modulepreload" href="../../../../_app/immutable/nodes/0.Ud5VFKaA.js">
		<link rel="modulepreload" href="../../../../_app/immutable/chunks/D7leeM5l.js">
		<link rel="modulepreload" href="../../../../_app/immutable/chunks/DKQVeb5P.js">
		<link rel="modulepreload" href="../../../../_app/immutable/chunks/CP-r3QU3.js">
		<link rel="modulepreload" href="../../../../_app/immutable/chunks/Bp7YhWCs.js">
		<link rel="modulepreload" href="../../../../_app/immutable/chunks/DkPbIObf.js">
		<link rel="modulepreload" href="../../../../_app/immutable/chunks/69_IOA4Y.js">
		<link rel="modulepreload" href="../../../../_app/immutable/chunks/D2vXKg8d.js">
		<link rel="modulepreload" href="../../../../_app/immutable/chunks/DJh_0fka.js">
		<link rel="modulepreload" href="../../../../_app/immutable/chunks/Dg0EvQHI.js">
		<link rel="modulepreload" href="../../../../_app/immutable/nodes/12.DiHZsoj1.js">
		<link rel="modulepreload" href="../../../../_app/immutable/chunks/DF2T1Nhr.js">
		<link rel="modulepreload" href="../../../../_app/immutable/chunks/CxRPdVhl.js"><!--1y1qu0s--><meta data-key="description" name="description" content="Concepts about concurrency"/> <meta property="og:type" content="article"/> <meta property="og:title" content="동시성 관련 개념 정리"/> <meta property="og:description" content="Concepts about concurrency"/><!----><title>동시성 관련 개념 정리</title>
		<!-- You can replace this block to update the Google fonts used in the project -->
		<!-- <link rel="preconnect" href="https://fonts.googleapis.com" />
		<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin /> -->
		<link
			rel="stylesheet"
			href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.7.1/styles/github.min.css"
		/>
		<link
			href="https://fonts.googleapis.com/css2?&family=Nanum+Gothic&family=Jua&family=Source+Code+Pro:wght@400&display=swap"
			rel="stylesheet"
		/>

		<!-- End Google Fonts block -->

		<!-- You can add global <meta> tags here, but anything not global or dynamic should be a `<svelte:head>` tag on the proper page(s) instead. -->
	</head>
	<body>
		<div id="svelte"><!--[--><!--[--><!----><div class="layout"><header><a class="skip-to-content-link" href="#main">Skip to main content</a> <nav class="main-nav"><ul><!--[--><li><a href="/posts" aria-current="false"><!---->Posts<!----></a></li><li><a href="/category" aria-current="false"><!---->Categories<!----></a></li><li><a href="/about" aria-current="false"><!---->About<!----></a></li><li><a href="/api/rss.xml" aria-current="false"><!---->RSS<!----></a></li><li><a href="/#" aria-current="false"><!---->Home<!----></a></li><!--]--></ul> <button aria-pressed="false" class="menu-button" tabindex="-1"><span class="sr-only">Toggle hamburger menu</span> <!--[--><svg viewBox="0 0 128 128" version="1.1" style="fill-rule:evenodd;clip-rule:evenodd;stroke-linejoin:round;stroke-miterlimit:2;"><path d="M64,48.496l-48.496,-48.496l-15.504,15.504l48.496,48.496l-48.496,48.496l15.504,15.504l48.496,-48.496l48.496,48.496l15.504,-15.504l-48.496,-48.496l48.496,-48.496l-15.504,-15.504l-48.496,48.496Z"></path></svg><!--]--></button><!----></nav><!----> <button aria-pressed="false" class="menu-button" tabindex="0"><span class="sr-only">Toggle hamburger menu</span> <!--[!--><svg viewBox="0 0 128 128" version="1.1" style="fill-rule:evenodd;clip-rule:evenodd;stroke-linejoin:round;stroke-miterlimit:2;"><g><rect x="0" y="12.48" width="128" height="18.688"></rect></g><g><rect x="0" y="96.832" width="128" height="18.688"></rect></g><g><rect x="0" y="54.656" width="128" height="18.688"></rect></g></svg><!--]--></button><!----> <a href="/" class="site-title">집밥서선생</a> <button class="toggle-theme"><!--[-->☀️<!--]--></button><!----></header><!----> <main id="main" tabindex="-1"><!----><div class="content"><!----><article class="post"><img class="cover-image" src="/post_img/Computer Science/OS/Concurrency/cover.png" alt="" style="aspect-ratio: 16 / 9;" width="16" height="9"/> <h1>동시성 관련 개념 정리</h1> <div class="meta"><b>Published:</b> 2023-08-18</div> <!----><p><strong>Effective Concurrency in Go</strong>를 읽던 중, 동시성 관련해서 좋은 내용들이 많이 나와서 한 번 개념을 정리해보았읍니다.</p> <ul><li>본 포스트 안에서 쓰레드와 고루틴을 혼용해서 사용했는데, 얼추 비슷한 애들이라고 생각하시면 됩니다.</li></ul> <br/><br/> <h2 id="동시성concurrency-vs-병렬성parallelism"><a aria-hidden="true" tabindex="-1" href="#동시성concurrency-vs-병렬성parallelism"><span class="icon icon-link"></span></a>동시성(Concurrency) vs 병렬성(Parallelism)</h2> <hr/> <h3 id="동시성concurrency"><a aria-hidden="true" tabindex="-1" href="#동시성concurrency"><span class="icon icon-link"></span></a>동시성(Concurrency)</h3> <ul><li><p>여러 작업을 동시에 수행하는 것<strong>처럼 보이는 것</strong><br/> 실제로는 여러 작업을 <strong>동시에 수행하는 것이 아니라, 짧은 시간 간격으로 번갈아가며 수행하는 것</strong>이다.<br/> 싱글 코어에서도 동시성을 구현할 수 있음.</p></li> <li><p>엄밀한 정의는, <strong>결과에 영향을 주지 않고, 프로그램의 서로 다른 부분이 partial order 또는 순서에 관계없이 실행될 수 있는 것</strong>을 의미함.<br/> 프로그램이 A,B,C로 구성되어 있을 때, A,C,B 또는 B,C,A 등로 실행되어도 결과에 영향을 주지 않는다면, 이 프로그램은 동시성을 가지고 있다고 할 수 있음.</p></li></ul> <h3 id="병렬성parallelism"><a aria-hidden="true" tabindex="-1" href="#병렬성parallelism"><span class="icon icon-link"></span></a>병렬성(Parallelism)</h3> <ul><li>여러 작업을 <strong>동시에 수행하는 것</strong><br/> 실제로 여러 작업이 <strong>동시에 수행됨</strong><br/> 멀티 코어, 즉 서로 다른 CPU 코어에서 돌아가는 프로세스나 쓰레드가 이에 해당함.</li></ul> <h3 id="동시성과-병렬성의-차이"><a aria-hidden="true" tabindex="-1" href="#동시성과-병렬성의-차이"><span class="icon icon-link"></span></a>동시성과 병렬성의 차이</h3> <p>동시성은 프로그램이 <span style="background-color: var(--highlightYellow)"><!---->작성되는 방식<!----></span><!---->에 관련된 것이고, 병렬성은 프로그램이 <span style="background-color: var(--highlightYellow)"><!---->실행되는 방식<!----></span><!---->에 관련된 것이다.</p> <br/><br/> <h2 id="동시성-프로그래밍"><a aria-hidden="true" tabindex="-1" href="#동시성-프로그래밍"><span class="icon icon-link"></span></a>동시성 프로그래밍</h2> <hr/> <ul><li>문제를 실행 단위로 나누어 time sharing 또는 병렬적으로 실행될 수 있게끔 하는 것</li> <li>이들은 서로 병렬적으로 또는 인터리빙(interleaving)되어 실행될 수 있으며, 메시지를 통해 통신할 수 있음.</li> <li>따라서 동시성 프로그래밍은 객체지향이나 함수형 프로그래밍처럼, 프로그램을 작성하는 방식이라고도 할 수 있음.</li></ul> <h3 id="time-sharing과-context-switching"><a aria-hidden="true" tabindex="-1" href="#time-sharing과-context-switching"><span class="icon icon-link"></span></a>Time Sharing과 Context Switching</h3> <ul><li>컴퓨팅 리소스(주로 CPU)를 여러 프로그램이 공유하는 것.</li> <li>어떤 프로세스가 여러 쓰레드로 구성되어 있다 할 때, 한 쓰레드가 일정한 time quantum 동안 CPU를 사용하고, 그 다음 쓰레드가 CPU를 사용하는 방식으로 진행됨. <ul><li>이를 <span style="background-color: var(--highlightYellow)"><!---->Context Switching<!----></span><!---->이라고 함.</li> <li>쓰레드의 실행 컨텍스트에는 해당 쓰레드의 state(레지스터 값, 프로그램 카운터, Stack Pointer 등)가 저장되어 있음.</li> <li>Context Switching이 발생하면, 현재 쓰레드의 state가 저장되고, 다음 쓰레드의 state가 복원됨.</li></ul></li> <li><strong>Preemptive Thread Scheduling</strong>에서는 쓰레드가 실행되는 도중 Context Switching이 발생할 수 있음.</li> <li><strong>Non-Preemptive Thread Scheduling</strong>(<strong>Cooperative Threading</strong>)에서는 쓰레드가 실행을 마칠 때까지 Context Switching이 발생하지 않음.</li></ul> <blockquote><p>정보) Go 언어에서는 1.14 이전까지는 Non-Preemptive Thread Scheduling을 사용하였으나, 1.14부터 Preemptive Thread Scheduling을 사용하도록 변경되었다.</p></blockquote> <ul><li>쓰레드의 상태와 스케줄링 <ul><li>쓰레드가 실행되면 <em>Ready</em> state로 들어가고, CPU를 사용할 수 있을 때 <em>Running</em> state로 들어감.</li> <li><em>Running</em> state의 쓰레드는 time quantum이 끝나면 다시 <em>Ready</em> state로 돌아감.</li> <li><em>Running</em> state의 쓰레드가 I/O 작업 등으로 인한 인터럽트가 발생하거나, lock을 획득하지 못하면 <em>Blocked</em> state로 들어감.</li> <li><em>Blocked</em> state의 쓰레드는 I/O 작업이 끝나거나, lock을 획득하면 다시 <em>Ready</em> state로 돌아가게 되고, 스케줄러에 의해 선택되기를 기다림. <ul><li>이 때 <em>Ready</em> state의 쓰레드가 바로 실행되리라는 보장은 없음.</li></ul></li></ul></li></ul> <h3 id="동시성-프로그래밍은-왜-어려운가"><a aria-hidden="true" tabindex="-1" href="#동시성-프로그래밍은-왜-어려운가"><span class="icon icon-link"></span></a>동시성 프로그래밍은 왜 어려운가?</h3> <p>상태 관리의 어려움 때문임</p> <ul><li>각각의 Sequantial Program은 상태(state)를 가지고 있음. <ul><li>state는 Sequantial Program의 실행 위치와 메모리에 저장된 값을 의미함</li> <li>프로그램의 현재 state에 따라 다음 state를 예측할 수 있음</li></ul></li> <li>그런데 동시에 여러 프로그램이 실행되면 각각의 Sequantial Program이 가지고 있는 state가 서로 영향을 미칠 수 있음.</li> <li>Sequantial Program이 많아질수록, 가능한 state의 수가 많아질수록 전체 프로그램이 가질 수 있는 state의 경우의 수가 기하급수적으로 증가함 <ul><li>n개의 state가 있는 Sequantial Program이 m개 실행되면 n^m개의 state가 존재함</li></ul></li></ul> <p>따라서, 일반적인 state 분석으로 동시성 프로그램의 행동을 예측하기 어려움.</p> <h3 id="happened-before-관계"><a aria-hidden="true" tabindex="-1" href="#happened-before-관계"><span class="icon icon-link"></span></a>Happened-Before 관계</h3> <ul><li>두 개의 서로 같지 않은 정수가 있다면, 이들의 대소 관계를 알 수 있음.</li> <li>마찬가지로 한 Sequantial Program에서 발생한 서로 다른 두 이벤트가 있다면, 한 이벤트는 반드시 다른 이벤트보다 먼저 발생했을 것임. <ul><li>이를 <span style="background-color: var(--highlightYellow)"><!---->Total Order<!----></span><!---->라고 함.</li></ul></li> <li>서로 다른 프로세스에서 발생한 이벤트에 순서를 정하는 것은 불가능하지만, Message Passing 등을 통해 이벤트의 순서를 일부 정의할 수 있음. <ul><li>이를 <span style="background-color: var(--highlightYellow)"><!---->Partial Order<!----></span><!---->라고 함.</li></ul></li></ul> <h3 id="dining-philosopher-problem"><a aria-hidden="true" tabindex="-1" href="#dining-philosopher-problem"><span class="icon icon-link"></span></a>Dining Philosopher Problem</h3> <ul><li><p>문제 정의</p> <ul><li>철학자들이 원형 테이블에 앉아있음.</li> <li>테이블 위에는 포크가 5개 놓여있음.</li> <li>철학자들은 생각을 하다가 배가 고파지면 양 옆의 포크를 집어들어 먹기 시작함.</li> <li>식사를 마치면 포크를 내려놓고 다시 생각을 하기 시작함.</li></ul></li> <li><p>Deadlock 발생 가능성</p> <ul><li>모든 철학자가 자신의 왼쪽 포크만을 집어든 상태라면, 모든 철학자는 다음 포크를 집어들기 위해 오른쪽 철학자가 포크를 내려놓기를 기다려야 함.</li> <li>이 상태에서는 모든 철학자가 포크를 내려놓기를 기다리는 상태로 무한 대기 상태에 빠짐.</li> <li>한 철학자가 자신의 포크를 내려놓지 않는 이상, 다른 철학자들은 포크를 집어들 수 없음.</li></ul></li></ul> <br/><br/> <h2 id="shared-memory와-message-passing"><a aria-hidden="true" tabindex="-1" href="#shared-memory와-message-passing"><span class="icon icon-link"></span></a>Shared Memory와 Message Passing</h2> <hr/> <h3 id="관련-computer-architecture-지식"><a aria-hidden="true" tabindex="-1" href="#관련-computer-architecture-지식"><span class="icon icon-link"></span></a>관련 Computer Architecture 지식</h3> <ul><li><p>UMA(Uniform Memory Access)</p> <ul><li>메모리에 접근할 때 모든 프로세서가 동일한 권한을 가지고 있음.</li> <li>동일한 메모리 액세스 버스가 공유되기 때문에 처리량이 감소할 수 있음.</li></ul></li> <li><p>NUMA(Non-Uniform Memory Access)</p> <ul><li>프로세서는 메모리의 특정 영역에 대해서만 접근 권한을 가짐</li> <li>OS가 프로세서에서 필요한 메모리를 해당 영역에 할당함으로써 전용 메모리 액세스 버스를 사용할 수 있기 때문에 처리량이 증가할 수 있음.</li></ul></li> <li><p>대부분의 프로세서는 캐시 메모리를 사용하며, 캐시 일관성(Cache Coherence) 프로토콜을 사용하여 캐시 메모리의 일관성을 유지함.</p></li> <li><p>현대 프로세서는 메모리 read 및 write가 완료될 때까지 기다리지 않음. 파이프라이닝(Pipelining)을 통해 다음 명령어를 동시에 실행함.</p> <ul><li>이 때 파이프라이닝의 최적화를 위해서 컴파일러가 명령어의 순서를 바꿀 수 있음.</li> <li>그래서 한 쓰레드에서 읽은 메모리의 값이 다른 쓰레드에서 쓰인(write) 값이라고 확신할 수 없음. <ul><li>따라서 컴파일러 및 프로세서가 모든 변경사항을 메모리에 커밋(commit)하는 방법이 필요함.</li> <li>메모리 배리어(Memory Barrier)는 가장 저수준의 메모리 일관성 프로토콜로, 프로세서와 컴파일러에 특정 순서 제약을 강제함. 메모리 배리어 이전에 실행되는 모든 작업은 반드시 메모리 배리어 이후에 실행되는 명령어보다 먼저 완료되어야 함.</li> <li>Go의 채널, Atomic 연산, 뮤텍스, condition variable 등은 모두 메모리 배리어를 사용함.</li></ul></li></ul></li></ul> <h3 id="shared-memory"><a aria-hidden="true" tabindex="-1" href="#shared-memory"><span class="icon icon-link"></span></a>Shared Memory</h3> <ul><li><p>단일 프로그램 내에서 Shared memory란 일반적으로 여러 쓰레드가 공유하는 변수 등의 메모리 공간을 의미함.</p></li> <li><p>Shared Memory를 통해 통신하는 경우 버그가 발생할 수 있는 가능성이 높아짐.
이 때 동시성으로 인해 발생하는 버그는 사실상 무작위적으로 발생하기에, 버그를 재현 및 디버깅하기가 어려움.</p></li> <li><p>lock을 통해 Happened-Before 관계를 정의함</p></li></ul> <h3 id="message-passing"><a aria-hidden="true" tabindex="-1" href="#message-passing"><span class="icon icon-link"></span></a>Message Passing</h3> <ul><li><p>UNIX나 LINUX의 철학은 프로세스가 서로 독립적이어야 하며, 메시지를 송수신하는 방식으로 통신해야 한다는 것임.</p> <ul><li>프로세스는 한 종류의 일을 잘 하도록 설계되며, 이러한 프로세스들이 모여 시스템을 구성함.</li></ul></li> <li><p>메시지를 통홰 Happened-Before 관계를 정의함. (메시지 패싱을 통해 두 쓰레드는 작업의 선후 관계를 정의할 수 있음)</p></li></ul> <h3 id="hybrid-approach"><a aria-hidden="true" tabindex="-1" href="#hybrid-approach"><span class="icon icon-link"></span></a>Hybrid Approach</h3> <ul><li><p>Shared Memory와 Message Passing을 혼용하는 방식</p></li> <li><p>보통 Shared Memory는 빠르고 활용성이 좋지만 data race가 발생할 수 있는 위협이 있음. 이러한 경우 Message Passing을 사용함.</p></li> <li><p>하지만 의도치 않게 메모리를 공유되는 경우가 발생할 수 있음.</p></li> <li><p>Golang에서의 접근 방식</p> <ul><li>어떤 고루틴이 데이터 객체를 채널로 전달하면, 해당 데이터 객체의 소유권을 잃음.</li> <li>해당 채널에서 데이터 객체를 꺼낸 고루틴이 소유권을 가짐.</li> <li>채널로 데이터 객체를 전달한 고루틴은, mutual exclusion을 충족시키지 않는 한 해당 데이터 객체에 다시 접근할 수 없음.</li></ul></li></ul> <br/><br/> <h2 id="atomicity-race-deadlock-starvation"><a aria-hidden="true" tabindex="-1" href="#atomicity-race-deadlock-starvation"><span class="icon icon-link"></span></a>Atomicity, Race, Deadlock, Starvation</h2> <hr/> <h3 id="race-condition"><a aria-hidden="true" tabindex="-1" href="#race-condition"><span class="icon icon-link"></span></a>Race Condition</h3> <ul><li><p>동시성 프로그램의 실행 순서 및 타이밍에 따라 실행 결과가 달라지는 것.</p></li> <li><p>각 쓰레드가 인터리빙되어 실행되기 때문에 발생함.</p></li> <li><p>이상적이지 않은 결과가 발생할 수 있음.</p></li> <li><p>실질적으로 재현이 어려움.</p></li> <li><p><strong>Data race</strong>는 다음과 같은 항목에 해당하는 Race Condition의 특수한 케이스임.</p> <ul><li>두 개 이상의 쓰레드가 동일한 메모리에 접근함</li> <li>한 개 이상의 쓰레드가 메모라에 쓰기 연산을 수행함</li> <li>두 쓰레드의 작업 순서를 보장하기 위한 동기화 및 lock이 없음</li></ul></li></ul> <h3 id="atomicity"><a aria-hidden="true" tabindex="-1" href="#atomicity"><span class="icon icon-link"></span></a>Atomicity</h3> <ul><li>어떤 작업 및 그 하위 작업이 실행될 때 모두 완료되거나, 아니면 전혀 실행되지 않는 것을 의미함.</li> <li>프로그램의 특정 영역에 반드시 한 쓰레드만 접근할 수 있게 하는 <strong>Critical Section</strong>을 사용하여 구현할 수 있음. <ul><li>Mutual Exclusion(Mutex)를 통해 <strong>Critical Section</strong>을 설정함.</li> <li>여러 shared object와 상호작용해야 하는 경우, Mutex의 사용이 복잡해짐. <ul><li>상황에 따라 Deadlock이 발생할 수도 있음.</li></ul></li></ul></li></ul> <h3 id="deadlock"><a aria-hidden="true" tabindex="-1" href="#deadlock"><span class="icon icon-link"></span></a>Deadlock</h3> <ul><li><p>두 개 이상의 쓰레드가 서로의 작업이 끝나기를 기다리는 상황</p></li> <li><p>Deadlock이 발생하려면 Coffman 조건이 충족되어야 함.</p> <ul><li>Mutual Exclusion: 한 쓰레드가 Critical Section에 들어가면, 다른 쓰레드는 해당 Critical Section에 들어갈 수 없음.</li> <li>Hold and Wait: 쓰레드는 어떤 자원을 점유한 상태에서, 다른 쓰레드가 점유한 자원을 기다림.</li> <li>No Preemption: 쓰레드는 점유한 자원을 다른 쓰레드가 강제로 빼앗을 수 없음.</li> <li>Circular Wait: 쓰레드 간에 자원을 순환적으로 기다림.</li></ul></li> <li><p>Deadlock을 예방하기 위해 shared resoruce에 대한 일관된 lock 순서를 정의할 수 있으나, 모든 Deadlock을 예방할 수는 없음.</p></li></ul> <blockquote><p>정보) Go에서는 모든 Goroutine이 Block된 상태이면 Deadlock이 발생했다고 판단하고, panic을 발생시킴.
그래서 모든 Goroutine이 아닌 일부 Goroutine에서만 Deadlock이 발생했다면 이를 감지하지 못함.</p></blockquote> <h3 id="starvation"><a aria-hidden="true" tabindex="-1" href="#starvation"><span class="icon icon-link"></span></a>Starvation</h3> <ul><li>일부 쓰레드가 Critical Section에 들어가기 위해 계속해서 기다리지만, 다른 쓰레드가 먼저 Critical Section에 들어감으로 인해 Critical Section에 지속적으로 접근하지 못하는 상황</li> <li>DoS(Denial of Service) 공격의 기본 원리임.</li></ul> <blockquote><p>정보) Go 런타임은 특정 Goroutine이 Starvation 상태에 빠지는 것을 감지하지는 못한다.</p></blockquote> <h3 id="livelock"><a aria-hidden="true" tabindex="-1" href="#livelock"><span class="icon icon-link"></span></a>Livelock</h3> <ul><li>Deadlock처럼 보이지만, 쓰레드가 lock을 획득하려고 시도하는 연산을 계속 반복하기 때문에 실제로는 차단된 쓰레드가 없는 상황</li> <li>쓰레드가 작동하더라도 실제로는 유의미한 작업을 수행하지 못하기 때문에, Starvation과 유사함.</li> <li>Livelock은 몇번 반복하다 보면 해결될 수 있기 때문에 확인하기 어려움.</li> <li>lock을 획득하기 위해 재시도 및 무작위적인 대기 시간을 추가하는 방법으로 해결할 수 있음.</li></ul> <br/><br/> <h2 id="references"><a aria-hidden="true" tabindex="-1" href="#references"><span class="icon icon-link"></span></a>References</h2> <hr/> <center><p>[</p> <img src="https://learning.oreilly.com/covers/urn:orm:book:9781804619070/400w/" alt="Effective Concurrency in Go" loading="lazy"/><!----> ](https://learning.oreilly.com/library/view/effective-concurrency-in/9781804619070/)<br/> [Burak Serdar, 『Effective Concurrency in Go』, Packt Publishing](https://learning.oreilly.com/library/view/effective-concurrency-in/9781804619070/)</center><!----> <!--[--><aside class="post-footer"><h2>Posted in:</h2> <ul><!--[--><li><a href="/category/Computer Science/">Computer Science</a></li><li><a href="/category/OS/">OS</a></li><li><a href="/category/Golang/">Golang</a></li><!--]--></ul></aside><!--]--></article> <!--[--><!--[!--><!--]--><!--]--><!----><!----></div><!----> <footer><p>© 2026 JHSeo</p></footer><!----></main></div><!----><!--]--> <!--[!--><!--]--><!--]-->
			
			<script>
				{
					__sveltekit_104ra4f = {
						base: new URL("../../../..", location).pathname.slice(0, -1)
					};

					const element = document.currentScript.parentElement;

					Promise.all([
						import("../../../../_app/immutable/entry/start.CEIBvBpx.js"),
						import("../../../../_app/immutable/entry/app.DrSGtxGh.js")
					]).then(([kit, app]) => {
						kit.start(app, element, {
							node_ids: [0, 12],
							data: [{type:"data",data:null,uses:{}},null],
							form: null,
							error: null
						});
					});
				}
			</script>
		</div>
	</body>
</html>
