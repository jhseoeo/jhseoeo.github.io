<!DOCTYPE html>
<html lang="en">
	<head>
		<meta charset="utf-8" />
		<link rel="icon" href="/favicon.png" />
		<meta name="viewport" content="width=device-width, initial-scale=1" />

		
		<link href="../../../../_app/immutable/assets/0.bf7b65b6.css" rel="stylesheet">
		<link href="../../../../_app/immutable/assets/CodeBlockWrapper.6bf551a2.css" rel="stylesheet">
		<link rel="modulepreload" href="../../../../_app/immutable/entry/start.d10f2c52.js">
		<link rel="modulepreload" href="../../../../_app/immutable/chunks/index.d78780bf.js">
		<link rel="modulepreload" href="../../../../_app/immutable/chunks/singletons.1a638bb9.js">
		<link rel="modulepreload" href="../../../../_app/immutable/chunks/index.53878e7f.js">
		<link rel="modulepreload" href="../../../../_app/immutable/chunks/control.f5b05b5f.js">
		<link rel="modulepreload" href="../../../../_app/immutable/entry/app.31b9f54f.js">
		<link rel="modulepreload" href="../../../../_app/immutable/chunks/preload-helper.41c905a7.js">
		<link rel="modulepreload" href="../../../../_app/immutable/nodes/0.8d0f0c2e.js">
		<link rel="modulepreload" href="../../../../_app/immutable/chunks/config.30afbbb8.js">
		<link rel="modulepreload" href="../../../../_app/immutable/chunks/store.8bff042e.js">
		<link rel="modulepreload" href="../../../../_app/immutable/chunks/index.96cef4e6.js">
		<link rel="modulepreload" href="../../../../_app/immutable/nodes/13.88f2325e.js"><title>Go의 동시성 지원</title><!-- HEAD_svelte-ovibev_START --><meta data-key="description" name="description" content="Go에서 동시성을 지원하는 방법들"><meta property="og:type" content="article"><meta property="og:title" content="Go의 동시성 지원"><meta property="og:description" content="Go에서 동시성을 지원하는 방법들"><meta property="og:image" content="https://jhseoeo.github.io//post_img/Go/Concurrency in Go/cover.png"><meta property="og:image:width" content="16"><meta property="og:image:height" content="9"><!-- HEAD_svelte-ovibev_END -->
		<!-- You can replace this block to update the Google fonts used in the project -->
		<link rel="preconnect" href="https://fonts.googleapis.com" />
		<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
		<link
			href="https://fonts.googleapis.com/css2?&family=Nanum+Gothic&family=Jua&family=Source+Code+Pro:wght@400&display=swap"
			rel="stylesheet"
		/>

		<!-- End Google Fonts block -->
		<meta name="google-site-verification" content="kTz5xeug4vOcZSULbtGzj4xjmF8AxGtxARj8vCKoVOA" />
		<!-- You can add global <meta> tags here, but anything not global or dynamic should be a `<svelte:head>` tag on the proper page(s) instead. -->
	</head>
	<body>
		<div id="svelte">






<div class="layout"><header><a class="skip-to-content-link" href="#main">Skip to main content
	</a>

	
<nav class="main-nav"><ul><li><a href="/posts" aria-current="page" class="active">Posts
			</a></li><li><a href="/category" aria-current="false">Categories
			</a></li><li><a href="/about" aria-current="false">About
			</a></li><li><a href="/learning" aria-current="false">Learning
			</a></li><li><a href="/api/rss.xml" aria-current="false">RSS
			</a></li><li><a href="/#" aria-current="false">Home
			</a></li></ul>
	<button aria-pressed="false" class="menu-button" tabindex="-1"><span class="sr-only">Toggle hamburger menu</span>
	<svg viewBox="0 0 128 128" version="1.1" style="fill-rule:evenodd;clip-rule:evenodd;stroke-linejoin:round;stroke-miterlimit:2;"><path d="M64,48.496l-48.496,-48.496l-15.504,15.504l48.496,48.496l-48.496,48.496l15.504,15.504l48.496,-48.496l48.496,48.496l15.504,-15.504l-48.496,-48.496l48.496,-48.496l-15.504,-15.504l-48.496,48.496Z"></path></svg></button></nav>
	<button aria-pressed="false" class="menu-button" tabindex="0"><span class="sr-only">Toggle hamburger menu</span>
	<svg viewBox="0 0 128 128" version="1.1" style="fill-rule:evenodd;clip-rule:evenodd;stroke-linejoin:round;stroke-miterlimit:2;"><g><rect x="0" y="12.48" width="128" height="18.688"></rect></g><g><rect x="0" y="96.832" width="128" height="18.688"></rect></g><g><rect x="0" y="54.656" width="128" height="18.688"></rect></g></svg></button>

	<a href="/" class="site-title">집밥서선생</a>

	<button class="toggle-theme">☀️</button></header>
	<main id="main" tabindex="-1"><div class="content">




<article class="post">
	<img class="cover-image" src="/post_img/Go/Concurrency in Go/cover.png" alt="" style="aspect-ratio: 16 / 9;" width="16" height="9">

	<h1>Go의 동시성 지원</h1>

	<div class="meta"><b>Published:</b>
		2023-08-25</div>

	<p>내용의 상당 부분이 <a href="https://jhseoeo.github.io/posts/post/Go/Golang%20Basics/GO10" rel="nofollow">https://jhseoeo.github.io/posts/post/Go/Golang%20Basics/GO10</a>의 내용과 중복되므로, 해당 포스트를 먼저 읽고 오시는 것을 추천드립니다.</p>
<p>해당 포스트에서 다루지 않은 내용만 중점적으로 다루려 합니다.</p>
<br><br>
<h2 id="goroutine"><a aria-hidden="true" tabindex="-1" href="#goroutine"><span class="icon icon-link"></span></a>Goroutine</h2>
<hr>
<h3 id="goroutine이-빠른-이유"><a aria-hidden="true" tabindex="-1" href="#goroutine이-빠른-이유"><span class="icon icon-link"></span></a>Goroutine이 빠른 이유</h3>
<ul><li><p>Go 런타임은 실행될 때 기본적으로 플랫폼의 프로세서(코어) 수만큼의 쓰레드를 생성함</p>
<ul><li>이 쓰레드 풀 위에서 Goroutine이 실행됨</li>
<li>만약 그 이하의 쓰레드를 생성하면 CPU utilization이 떨어짐</li>
<li>만약 그 이상의 쓰레드를 생성하면 Time Sharing때문에 Context Switching 오버헤드가 발생</li>
<li>만일 고루틴이 Channel, Mutex 등에 의해 block되면 해당 고루틴을 실행시키는 쓰레드는 다른 고루틴을 실행시킴</li>
<li>만일 고루틴이 동기 I/O에 의해 block되면 해당 고루틴을 실행시키는 쓰레드 자체가 block되므로, 새로운 쓰레드를 생성하거나 기존의 쓰레드를 재사용하여 다른 고루틴을 실행시킴</li></ul></li>
<li><p>Go Scheduler는 user space에 있기 때문에 OS Thread를 사용하는 것보다 오버헤드가 적음</p>
<ul><li>따라서 쓰레드 생성 및 관리에 대한 오버헤드가 적음</li></ul></li>
<li><p>Goroutine은 OS Thread보다 훨씬 적은 메모리를 사용함</p>
<ul><li>Goroutine의 Stack 크기는 2KB 정도인 반면, OS Thread의 Stack 크기는 MB 단위임</li></ul></li></ul>
<h3 id="goroutine의-특징"><a aria-hidden="true" tabindex="-1" href="#goroutine의-특징"><span class="icon icon-link"></span></a>Goroutine의 특징</h3>
<ul><li><p>OS Thread는 스케줄링 우선순위가 존재하지만, Goroutine은 존재하지 않음(Starvation이 발생하는 고루틴을 우선 선택하는 스케줄링 알고리즘이 있긴 하지만, 이를 지향하지는 않음)</p></li>
<li><p>Go 프로그램을 실행시키면 main 고루틴과 가비지 컬렉터 고루틴이 생성됨</p>
<ul><li>main 고루틴은 <code>main</code> 패키지의 <code>main</code> 함수에서 생성됨</li>
<li>main 함수가 종료되면 모든 고루틴이 종료되고 프로그램이 종료됨</li></ul></li>
<li><p>Goroutine을 일시정지 혹은 종료시키는 magic function은 없음</p>
<ul><li>고루틴이 중단되어야 함을 정의하는 message 또는 flag를 사용하는 것이 일반적</li>
<li><code>panic</code>은 고루틴을 종료시킬 수 있음. panic이 발생한 해당 고루틴이 종료됨</li></ul></li></ul>
<h3 id="closure"><a aria-hidden="true" tabindex="-1" href="#closure"><span class="icon icon-link"></span></a>Closure</h3>
<ul><li>어떤 익명 함수가 그 함수 내부 컨텍스트에 있는 변수를 참조하면, 그 익명 함수를 클로저(Closure)라고 함<ul><li>클로저가 참조하는 로컬 변수는 stack에서 heap으로 옮겨짐(escape to heap)<ul><li>stack에 저장되면 함수가 종료되면서 로컬 변수가 사라지기 때문</li></ul></li></ul></li></ul>
<br><br>
<h2 id="channel"><a aria-hidden="true" tabindex="-1" href="#channel"><span class="icon icon-link"></span></a>Channel</h2>
<hr>
<h3 id="channel의-length와-capacity"><a aria-hidden="true" tabindex="-1" href="#channel의-length와-capacity"><span class="icon icon-link"></span></a>Channel의 length와 capacity</h3>
<ul><li><p>Channel은 내부적으로 FIFO 큐로 구현되어 있음</p></li>
<li><p>Channel의 capacity는 채널 버퍼의 크기를 의미함</p></li>
<li><p>Channel의 length는 현재 큐에 들어있는 element의 개수를 의미함</p>
<ul><li>아래와 같은 코드는 좋지 않음</li></ul>
<pre class="language-go"><!-- HTML_TAG_START --><code class="language-go"><span class="token keyword">if</span> <span class="token function">len</span><span class="token punctuation">(</span>ch<span class="token punctuation">)</span> <span class="token operator">></span> <span class="token number">0</span> <span class="token punctuation">&#123;</span>
  x <span class="token operator">:=</span> <span class="token operator">&lt;-</span>ch
<span class="token punctuation">&#125;</span></code><!-- HTML_TAG_END --></pre>
<ul><li>이 코드는 ch에 element가 들어있는지 확인한 후, 들어있다면 element를 읽어옴</li>
<li>이 때 length를 가져오는 것은 데이터를 읽어오는 것과는 달리 mutual exclusive하지 않음</li>
<li>따라서 데이터를 읽어오려고 할 때 채널의 값을 다른 고루틴이 이미 읽어버리는 race condition이 발생할 수도 있음</li></ul></li></ul>
<h3 id="channel의-close"><a aria-hidden="true" tabindex="-1" href="#channel의-close"><span class="icon icon-link"></span></a>Channel의 close</h3>
<ul><li>원래 채널은 1:1 통신만 가능함.<ul><li>채널에서 데이터를 읽는 고루틴이 여러 개이고 데이터를 쓰는 고루틴이 하나라면, 쓰기 고루틴이 데이터를 쓸 때 무작위로 읽기 고루틴 중 하나에게 데이터를 전송함</li></ul></li>
<li>하지만 채널을 <code>close</code>하면 해당 채널을 receive하는 모든 고루틴이 이를 감지할 수 있음<ul><li>일종의 일회성 Broadcast인 셈</li></ul></li>
<li>닫힌 채널로부터 데이터를 읽어오면 해당 타입의 zero value를 읽어옴<ul><li>comma ok idiom을 사용하면 닫힌 채널인지 확인할 수 있음</li></ul></li>
<li>닫힌 채널에 데이터를 쓰려고 하면 panic이 발생함</li></ul>
<h3 id="메모리-공유"><a aria-hidden="true" tabindex="-1" href="#메모리-공유"><span class="icon icon-link"></span></a>메모리 공유</h3>
<ul><li>채널을 통해 전송한 데이터가 <code>int</code>, <code>float</code> 등의 primitive type이라면, 해당 데이터는 복사되어 전송됨</li>
<li>채널을 통해 전송한 데이터가 <code>slice</code>, <code>map</code> 등의 reference type이라면, 해당 데이터의 포인터 주소가 전송됨<ul><li>이 때 이 데이터의 ownership은 전송된 고루틴에게 넘어가지 않고 메모리는 공유됨.<ul><li>결과적으로 shared memory를 사용하는 것과 같은 상태가 됨</li>
<li>이 상태는 data race임.</li></ul></li>
<li>보통 채널을 통해 reference type의 데이터를 전송하고 나면 그 데이터를 사용하지 않는 것이 좋음.<ul><li>deep copy를 통해 복사본을 만들어 사용하거나, Mutex를 사용할 수도 있음</li></ul></li></ul></li></ul>
<h3 id="non-blocking-channel"><a aria-hidden="true" tabindex="-1" href="#non-blocking-channel"><span class="icon icon-link"></span></a>Non-blocking Channel</h3>
<ul><li><p>원래 채널은 blocking 성질을 가지고 있음</p>
<ul><li>채널에 데이터를 쓰려고 하면 채널에 데이터가 들어올 때까지 기다림</li>
<li>채널에서 데이터를 읽으려고 하면 채널에 데이터가 들어올 때까지 기다림</li></ul></li>
<li><p><code>select</code>문에 <code>default</code> 케이스가 있으면 non-blocking 채널이 됨.</p>
<ul><li>이 때 주의할 점은 채널에 대한 send, receive 연산의 우선순위가 가장 높지는 않다는 것임</li>
<li>예를 들면 아래 코드의 출력 결과는 <code>2</code>임.</li></ul>
<pre class="language-go"><!-- HTML_TAG_START --><code class="language-go"><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
  <span class="token keyword">var</span> i <span class="token builtin">int</span>
  f <span class="token operator">:=</span> <span class="token keyword">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    i<span class="token operator">++</span>
    <span class="token keyword">return</span> i
  <span class="token punctuation">&#125;</span>
  ch1 <span class="token operator">:=</span> <span class="token function">make</span><span class="token punctuation">(</span><span class="token keyword">chan</span> <span class="token builtin">int</span><span class="token punctuation">)</span>
  ch2 <span class="token operator">:=</span> <span class="token function">make</span><span class="token punctuation">(</span><span class="token keyword">chan</span> <span class="token builtin">int</span><span class="token punctuation">)</span>

  <span class="token keyword">select</span> <span class="token punctuation">&#123;</span>
  <span class="token keyword">case</span> ch1 <span class="token operator">&lt;-</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
  <span class="token keyword">case</span> ch2 <span class="token operator">&lt;-</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
  <span class="token keyword">default</span><span class="token punctuation">:</span>
  <span class="token punctuation">&#125;</span>
  fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span>
<span class="token punctuation">&#125;</span></code><!-- HTML_TAG_END --></pre>
<ul><li><code>default</code> 케이스로 넘어가기 이전 <code>ch1</code>, <code>ch2</code> 케이스에서 채널 blocking 여부를 확인하는데, 그 이전에 <code>f()</code>가 한 번씩 호출되기 때문</li>
<li>함수를 stateless하게 짜는 버릇을 들이자.</li></ul></li>
<li><p><code>select</code>문의 <code>case</code> 옆에 채널 연산자가 여러 개 붙어버리면 의도한 대로 동작 안할 수도 있음</p>
<pre class="language-go"><!-- HTML_TAG_START --><code class="language-go">ch1 <span class="token operator">:=</span> <span class="token function">make</span><span class="token punctuation">(</span><span class="token keyword">chan</span> <span class="token builtin">int</span><span class="token punctuation">)</span>
ch2 <span class="token operator">:=</span> <span class="token function">make</span><span class="token punctuation">(</span><span class="token keyword">chan</span> <span class="token builtin">int</span><span class="token punctuation">)</span>

<span class="token keyword">go</span> <span class="token keyword">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
  ch2 <span class="token operator">&lt;-</span> <span class="token number">1</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token keyword">go</span> <span class="token keyword">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
  fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token operator">&lt;-</span>ch1<span class="token punctuation">)</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">(</span><span class="token punctuation">)</span>

<span class="token keyword">select</span> <span class="token punctuation">&#123;</span>
<span class="token keyword">case</span> ch1<span class="token operator">&lt;-</span> <span class="token operator">&lt;-</span>ch2<span class="token punctuation">:</span>
  time<span class="token punctuation">.</span><span class="token function">Sleep</span><span class="token punctuation">(</span>time<span class="token punctuation">.</span>Second<span class="token punctuation">)</span>
<span class="token keyword">default</span><span class="token punctuation">:</span>
<span class="token punctuation">&#125;</span></code><!-- HTML_TAG_END --></pre>
<ul><li>위 코드는 <code>ch1</code>에 <code>ch2</code>의 값을 전송하고, <code>ch1</code>에서 값을 읽어와서 출력함</li>
<li>이 때 <code>&lt;-ch2</code>가 먼저 실행되는데, <code>ch2</code>에 값이 없을 때 읽어오려 하면 채널이 blocking됨</li>
<li>하지만 <code>default</code> 케이스로 넘어가지 않음. <code>ch1&lt;-</code>가 blocking될 때 <code>default</code>로 넘어가고, <code>&lt;-ch2</code>는 그냥 blocking됨</li>
<li>그러니까 이렇게 짜지 말자;;</li></ul></li></ul>
<br><br>
<h2 id="mutex"><a aria-hidden="true" tabindex="-1" href="#mutex"><span class="icon icon-link"></span></a>Mutex</h2>
<hr>
<ul><li>Mutex는 <span style="background-color: var(--highlightYellow)">Mutual Exclusion</span>의 약자로, critical section에 대한 여러 고루틴의 동시 접근을 막기 위해 사용됨.</li>
<li>기본적으로 선언과 동시에 사용할 수 있으며, <code>lock</code> 및 <code>unlock</code> 메소드를 지원함</li>
<li>Mutex 자체는 shared object여야 함. 단, Mutex가 복사되어선 안됨.<ul><li>Mutex가 복사되면 복사된 Mutex들이 각자의 lock을 가지게 되므로, 동시 접근을 막을 수 없음</li></ul></li></ul>
<h3 id="rwmutex"><a aria-hidden="true" tabindex="-1" href="#rwmutex"><span class="icon icon-link"></span></a>RWMutex</h3>
<ul><li>데이터의 Reader는 여러 명이어도 상관 없지만, Writer는 한 명 뿐이어야 함</li>
<li>RWMutex.RLock() 메소드를 통해 Reader가 lock을 획득하고, RWMutex.RUnlock() 메소드를 통해 lock을 해제함<ul><li>RWMutex.RLock()을 호출하는 여러 Reader 고루틴은 동시에 Critical Section에 접근할 수 있음</li></ul></li>
<li>RWMutex.Lock() 메소드를 통해 Writer가 lock을 획득하고, RWMutex.Unlock() 메소드를 통해 lock을 해제함<ul><li>RWMutex.Lock()을 호출하는 Writer 고루틴은 Critical Section에 접근할 수 있음</li>
<li>이 때 RWMutex.RLock()을 호출하는 Reader 고루틴은 Critical Section에 접근할 수 없음</li></ul></li></ul>
<br><br>
<h2 id="waitgroup"><a aria-hidden="true" tabindex="-1" href="#waitgroup"><span class="icon icon-link"></span></a>WaitGroup</h2>
<hr>
<ul><li>WaitGroup은 지정된 개수의 고루틴이 모두 종료될 때까지 기다리는 기능을 제공함</li>
<li>주로 여러 서비스를 호출하여 그 결과를 모아서 처리해야 할 때 유용하게 사용할 수 있음</li>
<li>WaitGroup과 Channel을 동시에 사용하는 경우 올바른 순서로 사용해야 함<ul><li>만약 채널에서 데이터를 읽어오기 전에 <code>Wg.Wait()</code>를 호출하면, Deadlock이 발생할 수 있음</li>
<li><code>Wg.Wait()</code> 이후 채널을 닫는 로직 또는 채널로부터 데이터를 읽어오는 로직을 별도의 고루틴으로 분리하는 것이 좋은 방법이 될 수 있음</li></ul></li></ul>
<br><br>
<h2 id="conditional-variable"><a aria-hidden="true" tabindex="-1" href="#conditional-variable"><span class="icon icon-link"></span></a>Conditional Variable</h2>
<hr>
<ul><li>Conditional Variable은 조건이 발생할 때까지 여러 고루틴이 기다리고, 조건이 발생하면 다른 고루틴에 이를 알리는 기능을 제공함</li>
<li>Go에서 Conditional Variable은 대부분 Channel로 대체될 수 있음</li>
<li>하지만 Shared Memory 시스템에서 Producer-Consumer 문제 등, 여러 문제를 해결할 때 유용할 수 있음</li></ul>
<blockquote><p><strong>Producer-Consumer 문제</strong></p>
<ul><li>Producer-Consumer 문제는 데이터를 생산하는 Producer와, 데이터를 소비하는 Consumer에 대한 문제임</li>
<li>1개 이상의 Producer와 Consumer가 존재할 수 있음</li>
<li>일반적으로 Producer가 데이터를 쓰고 Consumer가 데이터를 읽어오는 대기열(Queue)를 사용함<ul><li>Go에서는 이 대기열을 Channel로 구현할 수 있지만, Shared Memory 시스템에서는 Conditional Variable을 사용함</li></ul></li></ul></blockquote>
<ul><li><p>세개의 주요 오퍼레이션이 존재함</p>
<ul><li><code>Wait()</code>: 조건이 발생할 때까지 기다림</li>
<li><code>Signal()</code>: 조건이 발생했음을 알림</li>
<li><code>Broadcast()</code>: 조건이 발생했음을 알림. <code>Signal()</code>과 달리 모든 고루틴에게 알림</li></ul></li>
<li><p>Conditional Variable은 Mutex와 함께 사용됨</p>
<ul><li>Conditional Variable은 Critical Section 안에서만 수정할 수 있음</li></ul></li></ul>
<br><br>
<h2 id="references"><a aria-hidden="true" tabindex="-1" href="#references"><span class="icon icon-link"></span></a>References</h2>
<hr>
<center><p><a href="https://learning.oreilly.com/library/view/effective-concurrency-in/9781804619070/" rel="nofollow"><img src="https://learning.oreilly.com/covers/urn:orm:book:9781804619070/400w/" alt="Effective Concurrency in Go"></a> <br>
<a href="https://learning.oreilly.com/library/view/effective-concurrency-in/9781804619070/" rel="nofollow">Burak Serdar, 『Effective Concurrency in Go』, Packt Publishing</a></p></center>

	<aside class="post-footer"><h2>Posted in:</h2>
			<ul><li><a href="/category/Golang/">Golang</a>
					</li><li><a href="/category/Concurrency in Go/">Concurrency in Go</a>
					</li></ul></aside></article>

</div>
		<footer><p>© 2023 JHSeo. All right reserved.</p></footer></main></div>


			
			<script>
				{
					__sveltekit_b4l0pp = {
						base: new URL("../../../..", location).pathname.slice(0, -1),
						env: {}
					};

					const element = document.currentScript.parentElement;

					const data = [{"type":"data","data":null,"uses":{}},{"type":"data","data":{params:{post:"Go/Concurrency in Go/CIGO2"}},"uses":{"params":["post","then",null]}}];

					Promise.all([
						import("../../../../_app/immutable/entry/start.d10f2c52.js"),
						import("../../../../_app/immutable/entry/app.31b9f54f.js")
					]).then(([kit, app]) => {
						kit.start(app, element, {
							node_ids: [0, 13],
							data,
							form: null,
							error: null
						});
					});
				}
			</script>
		</div>
	</body>
</html>
