<!DOCTYPE html>
<html lang="en">
	<head>
		<meta charset="utf-8" />
		<link rel="icon" href="/favicon.png" />
		<meta name="viewport" content="width=device-width, initial-scale=1" />

		
		<link href="../../../../_app/immutable/assets/0.bf7b65b6.css" rel="stylesheet">
		<link href="../../../../_app/immutable/assets/CodeBlockWrapper.6bf551a2.css" rel="stylesheet">
		<link rel="modulepreload" href="../../../../_app/immutable/entry/start.e7b63fc3.js">
		<link rel="modulepreload" href="../../../../_app/immutable/chunks/index.5621e629.js">
		<link rel="modulepreload" href="../../../../_app/immutable/chunks/singletons.f8eb4c31.js">
		<link rel="modulepreload" href="../../../../_app/immutable/chunks/index.2a6e21b9.js">
		<link rel="modulepreload" href="../../../../_app/immutable/chunks/control.f5b05b5f.js">
		<link rel="modulepreload" href="../../../../_app/immutable/entry/app.3117b2a7.js">
		<link rel="modulepreload" href="../../../../_app/immutable/chunks/preload-helper.41c905a7.js">
		<link rel="modulepreload" href="../../../../_app/immutable/nodes/0.4813cb6f.js">
		<link rel="modulepreload" href="../../../../_app/immutable/chunks/config.4ba40868.js">
		<link rel="modulepreload" href="../../../../_app/immutable/chunks/store.b631b16d.js">
		<link rel="modulepreload" href="../../../../_app/immutable/chunks/index.a6b7245d.js">
		<link rel="modulepreload" href="../../../../_app/immutable/nodes/13.a4cac918.js"><title>WebRTC에 관하여 정리해보았다</title><!-- HEAD_svelte-15lge4r_START --><meta data-key="description" name="description" content="교내 프로젝트, 교과목, 스터디를 하며 정리한 WebRTC 관련 내용을 기록해보았습니다"><meta property="og:type" content="article"><meta property="og:title" content="WebRTC에 관하여 정리해보았다"><meta property="og:description" content="교내 프로젝트, 교과목, 스터디를 하며 정리한 WebRTC 관련 내용을 기록해보았습니다"><!-- HEAD_svelte-15lge4r_END -->
		<!-- You can replace this block to update the Google fonts used in the project -->
		<link rel="preconnect" href="https://fonts.googleapis.com" />
		<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
		<link
			rel="stylesheet"
			href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.7.1/styles/github.min.css"
		/>
		<link
			href="https://fonts.googleapis.com/css2?&family=Nanum+Gothic&family=Jua&family=Source+Code+Pro:wght@400&display=swap"
			rel="stylesheet"
		/>

		<!-- End Google Fonts block -->
		<meta name="google-site-verification" content="kTz5xeug4vOcZSULbtGzj4xjmF8AxGtxARj8vCKoVOA" />
		<!-- You can add global <meta> tags here, but anything not global or dynamic should be a `<svelte:head>` tag on the proper page(s) instead. -->
	</head>
	<body>
		<div id="svelte">






<div class="layout"><header><a class="skip-to-content-link" href="#main">Skip to main content
	</a>

	
<nav class="main-nav"><ul><li><a href="/posts" aria-current="page" class="active">Posts
			</a></li><li><a href="/category" aria-current="false">Categories
			</a></li><li><a href="/about" aria-current="false">About
			</a></li><li><a href="/learning" aria-current="false">Learning
			</a></li><li><a href="/api/rss.xml" aria-current="false">RSS
			</a></li><li><a href="/#" aria-current="false">Home
			</a></li></ul>
	<button aria-pressed="false" class="menu-button" tabindex="-1"><span class="sr-only">Toggle hamburger menu</span>
	<svg viewBox="0 0 128 128" version="1.1" style="fill-rule:evenodd;clip-rule:evenodd;stroke-linejoin:round;stroke-miterlimit:2;"><path d="M64,48.496l-48.496,-48.496l-15.504,15.504l48.496,48.496l-48.496,48.496l15.504,15.504l48.496,-48.496l48.496,48.496l15.504,-15.504l-48.496,-48.496l48.496,-48.496l-15.504,-15.504l-48.496,48.496Z"></path></svg></button></nav>
	<button aria-pressed="false" class="menu-button" tabindex="0"><span class="sr-only">Toggle hamburger menu</span>
	<svg viewBox="0 0 128 128" version="1.1" style="fill-rule:evenodd;clip-rule:evenodd;stroke-linejoin:round;stroke-miterlimit:2;"><g><rect x="0" y="12.48" width="128" height="18.688"></rect></g><g><rect x="0" y="96.832" width="128" height="18.688"></rect></g><g><rect x="0" y="54.656" width="128" height="18.688"></rect></g></svg></button>

	<a href="/" class="site-title">집밥서선생</a>

	<button class="toggle-theme">☀️</button></header>
	<main id="main" tabindex="-1"><div class="content">




<article class="post">
	<img class="cover-image" src="/post_img/Networking/WebRTC/cover.png" alt="" style="aspect-ratio: 16 / 9;" width="16" height="9">

	<h1>WebRTC에 관하여 정리해보았다</h1>

	<div class="meta"><b>Published:</b>
		2023-01-22</div>

	<p>교내 프로젝트, 교과목, 스터디를 통해 정리한 WebRTC 관련 내용을 기록해보았습니다</p>
<br><br>
<h2 id="webrtc"><a aria-hidden="true" tabindex="-1" href="#webrtc"><span class="icon icon-link"></span></a>WebRTC</h2>
<hr>
<h3 id="webrtc란"><a aria-hidden="true" tabindex="-1" href="#webrtc란"><span class="icon icon-link"></span></a>WebRTC란?</h3>
<ul><li><p>Web Real-Time Communication의 약자</p></li>
<li><p>별도의 소프트웨어나 플러그인 없이 (<strong>웹 브라우저 만으로도</strong>) 오디오 및 비디오 데이터를 주고받을 수 있음</p>
<ul><li>화상 통화, 실시간 회의 등 구현 가능</li></ul></li>
<li><p>웹 브라우저 뿐 아니라 IOS, Android Native App 위에서도 동작함</p></li>
<li><p>구글이 표준화를 주도하고 있어, Chrome 호환성이 제일 좋음</p></li>
<li><p>UDP, 피어-to-피어로 통신함</p></li>
<li><p>브라우저 API 제공</p>
<ul><li><code>RTC피어Connection()</code> : signal 처리, 코덱 처리, p2p 통신, 보안, bandwidth 관리 등, 다양한 역할을 하는 WebRTC 통신 주요 class</li>
<li><code>getUserMedia()</code> : 카메라나 마이크 등 장치에 접근하여 유저 데이터를 capture</li>
<li><code>RTCDataChannel()</code> : 오디오, 비디오 외의 비정형 데이터를 주고받기 위함. WebSocket과 거의 유사한 api</li></ul></li></ul>
<br>
<h3 id="webrtc-장점"><a aria-hidden="true" tabindex="-1" href="#webrtc-장점"><span class="icon icon-link"></span></a>WebRTC 장점</h3>
<ol><li><p>UDP를 사용하여 지연시간이 매우 짧다</p>
<ul><li>카메라로 찍은 화면이 상대에게 도달하기까지 걸리는 시간이 500ms 이하</li>
<li>다른 HTTP Live Stream 기술들의 경우, 주로 영상을 사람들에게 뿌리는(1:N) 용도라서 지연 시간이 존재</li></ul></li>
<li><p>Platform and Device Independent</p>
<ul><li>웹브라우저 위에서 돌아가도록 설계되었기 때문에, 브라우저만 돌아가면 OS, 장치가 무엇이든 상관없음</li></ul></li>
<li><p>Open-source 및 표준화되어있음</p>
<ul><li>언어별로 표준 문서가 존재하며, 표준대로 진행하면 모두 연결 가능함</li></ul></li>
<li><p>네트워크 성능에 따라 품질 조정</p>
<ul><li>네트워크 성능에 따라 전송받는 (영상)데이터의 품질(화질)이 달라질 수 있음</li>
<li>하지만 한 순간에는 특정 해상도의 영상 하나만 받을 수 있음</li>
<li>Simulcasting<ul><li>동시의 여러 해상도의 영상을 보냄</li>
<li>bandwidth를 낭비하지만, 수신 장치가 알아서 적합한 품질의 영상 선택</li></ul></li></ul></li>
<li><p>P2P의 장점</p>
<ul><li>주요 데이터가 서버를 경유하지 않기 때문에, 서버 입장에선 부담이 적음</li>
<li>유저 입장에선 내 데이터를 서버가 볼 수 없기 때문에, 안심하고 이용 가능</li></ul></li></ol>
<br>
<h3 id="webrtc-단점"><a aria-hidden="true" tabindex="-1" href="#webrtc-단점"><span class="icon icon-link"></span></a>WebRTC 단점</h3>
<ol><li><p>Scalability</p>
<ul><li>하나의 세션에 참가하는 통신 대상이 일정 이상 늘어나기 어려움</li>
<li>통신하는 대상의 수가 제한됨<ul><li>권고에 따르면 최대 50개 (WebRTC expert Tsahi LeventLevi recommends staying shy of any more than 50 concurrent 피어 connections.)</li></ul></li>
<li>몇 천 명의 유저가 통신하는 경우, live streaming server를 두어 데이터를 분산시킴<ul><li>SFU, MCU 등이 대표적</li></ul></li></ul></li>
<li><p>Broadcast Quality</p>
<ul><li>WebRTC 자체에 퀄리티 문제는 없지만, Broadcast를 함으로써 발생하는 영상 품질의 하락 문제</li></ul></li>
<li><p>그래도 서버가 필요함</p>
<ul><li>두 피어끼리의 connection 생성 및 해제 -&gt; Signaling Server</li>
<li>피어간 통신이 가능한지 여부 또는 Public IP를 확인해야 하는 경우 -&gt; STUN 서버</li>
<li>다양한 네트워크 상의 이슈(방화벽, 공유기나 라우터의 보안 정책 등) 때문에 피어간 직접 통신이 되지 않을 경우 -&gt; TURN 서버를 통해 데이터를 Relay</li></ul></li></ol>
<br>
<h3 id="webrtc-동작-흐름"><a aria-hidden="true" tabindex="-1" href="#webrtc-동작-흐름"><span class="icon icon-link"></span></a>WebRTC 동작 흐름</h3>
<p><img src="/post_img/Networking/WebRTC/2023-01-16-22-07-55.png" alt="webrtc signaling architecture"></p>
<ol><li>Signaling Server : 기기 사이에서 커넥션을 생성 및 해제해주고, 통신할 대상을 찾아줌</li>
<li>STUN Server : 요청자의 Public IP를 확인</li>
<li>TURN Server : P2P로 데이터를 직접 전송할 수 없다면, 데이터를 Relay</li></ol>
<p>자세한 내용은 아래에서 다룰 예정</p>
<br><br>
<h2 id="sdp"><a aria-hidden="true" tabindex="-1" href="#sdp"><span class="icon icon-link"></span></a>SDP</h2>
<hr>
<h3 id="sdp란"><a aria-hidden="true" tabindex="-1" href="#sdp란"><span class="icon icon-link"></span></a>SDP란?</h3>
<p><img src="/post_img/Networking/WebRTC/2023-01-29-22-15-14.PNG" alt="js sdp example"></p>
<ul><li>Session Description Protocol의 약자 (실질적으로는 프로토콜이 아니긴 함)</li>
<li>해상도, 형식, 코덱, 암호화 등, 컨텐츠에 대한 메타데이터 정보</li>
<li>누구와 어떻게 대화할지에 대한 정보를 포함함</li>
<li>SIP(Session Initiation Protocol)를 통해 SDP를 전송<ul><li>SIP는 WebRTC 이전에도 존재하던 사용자/참가자 그룹 간의 연결 설정 프로토콜이며, WebRTC는 SIP를 사용하여 Session 설정</li></ul></li></ul>
<br><br>
<h2 id="ice"><a aria-hidden="true" tabindex="-1" href="#ice"><span class="icon icon-link"></span></a>ICE</h2>
<hr>
<h3 id="ice란"><a aria-hidden="true" tabindex="-1" href="#ice란"><span class="icon icon-link"></span></a>ICE란?</h3>
<ul><li><p>Interactive Connectivity Establishment</p></li>
<li><p>브라우저가 피어를 통한 연결이 가능하게 해주는 프레임워크</p></li>
<li><p>두 피어간 <strong>최적의 경로</strong>를 찾아줌 (NAT Traversal)</p></li>
<li><p>피어끼리 연결이 쉽지 않은 이유</p>
<ul><li>방화벽에 걸리는 경우</li>
<li>장치에 Public IP가 없는 경우</li>
<li>라우터의 보안 정책이 피어간 직접 연결을 막는 경우</li></ul></li>
<li><p>ICE는 STUN서버와 TURN서버를 사용하여 이러한 작업 수행</p>
<ul><li>일반적으로, STUN, TURN 서버까지 거치고 나면 다음과 같은 주소를 얻음<ul><li>Private IP, Port</li>
<li>Public IP, Port (through STUN)</li>
<li>TURN 서버의 IP, Port(through TURN)</li></ul></li></ul></li></ul>
<br>
<h3 id="ice-candidates"><a aria-hidden="true" tabindex="-1" href="#ice-candidates"><span class="icon icon-link"></span></a>ICE Candidates</h3>
<ul><li>WebRTC 피어 연결을 시작하면, 일반적으로 여러개의 candiate들이 각 피어에 의해 만들어짐</li>
<li>구분자(<code>foundation</code>), IP, 포트, 우선순위, 프로토콜 등으로 구성</li>
<li>UDP가 기본이지만 UDP가 안되면 TCP도 허용함</li>
<li>각 피어가 수집한 ICE Candidates로 패킷을 보내 본 뒤, 가장 latency가 낮고 안정적인 ICE Candidates를 사용</li></ul>
<br>
<h3 id="trickle-ice"><a aria-hidden="true" tabindex="-1" href="#trickle-ice"><span class="icon icon-link"></span></a>Trickle ICE</h3>
<ul><li>일반적으로 피어는 ICE Candidates를 수집하여 목록을 완성한 후 한꺼번에 교환함<ul><li>이 방식은 네트워크 지연 등 이유로 ICE Candidates를 수집하는 데 오래 걸릴 수 있음</li></ul></li>
<li>비효율적인 ICE Candidates 교환 작업을 비동기 처리<ul><li>ICE Candidates를 찾은 즉시 피어에게 전송</li></ul></li></ul>
<br><br>
<h2 id="signaling"><a aria-hidden="true" tabindex="-1" href="#signaling"><span class="icon icon-link"></span></a>Signaling</h2>
<hr>
<h3 id="nat"><a aria-hidden="true" tabindex="-1" href="#nat"><span class="icon icon-link"></span></a>NAT?</h3>
<p><img src="/post_img/Networking/WebRTC/2023-01-17-00-20-14.png" alt="port forwarding"></p>
<ul><li>Network Address Translation</li>
<li>일반적인 사용자의 네트워크 환경에서는 대부분 공유기를 두기 때문에 Private IP, Public IP가 각각 존재함<ul><li>(일반적인 경우) 한 대의 공유기에 여러 대의 장치가 연결되고, 따라서 한 개의 Public IP와 여러 개의 Private IP가 존재함</li></ul></li>
<li>이 때 NAT는 Public IP를 특정 Private IP로 매핑시킴<ul><li>다만 연결된 장치 개수만큼 여러 대의 Private IP가 Public IP에 매핑될 필요가 있기에, PAT도 함께 적용</li>
<li>NAT + PAT(포트포워딩이라고도 함)는 Public IP:특정 포트를, 특정 Private IP:특정 포트로 매핑시킴</li>
<li>위 그림에서 Public IP:80으로 요청을 보내면, 192.168.0.37을 가진 장치가 80번 포트로 요청을 받을 것</li></ul></li></ul>
<br>
<h3 id="stun"><a aria-hidden="true" tabindex="-1" href="#stun"><span class="icon icon-link"></span></a>STUN</h3>
<ul><li>Session Traversal Utilities for NAT</li>
<li>기본적으로, NAT 환경에서 사용자 장치는 자신의 Public IP를 알 수 없음</li>
<li>STUN 서버는 사용자의 Public IP를 알려주는 역할<ul><li><a href="https://ipip.kr" rel="nofollow">https://ipip.kr</a>에 접속하면 Public IP를 알 수 있음. 이와 유사한 역할</li></ul></li>
<li>STUN을 통해 사용자가 P2P UDP 통신을 위해 사용할 수 있는 IP주소와 포트번호를 찾아냄</li></ul>
<br>
<h3 id="turn"><a aria-hidden="true" tabindex="-1" href="#turn"><span class="icon icon-link"></span></a>TURN</h3>
<ul><li>Traversal Using Relays around NAT</li>
<li>상대 Peer에게 보낼 정보를 TURN 서버에 전달하고, TURN이 상대 Peer에게 전달해줌</li>
<li>Symmetric NAT 등, Router의 NAT으로 생기는 제약 조건 등을 우회함</li>
<li>오버헤드가 발생하지만 대안이 없는 경우 사용</li>
<li>SFU, MCU도 TURN 서버의 일종이라고 볼 수 있음</li></ul>
<br>
<h3 id="p2p-vs-sfu-vs-mcu"><a aria-hidden="true" tabindex="-1" href="#p2p-vs-sfu-vs-mcu"><span class="icon icon-link"></span></a>P2P vs SFU vs MCU</h3>
<p><img src="/post_img/Networking/WebRTC/2023-01-29-23-58-14.png" alt="data flow diagram of each realy server"></p>
<ul><li><p>P2P</p>
<ul><li>각 사용자는 (전체 사용자-1) 만큼의 업로드/다운로드 연결을 가짐</li>
<li>서버의 부담이 덜하며 지연시간이 가장 짧음</li>
<li>통신에 참여하는 사용자가 많아질수록 클라이언트의 워크로드가 급격히 증가함</li>
<li>1:1 통신 및 소규모의 1:N, N:N 통신에 적합</li></ul></li>
<li><p>SFU</p>
<ul><li>각 사용자는 한 개의 중앙 서버와의 업로드 연결, 그리고 (전체 사용자-1) 만큼의 다운로드 연결을 가짐</li>
<li>지연 시간이 P2P보다는 길지만 MCU보다는 빠름</li>
<li>데이터가 서버를 거치기 때문에 서버 부담이 존재</li>
<li>클라이언트의 워크로드를 줄일 수 있지만, 대규모의 N:N 통신에서는 여전히 부하가 심함</li>
<li>1:N 및 대규모가 아닌 N:N 통신에 적합</li></ul></li>
<li><p>MCU</p>
<ul><li>각 사용자는 한 개의 중앙 서버와의 업로드/다운로드 연결을 가짐</li>
<li>클라이언트 부담 최소화</li>
<li>데이터가 서버를 거쳐, 각 클라이언트들에게 데이터를 처리하여 분배해야 하기 때문에 서버 부담이 매우 크며 지연 시간이 길어짐</li>
<li>대규모 N:N 통신에 적합</li></ul></li></ul>
<br>
<h3 id="signaling-server"><a aria-hidden="true" tabindex="-1" href="#signaling-server"><span class="icon icon-link"></span></a>Signaling Server</h3>
<p><img src="/post_img/Networking/WebRTC/2023-01-30-01-11-14.png" alt="webrtc signaling process"></p>
<ul><li>기기 사이에서 연결 생성 및 해제</li>
<li>통신할 대상을 찾아주는 역할</li>
<li>SDP나 ICE Candidates 등 연결 생성을 위한 데이터가 각 피어에게 전달됨</li>
<li>Websocket, HTTPS 등 서로 다른 통신 프로토콜로 설계 가능</li></ul>
<br><br>
<h2 id="출처"><a aria-hidden="true" tabindex="-1" href="#출처"><span class="icon icon-link"></span></a>출처</h2>
<p>WebRTC : <a href="https://wormwlrm.github.io/2021/01/24/Introducing-WebRTC.html" rel="nofollow">https://wormwlrm.github.io/2021/01/24/Introducing-WebRTC.html</a></p>
<br><br>

	<aside class="post-footer"><h2>Posted in:</h2>
			<ul><li><a href="/category/WebRTC/">WebRTC</a>
					</li></ul></aside></article>

</div>
		<footer><p>© 2023 JHSeo. All right reserved.</p></footer></main></div>


			
			<script>
				{
					__sveltekit_1hzau1k = {
						base: new URL("../../../..", location).pathname.slice(0, -1),
						env: {}
					};

					const element = document.currentScript.parentElement;

					const data = [{"type":"data","data":null,"uses":{}},{"type":"data","data":{params:{post:"Networking/WebRTC/webrtc"}},"uses":{"params":["post","then",null]}}];

					Promise.all([
						import("../../../../_app/immutable/entry/start.e7b63fc3.js"),
						import("../../../../_app/immutable/entry/app.3117b2a7.js")
					]).then(([kit, app]) => {
						kit.start(app, element, {
							node_ids: [0, 13],
							data,
							form: null,
							error: null
						});
					});
				}
			</script>
		</div>
	</body>
</html>
