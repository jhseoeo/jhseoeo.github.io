<!DOCTYPE html>
<html lang="en">
	<head>
		<meta charset="utf-8" />
		<link rel="icon" href="/favicon.png" />
		<meta name="viewport" content="width=device-width, initial-scale=1" />

		<meta http-equiv="content-security-policy" content="">
		<link href="../../../../_app/immutable/assets/_layout-ffe4af90.css" rel="stylesheet">
		<link rel="modulepreload" href="../../../../_app/immutable/start-d3a6f33f.js">
		<link rel="modulepreload" href="../../../../_app/immutable/chunks/index-d6e32500.js">
		<link rel="modulepreload" href="../../../../_app/immutable/chunks/singletons-8e55b403.js">
		<link rel="modulepreload" href="../../../../_app/immutable/chunks/index-ed7ec42a.js">
		<link rel="modulepreload" href="../../../../_app/immutable/chunks/preload-helper-41c905a7.js">
		<link rel="modulepreload" href="../../../../_app/immutable/chunks/control-f5b05b5f.js">
		<link rel="modulepreload" href="../../../../_app/immutable/components/pages/_layout.svelte-51fe4c05.js">
		<link rel="modulepreload" href="../../../../_app/immutable/chunks/config-2138fdd4.js">
		<link rel="modulepreload" href="../../../../_app/immutable/chunks/store-8f69a99e.js">
		<link rel="modulepreload" href="../../../../_app/immutable/modules/pages/_layout.js-f4efb1d0.js">
		<link rel="modulepreload" href="../../../../_app/immutable/chunks/_layout-ad2a582b.js">
		<link rel="modulepreload" href="../../../../_app/immutable/components/pages/posts/post/_...post_/_page.svelte-71ae990a.js"><title>RFC8828: WebRTC IP Address Handling Requirements 정리</title><!-- HEAD_svelte-15lge4r_START --><meta data-key="description" name="description" content="RFC8828을 읽고 WebRTC의 IP주소 처리 정책을 정리해보았습니다"><meta property="og:type" content="article"><meta property="og:title" content="RFC8828: WebRTC IP Address Handling Requirements 정리"><meta property="og:description" content="RFC8828을 읽고 WebRTC의 IP주소 처리 정책을 정리해보았습니다"><!-- HEAD_svelte-15lge4r_END -->
		<!-- You can replace this block to update the Google fonts used in the project -->
		<link rel="preconnect" href="https://fonts.googleapis.com" />
		<link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
		<link
			rel="stylesheet"
			href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.7.1/styles/github.min.css"
		/>
		<link
			href="https://fonts.googleapis.com/css2?&family=Nanum+Gothic&family=Jua&family=Source+Code+Pro:wght@400&display=swap"
			rel="stylesheet"
		/>

		<!-- End Google Fonts block -->
		<meta name="google-site-verification" content="kTz5xeug4vOcZSULbtGzj4xjmF8AxGtxARj8vCKoVOA" />
		<!-- You can add global <meta> tags here, but anything not global or dynamic should be a `<svelte:head>` tag on the proper page(s) instead. -->
	</head>
	<body>
		<div id="svelte">






<div class="layout"><header><a class="skip-to-content-link" href="#main">Skip to main content
	</a>

	
<nav class="main-nav"><ul><li><a href="/posts" aria-current="page" class="active">Posts
			</a></li><li><a href="/category" aria-current="false">Categories
			</a></li><li><a href="/about" aria-current="false">About
			</a></li><li><a href="/api/rss.xml" aria-current="false">RSS
			</a></li><li><a href="/#" aria-current="false">Home
			</a></li></ul>
	<button aria-pressed="false" class="menu-button" tabindex="-1"><span class="sr-only">Toggle hamburger menu</span>
	<svg viewBox="0 0 128 128" version="1.1" style="fill-rule:evenodd;clip-rule:evenodd;stroke-linejoin:round;stroke-miterlimit:2;"><path d="M64,48.496l-48.496,-48.496l-15.504,15.504l48.496,48.496l-48.496,48.496l15.504,15.504l48.496,-48.496l48.496,48.496l15.504,-15.504l-48.496,-48.496l48.496,-48.496l-15.504,-15.504l-48.496,48.496Z"></path></svg></button></nav>
	<button aria-pressed="false" class="menu-button" tabindex="0"><span class="sr-only">Toggle hamburger menu</span>
	<svg viewBox="0 0 128 128" version="1.1" style="fill-rule:evenodd;clip-rule:evenodd;stroke-linejoin:round;stroke-miterlimit:2;"><g><rect x="0" y="12.48" width="128" height="18.688"></rect></g><g><rect x="0" y="96.832" width="128" height="18.688"></rect></g><g><rect x="0" y="54.656" width="128" height="18.688"></rect></g></svg></button>

	<a href="/" class="site-title">집밥서선생</a>

	<button class="toggle-theme">☀️</button></header>
	<main id="main" tabindex="-1"><div class="content">




<article class="post">
	<img class="cover-image" src="/post_img/WebRTC/cover.png" alt="" style="aspect-ratio: 16 / 9;" width="16" height="9">

	<h1>RFC8828: WebRTC IP Address Handling Requirements 정리</h1>

	<div class="meta"><b>Published:</b>
		2023-03-15</div>

	<!-- HTML_TAG_START --><p>학교 프로젝트 진행 중 WebRTC 내부적으로 IP 주소를 처리하는 규칙에 대해 인사이트가 필요하여 읽어본 RFC8828의 내용을 정리해보았습니다.</p>
<h2 id="개요"><a aria-hidden="true" tabindex="-1" href="#개요"><span class="icon icon-link"></span></a>개요</h2>
<p>WebRTC의 ICE에서는 STUN을 통해 여러 개의 IP 주소를 찾아내고 각 local-remote 주소 페어의 연결성을 테스트하여 최선의 것을 찾아냄. 수집된 주소는 엔드포인트의 물리적인(또는 가상의) private 주소와 이의 public 주소로 이루어져 있음.</p>
<p>웹 애플리케이션에서는 이러한 주소로 원격 엔드포인트와 통신 가능함. 기존 웹 어플리케이션에서 public 주소 하나만 알 수 있었던 것과는 달리 로컬 네트워크 설정에 대한 추가적인 정보를 알 수 있음.</p>
<ol><li>만약 클라이언트가 multihomed인 경우 추가적인 public ip 주소를 알 수 있음. 가령 클라이언트가 split-tunnel이라고 하는 특정 종류의 VPN을 사용하는 경우 VPN의 public 주소 뿐 아니라 VPN 밑에서 돌아가는 ISP의 Public 주소도 알 수 있다고 함.</li>
<li>NAT로 숨겨진 IP를 알 수 있음.</li>
<li>클라이언트가 프록시를 쓰더라도, STUN으로 프록시를 우회하여 public ip를 알아낼 수 있음.</li></ol>
<br><br>
<h2 id="원리"><a aria-hidden="true" tabindex="-1" href="#원리"><span class="icon icon-link"></span></a>원리</h2>
<p>WebRTC IP 처리의 중요 원리는 다음과 같음</p>
<ol><li><p>기본적으로 WebRTC 트래픽은 전통적인 IP 라우팅 방식을 따르며(HTTP 트래픽과 동일한 인터페이스를 사용함), application이 시스템의 public 주소를 볼 수 있어야 함.</p>
<ul><li>하지만 최적의 미디어 퀄리티를 위해 WebRTC는 모든 네트워크 인터페이스에서 최적의 경로를 찾을 수 있어야 함.</li></ul></li>
<li><p>WebRTC는 NAT 순회 또는 TURN을 사용하지 않고 엔드포인트간의 직접적인 p2p 연결이 가능한 경우, 그렇게 해야 함. 이로써 p2p 라우팅을 필요로하는 애플리케이션이 성공적으로 동작할 수 있음.</p></li>
<li><p>WebRTC가 private IP를 공개하지 않기를 원한다면, 이를 설정할 수 있어야 함. 단 이게 기본 설정은 아님.</p></li>
<li><p>기본 설정으로 WebRTC 트래픽은 프록시 서버를 통해 전송되지는 않아야 함. 이는 프록시를 사용하여 통신하는 경우 WebRTC 트래픽이 TCP를 통해 전송되기 때문에 성능 문제가 발생하기 때문임. 또한 WebRTC의 long-lived, high bandwidth인 연결이 프록시를 통하면 성능 문제가 생김. 하지만 클라이언트가 원할 경우 프록시를 통하여 WebRTC 연결을 보내도록 설정할 수 있어야 함.</p></li></ol>
<p>이러한 원리에 기반하여, WebRTC 동작에 대한 4개의 모드를 정의할 수 있음.</p>
<ol><li><p>모든 주소를 열거함</p>
<ul><li>WebRTC는 모든 네트워크 인터페이스를 사용하여 STUN, TURN, 피어와 통신을 시도함.</li>
<li>이를 통해 최선의 미디어 경로를 찾음.</li>
<li>미디어 성능이 최우선적으로 중요할 때 사용하지만 많은 정보가 공개됨.</li></ul></li>
<li><p>기본 경로 + 연관된 로컬 주소</p>
<ul><li>WebRTC는 커널의 라우팅 테이블을 따라야 하며, 이 경우 일반적으로 미디어 패킷이 HTTP 트래픽과 같은 경로를 타게 됨.</li>
<li>만약 TURN 서버가 존재하는 경우, TRUN 서버를 통과하는 경로를 선호함.</li>
<li>인터페이스가 선택되면, 이 인터페이스와 연관된 private ipv4 및 ipv6 주소를 찾아 호스트 후보로 어플리케이션에 전달됨. 이로써 이 모드에서 직접적인 연결이 생성될 수 있음.</li></ul></li>
<li><p>기본 경로만 사용</p>
<ul><li>이 모드는 (2)의 모드와 비슷하지만, 연관된 private 주소가 제공되지 않음.</li>
<li>수집된 IP주소는 기본 경로에서 STUN 및 TURN과 같은 매커니즘을 통해 검색된 IP주소 이외엔 없음.</li>
<li>하지만 트래픽이 NAT를 통과하거나, TURN 서버를 통하거나, 모두 실패하여 품질에 영향을 미칠 수 있음.</li></ul></li>
<li><p>프록시 강제</p>
<ul><li>(3)의 모드와 동일하지만 HTTP 트래픽이 프록시를 통하는 경우, WebRTC의 트래픽도 프록시를 통하게 됨.</li>
<li>만약 프록시가 UDP를 지원하지 않거나 WebRTC 구현이 UDP 프록시를 지원하지 않는경우, WebRTC는 UDP를 사용하지 않고 TCP를 사용하여 프록시를 통해 전송 및 수신함.</li>
<li>TCP를 사용하면 미디어 품질 및 전송시 성능이 감소함.</li></ul></li></ol>
<br>
<p>이때 사용자 동의가 없는 한 모드 1을 사용하지 않는다. 사용자 정의에 관련된 부분은 <code>getUserMedia</code> 등에서 얻을 수 있는 듯 함. 동의가 없는 경우 모드 2를 사용한다.</p>
<ul><li>즉, 모드 2는 별다른 동의 없이 최적의 네트워크 성능을 달성할 수 있게끔 하는 합리적인 절충안이라고 볼 수 있음</li>
<li>직접 연결을 달성하는데 필요한 최소 정보만 동의 없이 어플리케이션에 제공</li>
<li>하지만 사용자 요구에 따라, 필요하다면 더 엄격한 모드를 선택함.</li></ul>
<br>
<p>제안된 기본값음 모든 외부 WebRTC 트래픽이 프록시나 TURN 서버를 통과하게끔 원하는 조직도 사용 가능함</p>
<ul><li>WebRTC 트래픽이 프록시나 TURN 서버를 통해서만 나가도록 조직의 방화벽 정책을 설정하면 됨</li>
<li>프록시나 TURN 서버가 외부 트래픽에 사용되지만, 조직 내 트래픽에 직접 연결될 수 있으며, 프록시의 경우 성능 문제를 방지할 수 있음</li></ul>
<br><br>
<h2 id="구현-가이드"><a aria-hidden="true" tabindex="-1" href="#구현-가이드"><span class="icon icon-link"></span></a>구현 가이드</h2>
<p>위 정책을 구현하는 방법에 대한 WebRTC 구현 지침</p>
<ol><li><p>정상 라우팅 보장</p>
<ul><li>모드 2 또는 모드 3과 같은 전통적인 IP 라우팅을 시도하는 경우, 가장 간단한 방법은 와일드카드 주소(IPv4의 0.0.0.0 및 IPv6의 ::)로 소켓을 <code>bind()</code>하는 것임.<ul><li>이렇게 하면 OS는 HTTP 트래픽과 동일한 방식으로 WebRTC 트래픽을 라우팅할 것이며, STUN과 TURN도 평소대로 사용되고, 호스트 후보는 아래 언급된 것처럼 여전히 결정될 수 있음.</li></ul></li></ul></li>
<li><p>연관된 로컬 주소 결정</p>
<ul><li>와일드카드 주소를 바인딩할 때, 모드 2에 필요한 연관된 로컬 주소를 결정하려면 추가적인 작업이 필요함.<ul><li>로컬 주소는 웹 애플리케이션 호스트로 전송되는 모든 패킷의 source address로 정의됨.</li>
<li>웹 애플리케이션 호스트를 destination으로 사용하면 애플리케이션의 위치에 관계 없이 올바른 source address가 선택됨.</li></ul></li>
<li>웹 애플리케이션 URI의 호스트 컴포넌트를 resolve하여 적절한 remote IPv4/IPv6 주소를 얻음. 클라이언트가 프록시 뒤에 있고 DNS를 통해 IP를 resolve할 수 없는 경우, 프록시의 주소를 대신 사용함.</li>
<li>일단 적절한 원격 IP가 결정되면, UDP 소켓을 적절한 와일드카드 주소에 <code>bind()</code>하고 원격 IP에 <code>connect()</code>함.<ul><li>일반적으로 이 소켓은 네트워크를 통해 패킷을 보내지 않고 커널의 라우팅 테이블을 바탕으로 로컬 주소를 할당받음.</li>
<li>결과적으로 이 소켓으로 <code>getsocketname()</code> 등을 호출하여 적절한 로컬 주소를 확인할 수 있음.</li></ul></li></ul></li>
<li><p>어플리케이션 동작</p>
<p>WebRTC를 사용하는 애플리케이션이 잘못 동작하지 않게끔, 다음과 같은 가이드라인을 제공함.</p>
<ul><li>모드 3 및 4를 지원하기 위해서는 UDP 및 TCP 연결을 모두 지원하는 TURN 서버를 배포해야 함.</li>
<li>어플리케이션은 host candidate의 존재 유무를 확인하여 모든 ICE candidates에 접근할 수 없는 경우를 감지할 수 있어야 함. host candidate가 없다면 모드 3 및 4를 사용중인 경우임.</li></ul></li></ol>
<br><br><!-- HTML_TAG_END -->

	<aside class="post-footer"><h2>Posted in:</h2>
			<ul><li><a href="/category/WebRTC/">WebRTC</a>
					</li><li><a href="/category/논문정리/">논문정리</a>
					</li></ul></aside></article>

</div>
		<footer><p>© 2023 JHSeo. All right reserved.</p></footer></main></div>


		<script type="module" data-sveltekit-hydrate="umqtqf">
			import { start } from "../../../../_app/immutable/start-d3a6f33f.js";

			start({
				env: {},
				paths: {"base":"","assets":""},
				target: document.querySelector('[data-sveltekit-hydrate="umqtqf"]').parentNode,
				version: "1679634338017",
				hydrate: {
					node_ids: [0, 12],
					data: [null,{type:"data",data:{PostContent:"\u003Cp\u003E학교 프로젝트 진행 중 WebRTC 내부적으로 IP 주소를 처리하는 규칙에 대해 인사이트가 필요하여 읽어본 RFC8828의 내용을 정리해보았습니다.\u003C\u002Fp\u003E\n\u003Ch2 id=\"개요\"\u003E\u003Ca aria-hidden=\"true\" tabindex=\"-1\" href=\"#개요\"\u003E\u003Cspan class=\"icon icon-link\"\u003E\u003C\u002Fspan\u003E\u003C\u002Fa\u003E개요\u003C\u002Fh2\u003E\n\u003Cp\u003EWebRTC의 ICE에서는 STUN을 통해 여러 개의 IP 주소를 찾아내고 각 local-remote 주소 페어의 연결성을 테스트하여 최선의 것을 찾아냄. 수집된 주소는 엔드포인트의 물리적인(또는 가상의) private 주소와 이의 public 주소로 이루어져 있음.\u003C\u002Fp\u003E\n\u003Cp\u003E웹 애플리케이션에서는 이러한 주소로 원격 엔드포인트와 통신 가능함. 기존 웹 어플리케이션에서 public 주소 하나만 알 수 있었던 것과는 달리 로컬 네트워크 설정에 대한 추가적인 정보를 알 수 있음.\u003C\u002Fp\u003E\n\u003Col\u003E\u003Cli\u003E만약 클라이언트가 multihomed인 경우 추가적인 public ip 주소를 알 수 있음. 가령 클라이언트가 split-tunnel이라고 하는 특정 종류의 VPN을 사용하는 경우 VPN의 public 주소 뿐 아니라 VPN 밑에서 돌아가는 ISP의 Public 주소도 알 수 있다고 함.\u003C\u002Fli\u003E\n\u003Cli\u003ENAT로 숨겨진 IP를 알 수 있음.\u003C\u002Fli\u003E\n\u003Cli\u003E클라이언트가 프록시를 쓰더라도, STUN으로 프록시를 우회하여 public ip를 알아낼 수 있음.\u003C\u002Fli\u003E\u003C\u002Fol\u003E\n\u003Cbr\u003E\u003Cbr\u003E\n\u003Ch2 id=\"원리\"\u003E\u003Ca aria-hidden=\"true\" tabindex=\"-1\" href=\"#원리\"\u003E\u003Cspan class=\"icon icon-link\"\u003E\u003C\u002Fspan\u003E\u003C\u002Fa\u003E원리\u003C\u002Fh2\u003E\n\u003Cp\u003EWebRTC IP 처리의 중요 원리는 다음과 같음\u003C\u002Fp\u003E\n\u003Col\u003E\u003Cli\u003E\u003Cp\u003E기본적으로 WebRTC 트래픽은 전통적인 IP 라우팅 방식을 따르며(HTTP 트래픽과 동일한 인터페이스를 사용함), application이 시스템의 public 주소를 볼 수 있어야 함.\u003C\u002Fp\u003E\n\u003Cul\u003E\u003Cli\u003E하지만 최적의 미디어 퀄리티를 위해 WebRTC는 모든 네트워크 인터페이스에서 최적의 경로를 찾을 수 있어야 함.\u003C\u002Fli\u003E\u003C\u002Ful\u003E\u003C\u002Fli\u003E\n\u003Cli\u003E\u003Cp\u003EWebRTC는 NAT 순회 또는 TURN을 사용하지 않고 엔드포인트간의 직접적인 p2p 연결이 가능한 경우, 그렇게 해야 함. 이로써 p2p 라우팅을 필요로하는 애플리케이션이 성공적으로 동작할 수 있음.\u003C\u002Fp\u003E\u003C\u002Fli\u003E\n\u003Cli\u003E\u003Cp\u003EWebRTC가 private IP를 공개하지 않기를 원한다면, 이를 설정할 수 있어야 함. 단 이게 기본 설정은 아님.\u003C\u002Fp\u003E\u003C\u002Fli\u003E\n\u003Cli\u003E\u003Cp\u003E기본 설정으로 WebRTC 트래픽은 프록시 서버를 통해 전송되지는 않아야 함. 이는 프록시를 사용하여 통신하는 경우 WebRTC 트래픽이 TCP를 통해 전송되기 때문에 성능 문제가 발생하기 때문임. 또한 WebRTC의 long-lived, high bandwidth인 연결이 프록시를 통하면 성능 문제가 생김. 하지만 클라이언트가 원할 경우 프록시를 통하여 WebRTC 연결을 보내도록 설정할 수 있어야 함.\u003C\u002Fp\u003E\u003C\u002Fli\u003E\u003C\u002Fol\u003E\n\u003Cp\u003E이러한 원리에 기반하여, WebRTC 동작에 대한 4개의 모드를 정의할 수 있음.\u003C\u002Fp\u003E\n\u003Col\u003E\u003Cli\u003E\u003Cp\u003E모든 주소를 열거함\u003C\u002Fp\u003E\n\u003Cul\u003E\u003Cli\u003EWebRTC는 모든 네트워크 인터페이스를 사용하여 STUN, TURN, 피어와 통신을 시도함.\u003C\u002Fli\u003E\n\u003Cli\u003E이를 통해 최선의 미디어 경로를 찾음.\u003C\u002Fli\u003E\n\u003Cli\u003E미디어 성능이 최우선적으로 중요할 때 사용하지만 많은 정보가 공개됨.\u003C\u002Fli\u003E\u003C\u002Ful\u003E\u003C\u002Fli\u003E\n\u003Cli\u003E\u003Cp\u003E기본 경로 + 연관된 로컬 주소\u003C\u002Fp\u003E\n\u003Cul\u003E\u003Cli\u003EWebRTC는 커널의 라우팅 테이블을 따라야 하며, 이 경우 일반적으로 미디어 패킷이 HTTP 트래픽과 같은 경로를 타게 됨.\u003C\u002Fli\u003E\n\u003Cli\u003E만약 TURN 서버가 존재하는 경우, TRUN 서버를 통과하는 경로를 선호함.\u003C\u002Fli\u003E\n\u003Cli\u003E인터페이스가 선택되면, 이 인터페이스와 연관된 private ipv4 및 ipv6 주소를 찾아 호스트 후보로 어플리케이션에 전달됨. 이로써 이 모드에서 직접적인 연결이 생성될 수 있음.\u003C\u002Fli\u003E\u003C\u002Ful\u003E\u003C\u002Fli\u003E\n\u003Cli\u003E\u003Cp\u003E기본 경로만 사용\u003C\u002Fp\u003E\n\u003Cul\u003E\u003Cli\u003E이 모드는 (2)의 모드와 비슷하지만, 연관된 private 주소가 제공되지 않음.\u003C\u002Fli\u003E\n\u003Cli\u003E수집된 IP주소는 기본 경로에서 STUN 및 TURN과 같은 매커니즘을 통해 검색된 IP주소 이외엔 없음.\u003C\u002Fli\u003E\n\u003Cli\u003E하지만 트래픽이 NAT를 통과하거나, TURN 서버를 통하거나, 모두 실패하여 품질에 영향을 미칠 수 있음.\u003C\u002Fli\u003E\u003C\u002Ful\u003E\u003C\u002Fli\u003E\n\u003Cli\u003E\u003Cp\u003E프록시 강제\u003C\u002Fp\u003E\n\u003Cul\u003E\u003Cli\u003E(3)의 모드와 동일하지만 HTTP 트래픽이 프록시를 통하는 경우, WebRTC의 트래픽도 프록시를 통하게 됨.\u003C\u002Fli\u003E\n\u003Cli\u003E만약 프록시가 UDP를 지원하지 않거나 WebRTC 구현이 UDP 프록시를 지원하지 않는경우, WebRTC는 UDP를 사용하지 않고 TCP를 사용하여 프록시를 통해 전송 및 수신함.\u003C\u002Fli\u003E\n\u003Cli\u003ETCP를 사용하면 미디어 품질 및 전송시 성능이 감소함.\u003C\u002Fli\u003E\u003C\u002Ful\u003E\u003C\u002Fli\u003E\u003C\u002Fol\u003E\n\u003Cbr\u003E\n\u003Cp\u003E이때 사용자 동의가 없는 한 모드 1을 사용하지 않는다. 사용자 정의에 관련된 부분은 \u003Ccode\u003EgetUserMedia\u003C\u002Fcode\u003E 등에서 얻을 수 있는 듯 함. 동의가 없는 경우 모드 2를 사용한다.\u003C\u002Fp\u003E\n\u003Cul\u003E\u003Cli\u003E즉, 모드 2는 별다른 동의 없이 최적의 네트워크 성능을 달성할 수 있게끔 하는 합리적인 절충안이라고 볼 수 있음\u003C\u002Fli\u003E\n\u003Cli\u003E직접 연결을 달성하는데 필요한 최소 정보만 동의 없이 어플리케이션에 제공\u003C\u002Fli\u003E\n\u003Cli\u003E하지만 사용자 요구에 따라, 필요하다면 더 엄격한 모드를 선택함.\u003C\u002Fli\u003E\u003C\u002Ful\u003E\n\u003Cbr\u003E\n\u003Cp\u003E제안된 기본값음 모든 외부 WebRTC 트래픽이 프록시나 TURN 서버를 통과하게끔 원하는 조직도 사용 가능함\u003C\u002Fp\u003E\n\u003Cul\u003E\u003Cli\u003EWebRTC 트래픽이 프록시나 TURN 서버를 통해서만 나가도록 조직의 방화벽 정책을 설정하면 됨\u003C\u002Fli\u003E\n\u003Cli\u003E프록시나 TURN 서버가 외부 트래픽에 사용되지만, 조직 내 트래픽에 직접 연결될 수 있으며, 프록시의 경우 성능 문제를 방지할 수 있음\u003C\u002Fli\u003E\u003C\u002Ful\u003E\n\u003Cbr\u003E\u003Cbr\u003E\n\u003Ch2 id=\"구현-가이드\"\u003E\u003Ca aria-hidden=\"true\" tabindex=\"-1\" href=\"#구현-가이드\"\u003E\u003Cspan class=\"icon icon-link\"\u003E\u003C\u002Fspan\u003E\u003C\u002Fa\u003E구현 가이드\u003C\u002Fh2\u003E\n\u003Cp\u003E위 정책을 구현하는 방법에 대한 WebRTC 구현 지침\u003C\u002Fp\u003E\n\u003Col\u003E\u003Cli\u003E\u003Cp\u003E정상 라우팅 보장\u003C\u002Fp\u003E\n\u003Cul\u003E\u003Cli\u003E모드 2 또는 모드 3과 같은 전통적인 IP 라우팅을 시도하는 경우, 가장 간단한 방법은 와일드카드 주소(IPv4의 0.0.0.0 및 IPv6의 ::)로 소켓을 \u003Ccode\u003Ebind()\u003C\u002Fcode\u003E하는 것임.\u003Cul\u003E\u003Cli\u003E이렇게 하면 OS는 HTTP 트래픽과 동일한 방식으로 WebRTC 트래픽을 라우팅할 것이며, STUN과 TURN도 평소대로 사용되고, 호스트 후보는 아래 언급된 것처럼 여전히 결정될 수 있음.\u003C\u002Fli\u003E\u003C\u002Ful\u003E\u003C\u002Fli\u003E\u003C\u002Ful\u003E\u003C\u002Fli\u003E\n\u003Cli\u003E\u003Cp\u003E연관된 로컬 주소 결정\u003C\u002Fp\u003E\n\u003Cul\u003E\u003Cli\u003E와일드카드 주소를 바인딩할 때, 모드 2에 필요한 연관된 로컬 주소를 결정하려면 추가적인 작업이 필요함.\u003Cul\u003E\u003Cli\u003E로컬 주소는 웹 애플리케이션 호스트로 전송되는 모든 패킷의 source address로 정의됨.\u003C\u002Fli\u003E\n\u003Cli\u003E웹 애플리케이션 호스트를 destination으로 사용하면 애플리케이션의 위치에 관계 없이 올바른 source address가 선택됨.\u003C\u002Fli\u003E\u003C\u002Ful\u003E\u003C\u002Fli\u003E\n\u003Cli\u003E웹 애플리케이션 URI의 호스트 컴포넌트를 resolve하여 적절한 remote IPv4\u002FIPv6 주소를 얻음. 클라이언트가 프록시 뒤에 있고 DNS를 통해 IP를 resolve할 수 없는 경우, 프록시의 주소를 대신 사용함.\u003C\u002Fli\u003E\n\u003Cli\u003E일단 적절한 원격 IP가 결정되면, UDP 소켓을 적절한 와일드카드 주소에 \u003Ccode\u003Ebind()\u003C\u002Fcode\u003E하고 원격 IP에 \u003Ccode\u003Econnect()\u003C\u002Fcode\u003E함.\u003Cul\u003E\u003Cli\u003E일반적으로 이 소켓은 네트워크를 통해 패킷을 보내지 않고 커널의 라우팅 테이블을 바탕으로 로컬 주소를 할당받음.\u003C\u002Fli\u003E\n\u003Cli\u003E결과적으로 이 소켓으로 \u003Ccode\u003Egetsocketname()\u003C\u002Fcode\u003E 등을 호출하여 적절한 로컬 주소를 확인할 수 있음.\u003C\u002Fli\u003E\u003C\u002Ful\u003E\u003C\u002Fli\u003E\u003C\u002Ful\u003E\u003C\u002Fli\u003E\n\u003Cli\u003E\u003Cp\u003E어플리케이션 동작\u003C\u002Fp\u003E\n\u003Cp\u003EWebRTC를 사용하는 애플리케이션이 잘못 동작하지 않게끔, 다음과 같은 가이드라인을 제공함.\u003C\u002Fp\u003E\n\u003Cul\u003E\u003Cli\u003E모드 3 및 4를 지원하기 위해서는 UDP 및 TCP 연결을 모두 지원하는 TURN 서버를 배포해야 함.\u003C\u002Fli\u003E\n\u003Cli\u003E어플리케이션은 host candidate의 존재 유무를 확인하여 모든 ICE candidates에 접근할 수 없는 경우를 감지할 수 있어야 함. host candidate가 없다면 모드 3 및 4를 사용중인 경우임.\u003C\u002Fli\u003E\u003C\u002Ful\u003E\u003C\u002Fli\u003E\u003C\u002Fol\u003E\n\u003Cbr\u003E\u003Cbr\u003E",meta:{title:"RFC8828: WebRTC IP Address Handling Requirements 정리",date:"2023-03-15T00:00:00.000Z",excerpt:"RFC8828을 읽고 WebRTC의 IP주소 처리 정책을 정리해보았습니다",categories:["WebRTC","논문정리"],coverImage:"\u002Fpost_img\u002FWebRTC\u002Fcover.png",coverWidth:16,coverHeight:9,slug:"Networking\u002FWebRTC\u002FRFC8828"}},uses:{params:["post"]}}],
					form: null
				}
			});
		</script>
	</div>
	</body>
</html>
