{"metadata":{"title":"복합 타입","date":"Jul 23, 2022","excerpt":"Composite Types"},"content":"<br>\n<p>본 글은 Golang을 공부하며 주요 내용이라 생각되는 것들을 기록해둔 자료이며, Ubuntu 20.04 LTS 기준으로 작성되었습니다.</p>\n<p><br><br></p>\n<h2>Array</h2>\n<hr>\n<p><strong>Array</strong>는 같은 타입의, 크기(개수)가 정해진 데이터들을 묶어서 처리하기 위해 사용된다.</p>\n<pre><code class=\"hljs language-go\"><span class=\"hljs-keyword\">var</span> arr [<span class=\"hljs-number\">3</span>]<span class=\"hljs-keyword\">int</span> <span class=\"hljs-comment\">// array declaration</span>\nfmt.Println(arr)\n<span class=\"hljs-comment\">// var size int = 5\t // can not specify size of array with variables.</span>\n<span class=\"hljs-comment\">// var arr [size]int // it occurs an error.</span>\n</code></pre>\n<p>위 코드에서 <code>[3]int</code>은 크기가 <em>3</em>인 <code>int</code>의 Array임을 나타낸다. Array의 값을 초기화하지 않았으므로, <code>int</code>의 Zero value인 0으로 채워진다.\n그리고 Array는 크기가 정해진 데이터에 대해서만 지원한다. 주석 처리된 부분처럼 배열의 크기를 변수값으로 초기화하는 것은 불가능하다.</p>\n<br>\n<p>C/C++에서 그렇듯, 중괄호를 이용하여 배열 내의 값을 초기화할 수 있다.</p>\n<pre><code class=\"hljs language-go\"><span class=\"hljs-comment\">// declare with literal</span>\n<span class=\"hljs-keyword\">var</span> x = [<span class=\"hljs-number\">3</span>]<span class=\"hljs-keyword\">int</span>{<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">3</span>}                  <span class=\"hljs-comment\">// [1, 2, 3]</span>\n<span class=\"hljs-keyword\">var</span> y = [<span class=\"hljs-number\">12</span>]<span class=\"hljs-keyword\">int</span>{<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">5</span>: <span class=\"hljs-number\">4</span>, <span class=\"hljs-number\">6</span>, <span class=\"hljs-number\">10</span>: <span class=\"hljs-number\">100</span>, <span class=\"hljs-number\">15</span>} <span class=\"hljs-comment\">// [1, 0, 0, 0, 0, 4, 6, 0, 0, 0, 100, 15]</span>\n<span class=\"hljs-keyword\">var</span> z = [...]<span class=\"hljs-keyword\">int</span>{<span class=\"hljs-number\">4</span>, <span class=\"hljs-number\">5</span>, <span class=\"hljs-number\">6</span>, <span class=\"hljs-number\">7</span>, <span class=\"hljs-number\">8</span>}          <span class=\"hljs-comment\">// [4, 5, 6, 7, 8]</span>\n</code></pre>\n<p>위 코드의 변수 <code>y</code>를 초기화하는 라인에서 <code>n:m</code> 형태의 표기법을 확인할 수 있다. <code>n</code>번째 인덱스의 값을 <code>m</code>으로 초기화한다는 의미이다.\n지정되지 않은 다른 값들은 Zero value인 <em>0</em>으로 초기화된다.<br>\n변수 <code>z</code>를 초기화하는 라인처럼 배열의 크기에 <code>...</code>가 입력되면 자동으로 배열의 크기를 결정한다. 위 코드에서 <code>z</code>의 크기는 <em>5</em>가 될 것이다.</p>\n<br>\n<p>여느 언어가 그렇듯, 대괄호를 통해 indexing한다. 인덱스에 음수나 배열 크기보다 큰 수 넣으면 런타임 에러가 발생한다.\n또한 <code>len()</code> 함수를 사용하여 Array의 크기를 확인할 수 있다.</p>\n<pre><code class=\"hljs language-go\">x[<span class=\"hljs-number\">2</span>] = <span class=\"hljs-number\">10</span>\nfmt.Println(x[<span class=\"hljs-number\">2</span>]) <span class=\"hljs-comment\">// indexing by bracket</span>\nfmt.Println(<span class=\"hljs-built_in\">len</span>(x))\n</code></pre>\n<br>\n<p>다차원 배열은 좀 난해하하다고 느꼈는데, 어떻게 사용하는지는 코드를 바로 보는 편이 이해가 빠를 것이다.</p>\n<pre><code class=\"hljs language-go\"><span class=\"hljs-keyword\">var</span> multidimentional = [<span class=\"hljs-number\">2</span>][<span class=\"hljs-number\">3</span>]<span class=\"hljs-keyword\">int</span>{{<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">3</span>}, {<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">3</span>}} <span class=\"hljs-comment\">// multidimetional array</span>\nfmt.Println(multidimentional)\n</code></pre>\n<br>\n<p>이건 좀 신기했던 부분인데, Go에서 Array는 크기와 element의 타입이 같다면 동일한 타입으로 여긴다. 그래서 <code>==</code>와 <code>!=</code>의 두 가지의 비교 연산이 가능하다!\n다만 element의 타입이 같아도 Array의 크기가 다르다면 서로 다른 타입으로 여기기 때문에, 비교 연산을 하면 에러가 발생한다.</p>\n<pre><code class=\"hljs language-go\"><span class=\"hljs-keyword\">var</span> a = [...]<span class=\"hljs-keyword\">int</span>{<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">3</span>}\n<span class=\"hljs-keyword\">var</span> b = [<span class=\"hljs-number\">3</span>]<span class=\"hljs-keyword\">int</span>{<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">3</span>}\n<span class=\"hljs-keyword\">var</span> c = [<span class=\"hljs-number\">2</span>]<span class=\"hljs-keyword\">int</span>{<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>}\nfmt.Println(a == b) <span class=\"hljs-comment\">// prints true</span>\n<span class=\"hljs-comment\">// fmt.Println(a == c) // occurs error</span>\n</code></pre>\n<p><br><br></p>\n<h2>Slice</h2>\n<hr>\n<p><strong>Slice</strong>는 동적으로 크기가 늘어났다 줄어들었다 하는 Array라고 볼 수 있다. 다른 언어에도 이와 유사한 타입들이 많이 존재하지만, Go의 Slice는 좀 유니크하다.<br>\n먼저 Array와는 달리 대괄호 사이를 비워놓고 선언한다. Array와 유사한 부분들을 모아보았다.</p>\n<pre><code class=\"hljs language-go\"><span class=\"hljs-keyword\">var</span> x = []<span class=\"hljs-keyword\">int</span>{<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">3</span>} <span class=\"hljs-comment\">// declaration + initialization</span>\n<span class=\"hljs-keyword\">var</span> y = []<span class=\"hljs-keyword\">int</span>{<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">5</span>: <span class=\"hljs-number\">4</span>, <span class=\"hljs-number\">6</span>, <span class=\"hljs-number\">10</span>: <span class=\"hljs-number\">100</span>, <span class=\"hljs-number\">15</span>} <span class=\"hljs-comment\">// [1, 0, 0, 0, 0, 4, 6, 0, 0, 0, 100, 15]</span>\nfmt.Println(x, y)\n\nx[<span class=\"hljs-number\">2</span>] = <span class=\"hljs-number\">10</span>\nfmt.Println(x[<span class=\"hljs-number\">2</span>]) <span class=\"hljs-comment\">// indexing by bracket</span>\n\n<span class=\"hljs-keyword\">var</span> multidimentional = [][]<span class=\"hljs-keyword\">int</span>{{<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">3</span>}, {<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">3</span>}} <span class=\"hljs-comment\">// multidimetional slice</span>\nfmt.Println(multidimentional)\n\nfmt.Println(<span class=\"hljs-built_in\">len</span>(x)) <span class=\"hljs-comment\">// the number of current elements</span>\n</code></pre>\n<br>\n<p>이제 다른 부분들을 하나씩 알아보자.</p>\n<p>선언만 하고 초기화하지 않으면 해당 타입의 Zero value로 초기화하는 Array와는 달리, Slice는 비어 있는 객체라는 뜻인 Slice는 <code>nil</code>이 된다.\n이때 <code>nil</code>과 Length가 0인 Slice는 엄연히 서로 다르다.\n<code>nil</code>은 C/C++의 <code>NULL</code>과 자바스크립트의 <code>null</code> 사이 어딘가의 느낌인데, 추후 설명하겠다.</p>\n<pre><code class=\"hljs language-go\"><span class=\"hljs-keyword\">var</span> slice1 []<span class=\"hljs-keyword\">int</span>            <span class=\"hljs-comment\">// slice declaration</span>\n<span class=\"hljs-keyword\">var</span> slice2 = []<span class=\"hljs-keyword\">int</span>{}        <span class=\"hljs-comment\">// zero-length slice</span>\nfmt.Println(slice1, slice2)\nfmt.Println(slice1 == <span class=\"hljs-literal\">nil</span>, slice2 == <span class=\"hljs-literal\">nil</span>)\n<span class=\"hljs-comment\">// comparation between two slices occurs error; only possible comparation is the one between slice and nil</span>\n</code></pre>\n<p>타입과 크기가 같다면 비교 연산을 할 수 있었던 Array와는 달리, slice끼리는 타입이 같아도 서로 비교 연산을 할 수 없다.\nslice와 nil과의 비교 연산만 허용된다.</p>\n<br>\n<p><code>make()</code> 함수를 이용하여 slice를 생성할 수도 있다. 타입, Length, Capacity를 인자로 설정한다.</p>\n<pre><code class=\"hljs language-go\">initialized_capacity := <span class=\"hljs-built_in\">make</span>([]<span class=\"hljs-keyword\">int</span>, <span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">5</span>) <span class=\"hljs-comment\">// make(type, length, capacity)</span>\n<span class=\"hljs-comment\">// initialized_capacity := make([]int, 6, 5) // it occurs an error (length > capacity)</span>\n</code></pre>\n<p><br><br></p>\n<h3>Appending Elements into Slices</h3>\n<br>\n<p>Slice에 값을 추가하기 위해서는 <code>append()</code> 함수를 사용한다. 값을 추가할 Slice와, 한 개 이상의 추가할 값들을 파라미터로 받는다.<br>\n<code>...</code> 연산자를 활용하여, 다른 Slice 변수의 값들을 추가할수도 있다.</p>\n<p>특이사항은 <code>append()</code>함수에 값을 추가할 Slice 변수를 넣고, 반환값을 다시 그 변수로 받아야 한다는 것이다.</p>\n<pre><code class=\"hljs language-go\"><span class=\"hljs-comment\">// capacity grows as it gets appended</span>\nslice = <span class=\"hljs-built_in\">append</span>(slice, <span class=\"hljs-number\">10</span>)\nfmt.Println(slice, <span class=\"hljs-built_in\">len</span>(slice), <span class=\"hljs-built_in\">cap</span>(slice))\nslice = <span class=\"hljs-built_in\">append</span>(slice, <span class=\"hljs-number\">20</span>, <span class=\"hljs-number\">30</span>, <span class=\"hljs-number\">40</span>, <span class=\"hljs-number\">50</span>)\nfmt.Println(slice, <span class=\"hljs-built_in\">len</span>(slice), <span class=\"hljs-built_in\">cap</span>(slice))\n\ntmp := []<span class=\"hljs-keyword\">int</span>{<span class=\"hljs-number\">20</span>, <span class=\"hljs-number\">30</span>, <span class=\"hljs-number\">40</span>}\nslice = <span class=\"hljs-built_in\">append</span>(slice, tmp...)\nfmt.Println(slice, <span class=\"hljs-built_in\">len</span>(slice), <span class=\"hljs-built_in\">cap</span>(slice))\n<span class=\"hljs-comment\">// append(slice, x...) => it occurs an error (append() returns an slice that the element is appended to.)</span>\n</code></pre>\n<p>이때 위 코드에서 <code>cap()</code>라는 함수를 사용된는 것을 확인할 수 있다.\nSlice에는 요소들의 개수를 나타내는 <em>Length</em>뿐 아니라, <strong>Capacity</strong>라는 속성이 존재한다. 이는 요소들이 추가될 수 있는 전체 공간의 크기를 의미한다.\n<code>append()</code>로 변수 <code>slice</code>에 요소들을 추가할 때마다 Length가 증가하고, Length가 Capacity를 초과하려고 할 때마다 Capacity도 증가함을 확인할 수 있다.</p>\n<p><br><br></p>\n<h3>Slicing Slices</h3>\n<br>\n<p>Python의 <code>List</code>처럼 대괄호에 콜론(<code>:</code>)과 인덱스를 붙여 Slicing할 수 있다.</p>\n<pre><code class=\"hljs language-go\">x := []<span class=\"hljs-keyword\">int</span>{<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">3</span>, <span class=\"hljs-number\">4</span>}\ny := x[:<span class=\"hljs-number\">2</span>]\nz := x[<span class=\"hljs-number\">1</span>:]\nd := x[<span class=\"hljs-number\">1</span>:<span class=\"hljs-number\">3</span>]\ne := x[:]\nfmt.Println(x, y, z, d, e)\n</code></pre>\n<p>Python은 이렇게 Slicing 하면, Slicing된 새로운 <code>List</code>가 복사되어, 원본과 같은 공간을 가리키지 않는다. 반면 Go의 Slicing된 <code>Slice</code>는 원본을 가리킨다. <code>e</code>의 값 중 하나를 수정해보면, <code>x</code>, <code>z</code>, <code>d</code>까지 해당 값을 포함했던 모든 <code>Slice</code>의 값들도 변경됨을 확인할 수 있다.</p>\n<pre><code class=\"hljs language-go\">e[<span class=\"hljs-number\">2</span>] = <span class=\"hljs-number\">1</span>                   <span class=\"hljs-comment\">// Slicing overwraps storage</span>\nfmt.Println(x, y, z, d, e) <span class=\"hljs-comment\">// value of x, z, d, e is changed</span>\n</code></pre>\n<br>\n<p>사실 여기까진 그냥 그런가보다 할텐데, 원소를 추가하기 시작하면 본격적으로 어지러워진다.</p>\n<pre><code class=\"hljs language-go\">fmt.Println(<span class=\"hljs-built_in\">cap</span>(x), <span class=\"hljs-built_in\">cap</span>(y), <span class=\"hljs-built_in\">cap</span>(z), <span class=\"hljs-built_in\">cap</span>(d), <span class=\"hljs-built_in\">cap</span>(e))\ny = <span class=\"hljs-built_in\">append</span>(y, <span class=\"hljs-number\">30</span>) <span class=\"hljs-comment\">// appending an elements into y changes the mapped value of other slices, but not changes their length</span>\n\nfmt.Println(x, y, z, d, e) <span class=\"hljs-comment\">// it's too confusing :(</span>\nfmt.Println(<span class=\"hljs-built_in\">cap</span>(x), <span class=\"hljs-built_in\">cap</span>(y), <span class=\"hljs-built_in\">cap</span>(z), <span class=\"hljs-built_in\">cap</span>(d), <span class=\"hljs-built_in\">cap</span>(e))\n</code></pre>\n<br>\n<p>추가 이전, <code>x</code>, <code>y</code>, <code>z</code>, <code>d</code>, <code>e</code>는 아래와 같았는데,</p>\n<pre><code class=\"hljs language-go\">[<span class=\"hljs-number\">1</span> <span class=\"hljs-number\">2</span> <span class=\"hljs-number\">1</span> <span class=\"hljs-number\">4</span>] [<span class=\"hljs-number\">1</span> <span class=\"hljs-number\">2</span>] [<span class=\"hljs-number\">2</span> <span class=\"hljs-number\">1</span> <span class=\"hljs-number\">4</span>] [<span class=\"hljs-number\">2</span> <span class=\"hljs-number\">1</span>] [<span class=\"hljs-number\">1</span> <span class=\"hljs-number\">2</span> <span class=\"hljs-number\">1</span> <span class=\"hljs-number\">4</span>]\n</code></pre>\n<p>이렇게 변했다.</p>\n<pre><code class=\"hljs language-go\">[<span class=\"hljs-number\">1</span> <span class=\"hljs-number\">2</span> <span class=\"hljs-number\">30</span> <span class=\"hljs-number\">4</span>] [<span class=\"hljs-number\">1</span> <span class=\"hljs-number\">2</span> <span class=\"hljs-number\">30</span>] [<span class=\"hljs-number\">2</span> <span class=\"hljs-number\">30</span> <span class=\"hljs-number\">4</span>] [<span class=\"hljs-number\">2</span> <span class=\"hljs-number\">30</span>] [<span class=\"hljs-number\">1</span> <span class=\"hljs-number\">2</span> <span class=\"hljs-number\">30</span> <span class=\"hljs-number\">4</span>]\n</code></pre>\n<p><code>y</code>에 <code>30</code>을 추가했으니 <code>[1 2 30]</code>이 된 건 그렇다 치고, <code>x</code>, <code>z</code>, <code>d</code>, <code>e</code>에서 대응되는 위치에 있었던 <code>1</code>도 모두 <code>30</code>으로 바뀌었음을 알 수 있다.\n그리고 여기서 <code>y</code>만 length가 바뀌었으므로, 나타나는 원소의 개수는 <code>y</code>만 2개에서 3개로 늘었다.</p>\n<br>\n<p>다음의 예제를 보자.</p>\n<pre><code class=\"hljs language-go\">xx := <span class=\"hljs-built_in\">make</span>([]<span class=\"hljs-keyword\">int</span>, <span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">5</span>)\nxx = <span class=\"hljs-built_in\">append</span>(xx, <span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">3</span>, <span class=\"hljs-number\">4</span>)\nyy := xx[:<span class=\"hljs-number\">2</span>]\nzz := xx[<span class=\"hljs-number\">2</span>:]\n\nfmt.Println(<span class=\"hljs-built_in\">cap</span>(xx), <span class=\"hljs-built_in\">cap</span>(yy), <span class=\"hljs-built_in\">cap</span>(zz))\nyy = <span class=\"hljs-built_in\">append</span>(yy, <span class=\"hljs-number\">30</span>, <span class=\"hljs-number\">40</span>, <span class=\"hljs-number\">50</span>)\nxx = <span class=\"hljs-built_in\">append</span>(xx, <span class=\"hljs-number\">60</span>)\nzz = <span class=\"hljs-built_in\">append</span>(zz, <span class=\"hljs-number\">70</span>)\n\nfmt.Println(<span class=\"hljs-string\">\"xx:\"</span>, xx)\nfmt.Println(<span class=\"hljs-string\">\"yy:\"</span>, yy)\nfmt.Println(<span class=\"hljs-string\">\"zz:\"</span>, zz)\n</code></pre>\n<p>해당 구문의 실행 결과는 ...</p>\n<pre><code class=\"hljs language-go\"><span class=\"hljs-number\">5</span> <span class=\"hljs-number\">5</span> <span class=\"hljs-number\">3</span>\nxx: [<span class=\"hljs-number\">1</span> <span class=\"hljs-number\">2</span> <span class=\"hljs-number\">30</span> <span class=\"hljs-number\">40</span> <span class=\"hljs-number\">70</span>]\nyy: [<span class=\"hljs-number\">1</span> <span class=\"hljs-number\">2</span> <span class=\"hljs-number\">30</span> <span class=\"hljs-number\">40</span> <span class=\"hljs-number\">70</span>]\nzz: [<span class=\"hljs-number\">30</span> <span class=\"hljs-number\">40</span> <span class=\"hljs-number\">70</span>]\n</code></pre>\n<br>\n<center>\n<p><img src=\"https://raw.githubusercontent.com/junhyuk0801/junhyuk0801.github.io/post-pictures/pictures/Golang/Golang%20Basics/GO3/1.jpg\" alt=\"\"></p>\n</center>\n<br>\n<p>상당히 혼란스럽다. 하나씩 알아보자.</p>\n<pre><code class=\"hljs language-go\">xx := <span class=\"hljs-built_in\">make</span>([]<span class=\"hljs-keyword\">int</span>, <span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">5</span>)\nxx = <span class=\"hljs-built_in\">append</span>(xx, <span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">3</span>, <span class=\"hljs-number\">4</span>)\nyy := xx[:<span class=\"hljs-number\">2</span>]\nzz := xx[<span class=\"hljs-number\">2</span>:]\n</code></pre>\n<p>여기까지 실행했을 때, <code>xx</code>, <code>yy</code>, <code>zz</code>의 값은</p>\n<pre><code class=\"hljs language-go\">xx: [<span class=\"hljs-number\">1</span> <span class=\"hljs-number\">2</span> <span class=\"hljs-number\">3</span> <span class=\"hljs-number\">4</span>] <span class=\"hljs-built_in\">len</span>=<span class=\"hljs-number\">4</span> <span class=\"hljs-built_in\">cap</span>=<span class=\"hljs-number\">5</span>\nyy: [<span class=\"hljs-number\">1</span> <span class=\"hljs-number\">2</span>] <span class=\"hljs-built_in\">len</span>=<span class=\"hljs-number\">2</span> <span class=\"hljs-built_in\">cap</span>=<span class=\"hljs-number\">5</span>\nzz: [<span class=\"hljs-number\">3</span> <span class=\"hljs-number\">4</span>] <span class=\"hljs-built_in\">len</span>=<span class=\"hljs-number\">2</span> <span class=\"hljs-built_in\">cap</span>=<span class=\"hljs-number\">3</span>\n</code></pre>\n<p>이다. 이제, <code>yy</code>에 <code>30</code>, <code>40</code>, <code>50</code>을 추가해보자.</p>\n<pre><code class=\"hljs language-go\">xx: [<span class=\"hljs-number\">1</span> <span class=\"hljs-number\">2</span> <span class=\"hljs-number\">30</span> <span class=\"hljs-number\">40</span>] <span class=\"hljs-built_in\">len</span>=<span class=\"hljs-number\">4</span> <span class=\"hljs-built_in\">cap</span>=<span class=\"hljs-number\">5</span>\nyy: [<span class=\"hljs-number\">1</span> <span class=\"hljs-number\">2</span> <span class=\"hljs-number\">30</span> <span class=\"hljs-number\">40</span> <span class=\"hljs-number\">50</span>] <span class=\"hljs-built_in\">len</span>=<span class=\"hljs-number\">5</span> <span class=\"hljs-built_in\">cap</span>=<span class=\"hljs-number\">5</span>\nzz: [<span class=\"hljs-number\">30</span> <span class=\"hljs-number\">40</span>] <span class=\"hljs-built_in\">len</span>=<span class=\"hljs-number\">2</span> <span class=\"hljs-built_in\">cap</span>=<span class=\"hljs-number\">3</span>\n</code></pre>\n<br>\n<p><code>xx</code>와 <code>zz</code>는 <code>yy</code>와 같은 공간을 공유한다. 따라서 대응되는 위치의 값이었던 <code>xx</code>와 <code>zz</code>의 <code>3</code>, <code>4</code>가 각각 <code>30</code>, <code>40</code>으로 바뀌었음을 확인할 수 있다.\n반면 <code>xx</code>와 <code>zz</code>의 Length는 바뀌지 않고, <code>yy</code>의 Length만 5로 바뀌었다.<br>\n여기서 <code>xx = append(xx, 60)</code>가 실행되면,</p>\n<pre><code class=\"hljs language-go\">xx: [<span class=\"hljs-number\">1</span> <span class=\"hljs-number\">2</span> <span class=\"hljs-number\">30</span> <span class=\"hljs-number\">40</span> <span class=\"hljs-number\">60</span>] <span class=\"hljs-built_in\">len</span>=<span class=\"hljs-number\">5</span> <span class=\"hljs-built_in\">cap</span>=<span class=\"hljs-number\">5</span>\nyy: [<span class=\"hljs-number\">1</span> <span class=\"hljs-number\">2</span> <span class=\"hljs-number\">30</span> <span class=\"hljs-number\">40</span> <span class=\"hljs-number\">60</span>] <span class=\"hljs-built_in\">len</span>=<span class=\"hljs-number\">5</span> <span class=\"hljs-built_in\">cap</span>=<span class=\"hljs-number\">5</span>\nzz: [<span class=\"hljs-number\">30</span> <span class=\"hljs-number\">40</span>] <span class=\"hljs-built_in\">len</span>=<span class=\"hljs-number\">2</span> <span class=\"hljs-built_in\">cap</span>=<span class=\"hljs-number\">3</span>\n</code></pre>\n<p><code>xx</code>에 60이 추가되며, <code>yy</code>의 대응되는 위치의 값이었던 50의 값이 60으로 바뀌었다.<br>\n여기서 <code>zz = append(zz, 70)</code>가 실행되면,</p>\n<pre><code class=\"hljs language-go\">xx: [<span class=\"hljs-number\">1</span> <span class=\"hljs-number\">2</span> <span class=\"hljs-number\">30</span> <span class=\"hljs-number\">40</span> <span class=\"hljs-number\">70</span>] <span class=\"hljs-built_in\">len</span>=<span class=\"hljs-number\">5</span> <span class=\"hljs-built_in\">cap</span>=<span class=\"hljs-number\">5</span>\nyy: [<span class=\"hljs-number\">1</span> <span class=\"hljs-number\">2</span> <span class=\"hljs-number\">30</span> <span class=\"hljs-number\">40</span> <span class=\"hljs-number\">70</span>] <span class=\"hljs-built_in\">len</span>=<span class=\"hljs-number\">5</span> <span class=\"hljs-built_in\">cap</span>=<span class=\"hljs-number\">5</span>\nzz: [<span class=\"hljs-number\">30</span> <span class=\"hljs-number\">40</span> <span class=\"hljs-number\">70</span>] <span class=\"hljs-built_in\">len</span>=<span class=\"hljs-number\">3</span> <span class=\"hljs-built_in\">cap</span>=<span class=\"hljs-number\">3</span>\n</code></pre>\n<p><code>xx</code>와 <code>yy</code>의 대응되는 위치의 값이었던 <code>60</code>이 <code>70</code>으로 바뀌었다.</p>\n<br>\n<p>Slice에 값을 <code>append</code>하였을 때 생기는 문제로 인해 직관적으로 이해하기 어려운 결과를 확인하였다.\n<code>xx</code>, <code>yy</code>, <code>zz</code>가 같은 Capacity를 공유하기 때문에 생긴 문제이다.\nSlice를 Slicing할 때, Capacity의 범위를 명시하는 표기법을 사용하면 이와 같은 문제를 어느 정도 해결할 수 있다.</p>\n<pre><code class=\"hljs language-go\">xxx := []<span class=\"hljs-keyword\">int</span>{<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">3</span>, <span class=\"hljs-number\">4</span>, <span class=\"hljs-number\">5</span>}\nyyy := xxx[:<span class=\"hljs-number\">2</span>:<span class=\"hljs-number\">2</span>] <span class=\"hljs-comment\">// limits capacity of slice, they not share additional capacity</span>\nzzz := xxx[<span class=\"hljs-number\">2</span>:<span class=\"hljs-number\">4</span>:<span class=\"hljs-number\">4</span>]\n\nfmt.Println(<span class=\"hljs-built_in\">cap</span>(xxx), <span class=\"hljs-built_in\">cap</span>(yyy), <span class=\"hljs-built_in\">cap</span>(zzz))\nyyy = <span class=\"hljs-built_in\">append</span>(yyy, <span class=\"hljs-number\">30</span>, <span class=\"hljs-number\">40</span>, <span class=\"hljs-number\">50</span>) <span class=\"hljs-comment\">// this appending never interacts with other slices</span>\nxxx = <span class=\"hljs-built_in\">append</span>(xxx, <span class=\"hljs-number\">60</span>)\nzzz = <span class=\"hljs-built_in\">append</span>(zzz, <span class=\"hljs-number\">70</span>)\nfmt.Println(xxx, yyy, zzz)\n</code></pre>\n<p>위 코드의 출력 결과는 아래와 같다.</p>\n<pre><code class=\"hljs language-go\"><span class=\"hljs-number\">5</span> <span class=\"hljs-number\">2</span> <span class=\"hljs-number\">2</span>\n[<span class=\"hljs-number\">1</span> <span class=\"hljs-number\">2</span> <span class=\"hljs-number\">3</span> <span class=\"hljs-number\">4</span> <span class=\"hljs-number\">5</span> <span class=\"hljs-number\">60</span>] [<span class=\"hljs-number\">1</span> <span class=\"hljs-number\">2</span> <span class=\"hljs-number\">30</span> <span class=\"hljs-number\">40</span> <span class=\"hljs-number\">50</span>] [<span class=\"hljs-number\">3</span> <span class=\"hljs-number\">4</span> <span class=\"hljs-number\">70</span>]\n</code></pre>\n<br>\n<p>한편 Array도 Slicing이 가능하며, Slicing된 값은 Slice 타입이다.</p>\n<pre><code class=\"hljs language-go\">ax := [...]<span class=\"hljs-keyword\">int</span>{<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">3</span>, <span class=\"hljs-number\">4</span>}\nay := ax[:<span class=\"hljs-number\">2</span>] <span class=\"hljs-comment\">// slicing array</span>\naz := ax[<span class=\"hljs-number\">2</span>:]\nax[<span class=\"hljs-number\">0</span>] = <span class=\"hljs-number\">10</span>\nfmt.Println(ax, ay, az)\n</code></pre>\n<p><br><br></p>\n<h3>Copying Slices</h3>\n<br>\n<p>또다른 해결방법은 다른 언어의 <em>deep copy</em>처럼, 새로운 공간에 값들을 복사하는 방법이다. <code>copy()</code> 함수를 통해 할 수 있다.</p>\n<pre><code class=\"hljs language-go\">x := []<span class=\"hljs-keyword\">int</span>{<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">3</span>, <span class=\"hljs-number\">4</span>}\ny := <span class=\"hljs-built_in\">make</span>([]<span class=\"hljs-keyword\">int</span>, <span class=\"hljs-number\">4</span>)\n\nnum := <span class=\"hljs-built_in\">copy</span>(y, x)   <span class=\"hljs-comment\">// copy(destination, source). x is copied into y</span>\nfmt.Println(y, num) <span class=\"hljs-comment\">// num: the number of elements copied (decided by length of slices)</span>\ny[<span class=\"hljs-number\">2</span>] = <span class=\"hljs-number\">1</span>            <span class=\"hljs-comment\">// if we change any value of y,</span>\nfmt.Println(y, x)   <span class=\"hljs-comment\">// values of x still unchanged (doesn't share memory spaces)</span>\n</code></pre>\n<br>\n<p><code>copy()</code> 함수는 두 번째 인수로 들어온 Array나 Slice를 첫 번째 인수로 들어온 Slice에 복사한다. 반환값은 복사된 원소의 수이다.</p>\n<pre><code class=\"hljs language-go\">z := <span class=\"hljs-built_in\">make</span>([]<span class=\"hljs-keyword\">int</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">4</span>) <span class=\"hljs-comment\">// because length of z is 2,</span>\nnum = <span class=\"hljs-built_in\">copy</span>(z, x)       <span class=\"hljs-comment\">// when it is copied, only two of x are copied.</span>\nfmt.Println(z, num)    <span class=\"hljs-comment\">// [1, 2] 2</span>\n</code></pre>\n<br>\n<p><code>copy()</code> 함수의 인수로 들어오는 Slice나 Array들은 Length가 서로 다를 수 있다.\nDestination Slice의 Length가 Source Slice보다 크다면, 앞쪽의 원소들부터 채워진다.</p>\n<pre><code class=\"hljs language-go\">w := <span class=\"hljs-built_in\">make</span>([]<span class=\"hljs-keyword\">int</span>, <span class=\"hljs-number\">4</span>, <span class=\"hljs-number\">4</span>) <span class=\"hljs-comment\">//</span>\nnum = <span class=\"hljs-built_in\">copy</span>(w, x[:<span class=\"hljs-number\">2</span>])   <span class=\"hljs-comment\">// because x[:2] has only two element (length is 2),</span>\nfmt.Println(w, num)    <span class=\"hljs-comment\">// x[:2] is copied into first two elements</span>\n</code></pre>\n<p>동일한 원리로 이런 것도 가능하다.</p>\n<pre><code class=\"hljs language-go\">q := []<span class=\"hljs-keyword\">int</span>{<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">3</span>, <span class=\"hljs-number\">4</span>}\nnum = <span class=\"hljs-built_in\">copy</span>(q[:<span class=\"hljs-number\">3</span>], q[<span class=\"hljs-number\">1</span>:]) <span class=\"hljs-comment\">// [2, 3, 4] is copied into [1, 2, 3]</span>\nfmt.Println(q, num)      <span class=\"hljs-comment\">// [2, 3, 4, 4]</span>\n</code></pre>\n<p><br><br></p>\n<h2>string</h2>\n<hr>\n<p><code>string</code>은 Primitive Data Type이지만, 여러 문자들의 Slice처럼 생각할 수도 있다. Slice처럼 <code>string</code>을 Slicing할 수도 있다.</p>\n<pre><code class=\"hljs language-go\"><span class=\"hljs-keyword\">var</span> s <span class=\"hljs-keyword\">string</span> = <span class=\"hljs-string\">\"Hello there\"</span>\nfmt.Println(s, b, <span class=\"hljs-built_in\">len</span>(s))\n\n<span class=\"hljs-comment\">// slicing string</span>\nfmt.Println(s[<span class=\"hljs-number\">4</span>:<span class=\"hljs-number\">7</span>])\nfmt.Println(s[<span class=\"hljs-number\">5</span>:])\nfmt.Println(s[:<span class=\"hljs-number\">6</span>])\n</code></pre>\n<p>한편, 알파벳과 같은 일반적인 문자들을 <code>string</code>으로 표현할 때는 문제를 느끼지 못할 수도 있다.\n하지만 한글처럼 UTF-8에서 2바이트 이상의 크기로 표현되는 문자들은 Slicing시 문자가 제대로 나타나지 않을 때도 있다.</p>\n<pre><code class=\"hljs language-go\"><span class=\"hljs-keyword\">var</span> h <span class=\"hljs-keyword\">string</span> = <span class=\"hljs-string\">\"한글조아\"</span>\nfmt.Println(h, <span class=\"hljs-built_in\">len</span>(h))\n<span class=\"hljs-comment\">// each character of korean letter takes 3 bytes, slicing like below would not be done properly</span>\nfmt.Println(h[<span class=\"hljs-number\">2</span>:])\nfmt.Println(h[:<span class=\"hljs-number\">5</span>])\nfmt.Println(h[<span class=\"hljs-number\">2</span>:<span class=\"hljs-number\">7</span>])\n</code></pre>\n<p><code>string</code>을 구성하는 각 문자들은 <code>rune</code> 타입이지만, 실제로 <code>string</code>은 <code>byte</code>들의 배열이다.\n<code>rune</code>은 문자가 1바이트든, 4바이트든 한 개의 문자를 온전히 나타낼 수 있고,\n<code>byte</code>는 2바이트 이상의 문자를 나타내기 위해서는 2개 이상 모여야 한다는 것이다.</p>\n<pre><code class=\"hljs language-go\"><span class=\"hljs-comment\">// difference of rune and byte</span>\n<span class=\"hljs-keyword\">var</span> ss <span class=\"hljs-keyword\">string</span> = <span class=\"hljs-string\">\"Hello 안녕\"</span>\n<span class=\"hljs-keyword\">var</span> bs []<span class=\"hljs-keyword\">byte</span> = []<span class=\"hljs-keyword\">byte</span>(ss) <span class=\"hljs-comment\">// []byte splits UTF-8 characters. usually use this.</span>\n<span class=\"hljs-keyword\">var</span> rs []<span class=\"hljs-keyword\">rune</span> = []<span class=\"hljs-keyword\">rune</span>(ss) <span class=\"hljs-comment\">// []rune doesn't split</span>\nfmt.Println(bs, rs)\n</code></pre>\n<p>위처럼 <code>string</code>을 각각 <code>byte</code>와 <code>rune</code>의 Slice로 변환해보면 확인할 수 있다.</p>\n<p><br><br></p>\n<h2>Map</h2>\n<hr>\n<p><strong>Map</strong>은 전형적인 Key-Value 페어의 데이터타입으로, C++의 <code>map</code>과 유사하다. 아래 코드처럼 선언하고, 초기화할 수 있다. <br>\nSlice와 마찬가지로 <code>map</code>의 Zero value는 반드시 <code>nil</code>이며, 크기가 0인 <code>map</code>과 <code>nil</code>은 서로 다르다.</p>\n<pre><code class=\"hljs language-go\"><span class=\"hljs-keyword\">var</span> nilMap <span class=\"hljs-keyword\">map</span>[<span class=\"hljs-keyword\">string</span>]<span class=\"hljs-keyword\">int</span>\nmamap := <span class=\"hljs-keyword\">map</span>[<span class=\"hljs-keyword\">string</span>]<span class=\"hljs-keyword\">int</span>{}\nfmt.Println(nilMap, mamap, nilMap == <span class=\"hljs-literal\">nil</span>, mamap == <span class=\"hljs-literal\">nil</span>)\n</code></pre>\n<br>\n<p>초기화하는 방법도 다른 언어와 유사하다. 아래의 예제는 key는 <code>string</code>이고, value는 <code>string</code>의 <code>slice</code>인 <code>map</code>이다.</p>\n<pre><code class=\"hljs language-go\"><span class=\"hljs-keyword\">var</span> teams = <span class=\"hljs-keyword\">map</span>[<span class=\"hljs-keyword\">string</span>][]<span class=\"hljs-keyword\">string</span>{\n    <span class=\"hljs-string\">\"Orcas\"</span>:   []<span class=\"hljs-keyword\">string</span>{<span class=\"hljs-string\">\"Fred\"</span>, <span class=\"hljs-string\">\"Ralph\"</span>},\n    <span class=\"hljs-string\">\"Lions\"</span>:   []<span class=\"hljs-keyword\">string</span>{<span class=\"hljs-string\">\"Sarah\"</span>, <span class=\"hljs-string\">\"Peter\"</span>},\n    <span class=\"hljs-string\">\"Kittens\"</span>: {<span class=\"hljs-string\">\"Waldo\"</span>, <span class=\"hljs-string\">\"Raul\"</span>}, <span class=\"hljs-comment\">// 이렇게 해도 됨</span>\n}\nfmt.Println(teams)\n</code></pre>\n<br>\n<p><code>make()</code>함수와 <code>len()</code>함수는 map에서도 사용할 수 있다.</p>\n<pre><code class=\"hljs language-go\">ages := <span class=\"hljs-built_in\">make</span>(<span class=\"hljs-keyword\">map</span>[<span class=\"hljs-keyword\">int</span>][]<span class=\"hljs-keyword\">string</span>, <span class=\"hljs-number\">10</span>)\nfmt.Println(ages, <span class=\"hljs-built_in\">len</span>(ages)) <span class=\"hljs-comment\">// len() returns the number of key-value pairs of map</span>\n</code></pre>\n<br>\n<p>사용 방법은 다른 언어의 일반적인 Key-Value 페어 데이터타입과 크게 다르지 않다. 이때 Value값이 존재하지 않는 Key에 접근하면 Zero value를 반환한다.</p>\n<pre><code class=\"hljs language-go\">totalWins := <span class=\"hljs-keyword\">map</span>[<span class=\"hljs-keyword\">string</span>]<span class=\"hljs-keyword\">int</span>{}\ntotalWins[<span class=\"hljs-string\">\"Orcas\"</span>] = <span class=\"hljs-number\">1</span> <span class=\"hljs-comment\">// assigning value into specific key with =, not :=</span>\ntotalWins[<span class=\"hljs-string\">\"Lions\"</span>] = <span class=\"hljs-number\">2</span>\nfmt.Println(totalWins[<span class=\"hljs-string\">\"Orcas\"</span>])\nfmt.Println(totalWins[<span class=\"hljs-string\">\"Kittens\"</span>]) <span class=\"hljs-comment\">// an initial value of int is zero.</span>\ntotalWins[<span class=\"hljs-string\">\"Kittens\"</span>]++            <span class=\"hljs-comment\">// value of \"Kittens\" would be 1</span>\ntotalWins[<span class=\"hljs-string\">\"Lions\"</span>] = <span class=\"hljs-number\">3</span>\nfmt.Println(totalWins[<span class=\"hljs-string\">\"Kittens\"</span>])\nfmt.Println(totalWins[<span class=\"hljs-string\">\"Lions\"</span>])\n</code></pre>\n<br>\n<p>이 때 Value값이 존재하지 않는 Key에 접근한 것인지, 아니면 그냥 Value값이 Zero value인지 알 수 없다.</p>\n<pre><code class=\"hljs language-go\">m := <span class=\"hljs-keyword\">map</span>[<span class=\"hljs-keyword\">string</span>]<span class=\"hljs-keyword\">int</span>{\n    <span class=\"hljs-string\">\"Hello\"</span>: <span class=\"hljs-number\">5</span>,\n    <span class=\"hljs-string\">\"world\"</span>: <span class=\"hljs-number\">0</span>,\n}\n</code></pre>\n<p>이를테면 위와 같은 예제에서 Key가 <code>\"world\"</code>일 때와, Key가 <code>\"Bye\"</code>일 때 동일하게 0이라는 값을 얻게 될 것이다.\nGo 개발자들은 당연히 이에 대한 해결책으로 <em>comma ok idiom</em>이란 것을 만들어 두었다.</p>\n<pre><code class=\"hljs language-go\"><span class=\"hljs-comment\">// comma idiom</span>\nv, ok := m[<span class=\"hljs-string\">\"Hello\"</span>] <span class=\"hljs-comment\">// v gets value of the given key</span>\nfmt.Println(v, ok)  <span class=\"hljs-comment\">// ok gets if the key exists in map</span>\n\nv, ok = m[<span class=\"hljs-string\">\"world\"</span>] <span class=\"hljs-comment\">// though v gets zero value,</span>\nfmt.Println(v, ok) <span class=\"hljs-comment\">// ok gets true because \"world\" exists in map</span>\n\nv, ok = m[<span class=\"hljs-string\">\"nono\"</span>]  <span class=\"hljs-comment\">// \"nono\" doesn't exist in map, so ok gets false</span>\nfmt.Println(v, ok) <span class=\"hljs-comment\">// v gets zero value,</span>\n\n<span class=\"hljs-built_in\">delete</span>(m, <span class=\"hljs-string\">\"Hello\"</span>) <span class=\"hljs-comment\">// deletes key \"Hello\" from the map</span>\nv, ok = m[<span class=\"hljs-string\">\"Hello\"</span>] <span class=\"hljs-comment\">// the key doesn't exist in map as it is deleted</span>\nfmt.Println(v, ok)\n</code></pre>\n<p>위 예제에서 <code>m</code>에서 반환받은 값을 계속 <code>v</code>, <code>ok</code> 두 개의 변수에 할당하는 것을 확인할 수 있다.\n이 때 첫 번째 변수인 <code>v</code>에는 Key에 해당하는 Value가 들어가며, 두 번째 변수인 <code>ok</code>에는 해당 Key가 <code>m</code>에 존재하는지 여부가 <code>true</code> or <code>false</code>로 들어간다.\n또한 <code>map</code>에서 Key-Value 페어를 지우려면 <code>delete()</code> 함수를 사용한다.</p>\n<p><br><br></p>\n<h2>struct</h2>\n<hr>\n<p>C/C++의 <code>struct</code>와 유사하다. Go가 일반적으로 그런 것처럼, 필드들을 선언할 때 자료형이 필드명의 뒤에 온다.\nC/C++의 <code>typedef</code> 키워드처럼, <code>type</code> 키워드를 통해 <code>struct</code> 타입을 정의할 수 있다.</p>\n<pre><code class=\"hljs language-go\"><span class=\"hljs-keyword\">type</span> person <span class=\"hljs-keyword\">struct</span> { <span class=\"hljs-comment\">// define struct type</span>\n    name <span class=\"hljs-keyword\">string</span>\n    age  <span class=\"hljs-keyword\">int</span>\n    pet  <span class=\"hljs-keyword\">string</span>\n}\n\n<span class=\"hljs-keyword\">var</span> john person <span class=\"hljs-comment\">// struct variable declaration</span>\n<span class=\"hljs-keyword\">var</span> james = person{<span class=\"hljs-string\">\"James\"</span>, <span class=\"hljs-number\">24</span>, <span class=\"hljs-string\">\"cat\"</span>}\nkim := person{}                   <span class=\"hljs-comment\">// there is no difference on empty struct and zero value of struct</span>\nfred := person{<span class=\"hljs-string\">\"Fred\"</span>, <span class=\"hljs-number\">22</span>, <span class=\"hljs-string\">\"dog\"</span>} <span class=\"hljs-comment\">// values are assigned to the fields in the order they were declared in struct definition</span>\nbeth := person{                   <span class=\"hljs-comment\">// using key names (recommended)</span>\n    age:  <span class=\"hljs-number\">20</span>,\n    name: <span class=\"hljs-string\">\"Beth\"</span>,\n}\nfred.pet = <span class=\"hljs-string\">\"parrot\"</span> <span class=\"hljs-comment\">// can use dotted notation</span>\n\nfmt.Println(john, kim, james, fred, beth)\n</code></pre>\n<p><code>struct</code> 인스턴스를 생성할 때는 <code>struct</code>를 정의할 때 입력했던 순서대로 각 필드의 값을 중괄호 안에 입력해주면 된다.\n특이사항으로는 <code>map</code>이나 <code>slice</code>와는 달리, <code>struct</code>의 Zero value와 비어있는 <code>struct</code>가 동일하게 처리된다.</p>\n<p><br><br></p>\n<h3>Anonymous Structs</h3>\n<pre><code class=\"hljs language-go\"><span class=\"hljs-keyword\">var</span> human <span class=\"hljs-keyword\">struct</span> { <span class=\"hljs-comment\">// anonymous structs</span>\n\t\tname <span class=\"hljs-keyword\">string</span>\n\t\tage  <span class=\"hljs-keyword\">int</span>\n\t\tpet  <span class=\"hljs-keyword\">string</span>\n\t}\n\thuman.name = <span class=\"hljs-string\">\"Bob\"</span>\n\thuman.age = <span class=\"hljs-number\">24</span>\n\thuman.pet = <span class=\"hljs-string\">\"dog\"</span>\n\n\tpet := <span class=\"hljs-keyword\">struct</span> { <span class=\"hljs-comment\">// directly initializing anonymous structs</span>\n\t\tname <span class=\"hljs-keyword\">string</span>\n\t\tkind <span class=\"hljs-keyword\">string</span>\n\t}{\n\t\tname: <span class=\"hljs-string\">\"choco\"</span>,\n\t\tkind: <span class=\"hljs-string\">\"dog\"</span>,\n\t}\n\n\tfmt.Println(human, pet)\n</code></pre>\n<p>위 코드는 익명 <code>struct</code> 변수를 선언하고, 또 선언과 동시에 초기화하는 예제이다.\n타입 명시와 값 할당이 다른 중괄호 안에서 이루어져야 하는 것만 주의하면 큰 문제 없는 듯.</p>\n<p><br><br></p>\n<h3>Comparing and Converting Structs</h3>\n<pre><code class=\"hljs language-go\"><span class=\"hljs-keyword\">type</span> firstPerson <span class=\"hljs-keyword\">struct</span> {\n    name <span class=\"hljs-keyword\">string</span>\n    age  <span class=\"hljs-keyword\">int</span>\n}\nf1 := firstPerson{<span class=\"hljs-string\">\"kim\"</span>, <span class=\"hljs-number\">24</span>}\nf2 := firstPerson{<span class=\"hljs-string\">\"lee\"</span>, <span class=\"hljs-number\">25</span>}\nfmt.Println(f1 == f2) <span class=\"hljs-comment\">// comparing two firstPerson instances is possible when they are composed of comparable types</span>\n</code></pre>\n<p><code>struct</code>의 필드가 비교 가능한 타입들로 이루어져 있다면, 서로 같은 <code>struct</code> 타입끼리는 서로 비교할 수 있다.</p>\n<br>\n<pre><code class=\"hljs language-go\"><span class=\"hljs-keyword\">type</span> secondPerson <span class=\"hljs-keyword\">struct</span> {\n    name <span class=\"hljs-keyword\">string</span>\n    age <span class=\"hljs-keyword\">int</span>\n}\ns1 := secondPerson{<span class=\"hljs-string\">\"choi\"</span>, <span class=\"hljs-number\">26</span>}\n<span class=\"hljs-comment\">// fmt.Println(s1 == f1) // comparing(==, !=) secondPerson with firstPerson is impossible</span>\nfmt.Println(firstPerson(s1)) <span class=\"hljs-comment\">// convert secondPerson into firstPerson is possible because they have same fields</span>\n</code></pre>\n<p>서로 다른 <code>struct</code> 타입끼리는 서로 비교할 수 없다.\n단, 필드의 타입과 필드명이 같다면 서로 변환할 수 있다.</p>\n<br>\n<pre><code class=\"hljs language-go\"><span class=\"hljs-keyword\">type</span> thirdPerson <span class=\"hljs-keyword\">struct</span> {\n    age <span class=\"hljs-keyword\">int</span>\n    name <span class=\"hljs-keyword\">string</span>\n}\n<span class=\"hljs-comment\">// t1 := thirdPerson{27, \"Park\"}</span>\n<span class=\"hljs-comment\">// fmt.Println(firstPerson(t1)) // convert thirdPerson into firstPerson is impossible because their fields have different order.</span>\n</code></pre>\n<p>만약 필드의 타입과 필드명이 같아도 선언된 순서가 다르다면 비교 및 변환할 수 없다.</p>\n<br>\n<pre><code class=\"hljs language-go\"><span class=\"hljs-keyword\">type</span> fourthPerson <span class=\"hljs-keyword\">struct</span> {\n    firstName <span class=\"hljs-keyword\">string</span>\n    age <span class=\"hljs-keyword\">int</span>\n}\n<span class=\"hljs-comment\">// f3 := fourthPerson{\"Kang\", 28}</span>\n<span class=\"hljs-comment\">// fmt.Println(firstPerson(f3)) // convert fourthPerson into firstPerson is impossible because their fields have different name.</span>\n\n<span class=\"hljs-keyword\">type</span> fifthPerson <span class=\"hljs-keyword\">struct</span> {\n    name <span class=\"hljs-keyword\">string</span>\n    age <span class=\"hljs-keyword\">int</span>\n    hobby <span class=\"hljs-keyword\">string</span>\n}\n<span class=\"hljs-comment\">// f4 := fifthPerson{\"Seo\", 24, \"Cooking\"}</span>\n<span class=\"hljs-comment\">// fmt.Println(firstPerson(f4)) // convert fourthPerson into firstPerson is impossible because there is an additional field.</span>\n</code></pre>\n<p>타입이 같아도 필드명이 다르다면 변환할 수 없으며, 다른 필드가 추가로 존재하면 비교 및 변환할 수 없다.</p>\n<br>\n<pre><code class=\"hljs language-go\"><span class=\"hljs-keyword\">var</span> g <span class=\"hljs-keyword\">struct</span> {\n    name <span class=\"hljs-keyword\">string</span>\n    age  <span class=\"hljs-keyword\">int</span>\n}\ng = f1 <span class=\"hljs-comment\">// =, == are possible when anonymous struct have same field</span>\nfmt.Println(g == f1)\n</code></pre>\n<p>동일한 필드를 가지고 있는 익명 <code>struct</code>에 대해서는 비교가 가능하다.</p>\n<p><br><br></p>\n<h2>References</h2>\n<hr>\n<center>\n<p><a href=\"https://learning.oreilly.com/library/view/learning-go/9781492077206/\"><img src=\"https://learning.oreilly.com/covers/urn:orm:book:9781492077206/400w/\" alt=\"\"></a> <br>\n<a href=\"https://learning.oreilly.com/library/view/learning-go/9781492077206/\">Jon Bodner, 『Learning Go』, O'Reilly Media, Inc.</a></p>\n</center>\n<p><br><br></p>","mainCategory":"Golang","subCategory":"Golang Basics"}