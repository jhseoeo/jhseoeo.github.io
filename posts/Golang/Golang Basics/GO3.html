<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="utf-8" />
        <link rel="icon" href="/favicon.ico" />
        <meta name="viewport" content="width=device-width, initial-scale=1" />
        <meta http-equiv="content-security-policy" content=""><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.7.1/styles/github.min.css" data-svelte="svelte-1pt6jb2"><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Overpass" data-svelte="svelte-1pt6jb2"><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Fira+Mono" data-svelte="svelte-1pt6jb2"><link rel="preconnect" href="https://fonts.gstatic.com" data-svelte="svelte-1pt6jb2"><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Black+And+White+Picture&family=Black+Han+Sans&family=Cute+Font&family=Do+Hyeon&family=Dokdo&family=East+Sea+Dokdo&family=Gaegu&family=Gamja+Flower&family=Gothic+A1&family=Gugi&family=Hi+Melody&family=Jua&family=Kirang+Haerang&family=Nanum+Brush+Script&family=Nanum+Gothic&family=Nanum+Gothic+Coding&family=Nanum+Myeongjo&family=Nanum+Pen+Script&family=Noto+Sans+KR&family=Noto+Serif+KR&family=Poor+Story&family=Single+Day&family=Song+Myung&family=Stylish&family=Sunflower:wght@300&family=Yeon+Sung&display=swap" data-svelte="svelte-1pt6jb2">
	<link rel="stylesheet" href="/_app/immutable/assets/pages/__layout.svelte-866c92ea.css">
	<link rel="stylesheet" href="/_app/immutable/assets/IconBase-05c40767.css">
	<link rel="stylesheet" href="/_app/immutable/assets/pages/posts/_mainCategory_/_subCategory_/_slug_.svelte-1e6f5432.css">
	<link rel="modulepreload" href="/_app/immutable/start-4d38e1cd.js">
	<link rel="modulepreload" href="/_app/immutable/chunks/index-f3b79873.js">
	<link rel="modulepreload" href="/_app/immutable/chunks/paths-396f020f.js">
	<link rel="modulepreload" href="/_app/immutable/chunks/preload-helper-60cab3ee.js">
	<link rel="modulepreload" href="/_app/immutable/chunks/singletons-d1fb5791.js">
	<link rel="modulepreload" href="/_app/immutable/pages/__layout.svelte-b969548a.js">
	<link rel="modulepreload" href="/_app/immutable/chunks/IconBase-0ff4bf3c.js">
	<link rel="modulepreload" href="/_app/immutable/pages/posts/_mainCategory_/_subCategory_/_slug_.svelte-0c17fdf6.js">
	<link rel="modulepreload" href="/_app/immutable/chunks/FaAngleRight-57d996e3.js">
    </head>
    <body>
        <div id="svelte">




<div class="app svelte-174pa0l"><nav class="topbar svelte-1jxcbio"><div class="menu svelte-1jxcbio"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" class="svelte-c8tyih"><path d="M432 176H80c-8.8 0-16-7.2-16-16s7.2-16 16-16h352c8.8 0 16 7.2 16 16s-7.2 16-16 16zM432 272H80c-8.8 0-16-7.2-16-16s7.2-16 16-16h352c8.8 0 16 7.2 16 16s-7.2 16-16 16zM432 368H80c-8.8 0-16-7.2-16-16s7.2-16 16-16h352c8.8 0 16 7.2 16 16s-7.2 16-16 16z"></path></svg></div>
	<div><a class="title svelte-1jxcbio" href="/">집밥서선생</a></div>
	<div class="ghcorner svelte-1jxcbio">
<a href="https://github.com/junhyuk0801" class="github-corner svelte-1t9vm59" aria-label="View source on GitHub"><svg width="60" height="60" viewBox="0 0 250 250" style="fill:#444; color:#fff; position: absolute; top: 0; border: 0; right: 0;" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm svelte-1t9vm59"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg>
</a></div></nav>


  
  <div class="g-app-wrapper svelte-174pa0l"><div class="contents svelte-174pa0l"><span class="svelte-166a0qx"><h1 class="title svelte-166a0qx">복합 타입</h1>
  <a class="backto svelte-166a0qx" href="/posts/Golang/Golang Basics">Golang Basics
    <div class="ico svelte-166a0qx"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 256 512" class="svelte-c8tyih"><path d="M224.3 273l-136 136c-9.4 9.4-24.6 9.4-33.9 0l-22.6-22.6c-9.4-9.4-9.4-24.6 0-33.9l96.4-96.4-96.4-96.4c-9.4-9.4-9.4-24.6 0-33.9L54.3 103c9.4-9.4 24.6-9.4 33.9 0l136 136c9.5 9.4 9.5 24.6.1 34z"></path></svg></div></a></span>

<p class="info"><a href="https://github.com/junhyuk0801">JHSeo</a> JUL 23, 2022</p>

<div class="postContents"><!-- HTML_TAG_START --><br>
<p>본 글은 Golang을 공부하며 주요 내용이라 생각되는 것들을 기록해둔 자료이며, Ubuntu 20.04 LTS 기준으로 작성되었습니다.</p>
<p><br><br></p>
<h2>Array</h2>
<hr>
<p><strong>Array</strong>는 같은 타입의, 크기(개수)가 정해진 데이터들을 묶어서 처리하기 위해 사용된다.</p>
<pre><code class="hljs language-go"><span class="hljs-keyword">var</span> arr [<span class="hljs-number">3</span>]<span class="hljs-keyword">int</span> <span class="hljs-comment">// array declaration</span>
fmt.Println(arr)
<span class="hljs-comment">// var size int = 5	 // can not specify size of array with variables.</span>
<span class="hljs-comment">// var arr [size]int // it occurs an error.</span>
</code></pre>
<p>위 코드에서 <code>[3]int</code>은 크기가 <em>3</em>인 <code>int</code>의 Array임을 나타낸다. Array의 값을 초기화하지 않았으므로, <code>int</code>의 Zero value인 0으로 채워진다.
그리고 Array는 크기가 정해진 데이터에 대해서만 지원한다. 주석 처리된 부분처럼 배열의 크기를 변수값으로 초기화하는 것은 불가능하다.</p>
<br>
<p>C/C++에서 그렇듯, 중괄호를 이용하여 배열 내의 값을 초기화할 수 있다.</p>
<pre><code class="hljs language-go"><span class="hljs-comment">// declare with literal</span>
<span class="hljs-keyword">var</span> x = [<span class="hljs-number">3</span>]<span class="hljs-keyword">int</span>{<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>}                  <span class="hljs-comment">// [1, 2, 3]</span>
<span class="hljs-keyword">var</span> y = [<span class="hljs-number">12</span>]<span class="hljs-keyword">int</span>{<span class="hljs-number">1</span>, <span class="hljs-number">5</span>: <span class="hljs-number">4</span>, <span class="hljs-number">6</span>, <span class="hljs-number">10</span>: <span class="hljs-number">100</span>, <span class="hljs-number">15</span>} <span class="hljs-comment">// [1, 0, 0, 0, 0, 4, 6, 0, 0, 0, 100, 15]</span>
<span class="hljs-keyword">var</span> z = [...]<span class="hljs-keyword">int</span>{<span class="hljs-number">4</span>, <span class="hljs-number">5</span>, <span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span>}          <span class="hljs-comment">// [4, 5, 6, 7, 8]</span>
</code></pre>
<p>위 코드의 변수 <code>y</code>를 초기화하는 라인에서 <code>n:m</code> 형태의 표기법을 확인할 수 있다. <code>n</code>번째 인덱스의 값을 <code>m</code>으로 초기화한다는 의미이다.
지정되지 않은 다른 값들은 Zero value인 <em>0</em>으로 초기화된다.<br>
변수 <code>z</code>를 초기화하는 라인처럼 배열의 크기에 <code>...</code>가 입력되면 자동으로 배열의 크기를 결정한다. 위 코드에서 <code>z</code>의 크기는 <em>5</em>가 될 것이다.</p>
<br>
<p>여느 언어가 그렇듯, 대괄호를 통해 indexing한다. 인덱스에 음수나 배열 크기보다 큰 수 넣으면 런타임 에러가 발생한다.
또한 <code>len()</code> 함수를 사용하여 Array의 크기를 확인할 수 있다.</p>
<pre><code class="hljs language-go">x[<span class="hljs-number">2</span>] = <span class="hljs-number">10</span>
fmt.Println(x[<span class="hljs-number">2</span>]) <span class="hljs-comment">// indexing by bracket</span>
fmt.Println(<span class="hljs-built_in">len</span>(x))
</code></pre>
<br>
<p>다차원 배열은 좀 난해하하다고 느꼈는데, 어떻게 사용하는지는 코드를 바로 보는 편이 이해가 빠를 것이다.</p>
<pre><code class="hljs language-go"><span class="hljs-keyword">var</span> multidimentional = [<span class="hljs-number">2</span>][<span class="hljs-number">3</span>]<span class="hljs-keyword">int</span>{{<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>}, {<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>}} <span class="hljs-comment">// multidimetional array</span>
fmt.Println(multidimentional)
</code></pre>
<br>
<p>이건 좀 신기했던 부분인데, Go에서 Array는 크기와 element의 타입이 같다면 동일한 타입으로 여긴다. 그래서 <code>==</code>와 <code>!=</code>의 두 가지의 비교 연산이 가능하다!
다만 element의 타입이 같아도 Array의 크기가 다르다면 서로 다른 타입으로 여기기 때문에, 비교 연산을 하면 에러가 발생한다.</p>
<pre><code class="hljs language-go"><span class="hljs-keyword">var</span> a = [...]<span class="hljs-keyword">int</span>{<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>}
<span class="hljs-keyword">var</span> b = [<span class="hljs-number">3</span>]<span class="hljs-keyword">int</span>{<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>}
<span class="hljs-keyword">var</span> c = [<span class="hljs-number">2</span>]<span class="hljs-keyword">int</span>{<span class="hljs-number">1</span>, <span class="hljs-number">2</span>}
fmt.Println(a == b) <span class="hljs-comment">// prints true</span>
<span class="hljs-comment">// fmt.Println(a == c) // occurs error</span>
</code></pre>
<p><br><br></p>
<h2>Slice</h2>
<hr>
<p><strong>Slice</strong>는 동적으로 크기가 늘어났다 줄어들었다 하는 Array라고 볼 수 있다. 다른 언어에도 이와 유사한 타입들이 많이 존재하지만, Go의 Slice는 좀 유니크하다.<br>
먼저 Array와는 달리 대괄호 사이를 비워놓고 선언한다. Array와 유사한 부분들을 모아보았다.</p>
<pre><code class="hljs language-go"><span class="hljs-keyword">var</span> x = []<span class="hljs-keyword">int</span>{<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>} <span class="hljs-comment">// declaration + initialization</span>
<span class="hljs-keyword">var</span> y = []<span class="hljs-keyword">int</span>{<span class="hljs-number">1</span>, <span class="hljs-number">5</span>: <span class="hljs-number">4</span>, <span class="hljs-number">6</span>, <span class="hljs-number">10</span>: <span class="hljs-number">100</span>, <span class="hljs-number">15</span>} <span class="hljs-comment">// [1, 0, 0, 0, 0, 4, 6, 0, 0, 0, 100, 15]</span>
fmt.Println(x, y)

x[<span class="hljs-number">2</span>] = <span class="hljs-number">10</span>
fmt.Println(x[<span class="hljs-number">2</span>]) <span class="hljs-comment">// indexing by bracket</span>

<span class="hljs-keyword">var</span> multidimentional = [][]<span class="hljs-keyword">int</span>{{<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>}, {<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>}} <span class="hljs-comment">// multidimetional slice</span>
fmt.Println(multidimentional)

fmt.Println(<span class="hljs-built_in">len</span>(x)) <span class="hljs-comment">// the number of current elements</span>
</code></pre>
<br>
<p>이제 다른 부분들을 하나씩 알아보자.</p>
<p>선언만 하고 초기화하지 않으면 해당 타입의 Zero value로 초기화하는 Array와는 달리, Slice는 비어 있는 객체라는 뜻인 Slice는 <code>nil</code>이 된다.
이때 <code>nil</code>과 Length가 0인 Slice는 엄연히 서로 다르다.
<code>nil</code>은 C/C++의 <code>NULL</code>과 자바스크립트의 <code>null</code> 사이 어딘가의 느낌인데, 추후 설명하겠다.</p>
<pre><code class="hljs language-go"><span class="hljs-keyword">var</span> slice1 []<span class="hljs-keyword">int</span>            <span class="hljs-comment">// slice declaration</span>
<span class="hljs-keyword">var</span> slice2 = []<span class="hljs-keyword">int</span>{}        <span class="hljs-comment">// zero-length slice</span>
fmt.Println(slice1, slice2)
fmt.Println(slice1 == <span class="hljs-literal">nil</span>, slice2 == <span class="hljs-literal">nil</span>)
<span class="hljs-comment">// comparation between two slices occurs error; only possible comparation is the one between slice and nil</span>
</code></pre>
<p>타입과 크기가 같다면 비교 연산을 할 수 있었던 Array와는 달리, slice끼리는 타입이 같아도 서로 비교 연산을 할 수 없다.
slice와 nil과의 비교 연산만 허용된다.</p>
<br>
<p><code>make()</code> 함수를 이용하여 slice를 생성할 수도 있다. 타입, Length, Capacity를 인자로 설정한다.</p>
<pre><code class="hljs language-go">initialized_capacity := <span class="hljs-built_in">make</span>([]<span class="hljs-keyword">int</span>, <span class="hljs-number">0</span>, <span class="hljs-number">5</span>) <span class="hljs-comment">// make(type, length, capacity)</span>
<span class="hljs-comment">// initialized_capacity := make([]int, 6, 5) // it occurs an error (length > capacity)</span>
</code></pre>
<p><br><br></p>
<h3>Appending Elements into Slices</h3>
<br>
<p>Slice에 값을 추가하기 위해서는 <code>append()</code> 함수를 사용한다. 값을 추가할 Slice와, 한 개 이상의 추가할 값들을 파라미터로 받는다.<br>
<code>...</code> 연산자를 활용하여, 다른 Slice 변수의 값들을 추가할수도 있다.</p>
<p>특이사항은 <code>append()</code>함수에 값을 추가할 Slice 변수를 넣고, 반환값을 다시 그 변수로 받아야 한다는 것이다.</p>
<pre><code class="hljs language-go"><span class="hljs-comment">// capacity grows as it gets appended</span>
slice = <span class="hljs-built_in">append</span>(slice, <span class="hljs-number">10</span>)
fmt.Println(slice, <span class="hljs-built_in">len</span>(slice), <span class="hljs-built_in">cap</span>(slice))
slice = <span class="hljs-built_in">append</span>(slice, <span class="hljs-number">20</span>, <span class="hljs-number">30</span>, <span class="hljs-number">40</span>, <span class="hljs-number">50</span>)
fmt.Println(slice, <span class="hljs-built_in">len</span>(slice), <span class="hljs-built_in">cap</span>(slice))

tmp := []<span class="hljs-keyword">int</span>{<span class="hljs-number">20</span>, <span class="hljs-number">30</span>, <span class="hljs-number">40</span>}
slice = <span class="hljs-built_in">append</span>(slice, tmp...)
fmt.Println(slice, <span class="hljs-built_in">len</span>(slice), <span class="hljs-built_in">cap</span>(slice))
<span class="hljs-comment">// append(slice, x...) => it occurs an error (append() returns an slice that the element is appended to.)</span>
</code></pre>
<p>이때 위 코드에서 <code>cap()</code>라는 함수를 사용된는 것을 확인할 수 있다.
Slice에는 요소들의 개수를 나타내는 <em>Length</em>뿐 아니라, <strong>Capacity</strong>라는 속성이 존재한다. 이는 요소들이 추가될 수 있는 전체 공간의 크기를 의미한다.
<code>append()</code>로 변수 <code>slice</code>에 요소들을 추가할 때마다 Length가 증가하고, Length가 Capacity를 초과하려고 할 때마다 Capacity도 증가함을 확인할 수 있다.</p>
<p><br><br></p>
<h3>Slicing Slices</h3>
<br>
<p>Python의 <code>List</code>처럼 대괄호에 콜론(<code>:</code>)과 인덱스를 붙여 Slicing할 수 있다.</p>
<pre><code class="hljs language-go">x := []<span class="hljs-keyword">int</span>{<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>}
y := x[:<span class="hljs-number">2</span>]
z := x[<span class="hljs-number">1</span>:]
d := x[<span class="hljs-number">1</span>:<span class="hljs-number">3</span>]
e := x[:]
fmt.Println(x, y, z, d, e)
</code></pre>
<p>Python은 이렇게 Slicing 하면, Slicing된 새로운 <code>List</code>가 복사되어, 원본과 같은 공간을 가리키지 않는다. 반면 Go의 Slicing된 <code>Slice</code>는 원본을 가리킨다. <code>e</code>의 값 중 하나를 수정해보면, <code>x</code>, <code>z</code>, <code>d</code>까지 해당 값을 포함했던 모든 <code>Slice</code>의 값들도 변경됨을 확인할 수 있다.</p>
<pre><code class="hljs language-go">e[<span class="hljs-number">2</span>] = <span class="hljs-number">1</span>                   <span class="hljs-comment">// Slicing overwraps storage</span>
fmt.Println(x, y, z, d, e) <span class="hljs-comment">// value of x, z, d, e is changed</span>
</code></pre>
<br>
<p>사실 여기까진 그냥 그런가보다 할텐데, 원소를 추가하기 시작하면 본격적으로 어지러워진다.</p>
<pre><code class="hljs language-go">fmt.Println(<span class="hljs-built_in">cap</span>(x), <span class="hljs-built_in">cap</span>(y), <span class="hljs-built_in">cap</span>(z), <span class="hljs-built_in">cap</span>(d), <span class="hljs-built_in">cap</span>(e))
y = <span class="hljs-built_in">append</span>(y, <span class="hljs-number">30</span>) <span class="hljs-comment">// appending an elements into y changes the mapped value of other slices, but not changes their length</span>

fmt.Println(x, y, z, d, e) <span class="hljs-comment">// it's too confusing :(</span>
fmt.Println(<span class="hljs-built_in">cap</span>(x), <span class="hljs-built_in">cap</span>(y), <span class="hljs-built_in">cap</span>(z), <span class="hljs-built_in">cap</span>(d), <span class="hljs-built_in">cap</span>(e))
</code></pre>
<br>
<p>추가 이전, <code>x</code>, <code>y</code>, <code>z</code>, <code>d</code>, <code>e</code>는 아래와 같았는데,</p>
<pre><code class="hljs language-go">[<span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">1</span> <span class="hljs-number">4</span>] [<span class="hljs-number">1</span> <span class="hljs-number">2</span>] [<span class="hljs-number">2</span> <span class="hljs-number">1</span> <span class="hljs-number">4</span>] [<span class="hljs-number">2</span> <span class="hljs-number">1</span>] [<span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">1</span> <span class="hljs-number">4</span>]
</code></pre>
<p>이렇게 변했다.</p>
<pre><code class="hljs language-go">[<span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">30</span> <span class="hljs-number">4</span>] [<span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">30</span>] [<span class="hljs-number">2</span> <span class="hljs-number">30</span> <span class="hljs-number">4</span>] [<span class="hljs-number">2</span> <span class="hljs-number">30</span>] [<span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">30</span> <span class="hljs-number">4</span>]
</code></pre>
<p><code>y</code>에 <code>30</code>을 추가했으니 <code>[1 2 30]</code>이 된 건 그렇다 치고, <code>x</code>, <code>z</code>, <code>d</code>, <code>e</code>에서 대응되는 위치에 있었던 <code>1</code>도 모두 <code>30</code>으로 바뀌었음을 알 수 있다.
그리고 여기서 <code>y</code>만 length가 바뀌었으므로, 나타나는 원소의 개수는 <code>y</code>만 2개에서 3개로 늘었다.</p>
<br>
<p>다음의 예제를 보자.</p>
<pre><code class="hljs language-go">xx := <span class="hljs-built_in">make</span>([]<span class="hljs-keyword">int</span>, <span class="hljs-number">0</span>, <span class="hljs-number">5</span>)
xx = <span class="hljs-built_in">append</span>(xx, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>)
yy := xx[:<span class="hljs-number">2</span>]
zz := xx[<span class="hljs-number">2</span>:]

fmt.Println(<span class="hljs-built_in">cap</span>(xx), <span class="hljs-built_in">cap</span>(yy), <span class="hljs-built_in">cap</span>(zz))
yy = <span class="hljs-built_in">append</span>(yy, <span class="hljs-number">30</span>, <span class="hljs-number">40</span>, <span class="hljs-number">50</span>)
xx = <span class="hljs-built_in">append</span>(xx, <span class="hljs-number">60</span>)
zz = <span class="hljs-built_in">append</span>(zz, <span class="hljs-number">70</span>)

fmt.Println(<span class="hljs-string">"xx:"</span>, xx)
fmt.Println(<span class="hljs-string">"yy:"</span>, yy)
fmt.Println(<span class="hljs-string">"zz:"</span>, zz)
</code></pre>
<p>해당 구문의 실행 결과는 ...</p>
<pre><code class="hljs language-go"><span class="hljs-number">5</span> <span class="hljs-number">5</span> <span class="hljs-number">3</span>
xx: [<span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">30</span> <span class="hljs-number">40</span> <span class="hljs-number">70</span>]
yy: [<span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">30</span> <span class="hljs-number">40</span> <span class="hljs-number">70</span>]
zz: [<span class="hljs-number">30</span> <span class="hljs-number">40</span> <span class="hljs-number">70</span>]
</code></pre>
<br>
<center>
<p><img src="https://raw.githubusercontent.com/junhyuk0801/junhyuk0801.github.io/post-pictures/pictures/Golang/Golang%20Basics/GO3/1.jpg" alt=""></p>
</center>
<br>
<p>상당히 혼란스럽다. 하나씩 알아보자.</p>
<pre><code class="hljs language-go">xx := <span class="hljs-built_in">make</span>([]<span class="hljs-keyword">int</span>, <span class="hljs-number">0</span>, <span class="hljs-number">5</span>)
xx = <span class="hljs-built_in">append</span>(xx, <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>)
yy := xx[:<span class="hljs-number">2</span>]
zz := xx[<span class="hljs-number">2</span>:]
</code></pre>
<p>여기까지 실행했을 때, <code>xx</code>, <code>yy</code>, <code>zz</code>의 값은</p>
<pre><code class="hljs language-go">xx: [<span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">3</span> <span class="hljs-number">4</span>] <span class="hljs-built_in">len</span>=<span class="hljs-number">4</span> <span class="hljs-built_in">cap</span>=<span class="hljs-number">5</span>
yy: [<span class="hljs-number">1</span> <span class="hljs-number">2</span>] <span class="hljs-built_in">len</span>=<span class="hljs-number">2</span> <span class="hljs-built_in">cap</span>=<span class="hljs-number">5</span>
zz: [<span class="hljs-number">3</span> <span class="hljs-number">4</span>] <span class="hljs-built_in">len</span>=<span class="hljs-number">2</span> <span class="hljs-built_in">cap</span>=<span class="hljs-number">3</span>
</code></pre>
<p>이다. 이제, <code>yy</code>에 <code>30</code>, <code>40</code>, <code>50</code>을 추가해보자.</p>
<pre><code class="hljs language-go">xx: [<span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">30</span> <span class="hljs-number">40</span>] <span class="hljs-built_in">len</span>=<span class="hljs-number">4</span> <span class="hljs-built_in">cap</span>=<span class="hljs-number">5</span>
yy: [<span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">30</span> <span class="hljs-number">40</span> <span class="hljs-number">50</span>] <span class="hljs-built_in">len</span>=<span class="hljs-number">5</span> <span class="hljs-built_in">cap</span>=<span class="hljs-number">5</span>
zz: [<span class="hljs-number">30</span> <span class="hljs-number">40</span>] <span class="hljs-built_in">len</span>=<span class="hljs-number">2</span> <span class="hljs-built_in">cap</span>=<span class="hljs-number">3</span>
</code></pre>
<br>
<p><code>xx</code>와 <code>zz</code>는 <code>yy</code>와 같은 공간을 공유한다. 따라서 대응되는 위치의 값이었던 <code>xx</code>와 <code>zz</code>의 <code>3</code>, <code>4</code>가 각각 <code>30</code>, <code>40</code>으로 바뀌었음을 확인할 수 있다.
반면 <code>xx</code>와 <code>zz</code>의 Length는 바뀌지 않고, <code>yy</code>의 Length만 5로 바뀌었다.<br>
여기서 <code>xx = append(xx, 60)</code>가 실행되면,</p>
<pre><code class="hljs language-go">xx: [<span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">30</span> <span class="hljs-number">40</span> <span class="hljs-number">60</span>] <span class="hljs-built_in">len</span>=<span class="hljs-number">5</span> <span class="hljs-built_in">cap</span>=<span class="hljs-number">5</span>
yy: [<span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">30</span> <span class="hljs-number">40</span> <span class="hljs-number">60</span>] <span class="hljs-built_in">len</span>=<span class="hljs-number">5</span> <span class="hljs-built_in">cap</span>=<span class="hljs-number">5</span>
zz: [<span class="hljs-number">30</span> <span class="hljs-number">40</span>] <span class="hljs-built_in">len</span>=<span class="hljs-number">2</span> <span class="hljs-built_in">cap</span>=<span class="hljs-number">3</span>
</code></pre>
<p><code>xx</code>에 60이 추가되며, <code>yy</code>의 대응되는 위치의 값이었던 50의 값이 60으로 바뀌었다.<br>
여기서 <code>zz = append(zz, 70)</code>가 실행되면,</p>
<pre><code class="hljs language-go">xx: [<span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">30</span> <span class="hljs-number">40</span> <span class="hljs-number">70</span>] <span class="hljs-built_in">len</span>=<span class="hljs-number">5</span> <span class="hljs-built_in">cap</span>=<span class="hljs-number">5</span>
yy: [<span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">30</span> <span class="hljs-number">40</span> <span class="hljs-number">70</span>] <span class="hljs-built_in">len</span>=<span class="hljs-number">5</span> <span class="hljs-built_in">cap</span>=<span class="hljs-number">5</span>
zz: [<span class="hljs-number">30</span> <span class="hljs-number">40</span> <span class="hljs-number">70</span>] <span class="hljs-built_in">len</span>=<span class="hljs-number">3</span> <span class="hljs-built_in">cap</span>=<span class="hljs-number">3</span>
</code></pre>
<p><code>xx</code>와 <code>yy</code>의 대응되는 위치의 값이었던 <code>60</code>이 <code>70</code>으로 바뀌었다.</p>
<br>
<p>Slice에 값을 <code>append</code>하였을 때 생기는 문제로 인해 직관적으로 이해하기 어려운 결과를 확인하였다.
<code>xx</code>, <code>yy</code>, <code>zz</code>가 같은 Capacity를 공유하기 때문에 생긴 문제이다.
Slice를 Slicing할 때, Capacity의 범위를 명시하는 표기법을 사용하면 이와 같은 문제를 어느 정도 해결할 수 있다.</p>
<pre><code class="hljs language-go">xxx := []<span class="hljs-keyword">int</span>{<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>}
yyy := xxx[:<span class="hljs-number">2</span>:<span class="hljs-number">2</span>] <span class="hljs-comment">// limits capacity of slice, they not share additional capacity</span>
zzz := xxx[<span class="hljs-number">2</span>:<span class="hljs-number">4</span>:<span class="hljs-number">4</span>]

fmt.Println(<span class="hljs-built_in">cap</span>(xxx), <span class="hljs-built_in">cap</span>(yyy), <span class="hljs-built_in">cap</span>(zzz))
yyy = <span class="hljs-built_in">append</span>(yyy, <span class="hljs-number">30</span>, <span class="hljs-number">40</span>, <span class="hljs-number">50</span>) <span class="hljs-comment">// this appending never interacts with other slices</span>
xxx = <span class="hljs-built_in">append</span>(xxx, <span class="hljs-number">60</span>)
zzz = <span class="hljs-built_in">append</span>(zzz, <span class="hljs-number">70</span>)
fmt.Println(xxx, yyy, zzz)
</code></pre>
<p>위 코드의 출력 결과는 아래와 같다.</p>
<pre><code class="hljs language-go"><span class="hljs-number">5</span> <span class="hljs-number">2</span> <span class="hljs-number">2</span>
[<span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">3</span> <span class="hljs-number">4</span> <span class="hljs-number">5</span> <span class="hljs-number">60</span>] [<span class="hljs-number">1</span> <span class="hljs-number">2</span> <span class="hljs-number">30</span> <span class="hljs-number">40</span> <span class="hljs-number">50</span>] [<span class="hljs-number">3</span> <span class="hljs-number">4</span> <span class="hljs-number">70</span>]
</code></pre>
<br>
<p>한편 Array도 Slicing이 가능하며, Slicing된 값은 Slice 타입이다.</p>
<pre><code class="hljs language-go">ax := [...]<span class="hljs-keyword">int</span>{<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>}
ay := ax[:<span class="hljs-number">2</span>] <span class="hljs-comment">// slicing array</span>
az := ax[<span class="hljs-number">2</span>:]
ax[<span class="hljs-number">0</span>] = <span class="hljs-number">10</span>
fmt.Println(ax, ay, az)
</code></pre>
<p><br><br></p>
<h3>Copying Slices</h3>
<br>
<p>또다른 해결방법은 다른 언어의 <em>deep copy</em>처럼, 새로운 공간에 값들을 복사하는 방법이다. <code>copy()</code> 함수를 통해 할 수 있다.</p>
<pre><code class="hljs language-go">x := []<span class="hljs-keyword">int</span>{<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>}
y := <span class="hljs-built_in">make</span>([]<span class="hljs-keyword">int</span>, <span class="hljs-number">4</span>)

num := <span class="hljs-built_in">copy</span>(y, x)   <span class="hljs-comment">// copy(destination, source). x is copied into y</span>
fmt.Println(y, num) <span class="hljs-comment">// num: the number of elements copied (decided by length of slices)</span>
y[<span class="hljs-number">2</span>] = <span class="hljs-number">1</span>            <span class="hljs-comment">// if we change any value of y,</span>
fmt.Println(y, x)   <span class="hljs-comment">// values of x still unchanged (doesn't share memory spaces)</span>
</code></pre>
<br>
<p><code>copy()</code> 함수는 두 번째 인수로 들어온 Array나 Slice를 첫 번째 인수로 들어온 Slice에 복사한다. 반환값은 복사된 원소의 수이다.</p>
<pre><code class="hljs language-go">z := <span class="hljs-built_in">make</span>([]<span class="hljs-keyword">int</span>, <span class="hljs-number">2</span>, <span class="hljs-number">4</span>) <span class="hljs-comment">// because length of z is 2,</span>
num = <span class="hljs-built_in">copy</span>(z, x)       <span class="hljs-comment">// when it is copied, only two of x are copied.</span>
fmt.Println(z, num)    <span class="hljs-comment">// [1, 2] 2</span>
</code></pre>
<br>
<p><code>copy()</code> 함수의 인수로 들어오는 Slice나 Array들은 Length가 서로 다를 수 있다.
Destination Slice의 Length가 Source Slice보다 크다면, 앞쪽의 원소들부터 채워진다.</p>
<pre><code class="hljs language-go">w := <span class="hljs-built_in">make</span>([]<span class="hljs-keyword">int</span>, <span class="hljs-number">4</span>, <span class="hljs-number">4</span>) <span class="hljs-comment">//</span>
num = <span class="hljs-built_in">copy</span>(w, x[:<span class="hljs-number">2</span>])   <span class="hljs-comment">// because x[:2] has only two element (length is 2),</span>
fmt.Println(w, num)    <span class="hljs-comment">// x[:2] is copied into first two elements</span>
</code></pre>
<p>동일한 원리로 이런 것도 가능하다.</p>
<pre><code class="hljs language-go">q := []<span class="hljs-keyword">int</span>{<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>}
num = <span class="hljs-built_in">copy</span>(q[:<span class="hljs-number">3</span>], q[<span class="hljs-number">1</span>:]) <span class="hljs-comment">// [2, 3, 4] is copied into [1, 2, 3]</span>
fmt.Println(q, num)      <span class="hljs-comment">// [2, 3, 4, 4]</span>
</code></pre>
<p><br><br></p>
<h2>string</h2>
<hr>
<p><code>string</code>은 Primitive Data Type이지만, 여러 문자들의 Slice처럼 생각할 수도 있다. Slice처럼 <code>string</code>을 Slicing할 수도 있다.</p>
<pre><code class="hljs language-go"><span class="hljs-keyword">var</span> s <span class="hljs-keyword">string</span> = <span class="hljs-string">"Hello there"</span>
fmt.Println(s, b, <span class="hljs-built_in">len</span>(s))

<span class="hljs-comment">// slicing string</span>
fmt.Println(s[<span class="hljs-number">4</span>:<span class="hljs-number">7</span>])
fmt.Println(s[<span class="hljs-number">5</span>:])
fmt.Println(s[:<span class="hljs-number">6</span>])
</code></pre>
<p>한편, 알파벳과 같은 일반적인 문자들을 <code>string</code>으로 표현할 때는 문제를 느끼지 못할 수도 있다.
하지만 한글처럼 UTF-8에서 2바이트 이상의 크기로 표현되는 문자들은 Slicing시 문자가 제대로 나타나지 않을 때도 있다.</p>
<pre><code class="hljs language-go"><span class="hljs-keyword">var</span> h <span class="hljs-keyword">string</span> = <span class="hljs-string">"한글조아"</span>
fmt.Println(h, <span class="hljs-built_in">len</span>(h))
<span class="hljs-comment">// each character of korean letter takes 3 bytes, slicing like below would not be done properly</span>
fmt.Println(h[<span class="hljs-number">2</span>:])
fmt.Println(h[:<span class="hljs-number">5</span>])
fmt.Println(h[<span class="hljs-number">2</span>:<span class="hljs-number">7</span>])
</code></pre>
<p><code>string</code>을 구성하는 각 문자들은 <code>rune</code> 타입이지만, 실제로 <code>string</code>은 <code>byte</code>들의 배열이다.
<code>rune</code>은 문자가 1바이트든, 4바이트든 한 개의 문자를 온전히 나타낼 수 있고,
<code>byte</code>는 2바이트 이상의 문자를 나타내기 위해서는 2개 이상 모여야 한다는 것이다.</p>
<pre><code class="hljs language-go"><span class="hljs-comment">// difference of rune and byte</span>
<span class="hljs-keyword">var</span> ss <span class="hljs-keyword">string</span> = <span class="hljs-string">"Hello 안녕"</span>
<span class="hljs-keyword">var</span> bs []<span class="hljs-keyword">byte</span> = []<span class="hljs-keyword">byte</span>(ss) <span class="hljs-comment">// []byte splits UTF-8 characters. usually use this.</span>
<span class="hljs-keyword">var</span> rs []<span class="hljs-keyword">rune</span> = []<span class="hljs-keyword">rune</span>(ss) <span class="hljs-comment">// []rune doesn't split</span>
fmt.Println(bs, rs)
</code></pre>
<p>위처럼 <code>string</code>을 각각 <code>byte</code>와 <code>rune</code>의 Slice로 변환해보면 확인할 수 있다.</p>
<p><br><br></p>
<h2>Map</h2>
<hr>
<p><strong>Map</strong>은 전형적인 Key-Value 페어의 데이터타입으로, C++의 <code>map</code>과 유사하다. 아래 코드처럼 선언하고, 초기화할 수 있다. <br>
Slice와 마찬가지로 <code>map</code>의 Zero value는 반드시 <code>nil</code>이며, 크기가 0인 <code>map</code>과 <code>nil</code>은 서로 다르다.</p>
<pre><code class="hljs language-go"><span class="hljs-keyword">var</span> nilMap <span class="hljs-keyword">map</span>[<span class="hljs-keyword">string</span>]<span class="hljs-keyword">int</span>
mamap := <span class="hljs-keyword">map</span>[<span class="hljs-keyword">string</span>]<span class="hljs-keyword">int</span>{}
fmt.Println(nilMap, mamap, nilMap == <span class="hljs-literal">nil</span>, mamap == <span class="hljs-literal">nil</span>)
</code></pre>
<br>
<p>초기화하는 방법도 다른 언어와 유사하다. 아래의 예제는 key는 <code>string</code>이고, value는 <code>string</code>의 <code>slice</code>인 <code>map</code>이다.</p>
<pre><code class="hljs language-go"><span class="hljs-keyword">var</span> teams = <span class="hljs-keyword">map</span>[<span class="hljs-keyword">string</span>][]<span class="hljs-keyword">string</span>{
    <span class="hljs-string">"Orcas"</span>:   []<span class="hljs-keyword">string</span>{<span class="hljs-string">"Fred"</span>, <span class="hljs-string">"Ralph"</span>},
    <span class="hljs-string">"Lions"</span>:   []<span class="hljs-keyword">string</span>{<span class="hljs-string">"Sarah"</span>, <span class="hljs-string">"Peter"</span>},
    <span class="hljs-string">"Kittens"</span>: {<span class="hljs-string">"Waldo"</span>, <span class="hljs-string">"Raul"</span>}, <span class="hljs-comment">// 이렇게 해도 됨</span>
}
fmt.Println(teams)
</code></pre>
<br>
<p><code>make()</code>함수와 <code>len()</code>함수는 map에서도 사용할 수 있다.</p>
<pre><code class="hljs language-go">ages := <span class="hljs-built_in">make</span>(<span class="hljs-keyword">map</span>[<span class="hljs-keyword">int</span>][]<span class="hljs-keyword">string</span>, <span class="hljs-number">10</span>)
fmt.Println(ages, <span class="hljs-built_in">len</span>(ages)) <span class="hljs-comment">// len() returns the number of key-value pairs of map</span>
</code></pre>
<br>
<p>사용 방법은 다른 언어의 일반적인 Key-Value 페어 데이터타입과 크게 다르지 않다. 이때 Value값이 존재하지 않는 Key에 접근하면 Zero value를 반환한다.</p>
<pre><code class="hljs language-go">totalWins := <span class="hljs-keyword">map</span>[<span class="hljs-keyword">string</span>]<span class="hljs-keyword">int</span>{}
totalWins[<span class="hljs-string">"Orcas"</span>] = <span class="hljs-number">1</span> <span class="hljs-comment">// assigning value into specific key with =, not :=</span>
totalWins[<span class="hljs-string">"Lions"</span>] = <span class="hljs-number">2</span>
fmt.Println(totalWins[<span class="hljs-string">"Orcas"</span>])
fmt.Println(totalWins[<span class="hljs-string">"Kittens"</span>]) <span class="hljs-comment">// an initial value of int is zero.</span>
totalWins[<span class="hljs-string">"Kittens"</span>]++            <span class="hljs-comment">// value of "Kittens" would be 1</span>
totalWins[<span class="hljs-string">"Lions"</span>] = <span class="hljs-number">3</span>
fmt.Println(totalWins[<span class="hljs-string">"Kittens"</span>])
fmt.Println(totalWins[<span class="hljs-string">"Lions"</span>])
</code></pre>
<br>
<p>이 때 Value값이 존재하지 않는 Key에 접근한 것인지, 아니면 그냥 Value값이 Zero value인지 알 수 없다.</p>
<pre><code class="hljs language-go">m := <span class="hljs-keyword">map</span>[<span class="hljs-keyword">string</span>]<span class="hljs-keyword">int</span>{
    <span class="hljs-string">"Hello"</span>: <span class="hljs-number">5</span>,
    <span class="hljs-string">"world"</span>: <span class="hljs-number">0</span>,
}
</code></pre>
<p>이를테면 위와 같은 예제에서 Key가 <code>"world"</code>일 때와, Key가 <code>"Bye"</code>일 때 동일하게 0이라는 값을 얻게 될 것이다.
Go 개발자들은 당연히 이에 대한 해결책으로 <em>comma ok idiom</em>이란 것을 만들어 두었다.</p>
<pre><code class="hljs language-go"><span class="hljs-comment">// comma idiom</span>
v, ok := m[<span class="hljs-string">"Hello"</span>] <span class="hljs-comment">// v gets value of the given key</span>
fmt.Println(v, ok)  <span class="hljs-comment">// ok gets if the key exists in map</span>

v, ok = m[<span class="hljs-string">"world"</span>] <span class="hljs-comment">// though v gets zero value,</span>
fmt.Println(v, ok) <span class="hljs-comment">// ok gets true because "world" exists in map</span>

v, ok = m[<span class="hljs-string">"nono"</span>]  <span class="hljs-comment">// "nono" doesn't exist in map, so ok gets false</span>
fmt.Println(v, ok) <span class="hljs-comment">// v gets zero value,</span>

<span class="hljs-built_in">delete</span>(m, <span class="hljs-string">"Hello"</span>) <span class="hljs-comment">// deletes key "Hello" from the map</span>
v, ok = m[<span class="hljs-string">"Hello"</span>] <span class="hljs-comment">// the key doesn't exist in map as it is deleted</span>
fmt.Println(v, ok)
</code></pre>
<p>위 예제에서 <code>m</code>에서 반환받은 값을 계속 <code>v</code>, <code>ok</code> 두 개의 변수에 할당하는 것을 확인할 수 있다.
이 때 첫 번째 변수인 <code>v</code>에는 Key에 해당하는 Value가 들어가며, 두 번째 변수인 <code>ok</code>에는 해당 Key가 <code>m</code>에 존재하는지 여부가 <code>true</code> or <code>false</code>로 들어간다.
또한 <code>map</code>에서 Key-Value 페어를 지우려면 <code>delete()</code> 함수를 사용한다.</p>
<p><br><br></p>
<h2>struct</h2>
<hr>
<p>C/C++의 <code>struct</code>와 유사하다. Go가 일반적으로 그런 것처럼, 필드들을 선언할 때 자료형이 필드명의 뒤에 온다.
C/C++의 <code>typedef</code> 키워드처럼, <code>type</code> 키워드를 통해 <code>struct</code> 타입을 정의할 수 있다.</p>
<pre><code class="hljs language-go"><span class="hljs-keyword">type</span> person <span class="hljs-keyword">struct</span> { <span class="hljs-comment">// define struct type</span>
    name <span class="hljs-keyword">string</span>
    age  <span class="hljs-keyword">int</span>
    pet  <span class="hljs-keyword">string</span>
}

<span class="hljs-keyword">var</span> john person <span class="hljs-comment">// struct variable declaration</span>
<span class="hljs-keyword">var</span> james = person{<span class="hljs-string">"James"</span>, <span class="hljs-number">24</span>, <span class="hljs-string">"cat"</span>}
kim := person{}                   <span class="hljs-comment">// there is no difference on empty struct and zero value of struct</span>
fred := person{<span class="hljs-string">"Fred"</span>, <span class="hljs-number">22</span>, <span class="hljs-string">"dog"</span>} <span class="hljs-comment">// values are assigned to the fields in the order they were declared in struct definition</span>
beth := person{                   <span class="hljs-comment">// using key names (recommended)</span>
    age:  <span class="hljs-number">20</span>,
    name: <span class="hljs-string">"Beth"</span>,
}
fred.pet = <span class="hljs-string">"parrot"</span> <span class="hljs-comment">// can use dotted notation</span>

fmt.Println(john, kim, james, fred, beth)
</code></pre>
<p><code>struct</code> 인스턴스를 생성할 때는 <code>struct</code>를 정의할 때 입력했던 순서대로 각 필드의 값을 중괄호 안에 입력해주면 된다.
특이사항으로는 <code>map</code>이나 <code>slice</code>와는 달리, <code>struct</code>의 Zero value와 비어있는 <code>struct</code>가 동일하게 처리된다.</p>
<p><br><br></p>
<h3>Anonymous Structs</h3>
<pre><code class="hljs language-go"><span class="hljs-keyword">var</span> human <span class="hljs-keyword">struct</span> { <span class="hljs-comment">// anonymous structs</span>
		name <span class="hljs-keyword">string</span>
		age  <span class="hljs-keyword">int</span>
		pet  <span class="hljs-keyword">string</span>
	}
	human.name = <span class="hljs-string">"Bob"</span>
	human.age = <span class="hljs-number">24</span>
	human.pet = <span class="hljs-string">"dog"</span>

	pet := <span class="hljs-keyword">struct</span> { <span class="hljs-comment">// directly initializing anonymous structs</span>
		name <span class="hljs-keyword">string</span>
		kind <span class="hljs-keyword">string</span>
	}{
		name: <span class="hljs-string">"choco"</span>,
		kind: <span class="hljs-string">"dog"</span>,
	}

	fmt.Println(human, pet)
</code></pre>
<p>위 코드는 익명 <code>struct</code> 변수를 선언하고, 또 선언과 동시에 초기화하는 예제이다.
타입 명시와 값 할당이 다른 중괄호 안에서 이루어져야 하는 것만 주의하면 큰 문제 없는 듯.</p>
<p><br><br></p>
<h3>Comparing and Converting Structs</h3>
<pre><code class="hljs language-go"><span class="hljs-keyword">type</span> firstPerson <span class="hljs-keyword">struct</span> {
    name <span class="hljs-keyword">string</span>
    age  <span class="hljs-keyword">int</span>
}
f1 := firstPerson{<span class="hljs-string">"kim"</span>, <span class="hljs-number">24</span>}
f2 := firstPerson{<span class="hljs-string">"lee"</span>, <span class="hljs-number">25</span>}
fmt.Println(f1 == f2) <span class="hljs-comment">// comparing two firstPerson instances is possible when they are composed of comparable types</span>
</code></pre>
<p><code>struct</code>의 필드가 비교 가능한 타입들로 이루어져 있다면, 서로 같은 <code>struct</code> 타입끼리는 서로 비교할 수 있다.</p>
<br>
<pre><code class="hljs language-go"><span class="hljs-keyword">type</span> secondPerson <span class="hljs-keyword">struct</span> {
    name <span class="hljs-keyword">string</span>
    age <span class="hljs-keyword">int</span>
}
s1 := secondPerson{<span class="hljs-string">"choi"</span>, <span class="hljs-number">26</span>}
<span class="hljs-comment">// fmt.Println(s1 == f1) // comparing(==, !=) secondPerson with firstPerson is impossible</span>
fmt.Println(firstPerson(s1)) <span class="hljs-comment">// convert secondPerson into firstPerson is possible because they have same fields</span>
</code></pre>
<p>서로 다른 <code>struct</code> 타입끼리는 서로 비교할 수 없다.
단, 필드의 타입과 필드명이 같다면 서로 변환할 수 있다.</p>
<br>
<pre><code class="hljs language-go"><span class="hljs-keyword">type</span> thirdPerson <span class="hljs-keyword">struct</span> {
    age <span class="hljs-keyword">int</span>
    name <span class="hljs-keyword">string</span>
}
<span class="hljs-comment">// t1 := thirdPerson{27, "Park"}</span>
<span class="hljs-comment">// fmt.Println(firstPerson(t1)) // convert thirdPerson into firstPerson is impossible because their fields have different order.</span>
</code></pre>
<p>만약 필드의 타입과 필드명이 같아도 선언된 순서가 다르다면 비교 및 변환할 수 없다.</p>
<br>
<pre><code class="hljs language-go"><span class="hljs-keyword">type</span> fourthPerson <span class="hljs-keyword">struct</span> {
    firstName <span class="hljs-keyword">string</span>
    age <span class="hljs-keyword">int</span>
}
<span class="hljs-comment">// f3 := fourthPerson{"Kang", 28}</span>
<span class="hljs-comment">// fmt.Println(firstPerson(f3)) // convert fourthPerson into firstPerson is impossible because their fields have different name.</span>

<span class="hljs-keyword">type</span> fifthPerson <span class="hljs-keyword">struct</span> {
    name <span class="hljs-keyword">string</span>
    age <span class="hljs-keyword">int</span>
    hobby <span class="hljs-keyword">string</span>
}
<span class="hljs-comment">// f4 := fifthPerson{"Seo", 24, "Cooking"}</span>
<span class="hljs-comment">// fmt.Println(firstPerson(f4)) // convert fourthPerson into firstPerson is impossible because there is an additional field.</span>
</code></pre>
<p>타입이 같아도 필드명이 다르다면 변환할 수 없으며, 다른 필드가 추가로 존재하면 비교 및 변환할 수 없다.</p>
<br>
<pre><code class="hljs language-go"><span class="hljs-keyword">var</span> g <span class="hljs-keyword">struct</span> {
    name <span class="hljs-keyword">string</span>
    age  <span class="hljs-keyword">int</span>
}
g = f1 <span class="hljs-comment">// =, == are possible when anonymous struct have same field</span>
fmt.Println(g == f1)
</code></pre>
<p>동일한 필드를 가지고 있는 익명 <code>struct</code>에 대해서는 비교가 가능하다.</p>
<p><br><br></p>
<h2>References</h2>
<hr>
<center>
<p><a href="https://learning.oreilly.com/library/view/learning-go/9781492077206/"><img src="https://learning.oreilly.com/covers/urn:orm:book:9781492077206/400w/" alt=""></a> <br>
<a href="https://learning.oreilly.com/library/view/learning-go/9781492077206/">Jon Bodner, 『Learning Go』, O'Reilly Media, Inc.</a></p>
</center>
<p><br><br></p><!-- HTML_TAG_END --></div>

</div>
    <footer class="site-footer svelte-174pa0l">© 2022 JHSeo. All rights reserved. <br><br></footer></div>
</div>


		<script type="module" data-sveltekit-hydrate="1cftys5">
		import { start } from "/_app/immutable/start-4d38e1cd.js";
		start({
			target: document.querySelector('[data-sveltekit-hydrate="1cftys5"]').parentNode,
			paths: {"base":"","assets":""},
			session: {},
			route: true,
			spa: false,
			trailing_slash: "never",
			hydrate: {
				status: 200,
				error: null,
				nodes: [0, 5],
				params: {mainCategory:"Golang",subCategory:"Golang Basics",slug:"GO3"},
				routeId: "posts/[mainCategory]/[subCategory]/[slug]"
			}
		});
	</script><script type="application/json" sveltekit:data-type="data" sveltekit:data-url="/posts/Golang/Golang Basics/GO3_json">{"status":200,"statusText":"","headers":{"content-type":"text/plain;charset=UTF-8"},"body":"{\"metadata\":{\"title\":\"복합 타입\",\"date\":\"Jul 23, 2022\",\"excerpt\":\"Composite Types\"},\"content\":\"\u003Cbr>\\n\u003Cp>본 글은 Golang을 공부하며 주요 내용이라 생각되는 것들을 기록해둔 자료이며, Ubuntu 20.04 LTS 기준으로 작성되었습니다.\u003C/p>\\n\u003Cp>\u003Cbr>\u003Cbr>\u003C/p>\\n\u003Ch2>Array\u003C/h2>\\n\u003Chr>\\n\u003Cp>\u003Cstrong>Array\u003C/strong>는 같은 타입의, 크기(개수)가 정해진 데이터들을 묶어서 처리하기 위해 사용된다.\u003C/p>\\n\u003Cpre>\u003Ccode class=\\\"hljs language-go\\\">\u003Cspan class=\\\"hljs-keyword\\\">var\u003C/span> arr [\u003Cspan class=\\\"hljs-number\\\">3\u003C/span>]\u003Cspan class=\\\"hljs-keyword\\\">int\u003C/span> \u003Cspan class=\\\"hljs-comment\\\">// array declaration\u003C/span>\\nfmt.Println(arr)\\n\u003Cspan class=\\\"hljs-comment\\\">// var size int = 5\\t // can not specify size of array with variables.\u003C/span>\\n\u003Cspan class=\\\"hljs-comment\\\">// var arr [size]int // it occurs an error.\u003C/span>\\n\u003C/code>\u003C/pre>\\n\u003Cp>위 코드에서 \u003Ccode>[3]int\u003C/code>은 크기가 \u003Cem>3\u003C/em>인 \u003Ccode>int\u003C/code>의 Array임을 나타낸다. Array의 값을 초기화하지 않았으므로, \u003Ccode>int\u003C/code>의 Zero value인 0으로 채워진다.\\n그리고 Array는 크기가 정해진 데이터에 대해서만 지원한다. 주석 처리된 부분처럼 배열의 크기를 변수값으로 초기화하는 것은 불가능하다.\u003C/p>\\n\u003Cbr>\\n\u003Cp>C/C++에서 그렇듯, 중괄호를 이용하여 배열 내의 값을 초기화할 수 있다.\u003C/p>\\n\u003Cpre>\u003Ccode class=\\\"hljs language-go\\\">\u003Cspan class=\\\"hljs-comment\\\">// declare with literal\u003C/span>\\n\u003Cspan class=\\\"hljs-keyword\\\">var\u003C/span> x = [\u003Cspan class=\\\"hljs-number\\\">3\u003C/span>]\u003Cspan class=\\\"hljs-keyword\\\">int\u003C/span>{\u003Cspan class=\\\"hljs-number\\\">1\u003C/span>, \u003Cspan class=\\\"hljs-number\\\">2\u003C/span>, \u003Cspan class=\\\"hljs-number\\\">3\u003C/span>}                  \u003Cspan class=\\\"hljs-comment\\\">// [1, 2, 3]\u003C/span>\\n\u003Cspan class=\\\"hljs-keyword\\\">var\u003C/span> y = [\u003Cspan class=\\\"hljs-number\\\">12\u003C/span>]\u003Cspan class=\\\"hljs-keyword\\\">int\u003C/span>{\u003Cspan class=\\\"hljs-number\\\">1\u003C/span>, \u003Cspan class=\\\"hljs-number\\\">5\u003C/span>: \u003Cspan class=\\\"hljs-number\\\">4\u003C/span>, \u003Cspan class=\\\"hljs-number\\\">6\u003C/span>, \u003Cspan class=\\\"hljs-number\\\">10\u003C/span>: \u003Cspan class=\\\"hljs-number\\\">100\u003C/span>, \u003Cspan class=\\\"hljs-number\\\">15\u003C/span>} \u003Cspan class=\\\"hljs-comment\\\">// [1, 0, 0, 0, 0, 4, 6, 0, 0, 0, 100, 15]\u003C/span>\\n\u003Cspan class=\\\"hljs-keyword\\\">var\u003C/span> z = [...]\u003Cspan class=\\\"hljs-keyword\\\">int\u003C/span>{\u003Cspan class=\\\"hljs-number\\\">4\u003C/span>, \u003Cspan class=\\\"hljs-number\\\">5\u003C/span>, \u003Cspan class=\\\"hljs-number\\\">6\u003C/span>, \u003Cspan class=\\\"hljs-number\\\">7\u003C/span>, \u003Cspan class=\\\"hljs-number\\\">8\u003C/span>}          \u003Cspan class=\\\"hljs-comment\\\">// [4, 5, 6, 7, 8]\u003C/span>\\n\u003C/code>\u003C/pre>\\n\u003Cp>위 코드의 변수 \u003Ccode>y\u003C/code>를 초기화하는 라인에서 \u003Ccode>n:m\u003C/code> 형태의 표기법을 확인할 수 있다. \u003Ccode>n\u003C/code>번째 인덱스의 값을 \u003Ccode>m\u003C/code>으로 초기화한다는 의미이다.\\n지정되지 않은 다른 값들은 Zero value인 \u003Cem>0\u003C/em>으로 초기화된다.\u003Cbr>\\n변수 \u003Ccode>z\u003C/code>를 초기화하는 라인처럼 배열의 크기에 \u003Ccode>...\u003C/code>가 입력되면 자동으로 배열의 크기를 결정한다. 위 코드에서 \u003Ccode>z\u003C/code>의 크기는 \u003Cem>5\u003C/em>가 될 것이다.\u003C/p>\\n\u003Cbr>\\n\u003Cp>여느 언어가 그렇듯, 대괄호를 통해 indexing한다. 인덱스에 음수나 배열 크기보다 큰 수 넣으면 런타임 에러가 발생한다.\\n또한 \u003Ccode>len()\u003C/code> 함수를 사용하여 Array의 크기를 확인할 수 있다.\u003C/p>\\n\u003Cpre>\u003Ccode class=\\\"hljs language-go\\\">x[\u003Cspan class=\\\"hljs-number\\\">2\u003C/span>] = \u003Cspan class=\\\"hljs-number\\\">10\u003C/span>\\nfmt.Println(x[\u003Cspan class=\\\"hljs-number\\\">2\u003C/span>]) \u003Cspan class=\\\"hljs-comment\\\">// indexing by bracket\u003C/span>\\nfmt.Println(\u003Cspan class=\\\"hljs-built_in\\\">len\u003C/span>(x))\\n\u003C/code>\u003C/pre>\\n\u003Cbr>\\n\u003Cp>다차원 배열은 좀 난해하하다고 느꼈는데, 어떻게 사용하는지는 코드를 바로 보는 편이 이해가 빠를 것이다.\u003C/p>\\n\u003Cpre>\u003Ccode class=\\\"hljs language-go\\\">\u003Cspan class=\\\"hljs-keyword\\\">var\u003C/span> multidimentional = [\u003Cspan class=\\\"hljs-number\\\">2\u003C/span>][\u003Cspan class=\\\"hljs-number\\\">3\u003C/span>]\u003Cspan class=\\\"hljs-keyword\\\">int\u003C/span>{{\u003Cspan class=\\\"hljs-number\\\">1\u003C/span>, \u003Cspan class=\\\"hljs-number\\\">2\u003C/span>, \u003Cspan class=\\\"hljs-number\\\">3\u003C/span>}, {\u003Cspan class=\\\"hljs-number\\\">1\u003C/span>, \u003Cspan class=\\\"hljs-number\\\">2\u003C/span>, \u003Cspan class=\\\"hljs-number\\\">3\u003C/span>}} \u003Cspan class=\\\"hljs-comment\\\">// multidimetional array\u003C/span>\\nfmt.Println(multidimentional)\\n\u003C/code>\u003C/pre>\\n\u003Cbr>\\n\u003Cp>이건 좀 신기했던 부분인데, Go에서 Array는 크기와 element의 타입이 같다면 동일한 타입으로 여긴다. 그래서 \u003Ccode>==\u003C/code>와 \u003Ccode>!=\u003C/code>의 두 가지의 비교 연산이 가능하다!\\n다만 element의 타입이 같아도 Array의 크기가 다르다면 서로 다른 타입으로 여기기 때문에, 비교 연산을 하면 에러가 발생한다.\u003C/p>\\n\u003Cpre>\u003Ccode class=\\\"hljs language-go\\\">\u003Cspan class=\\\"hljs-keyword\\\">var\u003C/span> a = [...]\u003Cspan class=\\\"hljs-keyword\\\">int\u003C/span>{\u003Cspan class=\\\"hljs-number\\\">1\u003C/span>, \u003Cspan class=\\\"hljs-number\\\">2\u003C/span>, \u003Cspan class=\\\"hljs-number\\\">3\u003C/span>}\\n\u003Cspan class=\\\"hljs-keyword\\\">var\u003C/span> b = [\u003Cspan class=\\\"hljs-number\\\">3\u003C/span>]\u003Cspan class=\\\"hljs-keyword\\\">int\u003C/span>{\u003Cspan class=\\\"hljs-number\\\">1\u003C/span>, \u003Cspan class=\\\"hljs-number\\\">2\u003C/span>, \u003Cspan class=\\\"hljs-number\\\">3\u003C/span>}\\n\u003Cspan class=\\\"hljs-keyword\\\">var\u003C/span> c = [\u003Cspan class=\\\"hljs-number\\\">2\u003C/span>]\u003Cspan class=\\\"hljs-keyword\\\">int\u003C/span>{\u003Cspan class=\\\"hljs-number\\\">1\u003C/span>, \u003Cspan class=\\\"hljs-number\\\">2\u003C/span>}\\nfmt.Println(a == b) \u003Cspan class=\\\"hljs-comment\\\">// prints true\u003C/span>\\n\u003Cspan class=\\\"hljs-comment\\\">// fmt.Println(a == c) // occurs error\u003C/span>\\n\u003C/code>\u003C/pre>\\n\u003Cp>\u003Cbr>\u003Cbr>\u003C/p>\\n\u003Ch2>Slice\u003C/h2>\\n\u003Chr>\\n\u003Cp>\u003Cstrong>Slice\u003C/strong>는 동적으로 크기가 늘어났다 줄어들었다 하는 Array라고 볼 수 있다. 다른 언어에도 이와 유사한 타입들이 많이 존재하지만, Go의 Slice는 좀 유니크하다.\u003Cbr>\\n먼저 Array와는 달리 대괄호 사이를 비워놓고 선언한다. Array와 유사한 부분들을 모아보았다.\u003C/p>\\n\u003Cpre>\u003Ccode class=\\\"hljs language-go\\\">\u003Cspan class=\\\"hljs-keyword\\\">var\u003C/span> x = []\u003Cspan class=\\\"hljs-keyword\\\">int\u003C/span>{\u003Cspan class=\\\"hljs-number\\\">1\u003C/span>, \u003Cspan class=\\\"hljs-number\\\">2\u003C/span>, \u003Cspan class=\\\"hljs-number\\\">3\u003C/span>} \u003Cspan class=\\\"hljs-comment\\\">// declaration + initialization\u003C/span>\\n\u003Cspan class=\\\"hljs-keyword\\\">var\u003C/span> y = []\u003Cspan class=\\\"hljs-keyword\\\">int\u003C/span>{\u003Cspan class=\\\"hljs-number\\\">1\u003C/span>, \u003Cspan class=\\\"hljs-number\\\">5\u003C/span>: \u003Cspan class=\\\"hljs-number\\\">4\u003C/span>, \u003Cspan class=\\\"hljs-number\\\">6\u003C/span>, \u003Cspan class=\\\"hljs-number\\\">10\u003C/span>: \u003Cspan class=\\\"hljs-number\\\">100\u003C/span>, \u003Cspan class=\\\"hljs-number\\\">15\u003C/span>} \u003Cspan class=\\\"hljs-comment\\\">// [1, 0, 0, 0, 0, 4, 6, 0, 0, 0, 100, 15]\u003C/span>\\nfmt.Println(x, y)\\n\\nx[\u003Cspan class=\\\"hljs-number\\\">2\u003C/span>] = \u003Cspan class=\\\"hljs-number\\\">10\u003C/span>\\nfmt.Println(x[\u003Cspan class=\\\"hljs-number\\\">2\u003C/span>]) \u003Cspan class=\\\"hljs-comment\\\">// indexing by bracket\u003C/span>\\n\\n\u003Cspan class=\\\"hljs-keyword\\\">var\u003C/span> multidimentional = [][]\u003Cspan class=\\\"hljs-keyword\\\">int\u003C/span>{{\u003Cspan class=\\\"hljs-number\\\">1\u003C/span>, \u003Cspan class=\\\"hljs-number\\\">2\u003C/span>, \u003Cspan class=\\\"hljs-number\\\">3\u003C/span>}, {\u003Cspan class=\\\"hljs-number\\\">1\u003C/span>, \u003Cspan class=\\\"hljs-number\\\">2\u003C/span>, \u003Cspan class=\\\"hljs-number\\\">3\u003C/span>}} \u003Cspan class=\\\"hljs-comment\\\">// multidimetional slice\u003C/span>\\nfmt.Println(multidimentional)\\n\\nfmt.Println(\u003Cspan class=\\\"hljs-built_in\\\">len\u003C/span>(x)) \u003Cspan class=\\\"hljs-comment\\\">// the number of current elements\u003C/span>\\n\u003C/code>\u003C/pre>\\n\u003Cbr>\\n\u003Cp>이제 다른 부분들을 하나씩 알아보자.\u003C/p>\\n\u003Cp>선언만 하고 초기화하지 않으면 해당 타입의 Zero value로 초기화하는 Array와는 달리, Slice는 비어 있는 객체라는 뜻인 Slice는 \u003Ccode>nil\u003C/code>이 된다.\\n이때 \u003Ccode>nil\u003C/code>과 Length가 0인 Slice는 엄연히 서로 다르다.\\n\u003Ccode>nil\u003C/code>은 C/C++의 \u003Ccode>NULL\u003C/code>과 자바스크립트의 \u003Ccode>null\u003C/code> 사이 어딘가의 느낌인데, 추후 설명하겠다.\u003C/p>\\n\u003Cpre>\u003Ccode class=\\\"hljs language-go\\\">\u003Cspan class=\\\"hljs-keyword\\\">var\u003C/span> slice1 []\u003Cspan class=\\\"hljs-keyword\\\">int\u003C/span>            \u003Cspan class=\\\"hljs-comment\\\">// slice declaration\u003C/span>\\n\u003Cspan class=\\\"hljs-keyword\\\">var\u003C/span> slice2 = []\u003Cspan class=\\\"hljs-keyword\\\">int\u003C/span>{}        \u003Cspan class=\\\"hljs-comment\\\">// zero-length slice\u003C/span>\\nfmt.Println(slice1, slice2)\\nfmt.Println(slice1 == \u003Cspan class=\\\"hljs-literal\\\">nil\u003C/span>, slice2 == \u003Cspan class=\\\"hljs-literal\\\">nil\u003C/span>)\\n\u003Cspan class=\\\"hljs-comment\\\">// comparation between two slices occurs error; only possible comparation is the one between slice and nil\u003C/span>\\n\u003C/code>\u003C/pre>\\n\u003Cp>타입과 크기가 같다면 비교 연산을 할 수 있었던 Array와는 달리, slice끼리는 타입이 같아도 서로 비교 연산을 할 수 없다.\\nslice와 nil과의 비교 연산만 허용된다.\u003C/p>\\n\u003Cbr>\\n\u003Cp>\u003Ccode>make()\u003C/code> 함수를 이용하여 slice를 생성할 수도 있다. 타입, Length, Capacity를 인자로 설정한다.\u003C/p>\\n\u003Cpre>\u003Ccode class=\\\"hljs language-go\\\">initialized_capacity := \u003Cspan class=\\\"hljs-built_in\\\">make\u003C/span>([]\u003Cspan class=\\\"hljs-keyword\\\">int\u003C/span>, \u003Cspan class=\\\"hljs-number\\\">0\u003C/span>, \u003Cspan class=\\\"hljs-number\\\">5\u003C/span>) \u003Cspan class=\\\"hljs-comment\\\">// make(type, length, capacity)\u003C/span>\\n\u003Cspan class=\\\"hljs-comment\\\">// initialized_capacity := make([]int, 6, 5) // it occurs an error (length > capacity)\u003C/span>\\n\u003C/code>\u003C/pre>\\n\u003Cp>\u003Cbr>\u003Cbr>\u003C/p>\\n\u003Ch3>Appending Elements into Slices\u003C/h3>\\n\u003Cbr>\\n\u003Cp>Slice에 값을 추가하기 위해서는 \u003Ccode>append()\u003C/code> 함수를 사용한다. 값을 추가할 Slice와, 한 개 이상의 추가할 값들을 파라미터로 받는다.\u003Cbr>\\n\u003Ccode>...\u003C/code> 연산자를 활용하여, 다른 Slice 변수의 값들을 추가할수도 있다.\u003C/p>\\n\u003Cp>특이사항은 \u003Ccode>append()\u003C/code>함수에 값을 추가할 Slice 변수를 넣고, 반환값을 다시 그 변수로 받아야 한다는 것이다.\u003C/p>\\n\u003Cpre>\u003Ccode class=\\\"hljs language-go\\\">\u003Cspan class=\\\"hljs-comment\\\">// capacity grows as it gets appended\u003C/span>\\nslice = \u003Cspan class=\\\"hljs-built_in\\\">append\u003C/span>(slice, \u003Cspan class=\\\"hljs-number\\\">10\u003C/span>)\\nfmt.Println(slice, \u003Cspan class=\\\"hljs-built_in\\\">len\u003C/span>(slice), \u003Cspan class=\\\"hljs-built_in\\\">cap\u003C/span>(slice))\\nslice = \u003Cspan class=\\\"hljs-built_in\\\">append\u003C/span>(slice, \u003Cspan class=\\\"hljs-number\\\">20\u003C/span>, \u003Cspan class=\\\"hljs-number\\\">30\u003C/span>, \u003Cspan class=\\\"hljs-number\\\">40\u003C/span>, \u003Cspan class=\\\"hljs-number\\\">50\u003C/span>)\\nfmt.Println(slice, \u003Cspan class=\\\"hljs-built_in\\\">len\u003C/span>(slice), \u003Cspan class=\\\"hljs-built_in\\\">cap\u003C/span>(slice))\\n\\ntmp := []\u003Cspan class=\\\"hljs-keyword\\\">int\u003C/span>{\u003Cspan class=\\\"hljs-number\\\">20\u003C/span>, \u003Cspan class=\\\"hljs-number\\\">30\u003C/span>, \u003Cspan class=\\\"hljs-number\\\">40\u003C/span>}\\nslice = \u003Cspan class=\\\"hljs-built_in\\\">append\u003C/span>(slice, tmp...)\\nfmt.Println(slice, \u003Cspan class=\\\"hljs-built_in\\\">len\u003C/span>(slice), \u003Cspan class=\\\"hljs-built_in\\\">cap\u003C/span>(slice))\\n\u003Cspan class=\\\"hljs-comment\\\">// append(slice, x...) => it occurs an error (append() returns an slice that the element is appended to.)\u003C/span>\\n\u003C/code>\u003C/pre>\\n\u003Cp>이때 위 코드에서 \u003Ccode>cap()\u003C/code>라는 함수를 사용된는 것을 확인할 수 있다.\\nSlice에는 요소들의 개수를 나타내는 \u003Cem>Length\u003C/em>뿐 아니라, \u003Cstrong>Capacity\u003C/strong>라는 속성이 존재한다. 이는 요소들이 추가될 수 있는 전체 공간의 크기를 의미한다.\\n\u003Ccode>append()\u003C/code>로 변수 \u003Ccode>slice\u003C/code>에 요소들을 추가할 때마다 Length가 증가하고, Length가 Capacity를 초과하려고 할 때마다 Capacity도 증가함을 확인할 수 있다.\u003C/p>\\n\u003Cp>\u003Cbr>\u003Cbr>\u003C/p>\\n\u003Ch3>Slicing Slices\u003C/h3>\\n\u003Cbr>\\n\u003Cp>Python의 \u003Ccode>List\u003C/code>처럼 대괄호에 콜론(\u003Ccode>:\u003C/code>)과 인덱스를 붙여 Slicing할 수 있다.\u003C/p>\\n\u003Cpre>\u003Ccode class=\\\"hljs language-go\\\">x := []\u003Cspan class=\\\"hljs-keyword\\\">int\u003C/span>{\u003Cspan class=\\\"hljs-number\\\">1\u003C/span>, \u003Cspan class=\\\"hljs-number\\\">2\u003C/span>, \u003Cspan class=\\\"hljs-number\\\">3\u003C/span>, \u003Cspan class=\\\"hljs-number\\\">4\u003C/span>}\\ny := x[:\u003Cspan class=\\\"hljs-number\\\">2\u003C/span>]\\nz := x[\u003Cspan class=\\\"hljs-number\\\">1\u003C/span>:]\\nd := x[\u003Cspan class=\\\"hljs-number\\\">1\u003C/span>:\u003Cspan class=\\\"hljs-number\\\">3\u003C/span>]\\ne := x[:]\\nfmt.Println(x, y, z, d, e)\\n\u003C/code>\u003C/pre>\\n\u003Cp>Python은 이렇게 Slicing 하면, Slicing된 새로운 \u003Ccode>List\u003C/code>가 복사되어, 원본과 같은 공간을 가리키지 않는다. 반면 Go의 Slicing된 \u003Ccode>Slice\u003C/code>는 원본을 가리킨다. \u003Ccode>e\u003C/code>의 값 중 하나를 수정해보면, \u003Ccode>x\u003C/code>, \u003Ccode>z\u003C/code>, \u003Ccode>d\u003C/code>까지 해당 값을 포함했던 모든 \u003Ccode>Slice\u003C/code>의 값들도 변경됨을 확인할 수 있다.\u003C/p>\\n\u003Cpre>\u003Ccode class=\\\"hljs language-go\\\">e[\u003Cspan class=\\\"hljs-number\\\">2\u003C/span>] = \u003Cspan class=\\\"hljs-number\\\">1\u003C/span>                   \u003Cspan class=\\\"hljs-comment\\\">// Slicing overwraps storage\u003C/span>\\nfmt.Println(x, y, z, d, e) \u003Cspan class=\\\"hljs-comment\\\">// value of x, z, d, e is changed\u003C/span>\\n\u003C/code>\u003C/pre>\\n\u003Cbr>\\n\u003Cp>사실 여기까진 그냥 그런가보다 할텐데, 원소를 추가하기 시작하면 본격적으로 어지러워진다.\u003C/p>\\n\u003Cpre>\u003Ccode class=\\\"hljs language-go\\\">fmt.Println(\u003Cspan class=\\\"hljs-built_in\\\">cap\u003C/span>(x), \u003Cspan class=\\\"hljs-built_in\\\">cap\u003C/span>(y), \u003Cspan class=\\\"hljs-built_in\\\">cap\u003C/span>(z), \u003Cspan class=\\\"hljs-built_in\\\">cap\u003C/span>(d), \u003Cspan class=\\\"hljs-built_in\\\">cap\u003C/span>(e))\\ny = \u003Cspan class=\\\"hljs-built_in\\\">append\u003C/span>(y, \u003Cspan class=\\\"hljs-number\\\">30\u003C/span>) \u003Cspan class=\\\"hljs-comment\\\">// appending an elements into y changes the mapped value of other slices, but not changes their length\u003C/span>\\n\\nfmt.Println(x, y, z, d, e) \u003Cspan class=\\\"hljs-comment\\\">// it's too confusing :(\u003C/span>\\nfmt.Println(\u003Cspan class=\\\"hljs-built_in\\\">cap\u003C/span>(x), \u003Cspan class=\\\"hljs-built_in\\\">cap\u003C/span>(y), \u003Cspan class=\\\"hljs-built_in\\\">cap\u003C/span>(z), \u003Cspan class=\\\"hljs-built_in\\\">cap\u003C/span>(d), \u003Cspan class=\\\"hljs-built_in\\\">cap\u003C/span>(e))\\n\u003C/code>\u003C/pre>\\n\u003Cbr>\\n\u003Cp>추가 이전, \u003Ccode>x\u003C/code>, \u003Ccode>y\u003C/code>, \u003Ccode>z\u003C/code>, \u003Ccode>d\u003C/code>, \u003Ccode>e\u003C/code>는 아래와 같았는데,\u003C/p>\\n\u003Cpre>\u003Ccode class=\\\"hljs language-go\\\">[\u003Cspan class=\\\"hljs-number\\\">1\u003C/span> \u003Cspan class=\\\"hljs-number\\\">2\u003C/span> \u003Cspan class=\\\"hljs-number\\\">1\u003C/span> \u003Cspan class=\\\"hljs-number\\\">4\u003C/span>] [\u003Cspan class=\\\"hljs-number\\\">1\u003C/span> \u003Cspan class=\\\"hljs-number\\\">2\u003C/span>] [\u003Cspan class=\\\"hljs-number\\\">2\u003C/span> \u003Cspan class=\\\"hljs-number\\\">1\u003C/span> \u003Cspan class=\\\"hljs-number\\\">4\u003C/span>] [\u003Cspan class=\\\"hljs-number\\\">2\u003C/span> \u003Cspan class=\\\"hljs-number\\\">1\u003C/span>] [\u003Cspan class=\\\"hljs-number\\\">1\u003C/span> \u003Cspan class=\\\"hljs-number\\\">2\u003C/span> \u003Cspan class=\\\"hljs-number\\\">1\u003C/span> \u003Cspan class=\\\"hljs-number\\\">4\u003C/span>]\\n\u003C/code>\u003C/pre>\\n\u003Cp>이렇게 변했다.\u003C/p>\\n\u003Cpre>\u003Ccode class=\\\"hljs language-go\\\">[\u003Cspan class=\\\"hljs-number\\\">1\u003C/span> \u003Cspan class=\\\"hljs-number\\\">2\u003C/span> \u003Cspan class=\\\"hljs-number\\\">30\u003C/span> \u003Cspan class=\\\"hljs-number\\\">4\u003C/span>] [\u003Cspan class=\\\"hljs-number\\\">1\u003C/span> \u003Cspan class=\\\"hljs-number\\\">2\u003C/span> \u003Cspan class=\\\"hljs-number\\\">30\u003C/span>] [\u003Cspan class=\\\"hljs-number\\\">2\u003C/span> \u003Cspan class=\\\"hljs-number\\\">30\u003C/span> \u003Cspan class=\\\"hljs-number\\\">4\u003C/span>] [\u003Cspan class=\\\"hljs-number\\\">2\u003C/span> \u003Cspan class=\\\"hljs-number\\\">30\u003C/span>] [\u003Cspan class=\\\"hljs-number\\\">1\u003C/span> \u003Cspan class=\\\"hljs-number\\\">2\u003C/span> \u003Cspan class=\\\"hljs-number\\\">30\u003C/span> \u003Cspan class=\\\"hljs-number\\\">4\u003C/span>]\\n\u003C/code>\u003C/pre>\\n\u003Cp>\u003Ccode>y\u003C/code>에 \u003Ccode>30\u003C/code>을 추가했으니 \u003Ccode>[1 2 30]\u003C/code>이 된 건 그렇다 치고, \u003Ccode>x\u003C/code>, \u003Ccode>z\u003C/code>, \u003Ccode>d\u003C/code>, \u003Ccode>e\u003C/code>에서 대응되는 위치에 있었던 \u003Ccode>1\u003C/code>도 모두 \u003Ccode>30\u003C/code>으로 바뀌었음을 알 수 있다.\\n그리고 여기서 \u003Ccode>y\u003C/code>만 length가 바뀌었으므로, 나타나는 원소의 개수는 \u003Ccode>y\u003C/code>만 2개에서 3개로 늘었다.\u003C/p>\\n\u003Cbr>\\n\u003Cp>다음의 예제를 보자.\u003C/p>\\n\u003Cpre>\u003Ccode class=\\\"hljs language-go\\\">xx := \u003Cspan class=\\\"hljs-built_in\\\">make\u003C/span>([]\u003Cspan class=\\\"hljs-keyword\\\">int\u003C/span>, \u003Cspan class=\\\"hljs-number\\\">0\u003C/span>, \u003Cspan class=\\\"hljs-number\\\">5\u003C/span>)\\nxx = \u003Cspan class=\\\"hljs-built_in\\\">append\u003C/span>(xx, \u003Cspan class=\\\"hljs-number\\\">1\u003C/span>, \u003Cspan class=\\\"hljs-number\\\">2\u003C/span>, \u003Cspan class=\\\"hljs-number\\\">3\u003C/span>, \u003Cspan class=\\\"hljs-number\\\">4\u003C/span>)\\nyy := xx[:\u003Cspan class=\\\"hljs-number\\\">2\u003C/span>]\\nzz := xx[\u003Cspan class=\\\"hljs-number\\\">2\u003C/span>:]\\n\\nfmt.Println(\u003Cspan class=\\\"hljs-built_in\\\">cap\u003C/span>(xx), \u003Cspan class=\\\"hljs-built_in\\\">cap\u003C/span>(yy), \u003Cspan class=\\\"hljs-built_in\\\">cap\u003C/span>(zz))\\nyy = \u003Cspan class=\\\"hljs-built_in\\\">append\u003C/span>(yy, \u003Cspan class=\\\"hljs-number\\\">30\u003C/span>, \u003Cspan class=\\\"hljs-number\\\">40\u003C/span>, \u003Cspan class=\\\"hljs-number\\\">50\u003C/span>)\\nxx = \u003Cspan class=\\\"hljs-built_in\\\">append\u003C/span>(xx, \u003Cspan class=\\\"hljs-number\\\">60\u003C/span>)\\nzz = \u003Cspan class=\\\"hljs-built_in\\\">append\u003C/span>(zz, \u003Cspan class=\\\"hljs-number\\\">70\u003C/span>)\\n\\nfmt.Println(\u003Cspan class=\\\"hljs-string\\\">\\\"xx:\\\"\u003C/span>, xx)\\nfmt.Println(\u003Cspan class=\\\"hljs-string\\\">\\\"yy:\\\"\u003C/span>, yy)\\nfmt.Println(\u003Cspan class=\\\"hljs-string\\\">\\\"zz:\\\"\u003C/span>, zz)\\n\u003C/code>\u003C/pre>\\n\u003Cp>해당 구문의 실행 결과는 ...\u003C/p>\\n\u003Cpre>\u003Ccode class=\\\"hljs language-go\\\">\u003Cspan class=\\\"hljs-number\\\">5\u003C/span> \u003Cspan class=\\\"hljs-number\\\">5\u003C/span> \u003Cspan class=\\\"hljs-number\\\">3\u003C/span>\\nxx: [\u003Cspan class=\\\"hljs-number\\\">1\u003C/span> \u003Cspan class=\\\"hljs-number\\\">2\u003C/span> \u003Cspan class=\\\"hljs-number\\\">30\u003C/span> \u003Cspan class=\\\"hljs-number\\\">40\u003C/span> \u003Cspan class=\\\"hljs-number\\\">70\u003C/span>]\\nyy: [\u003Cspan class=\\\"hljs-number\\\">1\u003C/span> \u003Cspan class=\\\"hljs-number\\\">2\u003C/span> \u003Cspan class=\\\"hljs-number\\\">30\u003C/span> \u003Cspan class=\\\"hljs-number\\\">40\u003C/span> \u003Cspan class=\\\"hljs-number\\\">70\u003C/span>]\\nzz: [\u003Cspan class=\\\"hljs-number\\\">30\u003C/span> \u003Cspan class=\\\"hljs-number\\\">40\u003C/span> \u003Cspan class=\\\"hljs-number\\\">70\u003C/span>]\\n\u003C/code>\u003C/pre>\\n\u003Cbr>\\n\u003Ccenter>\\n\u003Cp>\u003Cimg src=\\\"https://raw.githubusercontent.com/junhyuk0801/junhyuk0801.github.io/post-pictures/pictures/Golang/Golang%20Basics/GO3/1.jpg\\\" alt=\\\"\\\">\u003C/p>\\n\u003C/center>\\n\u003Cbr>\\n\u003Cp>상당히 혼란스럽다. 하나씩 알아보자.\u003C/p>\\n\u003Cpre>\u003Ccode class=\\\"hljs language-go\\\">xx := \u003Cspan class=\\\"hljs-built_in\\\">make\u003C/span>([]\u003Cspan class=\\\"hljs-keyword\\\">int\u003C/span>, \u003Cspan class=\\\"hljs-number\\\">0\u003C/span>, \u003Cspan class=\\\"hljs-number\\\">5\u003C/span>)\\nxx = \u003Cspan class=\\\"hljs-built_in\\\">append\u003C/span>(xx, \u003Cspan class=\\\"hljs-number\\\">1\u003C/span>, \u003Cspan class=\\\"hljs-number\\\">2\u003C/span>, \u003Cspan class=\\\"hljs-number\\\">3\u003C/span>, \u003Cspan class=\\\"hljs-number\\\">4\u003C/span>)\\nyy := xx[:\u003Cspan class=\\\"hljs-number\\\">2\u003C/span>]\\nzz := xx[\u003Cspan class=\\\"hljs-number\\\">2\u003C/span>:]\\n\u003C/code>\u003C/pre>\\n\u003Cp>여기까지 실행했을 때, \u003Ccode>xx\u003C/code>, \u003Ccode>yy\u003C/code>, \u003Ccode>zz\u003C/code>의 값은\u003C/p>\\n\u003Cpre>\u003Ccode class=\\\"hljs language-go\\\">xx: [\u003Cspan class=\\\"hljs-number\\\">1\u003C/span> \u003Cspan class=\\\"hljs-number\\\">2\u003C/span> \u003Cspan class=\\\"hljs-number\\\">3\u003C/span> \u003Cspan class=\\\"hljs-number\\\">4\u003C/span>] \u003Cspan class=\\\"hljs-built_in\\\">len\u003C/span>=\u003Cspan class=\\\"hljs-number\\\">4\u003C/span> \u003Cspan class=\\\"hljs-built_in\\\">cap\u003C/span>=\u003Cspan class=\\\"hljs-number\\\">5\u003C/span>\\nyy: [\u003Cspan class=\\\"hljs-number\\\">1\u003C/span> \u003Cspan class=\\\"hljs-number\\\">2\u003C/span>] \u003Cspan class=\\\"hljs-built_in\\\">len\u003C/span>=\u003Cspan class=\\\"hljs-number\\\">2\u003C/span> \u003Cspan class=\\\"hljs-built_in\\\">cap\u003C/span>=\u003Cspan class=\\\"hljs-number\\\">5\u003C/span>\\nzz: [\u003Cspan class=\\\"hljs-number\\\">3\u003C/span> \u003Cspan class=\\\"hljs-number\\\">4\u003C/span>] \u003Cspan class=\\\"hljs-built_in\\\">len\u003C/span>=\u003Cspan class=\\\"hljs-number\\\">2\u003C/span> \u003Cspan class=\\\"hljs-built_in\\\">cap\u003C/span>=\u003Cspan class=\\\"hljs-number\\\">3\u003C/span>\\n\u003C/code>\u003C/pre>\\n\u003Cp>이다. 이제, \u003Ccode>yy\u003C/code>에 \u003Ccode>30\u003C/code>, \u003Ccode>40\u003C/code>, \u003Ccode>50\u003C/code>을 추가해보자.\u003C/p>\\n\u003Cpre>\u003Ccode class=\\\"hljs language-go\\\">xx: [\u003Cspan class=\\\"hljs-number\\\">1\u003C/span> \u003Cspan class=\\\"hljs-number\\\">2\u003C/span> \u003Cspan class=\\\"hljs-number\\\">30\u003C/span> \u003Cspan class=\\\"hljs-number\\\">40\u003C/span>] \u003Cspan class=\\\"hljs-built_in\\\">len\u003C/span>=\u003Cspan class=\\\"hljs-number\\\">4\u003C/span> \u003Cspan class=\\\"hljs-built_in\\\">cap\u003C/span>=\u003Cspan class=\\\"hljs-number\\\">5\u003C/span>\\nyy: [\u003Cspan class=\\\"hljs-number\\\">1\u003C/span> \u003Cspan class=\\\"hljs-number\\\">2\u003C/span> \u003Cspan class=\\\"hljs-number\\\">30\u003C/span> \u003Cspan class=\\\"hljs-number\\\">40\u003C/span> \u003Cspan class=\\\"hljs-number\\\">50\u003C/span>] \u003Cspan class=\\\"hljs-built_in\\\">len\u003C/span>=\u003Cspan class=\\\"hljs-number\\\">5\u003C/span> \u003Cspan class=\\\"hljs-built_in\\\">cap\u003C/span>=\u003Cspan class=\\\"hljs-number\\\">5\u003C/span>\\nzz: [\u003Cspan class=\\\"hljs-number\\\">30\u003C/span> \u003Cspan class=\\\"hljs-number\\\">40\u003C/span>] \u003Cspan class=\\\"hljs-built_in\\\">len\u003C/span>=\u003Cspan class=\\\"hljs-number\\\">2\u003C/span> \u003Cspan class=\\\"hljs-built_in\\\">cap\u003C/span>=\u003Cspan class=\\\"hljs-number\\\">3\u003C/span>\\n\u003C/code>\u003C/pre>\\n\u003Cbr>\\n\u003Cp>\u003Ccode>xx\u003C/code>와 \u003Ccode>zz\u003C/code>는 \u003Ccode>yy\u003C/code>와 같은 공간을 공유한다. 따라서 대응되는 위치의 값이었던 \u003Ccode>xx\u003C/code>와 \u003Ccode>zz\u003C/code>의 \u003Ccode>3\u003C/code>, \u003Ccode>4\u003C/code>가 각각 \u003Ccode>30\u003C/code>, \u003Ccode>40\u003C/code>으로 바뀌었음을 확인할 수 있다.\\n반면 \u003Ccode>xx\u003C/code>와 \u003Ccode>zz\u003C/code>의 Length는 바뀌지 않고, \u003Ccode>yy\u003C/code>의 Length만 5로 바뀌었다.\u003Cbr>\\n여기서 \u003Ccode>xx = append(xx, 60)\u003C/code>가 실행되면,\u003C/p>\\n\u003Cpre>\u003Ccode class=\\\"hljs language-go\\\">xx: [\u003Cspan class=\\\"hljs-number\\\">1\u003C/span> \u003Cspan class=\\\"hljs-number\\\">2\u003C/span> \u003Cspan class=\\\"hljs-number\\\">30\u003C/span> \u003Cspan class=\\\"hljs-number\\\">40\u003C/span> \u003Cspan class=\\\"hljs-number\\\">60\u003C/span>] \u003Cspan class=\\\"hljs-built_in\\\">len\u003C/span>=\u003Cspan class=\\\"hljs-number\\\">5\u003C/span> \u003Cspan class=\\\"hljs-built_in\\\">cap\u003C/span>=\u003Cspan class=\\\"hljs-number\\\">5\u003C/span>\\nyy: [\u003Cspan class=\\\"hljs-number\\\">1\u003C/span> \u003Cspan class=\\\"hljs-number\\\">2\u003C/span> \u003Cspan class=\\\"hljs-number\\\">30\u003C/span> \u003Cspan class=\\\"hljs-number\\\">40\u003C/span> \u003Cspan class=\\\"hljs-number\\\">60\u003C/span>] \u003Cspan class=\\\"hljs-built_in\\\">len\u003C/span>=\u003Cspan class=\\\"hljs-number\\\">5\u003C/span> \u003Cspan class=\\\"hljs-built_in\\\">cap\u003C/span>=\u003Cspan class=\\\"hljs-number\\\">5\u003C/span>\\nzz: [\u003Cspan class=\\\"hljs-number\\\">30\u003C/span> \u003Cspan class=\\\"hljs-number\\\">40\u003C/span>] \u003Cspan class=\\\"hljs-built_in\\\">len\u003C/span>=\u003Cspan class=\\\"hljs-number\\\">2\u003C/span> \u003Cspan class=\\\"hljs-built_in\\\">cap\u003C/span>=\u003Cspan class=\\\"hljs-number\\\">3\u003C/span>\\n\u003C/code>\u003C/pre>\\n\u003Cp>\u003Ccode>xx\u003C/code>에 60이 추가되며, \u003Ccode>yy\u003C/code>의 대응되는 위치의 값이었던 50의 값이 60으로 바뀌었다.\u003Cbr>\\n여기서 \u003Ccode>zz = append(zz, 70)\u003C/code>가 실행되면,\u003C/p>\\n\u003Cpre>\u003Ccode class=\\\"hljs language-go\\\">xx: [\u003Cspan class=\\\"hljs-number\\\">1\u003C/span> \u003Cspan class=\\\"hljs-number\\\">2\u003C/span> \u003Cspan class=\\\"hljs-number\\\">30\u003C/span> \u003Cspan class=\\\"hljs-number\\\">40\u003C/span> \u003Cspan class=\\\"hljs-number\\\">70\u003C/span>] \u003Cspan class=\\\"hljs-built_in\\\">len\u003C/span>=\u003Cspan class=\\\"hljs-number\\\">5\u003C/span> \u003Cspan class=\\\"hljs-built_in\\\">cap\u003C/span>=\u003Cspan class=\\\"hljs-number\\\">5\u003C/span>\\nyy: [\u003Cspan class=\\\"hljs-number\\\">1\u003C/span> \u003Cspan class=\\\"hljs-number\\\">2\u003C/span> \u003Cspan class=\\\"hljs-number\\\">30\u003C/span> \u003Cspan class=\\\"hljs-number\\\">40\u003C/span> \u003Cspan class=\\\"hljs-number\\\">70\u003C/span>] \u003Cspan class=\\\"hljs-built_in\\\">len\u003C/span>=\u003Cspan class=\\\"hljs-number\\\">5\u003C/span> \u003Cspan class=\\\"hljs-built_in\\\">cap\u003C/span>=\u003Cspan class=\\\"hljs-number\\\">5\u003C/span>\\nzz: [\u003Cspan class=\\\"hljs-number\\\">30\u003C/span> \u003Cspan class=\\\"hljs-number\\\">40\u003C/span> \u003Cspan class=\\\"hljs-number\\\">70\u003C/span>] \u003Cspan class=\\\"hljs-built_in\\\">len\u003C/span>=\u003Cspan class=\\\"hljs-number\\\">3\u003C/span> \u003Cspan class=\\\"hljs-built_in\\\">cap\u003C/span>=\u003Cspan class=\\\"hljs-number\\\">3\u003C/span>\\n\u003C/code>\u003C/pre>\\n\u003Cp>\u003Ccode>xx\u003C/code>와 \u003Ccode>yy\u003C/code>의 대응되는 위치의 값이었던 \u003Ccode>60\u003C/code>이 \u003Ccode>70\u003C/code>으로 바뀌었다.\u003C/p>\\n\u003Cbr>\\n\u003Cp>Slice에 값을 \u003Ccode>append\u003C/code>하였을 때 생기는 문제로 인해 직관적으로 이해하기 어려운 결과를 확인하였다.\\n\u003Ccode>xx\u003C/code>, \u003Ccode>yy\u003C/code>, \u003Ccode>zz\u003C/code>가 같은 Capacity를 공유하기 때문에 생긴 문제이다.\\nSlice를 Slicing할 때, Capacity의 범위를 명시하는 표기법을 사용하면 이와 같은 문제를 어느 정도 해결할 수 있다.\u003C/p>\\n\u003Cpre>\u003Ccode class=\\\"hljs language-go\\\">xxx := []\u003Cspan class=\\\"hljs-keyword\\\">int\u003C/span>{\u003Cspan class=\\\"hljs-number\\\">1\u003C/span>, \u003Cspan class=\\\"hljs-number\\\">2\u003C/span>, \u003Cspan class=\\\"hljs-number\\\">3\u003C/span>, \u003Cspan class=\\\"hljs-number\\\">4\u003C/span>, \u003Cspan class=\\\"hljs-number\\\">5\u003C/span>}\\nyyy := xxx[:\u003Cspan class=\\\"hljs-number\\\">2\u003C/span>:\u003Cspan class=\\\"hljs-number\\\">2\u003C/span>] \u003Cspan class=\\\"hljs-comment\\\">// limits capacity of slice, they not share additional capacity\u003C/span>\\nzzz := xxx[\u003Cspan class=\\\"hljs-number\\\">2\u003C/span>:\u003Cspan class=\\\"hljs-number\\\">4\u003C/span>:\u003Cspan class=\\\"hljs-number\\\">4\u003C/span>]\\n\\nfmt.Println(\u003Cspan class=\\\"hljs-built_in\\\">cap\u003C/span>(xxx), \u003Cspan class=\\\"hljs-built_in\\\">cap\u003C/span>(yyy), \u003Cspan class=\\\"hljs-built_in\\\">cap\u003C/span>(zzz))\\nyyy = \u003Cspan class=\\\"hljs-built_in\\\">append\u003C/span>(yyy, \u003Cspan class=\\\"hljs-number\\\">30\u003C/span>, \u003Cspan class=\\\"hljs-number\\\">40\u003C/span>, \u003Cspan class=\\\"hljs-number\\\">50\u003C/span>) \u003Cspan class=\\\"hljs-comment\\\">// this appending never interacts with other slices\u003C/span>\\nxxx = \u003Cspan class=\\\"hljs-built_in\\\">append\u003C/span>(xxx, \u003Cspan class=\\\"hljs-number\\\">60\u003C/span>)\\nzzz = \u003Cspan class=\\\"hljs-built_in\\\">append\u003C/span>(zzz, \u003Cspan class=\\\"hljs-number\\\">70\u003C/span>)\\nfmt.Println(xxx, yyy, zzz)\\n\u003C/code>\u003C/pre>\\n\u003Cp>위 코드의 출력 결과는 아래와 같다.\u003C/p>\\n\u003Cpre>\u003Ccode class=\\\"hljs language-go\\\">\u003Cspan class=\\\"hljs-number\\\">5\u003C/span> \u003Cspan class=\\\"hljs-number\\\">2\u003C/span> \u003Cspan class=\\\"hljs-number\\\">2\u003C/span>\\n[\u003Cspan class=\\\"hljs-number\\\">1\u003C/span> \u003Cspan class=\\\"hljs-number\\\">2\u003C/span> \u003Cspan class=\\\"hljs-number\\\">3\u003C/span> \u003Cspan class=\\\"hljs-number\\\">4\u003C/span> \u003Cspan class=\\\"hljs-number\\\">5\u003C/span> \u003Cspan class=\\\"hljs-number\\\">60\u003C/span>] [\u003Cspan class=\\\"hljs-number\\\">1\u003C/span> \u003Cspan class=\\\"hljs-number\\\">2\u003C/span> \u003Cspan class=\\\"hljs-number\\\">30\u003C/span> \u003Cspan class=\\\"hljs-number\\\">40\u003C/span> \u003Cspan class=\\\"hljs-number\\\">50\u003C/span>] [\u003Cspan class=\\\"hljs-number\\\">3\u003C/span> \u003Cspan class=\\\"hljs-number\\\">4\u003C/span> \u003Cspan class=\\\"hljs-number\\\">70\u003C/span>]\\n\u003C/code>\u003C/pre>\\n\u003Cbr>\\n\u003Cp>한편 Array도 Slicing이 가능하며, Slicing된 값은 Slice 타입이다.\u003C/p>\\n\u003Cpre>\u003Ccode class=\\\"hljs language-go\\\">ax := [...]\u003Cspan class=\\\"hljs-keyword\\\">int\u003C/span>{\u003Cspan class=\\\"hljs-number\\\">1\u003C/span>, \u003Cspan class=\\\"hljs-number\\\">2\u003C/span>, \u003Cspan class=\\\"hljs-number\\\">3\u003C/span>, \u003Cspan class=\\\"hljs-number\\\">4\u003C/span>}\\nay := ax[:\u003Cspan class=\\\"hljs-number\\\">2\u003C/span>] \u003Cspan class=\\\"hljs-comment\\\">// slicing array\u003C/span>\\naz := ax[\u003Cspan class=\\\"hljs-number\\\">2\u003C/span>:]\\nax[\u003Cspan class=\\\"hljs-number\\\">0\u003C/span>] = \u003Cspan class=\\\"hljs-number\\\">10\u003C/span>\\nfmt.Println(ax, ay, az)\\n\u003C/code>\u003C/pre>\\n\u003Cp>\u003Cbr>\u003Cbr>\u003C/p>\\n\u003Ch3>Copying Slices\u003C/h3>\\n\u003Cbr>\\n\u003Cp>또다른 해결방법은 다른 언어의 \u003Cem>deep copy\u003C/em>처럼, 새로운 공간에 값들을 복사하는 방법이다. \u003Ccode>copy()\u003C/code> 함수를 통해 할 수 있다.\u003C/p>\\n\u003Cpre>\u003Ccode class=\\\"hljs language-go\\\">x := []\u003Cspan class=\\\"hljs-keyword\\\">int\u003C/span>{\u003Cspan class=\\\"hljs-number\\\">1\u003C/span>, \u003Cspan class=\\\"hljs-number\\\">2\u003C/span>, \u003Cspan class=\\\"hljs-number\\\">3\u003C/span>, \u003Cspan class=\\\"hljs-number\\\">4\u003C/span>}\\ny := \u003Cspan class=\\\"hljs-built_in\\\">make\u003C/span>([]\u003Cspan class=\\\"hljs-keyword\\\">int\u003C/span>, \u003Cspan class=\\\"hljs-number\\\">4\u003C/span>)\\n\\nnum := \u003Cspan class=\\\"hljs-built_in\\\">copy\u003C/span>(y, x)   \u003Cspan class=\\\"hljs-comment\\\">// copy(destination, source). x is copied into y\u003C/span>\\nfmt.Println(y, num) \u003Cspan class=\\\"hljs-comment\\\">// num: the number of elements copied (decided by length of slices)\u003C/span>\\ny[\u003Cspan class=\\\"hljs-number\\\">2\u003C/span>] = \u003Cspan class=\\\"hljs-number\\\">1\u003C/span>            \u003Cspan class=\\\"hljs-comment\\\">// if we change any value of y,\u003C/span>\\nfmt.Println(y, x)   \u003Cspan class=\\\"hljs-comment\\\">// values of x still unchanged (doesn't share memory spaces)\u003C/span>\\n\u003C/code>\u003C/pre>\\n\u003Cbr>\\n\u003Cp>\u003Ccode>copy()\u003C/code> 함수는 두 번째 인수로 들어온 Array나 Slice를 첫 번째 인수로 들어온 Slice에 복사한다. 반환값은 복사된 원소의 수이다.\u003C/p>\\n\u003Cpre>\u003Ccode class=\\\"hljs language-go\\\">z := \u003Cspan class=\\\"hljs-built_in\\\">make\u003C/span>([]\u003Cspan class=\\\"hljs-keyword\\\">int\u003C/span>, \u003Cspan class=\\\"hljs-number\\\">2\u003C/span>, \u003Cspan class=\\\"hljs-number\\\">4\u003C/span>) \u003Cspan class=\\\"hljs-comment\\\">// because length of z is 2,\u003C/span>\\nnum = \u003Cspan class=\\\"hljs-built_in\\\">copy\u003C/span>(z, x)       \u003Cspan class=\\\"hljs-comment\\\">// when it is copied, only two of x are copied.\u003C/span>\\nfmt.Println(z, num)    \u003Cspan class=\\\"hljs-comment\\\">// [1, 2] 2\u003C/span>\\n\u003C/code>\u003C/pre>\\n\u003Cbr>\\n\u003Cp>\u003Ccode>copy()\u003C/code> 함수의 인수로 들어오는 Slice나 Array들은 Length가 서로 다를 수 있다.\\nDestination Slice의 Length가 Source Slice보다 크다면, 앞쪽의 원소들부터 채워진다.\u003C/p>\\n\u003Cpre>\u003Ccode class=\\\"hljs language-go\\\">w := \u003Cspan class=\\\"hljs-built_in\\\">make\u003C/span>([]\u003Cspan class=\\\"hljs-keyword\\\">int\u003C/span>, \u003Cspan class=\\\"hljs-number\\\">4\u003C/span>, \u003Cspan class=\\\"hljs-number\\\">4\u003C/span>) \u003Cspan class=\\\"hljs-comment\\\">//\u003C/span>\\nnum = \u003Cspan class=\\\"hljs-built_in\\\">copy\u003C/span>(w, x[:\u003Cspan class=\\\"hljs-number\\\">2\u003C/span>])   \u003Cspan class=\\\"hljs-comment\\\">// because x[:2] has only two element (length is 2),\u003C/span>\\nfmt.Println(w, num)    \u003Cspan class=\\\"hljs-comment\\\">// x[:2] is copied into first two elements\u003C/span>\\n\u003C/code>\u003C/pre>\\n\u003Cp>동일한 원리로 이런 것도 가능하다.\u003C/p>\\n\u003Cpre>\u003Ccode class=\\\"hljs language-go\\\">q := []\u003Cspan class=\\\"hljs-keyword\\\">int\u003C/span>{\u003Cspan class=\\\"hljs-number\\\">1\u003C/span>, \u003Cspan class=\\\"hljs-number\\\">2\u003C/span>, \u003Cspan class=\\\"hljs-number\\\">3\u003C/span>, \u003Cspan class=\\\"hljs-number\\\">4\u003C/span>}\\nnum = \u003Cspan class=\\\"hljs-built_in\\\">copy\u003C/span>(q[:\u003Cspan class=\\\"hljs-number\\\">3\u003C/span>], q[\u003Cspan class=\\\"hljs-number\\\">1\u003C/span>:]) \u003Cspan class=\\\"hljs-comment\\\">// [2, 3, 4] is copied into [1, 2, 3]\u003C/span>\\nfmt.Println(q, num)      \u003Cspan class=\\\"hljs-comment\\\">// [2, 3, 4, 4]\u003C/span>\\n\u003C/code>\u003C/pre>\\n\u003Cp>\u003Cbr>\u003Cbr>\u003C/p>\\n\u003Ch2>string\u003C/h2>\\n\u003Chr>\\n\u003Cp>\u003Ccode>string\u003C/code>은 Primitive Data Type이지만, 여러 문자들의 Slice처럼 생각할 수도 있다. Slice처럼 \u003Ccode>string\u003C/code>을 Slicing할 수도 있다.\u003C/p>\\n\u003Cpre>\u003Ccode class=\\\"hljs language-go\\\">\u003Cspan class=\\\"hljs-keyword\\\">var\u003C/span> s \u003Cspan class=\\\"hljs-keyword\\\">string\u003C/span> = \u003Cspan class=\\\"hljs-string\\\">\\\"Hello there\\\"\u003C/span>\\nfmt.Println(s, b, \u003Cspan class=\\\"hljs-built_in\\\">len\u003C/span>(s))\\n\\n\u003Cspan class=\\\"hljs-comment\\\">// slicing string\u003C/span>\\nfmt.Println(s[\u003Cspan class=\\\"hljs-number\\\">4\u003C/span>:\u003Cspan class=\\\"hljs-number\\\">7\u003C/span>])\\nfmt.Println(s[\u003Cspan class=\\\"hljs-number\\\">5\u003C/span>:])\\nfmt.Println(s[:\u003Cspan class=\\\"hljs-number\\\">6\u003C/span>])\\n\u003C/code>\u003C/pre>\\n\u003Cp>한편, 알파벳과 같은 일반적인 문자들을 \u003Ccode>string\u003C/code>으로 표현할 때는 문제를 느끼지 못할 수도 있다.\\n하지만 한글처럼 UTF-8에서 2바이트 이상의 크기로 표현되는 문자들은 Slicing시 문자가 제대로 나타나지 않을 때도 있다.\u003C/p>\\n\u003Cpre>\u003Ccode class=\\\"hljs language-go\\\">\u003Cspan class=\\\"hljs-keyword\\\">var\u003C/span> h \u003Cspan class=\\\"hljs-keyword\\\">string\u003C/span> = \u003Cspan class=\\\"hljs-string\\\">\\\"한글조아\\\"\u003C/span>\\nfmt.Println(h, \u003Cspan class=\\\"hljs-built_in\\\">len\u003C/span>(h))\\n\u003Cspan class=\\\"hljs-comment\\\">// each character of korean letter takes 3 bytes, slicing like below would not be done properly\u003C/span>\\nfmt.Println(h[\u003Cspan class=\\\"hljs-number\\\">2\u003C/span>:])\\nfmt.Println(h[:\u003Cspan class=\\\"hljs-number\\\">5\u003C/span>])\\nfmt.Println(h[\u003Cspan class=\\\"hljs-number\\\">2\u003C/span>:\u003Cspan class=\\\"hljs-number\\\">7\u003C/span>])\\n\u003C/code>\u003C/pre>\\n\u003Cp>\u003Ccode>string\u003C/code>을 구성하는 각 문자들은 \u003Ccode>rune\u003C/code> 타입이지만, 실제로 \u003Ccode>string\u003C/code>은 \u003Ccode>byte\u003C/code>들의 배열이다.\\n\u003Ccode>rune\u003C/code>은 문자가 1바이트든, 4바이트든 한 개의 문자를 온전히 나타낼 수 있고,\\n\u003Ccode>byte\u003C/code>는 2바이트 이상의 문자를 나타내기 위해서는 2개 이상 모여야 한다는 것이다.\u003C/p>\\n\u003Cpre>\u003Ccode class=\\\"hljs language-go\\\">\u003Cspan class=\\\"hljs-comment\\\">// difference of rune and byte\u003C/span>\\n\u003Cspan class=\\\"hljs-keyword\\\">var\u003C/span> ss \u003Cspan class=\\\"hljs-keyword\\\">string\u003C/span> = \u003Cspan class=\\\"hljs-string\\\">\\\"Hello 안녕\\\"\u003C/span>\\n\u003Cspan class=\\\"hljs-keyword\\\">var\u003C/span> bs []\u003Cspan class=\\\"hljs-keyword\\\">byte\u003C/span> = []\u003Cspan class=\\\"hljs-keyword\\\">byte\u003C/span>(ss) \u003Cspan class=\\\"hljs-comment\\\">// []byte splits UTF-8 characters. usually use this.\u003C/span>\\n\u003Cspan class=\\\"hljs-keyword\\\">var\u003C/span> rs []\u003Cspan class=\\\"hljs-keyword\\\">rune\u003C/span> = []\u003Cspan class=\\\"hljs-keyword\\\">rune\u003C/span>(ss) \u003Cspan class=\\\"hljs-comment\\\">// []rune doesn't split\u003C/span>\\nfmt.Println(bs, rs)\\n\u003C/code>\u003C/pre>\\n\u003Cp>위처럼 \u003Ccode>string\u003C/code>을 각각 \u003Ccode>byte\u003C/code>와 \u003Ccode>rune\u003C/code>의 Slice로 변환해보면 확인할 수 있다.\u003C/p>\\n\u003Cp>\u003Cbr>\u003Cbr>\u003C/p>\\n\u003Ch2>Map\u003C/h2>\\n\u003Chr>\\n\u003Cp>\u003Cstrong>Map\u003C/strong>은 전형적인 Key-Value 페어의 데이터타입으로, C++의 \u003Ccode>map\u003C/code>과 유사하다. 아래 코드처럼 선언하고, 초기화할 수 있다. \u003Cbr>\\nSlice와 마찬가지로 \u003Ccode>map\u003C/code>의 Zero value는 반드시 \u003Ccode>nil\u003C/code>이며, 크기가 0인 \u003Ccode>map\u003C/code>과 \u003Ccode>nil\u003C/code>은 서로 다르다.\u003C/p>\\n\u003Cpre>\u003Ccode class=\\\"hljs language-go\\\">\u003Cspan class=\\\"hljs-keyword\\\">var\u003C/span> nilMap \u003Cspan class=\\\"hljs-keyword\\\">map\u003C/span>[\u003Cspan class=\\\"hljs-keyword\\\">string\u003C/span>]\u003Cspan class=\\\"hljs-keyword\\\">int\u003C/span>\\nmamap := \u003Cspan class=\\\"hljs-keyword\\\">map\u003C/span>[\u003Cspan class=\\\"hljs-keyword\\\">string\u003C/span>]\u003Cspan class=\\\"hljs-keyword\\\">int\u003C/span>{}\\nfmt.Println(nilMap, mamap, nilMap == \u003Cspan class=\\\"hljs-literal\\\">nil\u003C/span>, mamap == \u003Cspan class=\\\"hljs-literal\\\">nil\u003C/span>)\\n\u003C/code>\u003C/pre>\\n\u003Cbr>\\n\u003Cp>초기화하는 방법도 다른 언어와 유사하다. 아래의 예제는 key는 \u003Ccode>string\u003C/code>이고, value는 \u003Ccode>string\u003C/code>의 \u003Ccode>slice\u003C/code>인 \u003Ccode>map\u003C/code>이다.\u003C/p>\\n\u003Cpre>\u003Ccode class=\\\"hljs language-go\\\">\u003Cspan class=\\\"hljs-keyword\\\">var\u003C/span> teams = \u003Cspan class=\\\"hljs-keyword\\\">map\u003C/span>[\u003Cspan class=\\\"hljs-keyword\\\">string\u003C/span>][]\u003Cspan class=\\\"hljs-keyword\\\">string\u003C/span>{\\n    \u003Cspan class=\\\"hljs-string\\\">\\\"Orcas\\\"\u003C/span>:   []\u003Cspan class=\\\"hljs-keyword\\\">string\u003C/span>{\u003Cspan class=\\\"hljs-string\\\">\\\"Fred\\\"\u003C/span>, \u003Cspan class=\\\"hljs-string\\\">\\\"Ralph\\\"\u003C/span>},\\n    \u003Cspan class=\\\"hljs-string\\\">\\\"Lions\\\"\u003C/span>:   []\u003Cspan class=\\\"hljs-keyword\\\">string\u003C/span>{\u003Cspan class=\\\"hljs-string\\\">\\\"Sarah\\\"\u003C/span>, \u003Cspan class=\\\"hljs-string\\\">\\\"Peter\\\"\u003C/span>},\\n    \u003Cspan class=\\\"hljs-string\\\">\\\"Kittens\\\"\u003C/span>: {\u003Cspan class=\\\"hljs-string\\\">\\\"Waldo\\\"\u003C/span>, \u003Cspan class=\\\"hljs-string\\\">\\\"Raul\\\"\u003C/span>}, \u003Cspan class=\\\"hljs-comment\\\">// 이렇게 해도 됨\u003C/span>\\n}\\nfmt.Println(teams)\\n\u003C/code>\u003C/pre>\\n\u003Cbr>\\n\u003Cp>\u003Ccode>make()\u003C/code>함수와 \u003Ccode>len()\u003C/code>함수는 map에서도 사용할 수 있다.\u003C/p>\\n\u003Cpre>\u003Ccode class=\\\"hljs language-go\\\">ages := \u003Cspan class=\\\"hljs-built_in\\\">make\u003C/span>(\u003Cspan class=\\\"hljs-keyword\\\">map\u003C/span>[\u003Cspan class=\\\"hljs-keyword\\\">int\u003C/span>][]\u003Cspan class=\\\"hljs-keyword\\\">string\u003C/span>, \u003Cspan class=\\\"hljs-number\\\">10\u003C/span>)\\nfmt.Println(ages, \u003Cspan class=\\\"hljs-built_in\\\">len\u003C/span>(ages)) \u003Cspan class=\\\"hljs-comment\\\">// len() returns the number of key-value pairs of map\u003C/span>\\n\u003C/code>\u003C/pre>\\n\u003Cbr>\\n\u003Cp>사용 방법은 다른 언어의 일반적인 Key-Value 페어 데이터타입과 크게 다르지 않다. 이때 Value값이 존재하지 않는 Key에 접근하면 Zero value를 반환한다.\u003C/p>\\n\u003Cpre>\u003Ccode class=\\\"hljs language-go\\\">totalWins := \u003Cspan class=\\\"hljs-keyword\\\">map\u003C/span>[\u003Cspan class=\\\"hljs-keyword\\\">string\u003C/span>]\u003Cspan class=\\\"hljs-keyword\\\">int\u003C/span>{}\\ntotalWins[\u003Cspan class=\\\"hljs-string\\\">\\\"Orcas\\\"\u003C/span>] = \u003Cspan class=\\\"hljs-number\\\">1\u003C/span> \u003Cspan class=\\\"hljs-comment\\\">// assigning value into specific key with =, not :=\u003C/span>\\ntotalWins[\u003Cspan class=\\\"hljs-string\\\">\\\"Lions\\\"\u003C/span>] = \u003Cspan class=\\\"hljs-number\\\">2\u003C/span>\\nfmt.Println(totalWins[\u003Cspan class=\\\"hljs-string\\\">\\\"Orcas\\\"\u003C/span>])\\nfmt.Println(totalWins[\u003Cspan class=\\\"hljs-string\\\">\\\"Kittens\\\"\u003C/span>]) \u003Cspan class=\\\"hljs-comment\\\">// an initial value of int is zero.\u003C/span>\\ntotalWins[\u003Cspan class=\\\"hljs-string\\\">\\\"Kittens\\\"\u003C/span>]++            \u003Cspan class=\\\"hljs-comment\\\">// value of \\\"Kittens\\\" would be 1\u003C/span>\\ntotalWins[\u003Cspan class=\\\"hljs-string\\\">\\\"Lions\\\"\u003C/span>] = \u003Cspan class=\\\"hljs-number\\\">3\u003C/span>\\nfmt.Println(totalWins[\u003Cspan class=\\\"hljs-string\\\">\\\"Kittens\\\"\u003C/span>])\\nfmt.Println(totalWins[\u003Cspan class=\\\"hljs-string\\\">\\\"Lions\\\"\u003C/span>])\\n\u003C/code>\u003C/pre>\\n\u003Cbr>\\n\u003Cp>이 때 Value값이 존재하지 않는 Key에 접근한 것인지, 아니면 그냥 Value값이 Zero value인지 알 수 없다.\u003C/p>\\n\u003Cpre>\u003Ccode class=\\\"hljs language-go\\\">m := \u003Cspan class=\\\"hljs-keyword\\\">map\u003C/span>[\u003Cspan class=\\\"hljs-keyword\\\">string\u003C/span>]\u003Cspan class=\\\"hljs-keyword\\\">int\u003C/span>{\\n    \u003Cspan class=\\\"hljs-string\\\">\\\"Hello\\\"\u003C/span>: \u003Cspan class=\\\"hljs-number\\\">5\u003C/span>,\\n    \u003Cspan class=\\\"hljs-string\\\">\\\"world\\\"\u003C/span>: \u003Cspan class=\\\"hljs-number\\\">0\u003C/span>,\\n}\\n\u003C/code>\u003C/pre>\\n\u003Cp>이를테면 위와 같은 예제에서 Key가 \u003Ccode>\\\"world\\\"\u003C/code>일 때와, Key가 \u003Ccode>\\\"Bye\\\"\u003C/code>일 때 동일하게 0이라는 값을 얻게 될 것이다.\\nGo 개발자들은 당연히 이에 대한 해결책으로 \u003Cem>comma ok idiom\u003C/em>이란 것을 만들어 두었다.\u003C/p>\\n\u003Cpre>\u003Ccode class=\\\"hljs language-go\\\">\u003Cspan class=\\\"hljs-comment\\\">// comma idiom\u003C/span>\\nv, ok := m[\u003Cspan class=\\\"hljs-string\\\">\\\"Hello\\\"\u003C/span>] \u003Cspan class=\\\"hljs-comment\\\">// v gets value of the given key\u003C/span>\\nfmt.Println(v, ok)  \u003Cspan class=\\\"hljs-comment\\\">// ok gets if the key exists in map\u003C/span>\\n\\nv, ok = m[\u003Cspan class=\\\"hljs-string\\\">\\\"world\\\"\u003C/span>] \u003Cspan class=\\\"hljs-comment\\\">// though v gets zero value,\u003C/span>\\nfmt.Println(v, ok) \u003Cspan class=\\\"hljs-comment\\\">// ok gets true because \\\"world\\\" exists in map\u003C/span>\\n\\nv, ok = m[\u003Cspan class=\\\"hljs-string\\\">\\\"nono\\\"\u003C/span>]  \u003Cspan class=\\\"hljs-comment\\\">// \\\"nono\\\" doesn't exist in map, so ok gets false\u003C/span>\\nfmt.Println(v, ok) \u003Cspan class=\\\"hljs-comment\\\">// v gets zero value,\u003C/span>\\n\\n\u003Cspan class=\\\"hljs-built_in\\\">delete\u003C/span>(m, \u003Cspan class=\\\"hljs-string\\\">\\\"Hello\\\"\u003C/span>) \u003Cspan class=\\\"hljs-comment\\\">// deletes key \\\"Hello\\\" from the map\u003C/span>\\nv, ok = m[\u003Cspan class=\\\"hljs-string\\\">\\\"Hello\\\"\u003C/span>] \u003Cspan class=\\\"hljs-comment\\\">// the key doesn't exist in map as it is deleted\u003C/span>\\nfmt.Println(v, ok)\\n\u003C/code>\u003C/pre>\\n\u003Cp>위 예제에서 \u003Ccode>m\u003C/code>에서 반환받은 값을 계속 \u003Ccode>v\u003C/code>, \u003Ccode>ok\u003C/code> 두 개의 변수에 할당하는 것을 확인할 수 있다.\\n이 때 첫 번째 변수인 \u003Ccode>v\u003C/code>에는 Key에 해당하는 Value가 들어가며, 두 번째 변수인 \u003Ccode>ok\u003C/code>에는 해당 Key가 \u003Ccode>m\u003C/code>에 존재하는지 여부가 \u003Ccode>true\u003C/code> or \u003Ccode>false\u003C/code>로 들어간다.\\n또한 \u003Ccode>map\u003C/code>에서 Key-Value 페어를 지우려면 \u003Ccode>delete()\u003C/code> 함수를 사용한다.\u003C/p>\\n\u003Cp>\u003Cbr>\u003Cbr>\u003C/p>\\n\u003Ch2>struct\u003C/h2>\\n\u003Chr>\\n\u003Cp>C/C++의 \u003Ccode>struct\u003C/code>와 유사하다. Go가 일반적으로 그런 것처럼, 필드들을 선언할 때 자료형이 필드명의 뒤에 온다.\\nC/C++의 \u003Ccode>typedef\u003C/code> 키워드처럼, \u003Ccode>type\u003C/code> 키워드를 통해 \u003Ccode>struct\u003C/code> 타입을 정의할 수 있다.\u003C/p>\\n\u003Cpre>\u003Ccode class=\\\"hljs language-go\\\">\u003Cspan class=\\\"hljs-keyword\\\">type\u003C/span> person \u003Cspan class=\\\"hljs-keyword\\\">struct\u003C/span> { \u003Cspan class=\\\"hljs-comment\\\">// define struct type\u003C/span>\\n    name \u003Cspan class=\\\"hljs-keyword\\\">string\u003C/span>\\n    age  \u003Cspan class=\\\"hljs-keyword\\\">int\u003C/span>\\n    pet  \u003Cspan class=\\\"hljs-keyword\\\">string\u003C/span>\\n}\\n\\n\u003Cspan class=\\\"hljs-keyword\\\">var\u003C/span> john person \u003Cspan class=\\\"hljs-comment\\\">// struct variable declaration\u003C/span>\\n\u003Cspan class=\\\"hljs-keyword\\\">var\u003C/span> james = person{\u003Cspan class=\\\"hljs-string\\\">\\\"James\\\"\u003C/span>, \u003Cspan class=\\\"hljs-number\\\">24\u003C/span>, \u003Cspan class=\\\"hljs-string\\\">\\\"cat\\\"\u003C/span>}\\nkim := person{}                   \u003Cspan class=\\\"hljs-comment\\\">// there is no difference on empty struct and zero value of struct\u003C/span>\\nfred := person{\u003Cspan class=\\\"hljs-string\\\">\\\"Fred\\\"\u003C/span>, \u003Cspan class=\\\"hljs-number\\\">22\u003C/span>, \u003Cspan class=\\\"hljs-string\\\">\\\"dog\\\"\u003C/span>} \u003Cspan class=\\\"hljs-comment\\\">// values are assigned to the fields in the order they were declared in struct definition\u003C/span>\\nbeth := person{                   \u003Cspan class=\\\"hljs-comment\\\">// using key names (recommended)\u003C/span>\\n    age:  \u003Cspan class=\\\"hljs-number\\\">20\u003C/span>,\\n    name: \u003Cspan class=\\\"hljs-string\\\">\\\"Beth\\\"\u003C/span>,\\n}\\nfred.pet = \u003Cspan class=\\\"hljs-string\\\">\\\"parrot\\\"\u003C/span> \u003Cspan class=\\\"hljs-comment\\\">// can use dotted notation\u003C/span>\\n\\nfmt.Println(john, kim, james, fred, beth)\\n\u003C/code>\u003C/pre>\\n\u003Cp>\u003Ccode>struct\u003C/code> 인스턴스를 생성할 때는 \u003Ccode>struct\u003C/code>를 정의할 때 입력했던 순서대로 각 필드의 값을 중괄호 안에 입력해주면 된다.\\n특이사항으로는 \u003Ccode>map\u003C/code>이나 \u003Ccode>slice\u003C/code>와는 달리, \u003Ccode>struct\u003C/code>의 Zero value와 비어있는 \u003Ccode>struct\u003C/code>가 동일하게 처리된다.\u003C/p>\\n\u003Cp>\u003Cbr>\u003Cbr>\u003C/p>\\n\u003Ch3>Anonymous Structs\u003C/h3>\\n\u003Cpre>\u003Ccode class=\\\"hljs language-go\\\">\u003Cspan class=\\\"hljs-keyword\\\">var\u003C/span> human \u003Cspan class=\\\"hljs-keyword\\\">struct\u003C/span> { \u003Cspan class=\\\"hljs-comment\\\">// anonymous structs\u003C/span>\\n\\t\\tname \u003Cspan class=\\\"hljs-keyword\\\">string\u003C/span>\\n\\t\\tage  \u003Cspan class=\\\"hljs-keyword\\\">int\u003C/span>\\n\\t\\tpet  \u003Cspan class=\\\"hljs-keyword\\\">string\u003C/span>\\n\\t}\\n\\thuman.name = \u003Cspan class=\\\"hljs-string\\\">\\\"Bob\\\"\u003C/span>\\n\\thuman.age = \u003Cspan class=\\\"hljs-number\\\">24\u003C/span>\\n\\thuman.pet = \u003Cspan class=\\\"hljs-string\\\">\\\"dog\\\"\u003C/span>\\n\\n\\tpet := \u003Cspan class=\\\"hljs-keyword\\\">struct\u003C/span> { \u003Cspan class=\\\"hljs-comment\\\">// directly initializing anonymous structs\u003C/span>\\n\\t\\tname \u003Cspan class=\\\"hljs-keyword\\\">string\u003C/span>\\n\\t\\tkind \u003Cspan class=\\\"hljs-keyword\\\">string\u003C/span>\\n\\t}{\\n\\t\\tname: \u003Cspan class=\\\"hljs-string\\\">\\\"choco\\\"\u003C/span>,\\n\\t\\tkind: \u003Cspan class=\\\"hljs-string\\\">\\\"dog\\\"\u003C/span>,\\n\\t}\\n\\n\\tfmt.Println(human, pet)\\n\u003C/code>\u003C/pre>\\n\u003Cp>위 코드는 익명 \u003Ccode>struct\u003C/code> 변수를 선언하고, 또 선언과 동시에 초기화하는 예제이다.\\n타입 명시와 값 할당이 다른 중괄호 안에서 이루어져야 하는 것만 주의하면 큰 문제 없는 듯.\u003C/p>\\n\u003Cp>\u003Cbr>\u003Cbr>\u003C/p>\\n\u003Ch3>Comparing and Converting Structs\u003C/h3>\\n\u003Cpre>\u003Ccode class=\\\"hljs language-go\\\">\u003Cspan class=\\\"hljs-keyword\\\">type\u003C/span> firstPerson \u003Cspan class=\\\"hljs-keyword\\\">struct\u003C/span> {\\n    name \u003Cspan class=\\\"hljs-keyword\\\">string\u003C/span>\\n    age  \u003Cspan class=\\\"hljs-keyword\\\">int\u003C/span>\\n}\\nf1 := firstPerson{\u003Cspan class=\\\"hljs-string\\\">\\\"kim\\\"\u003C/span>, \u003Cspan class=\\\"hljs-number\\\">24\u003C/span>}\\nf2 := firstPerson{\u003Cspan class=\\\"hljs-string\\\">\\\"lee\\\"\u003C/span>, \u003Cspan class=\\\"hljs-number\\\">25\u003C/span>}\\nfmt.Println(f1 == f2) \u003Cspan class=\\\"hljs-comment\\\">// comparing two firstPerson instances is possible when they are composed of comparable types\u003C/span>\\n\u003C/code>\u003C/pre>\\n\u003Cp>\u003Ccode>struct\u003C/code>의 필드가 비교 가능한 타입들로 이루어져 있다면, 서로 같은 \u003Ccode>struct\u003C/code> 타입끼리는 서로 비교할 수 있다.\u003C/p>\\n\u003Cbr>\\n\u003Cpre>\u003Ccode class=\\\"hljs language-go\\\">\u003Cspan class=\\\"hljs-keyword\\\">type\u003C/span> secondPerson \u003Cspan class=\\\"hljs-keyword\\\">struct\u003C/span> {\\n    name \u003Cspan class=\\\"hljs-keyword\\\">string\u003C/span>\\n    age \u003Cspan class=\\\"hljs-keyword\\\">int\u003C/span>\\n}\\ns1 := secondPerson{\u003Cspan class=\\\"hljs-string\\\">\\\"choi\\\"\u003C/span>, \u003Cspan class=\\\"hljs-number\\\">26\u003C/span>}\\n\u003Cspan class=\\\"hljs-comment\\\">// fmt.Println(s1 == f1) // comparing(==, !=) secondPerson with firstPerson is impossible\u003C/span>\\nfmt.Println(firstPerson(s1)) \u003Cspan class=\\\"hljs-comment\\\">// convert secondPerson into firstPerson is possible because they have same fields\u003C/span>\\n\u003C/code>\u003C/pre>\\n\u003Cp>서로 다른 \u003Ccode>struct\u003C/code> 타입끼리는 서로 비교할 수 없다.\\n단, 필드의 타입과 필드명이 같다면 서로 변환할 수 있다.\u003C/p>\\n\u003Cbr>\\n\u003Cpre>\u003Ccode class=\\\"hljs language-go\\\">\u003Cspan class=\\\"hljs-keyword\\\">type\u003C/span> thirdPerson \u003Cspan class=\\\"hljs-keyword\\\">struct\u003C/span> {\\n    age \u003Cspan class=\\\"hljs-keyword\\\">int\u003C/span>\\n    name \u003Cspan class=\\\"hljs-keyword\\\">string\u003C/span>\\n}\\n\u003Cspan class=\\\"hljs-comment\\\">// t1 := thirdPerson{27, \\\"Park\\\"}\u003C/span>\\n\u003Cspan class=\\\"hljs-comment\\\">// fmt.Println(firstPerson(t1)) // convert thirdPerson into firstPerson is impossible because their fields have different order.\u003C/span>\\n\u003C/code>\u003C/pre>\\n\u003Cp>만약 필드의 타입과 필드명이 같아도 선언된 순서가 다르다면 비교 및 변환할 수 없다.\u003C/p>\\n\u003Cbr>\\n\u003Cpre>\u003Ccode class=\\\"hljs language-go\\\">\u003Cspan class=\\\"hljs-keyword\\\">type\u003C/span> fourthPerson \u003Cspan class=\\\"hljs-keyword\\\">struct\u003C/span> {\\n    firstName \u003Cspan class=\\\"hljs-keyword\\\">string\u003C/span>\\n    age \u003Cspan class=\\\"hljs-keyword\\\">int\u003C/span>\\n}\\n\u003Cspan class=\\\"hljs-comment\\\">// f3 := fourthPerson{\\\"Kang\\\", 28}\u003C/span>\\n\u003Cspan class=\\\"hljs-comment\\\">// fmt.Println(firstPerson(f3)) // convert fourthPerson into firstPerson is impossible because their fields have different name.\u003C/span>\\n\\n\u003Cspan class=\\\"hljs-keyword\\\">type\u003C/span> fifthPerson \u003Cspan class=\\\"hljs-keyword\\\">struct\u003C/span> {\\n    name \u003Cspan class=\\\"hljs-keyword\\\">string\u003C/span>\\n    age \u003Cspan class=\\\"hljs-keyword\\\">int\u003C/span>\\n    hobby \u003Cspan class=\\\"hljs-keyword\\\">string\u003C/span>\\n}\\n\u003Cspan class=\\\"hljs-comment\\\">// f4 := fifthPerson{\\\"Seo\\\", 24, \\\"Cooking\\\"}\u003C/span>\\n\u003Cspan class=\\\"hljs-comment\\\">// fmt.Println(firstPerson(f4)) // convert fourthPerson into firstPerson is impossible because there is an additional field.\u003C/span>\\n\u003C/code>\u003C/pre>\\n\u003Cp>타입이 같아도 필드명이 다르다면 변환할 수 없으며, 다른 필드가 추가로 존재하면 비교 및 변환할 수 없다.\u003C/p>\\n\u003Cbr>\\n\u003Cpre>\u003Ccode class=\\\"hljs language-go\\\">\u003Cspan class=\\\"hljs-keyword\\\">var\u003C/span> g \u003Cspan class=\\\"hljs-keyword\\\">struct\u003C/span> {\\n    name \u003Cspan class=\\\"hljs-keyword\\\">string\u003C/span>\\n    age  \u003Cspan class=\\\"hljs-keyword\\\">int\u003C/span>\\n}\\ng = f1 \u003Cspan class=\\\"hljs-comment\\\">// =, == are possible when anonymous struct have same field\u003C/span>\\nfmt.Println(g == f1)\\n\u003C/code>\u003C/pre>\\n\u003Cp>동일한 필드를 가지고 있는 익명 \u003Ccode>struct\u003C/code>에 대해서는 비교가 가능하다.\u003C/p>\\n\u003Cp>\u003Cbr>\u003Cbr>\u003C/p>\\n\u003Ch2>References\u003C/h2>\\n\u003Chr>\\n\u003Ccenter>\\n\u003Cp>\u003Ca href=\\\"https://learning.oreilly.com/library/view/learning-go/9781492077206/\\\">\u003Cimg src=\\\"https://learning.oreilly.com/covers/urn:orm:book:9781492077206/400w/\\\" alt=\\\"\\\">\u003C/a> \u003Cbr>\\n\u003Ca href=\\\"https://learning.oreilly.com/library/view/learning-go/9781492077206/\\\">Jon Bodner, 『Learning Go』, O'Reilly Media, Inc.\u003C/a>\u003C/p>\\n\u003C/center>\\n\u003Cp>\u003Cbr>\u003Cbr>\u003C/p>\",\"mainCategory\":\"Golang\",\"subCategory\":\"Golang Basics\"}"}</script></div>
    </body>
</html>
