<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="utf-8" />
        <link rel="icon" href="/favicon.ico" />
        <meta name="viewport" content="width=device-width, initial-scale=1" />
        <meta http-equiv="content-security-policy" content=""><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.7.1/styles/github.min.css" data-svelte="svelte-1pt6jb2"><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Overpass" data-svelte="svelte-1pt6jb2"><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Fira+Mono" data-svelte="svelte-1pt6jb2"><link rel="preconnect" href="https://fonts.gstatic.com" data-svelte="svelte-1pt6jb2"><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Black+And+White+Picture&family=Black+Han+Sans&family=Cute+Font&family=Do+Hyeon&family=Dokdo&family=East+Sea+Dokdo&family=Gaegu&family=Gamja+Flower&family=Gothic+A1&family=Gugi&family=Hi+Melody&family=Jua&family=Kirang+Haerang&family=Nanum+Brush+Script&family=Nanum+Gothic&family=Nanum+Gothic+Coding&family=Nanum+Myeongjo&family=Nanum+Pen+Script&family=Noto+Sans+KR&family=Noto+Serif+KR&family=Poor+Story&family=Single+Day&family=Song+Myung&family=Stylish&family=Sunflower:wght@300&family=Yeon+Sung&display=swap" data-svelte="svelte-1pt6jb2">
	<link rel="stylesheet" href="/_app/immutable/assets/pages/__layout.svelte-866c92ea.css">
	<link rel="stylesheet" href="/_app/immutable/assets/IconBase-05c40767.css">
	<link rel="stylesheet" href="/_app/immutable/assets/pages/posts/_mainCategory_/_subCategory_/_slug_.svelte-1e6f5432.css">
	<link rel="modulepreload" href="/_app/immutable/start-d3635e20.js">
	<link rel="modulepreload" href="/_app/immutable/chunks/index-f3b79873.js">
	<link rel="modulepreload" href="/_app/immutable/chunks/paths-396f020f.js">
	<link rel="modulepreload" href="/_app/immutable/chunks/preload-helper-60cab3ee.js">
	<link rel="modulepreload" href="/_app/immutable/chunks/singletons-d1fb5791.js">
	<link rel="modulepreload" href="/_app/immutable/pages/__layout.svelte-b969548a.js">
	<link rel="modulepreload" href="/_app/immutable/chunks/IconBase-0ff4bf3c.js">
	<link rel="modulepreload" href="/_app/immutable/pages/posts/_mainCategory_/_subCategory_/_slug_.svelte-0c17fdf6.js">
	<link rel="modulepreload" href="/_app/immutable/chunks/FaAngleRight-57d996e3.js">
    </head>
    <body>
        <div id="svelte">




<div class="app svelte-174pa0l"><nav class="topbar svelte-1jxcbio"><div class="menu svelte-1jxcbio"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" class="svelte-c8tyih"><path d="M432 176H80c-8.8 0-16-7.2-16-16s7.2-16 16-16h352c8.8 0 16 7.2 16 16s-7.2 16-16 16zM432 272H80c-8.8 0-16-7.2-16-16s7.2-16 16-16h352c8.8 0 16 7.2 16 16s-7.2 16-16 16zM432 368H80c-8.8 0-16-7.2-16-16s7.2-16 16-16h352c8.8 0 16 7.2 16 16s-7.2 16-16 16z"></path></svg></div>
	<div><a class="title svelte-1jxcbio" href="/">집밥서선생</a></div>
	<div class="ghcorner svelte-1jxcbio">
<a href="https://github.com/junhyuk0801" class="github-corner svelte-1t9vm59" aria-label="View source on GitHub"><svg width="60" height="60" viewBox="0 0 250 250" style="fill:#444; color:#fff; position: absolute; top: 0; border: 0; right: 0;" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm svelte-1t9vm59"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg>
</a></div></nav>


  
  <div class="g-app-wrapper svelte-174pa0l"><div class="contents svelte-174pa0l"><span class="svelte-166a0qx"><h1 class="title svelte-166a0qx">블록, Shadowing, 흐름 제어문</h1>
  <a class="backto svelte-166a0qx" href="/posts/Golang/Golang Basics">Golang Basics
    <div class="ico svelte-166a0qx"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 256 512" class="svelte-c8tyih"><path d="M224.3 273l-136 136c-9.4 9.4-24.6 9.4-33.9 0l-22.6-22.6c-9.4-9.4-9.4-24.6 0-33.9l96.4-96.4-96.4-96.4c-9.4-9.4-9.4-24.6 0-33.9L54.3 103c9.4-9.4 24.6-9.4 33.9 0l136 136c9.5 9.4 9.5 24.6.1 34z"></path></svg></div></a></span>

<p class="info"><a href="https://github.com/junhyuk0801">JHSeo</a> JUL 27, 2022</p>

<div class="postContents"><!-- HTML_TAG_START --><br>
<p>본 글은 Golang을 공부하며 주요 내용이라 생각되는 것들을 기록해둔 자료이며, Ubuntu 20.04 LTS 기준으로 작성되었습니다.</p>
<p><br><br></p>
<h2>Shadowing</h2>
<hr>
<p>Go에서 기본적으로 <code>Block</code>의 개념은 타 언어와 유사하다.
<code>if</code>, <code>for</code> 등 흐름 제어 키워드들에 의해 중괄호가 시작되고, 해당 중괄호가 닫히는 영역까지를 <code>Block</code>이라 한다.</p>
<pre><code class="hljs language-go">x1 := <span class="hljs-number">10</span> <span class="hljs-comment">// shadowed variable.</span>
<span class="hljs-keyword">if</span> x1 > <span class="hljs-number">5</span> {
    fmt.Println(x1) <span class="hljs-comment">// 10 => x1 is not yet shadowed</span>
    x1 := <span class="hljs-number">5</span>         <span class="hljs-comment">// shadowing variable. from this line to end of this block</span>
    fmt.Println(x1) <span class="hljs-comment">// 5 => x1 is shadowed until if-blocks ends</span>
}
fmt.Println(x1) <span class="hljs-comment">// 10 => if-block ends. x1 is not shadowed</span>
</code></pre>
<p>이전 챕터에서도 다루었지만, Shadowing이 발생하면 해당 블록이 끝날 때까지 Shadowing된 변수에 접근할 수 없다.</p>
<br>
<pre><code class="hljs language-go">	<span class="hljs-literal">true</span>, <span class="hljs-keyword">int</span> := <span class="hljs-number">10</span>, <span class="hljs-string">"hi"</span>
	fmt := <span class="hljs-string">"oops"</span>    <span class="hljs-comment">// fmt is shadowed</span>
</code></pre>
<p>이렇게 패키지명이나 <em>universe block</em>의 구분자들을 Shadowing하는 것이 문법적으로는 가능하지만, <strong>절대</strong> 이렇게 하지 않도록 주의하자.</p>
<br>
<p>변수가 Shadowing되는 것을 확인할 수 있는 명령어가 존재한다. 외부 모듈이므로 설치 후 사용해주어야 한다.</p>
<pre><code class="hljs language-bash">go install golang.org/x/tools/go/analysis/passes/shadow/cmd/shadow@latest
shadow ./..
</code></pre>
<p>위와 같이 설치 후, <code>shadow</code> 명령어를 통해 검사를 실시하고자 하는 파일을 지정한다.</p>
<pre><code class="hljs language-bash">declaration of <span class="hljs-string">"x"</span> shadows declaration at line 6
</code></pre>
<p><br><br></p>
<h2>if</h2>
<hr>
<p>C 계열 프로그래밍 언어의 <code>if</code>문과 크게 다르지 않다. 특이사항으로는 괄호를 생략한다.</p>
<pre><code class="hljs language-go">n1 := <span class="hljs-number">7</span>
<span class="hljs-keyword">if</span> n1 == <span class="hljs-number">0</span> {        <span class="hljs-comment">// there is no parenthesis around the condition</span>
    fmt.Println(<span class="hljs-string">"too low"</span>)
} <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> n1 > <span class="hljs-number">5</span> {
    fmt.Println(<span class="hljs-string">"too big :"</span>, n1)
} <span class="hljs-keyword">else</span> {
    fmt.Println(<span class="hljs-string">"good :"</span>, n1)
}
</code></pre>
<br>
<p>특이사항으로는 <code>if</code>문의 조건 확인 구문 안에서 변수 선언을 동시에 할 수 있다.</p>
<pre><code class="hljs language-go"><span class="hljs-keyword">if</span> n2 := <span class="hljs-number">4</span>; n2 == <span class="hljs-number">0</span> { <span class="hljs-comment">// both declaring variable and checking condition</span>
    fmt.Println(<span class="hljs-string">"too low"</span>)
} <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> n2 > <span class="hljs-number">5</span> {
    fmt.Println(<span class="hljs-string">"too big :"</span>, n2)
} <span class="hljs-keyword">else</span> {
    fmt.Println(<span class="hljs-string">"good :"</span>, n2)
}

<span class="hljs-comment">// fmt.Println(n2) // it causes error. once a if/else statement ends, n1 is not accessable.</span>
</code></pre>
<p>단, 이렇게 선언된 변수는 <code>if</code>문 밖에선 접근할 수 없다.</p>
<p><br><br></p>
<h2>for</h2>
<hr>
<p>Go의 <code>for</code>문은 4가지 유형이 존재한다.</p>
<ol>
<li>일반적인 <code>for</code>문과 유사함 => <code>for(int i = 0; i &#x3C; n; i++) {}</code></li>
<li>일반적인 while문과 유사함 => <code>while(condition)</code></li>
<li>무한 루프 => <code>while(True)</code></li>
<li>range-based의 foreach문 => <code>for(const auto&#x26; element : containor) {}</code></li>
</ol>
<p>하나씩 살펴보자.</p>
<p><br><br></p>
<h3>The Complete for Statement</h3>
<pre><code class="hljs language-go"><span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &#x3C; <span class="hljs-number">10</span>; i++ {
    fmt.Print(i)
}
</code></pre>
<p><code>if</code>문처럼 괄호를 사용하지 않는다. 또한 변수를 초기화할 때 <code>var</code> 키워드를 사용하지 않고, <code>:=</code> 연산자를 이용하여 초기화해야 한다.</p>
<br>
<h3>condition-only statements</h3>
<pre><code class="hljs language-go">i := <span class="hljs-number">1</span>
<span class="hljs-keyword">for</span> i &#x3C; <span class="hljs-number">100</span> {
    fmt.Print(i, <span class="hljs-string">" "</span>)
    i = i * <span class="hljs-number">2</span>
}
</code></pre>
<p>변수의 선언과 증감이 생략된 형태로, 다른 언어의 while문과 유사한 형태이다.</p>
<br>
<h3>infinite loop and break, continue statements</h3>
<pre><code class="hljs language-go">j := <span class="hljs-number">0</span>
<span class="hljs-keyword">for</span> {
    <span class="hljs-keyword">if</span> j++; j > <span class="hljs-number">10</span> {
        <span class="hljs-keyword">break</span> <span class="hljs-comment">// if there is no break statement, loop will last until a keyboard interrupt(ctrl-c) occurs</span>
    } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> j%<span class="hljs-number">2</span> == <span class="hljs-number">0</span> {
        <span class="hljs-keyword">continue</span>
    }
    fmt.Print(i, <span class="hljs-string">" "</span>)
}
</code></pre>
<p><code>for</code> 키워드 이후 아무런 표현식도 오지 않으면 무한루프를 돌게 된다. <code>break</code>문과 <code>contine</code>문도 사용 가능하다.</p>
<br>
<h3>for-range loop</h3>
<pre><code class="hljs language-go"><span class="hljs-comment">// for-range loop (array, slice, string)</span>
evenVals := []<span class="hljs-keyword">int</span>{<span class="hljs-number">2</span>, <span class="hljs-number">4</span>, <span class="hljs-number">6</span>, <span class="hljs-number">8</span>, <span class="hljs-number">10</span>, <span class="hljs-number">12</span>}
<span class="hljs-keyword">for</span> i, v := <span class="hljs-keyword">range</span> evenVals {
    fmt.Println(i, v) <span class="hljs-comment">// i is an key(index) of the data, v is value of the data</span>
}

<span class="hljs-comment">// ignoring the key in a for-range loop</span>
<span class="hljs-keyword">for</span> _, v := <span class="hljs-keyword">range</span> evenVals { <span class="hljs-comment">// using underscore(_), we can only access the value</span>
    fmt.Print(v, <span class="hljs-string">" "</span>) <span class="hljs-comment">// if you want, it is also possible to ignore the value by using underscore</span>
}
</code></pre>
<p>다른 언어에 존재하는 <code>for-each</code> 형태의 반복문과 유사한 형태이다. <code>range</code> 키워드를 통해 각각 인덱스와 값에 접근할 수 있다.
또한 변수 이름을 언더바(<code>_</code>)로 설정하면, 해당 값을 사용하지 않고 넘긴다는 의미가 된다. 적절히 사용할 수 있도록 하자.</p>
<br>
<p><code>map</code> 타입에 대해서도 for-range loop를 적용할 수 있다.</p>
<pre><code class="hljs language-go"><span class="hljs-comment">// for-range loop (map)</span>
names := <span class="hljs-keyword">map</span>[<span class="hljs-keyword">string</span>]<span class="hljs-keyword">bool</span>{
    <span class="hljs-string">"Fred"</span>: <span class="hljs-literal">true</span>,
    <span class="hljs-string">"Raul"</span>: <span class="hljs-literal">true</span>,
    <span class="hljs-string">"Will"</span>: <span class="hljs-literal">false</span>,
}

<span class="hljs-keyword">for</span> k, v := <span class="hljs-keyword">range</span> names {
    fmt.Println(k, v)
}

<span class="hljs-keyword">for</span> k := <span class="hljs-keyword">range</span> names { <span class="hljs-comment">// by leave off second variable, it is possible to get key only.</span>
    fmt.Println(k, names[k])
}
</code></pre>
<p>대충 Python이랑 비슷한 것 같다.</p>
<br>
<p><code>string</code>에 대해서도 for-range loop가 가능하다.</p>
<pre><code class="hljs language-go"><span class="hljs-comment">// for-range loop (string)</span>
samples := []<span class="hljs-keyword">string</span>{<span class="hljs-string">"hello"</span>, <span class="hljs-string">"안녕하세요"</span>}

<span class="hljs-keyword">for</span> _, sample := <span class="hljs-keyword">range</span> samples {
    <span class="hljs-keyword">for</span> i, r := <span class="hljs-keyword">range</span> sample { <span class="hljs-comment">// it iterates over the runes, not bytes</span>
        fmt.Println(i, r, <span class="hljs-keyword">string</span>(r)) <span class="hljs-comment">// key is the number of byte from the beginning of the string, type of value is rune</span>
    }
}
</code></pre>
<p>특이사항은 <code>byte</code> 단위가 아닌 <code>rune</code> 단위로 iterating한다는 것.
따라서 문자의 크기가 2바이트 이상인 경우, 인덱스가 점프하는 것을 확인할 수 있다.</p>
<br>
<p>Go에서의 <code>for</code>문은 <strong>Labeling</strong>을 지원한다.</p>
<pre><code class="hljs language-go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> {
	samples := []<span class="hljs-keyword">string</span>{<span class="hljs-string">"hello"</span>, <span class="hljs-string">"안녕hello"</span>}

outer: <span class="hljs-comment">// label of outer for-statements</span>
	<span class="hljs-keyword">for</span> _, sample := <span class="hljs-keyword">range</span> samples {
		<span class="hljs-keyword">for</span> i, r := <span class="hljs-keyword">range</span> sample {
			fmt.Println(i, r, <span class="hljs-keyword">string</span>(r))
			<span class="hljs-keyword">if</span> r == <span class="hljs-string">'l'</span> {
				<span class="hljs-keyword">continue</span> outer <span class="hljs-comment">// this leads to continue nested loop</span>
			}
		}
		fmt.Println() <span class="hljs-comment">// this line is not reached because all the strings contain 'l', and the process continued outer loop</span>
	}
}
</code></pre>
<p>바깥쪽 반복문에 <code>outer</code>라는 Label이 붙어있다.
그리고 안쪽 반복문에서 <code>continue outer</code>를 통해 <code>for i, r := range sample {}</code> 블록이 아닌, <code>for _, sample := range samples</code> 블록의 시작점으로 되돌아가고 있다.</p>
<p><br><br></p>
<h2>switch</h2>
<hr>
<p>보통 제한적인 상황에서만 사용되거나 <code>switch</code>문이 없는 다른 언어들과는 달리, Go는 <code>switch</code>문이 엄청 잘되어있다.</p>
<pre><code class="hljs language-go">words := []<span class="hljs-keyword">string</span>{<span class="hljs-string">"a"</span>, <span class="hljs-string">"cow"</span>, <span class="hljs-string">"smile"</span>, <span class="hljs-string">"gopher"</span>, <span class="hljs-string">"octopus"</span>, <span class="hljs-string">"영어싫어"</span>, <span class="hljs-string">""</span>}

<span class="hljs-keyword">for</span> _, word := <span class="hljs-keyword">range</span> words {
    <span class="hljs-keyword">switch</span> size := <span class="hljs-built_in">len</span>(word); size { <span class="hljs-comment">// as like if-statements, there is no parenthesis</span>
    <span class="hljs-keyword">case</span> <span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>: <span class="hljs-comment">// using comma(,), we can make multiple matches</span>
        fmt.Println(word, <span class="hljs-string">"is a short word!"</span>)
    <span class="hljs-keyword">case</span> <span class="hljs-number">5</span>:
        fmt.Println(word, <span class="hljs-string">"is exactly the right length:"</span>, size)
        <span class="hljs-keyword">break</span>                         <span class="hljs-comment">// this makes it exits switch earlier</span>
        fmt.Println(<span class="hljs-string">"not be printed"</span>) <span class="hljs-comment">// because of break above, this line is unreachable</span>
    <span class="hljs-keyword">case</span> <span class="hljs-number">6</span>, <span class="hljs-number">7</span>, <span class="hljs-number">8</span>, <span class="hljs-number">9</span>: <span class="hljs-comment">// empty case (nothing happened)</span>
        <span class="hljs-comment">// fallthrough // if keyword `fallthrough` is here, as like other languages, run next case's block</span>
    <span class="hljs-keyword">default</span>:
        fmt.Println(word, <span class="hljs-string">"is a wrong word"</span>)
    }
}
</code></pre>
<p>여러 값에 대해 적용되는 <code>case</code>를 설정하려면 컴마(<code>,</code>)로 값들을 구분지어서 나열하면 된다.<br>
특이사항은 <code>case</code> 블록에서 <code>break</code>를 통한 탈출을 지원하긴 하지만, 다른 언어와 달리 반드시 사용하지 않아도 <code>case</code> 블록이 끝나면 알아서 탈출해준다.
만약 <code>case</code> 블록이 끝나고 아래 <code>case</code> 블록도 실행되게끔 하고자 하는 경우, <code>fallthrough</code> 키워드를 사용하면 된다 한다. 다만 권장되지는 않는 듯 하다.</p>
<br>
<p><code>switch</code>문에 아무런 변수도 할당하지 않는 경우, boolean expression의 true/false 여부에 따라 <code>case</code> 블록이 실행된다. <code>if</code>/<code>else</code>문이랑 비슷한듯.</p>
<pre><code class="hljs language-go">	<span class="hljs-comment">// blank switch, break a loop in switch/case statements</span>
loop: <span class="hljs-comment">// to break in switch/case statement, attach a label to for-statements</span>
	<span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &#x3C; <span class="hljs-number">10</span>; i++ {
		<span class="hljs-keyword">switch</span> { <span class="hljs-comment">// this is a blank switch. no variable</span>
		<span class="hljs-keyword">case</span> i%<span class="hljs-number">2</span> == <span class="hljs-number">0</span>: <span class="hljs-comment">// here can be boolean expression</span>
			fmt.Println(i, <span class="hljs-string">"is even number"</span>)
		<span class="hljs-keyword">case</span> i%<span class="hljs-number">3</span> == <span class="hljs-number">0</span>:
			fmt.Println(i, <span class="hljs-string">"is divisible by 3 but not 2"</span>)
		<span class="hljs-keyword">case</span> i%<span class="hljs-number">7</span> == <span class="hljs-number">0</span>:
			fmt.Println(<span class="hljs-string">"exit the loop"</span>)
			<span class="hljs-keyword">break</span> loop <span class="hljs-comment">// if this statement is just `break`, it cannot exit the loop. just proceed until the loop ends</span>
		<span class="hljs-keyword">default</span>:
			fmt.Println(i, <span class="hljs-string">"is boring"</span>)
		}
	}
</code></pre>
<p><code>case</code>안에서 <code>for</code>문을 탈출하려면 위처럼 <code>break</code>문에 Label을 명시해주어야 한다.</p>
<p><br><br></p>
<h2>goto</h2>
<hr>
<p>놀랍게도 Go엔 <code>goto</code>가 있다. <code>goto</code> 자체가 가지고 있는 문제점을 해결하기 위해 몇 가지 보완이 이루어진 듯 하다.</p>
<pre><code class="hljs language-go">	a := <span class="hljs-number">10</span>
	<span class="hljs-comment">// goto skip // cannot jump over variable declaration</span>
	b := <span class="hljs-number">20</span>
	<span class="hljs-keyword">goto</span> skip
skip:
	c := <span class="hljs-number">30</span>

	fmt.Println(a, b, c)
	<span class="hljs-keyword">if</span> c > a {
		<span class="hljs-comment">// goto inner // cannot jump into block</span>
	}

	<span class="hljs-keyword">if</span> a &#x3C; b {
		<span class="hljs-keyword">goto</span> inner
	inner:
		fmt.Println(<span class="hljs-string">"a is less than b"</span>)
	}
</code></pre>
<p><code>goto</code>를 통해 특정 block 안으로 들어가거나, 변수 선언 이전으로 되돌아가거나 할 수는 없다.</p>
<br>
<p><code>goto</code>가 유용하게 쓰이는 경우가 한 가지 있다.</p>
<pre><code class="hljs language-go">    x := rand.Intn(<span class="hljs-number">10</span>)

	<span class="hljs-keyword">for</span> x &#x3C; <span class="hljs-number">100</span> {
		<span class="hljs-keyword">if</span> a%<span class="hljs-number">5</span> == <span class="hljs-number">0</span> {
			<span class="hljs-keyword">goto</span> done <span class="hljs-comment">// in this case, instead of using boolean flag, using goto makes code clearer and readable</span>
		}
		a = a*<span class="hljs-number">2</span> + <span class="hljs-number">1</span>
	}

	fmt.Println(<span class="hljs-string">"do something when the loop completes normally"</span>)
done:
	fmt.Println(<span class="hljs-string">"do complicated stuff no matter why we left the loop"</span>)
	fmt.Println(a)
</code></pre>
<p>위처럼 flag를 설정하여, flag의 여부에 따라 추가적으로 처리를 해주어야 하는 경우이다.
이 경우 위처럼 <code>goto</code>를 사용하는 것이 <code>if</code>를 사용하는 것보다 깔끔하다고 한다.</p>
<p><br><br></p>
<h2>References</h2>
<hr>
<center>
<p><a href="https://learning.oreilly.com/library/view/learning-go/9781492077206/"><img src="https://learning.oreilly.com/covers/urn:orm:book:9781492077206/400w/" alt=""></a> <br>
<a href="https://learning.oreilly.com/library/view/learning-go/9781492077206/">Jon Bodner, 『Learning Go』, O'Reilly Media, Inc.</a></p>
</center>
<p><br><br></p><!-- HTML_TAG_END --></div>

</div>
    <footer class="site-footer svelte-174pa0l">© 2022 JHSeo. All rights reserved. <br><br></footer></div>
</div>


		<script type="module" data-sveltekit-hydrate="trwcl">
		import { start } from "/_app/immutable/start-d3635e20.js";
		start({
			target: document.querySelector('[data-sveltekit-hydrate="trwcl"]').parentNode,
			paths: {"base":"","assets":""},
			session: {},
			route: true,
			spa: false,
			trailing_slash: "never",
			hydrate: {
				status: 200,
				error: null,
				nodes: [0, 5],
				params: {mainCategory:"Golang",subCategory:"Golang Basics",slug:"GO4"},
				routeId: "posts/[mainCategory]/[subCategory]/[slug]"
			}
		});
	</script><script type="application/json" sveltekit:data-type="data" sveltekit:data-url="/posts/Golang/Golang Basics/GO4_json">{"status":200,"statusText":"","headers":{"content-type":"text/plain;charset=UTF-8"},"body":"{\"metadata\":{\"title\":\"블록, Shadowing, 흐름 제어문\",\"date\":\"Jul 27, 2022\",\"excerpt\":\"Blocks, Shadows, and Control Structures\"},\"content\":\"\u003Cbr>\\n\u003Cp>본 글은 Golang을 공부하며 주요 내용이라 생각되는 것들을 기록해둔 자료이며, Ubuntu 20.04 LTS 기준으로 작성되었습니다.\u003C/p>\\n\u003Cp>\u003Cbr>\u003Cbr>\u003C/p>\\n\u003Ch2>Shadowing\u003C/h2>\\n\u003Chr>\\n\u003Cp>Go에서 기본적으로 \u003Ccode>Block\u003C/code>의 개념은 타 언어와 유사하다.\\n\u003Ccode>if\u003C/code>, \u003Ccode>for\u003C/code> 등 흐름 제어 키워드들에 의해 중괄호가 시작되고, 해당 중괄호가 닫히는 영역까지를 \u003Ccode>Block\u003C/code>이라 한다.\u003C/p>\\n\u003Cpre>\u003Ccode class=\\\"hljs language-go\\\">x1 := \u003Cspan class=\\\"hljs-number\\\">10\u003C/span> \u003Cspan class=\\\"hljs-comment\\\">// shadowed variable.\u003C/span>\\n\u003Cspan class=\\\"hljs-keyword\\\">if\u003C/span> x1 > \u003Cspan class=\\\"hljs-number\\\">5\u003C/span> {\\n    fmt.Println(x1) \u003Cspan class=\\\"hljs-comment\\\">// 10 => x1 is not yet shadowed\u003C/span>\\n    x1 := \u003Cspan class=\\\"hljs-number\\\">5\u003C/span>         \u003Cspan class=\\\"hljs-comment\\\">// shadowing variable. from this line to end of this block\u003C/span>\\n    fmt.Println(x1) \u003Cspan class=\\\"hljs-comment\\\">// 5 => x1 is shadowed until if-blocks ends\u003C/span>\\n}\\nfmt.Println(x1) \u003Cspan class=\\\"hljs-comment\\\">// 10 => if-block ends. x1 is not shadowed\u003C/span>\\n\u003C/code>\u003C/pre>\\n\u003Cp>이전 챕터에서도 다루었지만, Shadowing이 발생하면 해당 블록이 끝날 때까지 Shadowing된 변수에 접근할 수 없다.\u003C/p>\\n\u003Cbr>\\n\u003Cpre>\u003Ccode class=\\\"hljs language-go\\\">\\t\u003Cspan class=\\\"hljs-literal\\\">true\u003C/span>, \u003Cspan class=\\\"hljs-keyword\\\">int\u003C/span> := \u003Cspan class=\\\"hljs-number\\\">10\u003C/span>, \u003Cspan class=\\\"hljs-string\\\">\\\"hi\\\"\u003C/span>\\n\\tfmt := \u003Cspan class=\\\"hljs-string\\\">\\\"oops\\\"\u003C/span>    \u003Cspan class=\\\"hljs-comment\\\">// fmt is shadowed\u003C/span>\\n\u003C/code>\u003C/pre>\\n\u003Cp>이렇게 패키지명이나 \u003Cem>universe block\u003C/em>의 구분자들을 Shadowing하는 것이 문법적으로는 가능하지만, \u003Cstrong>절대\u003C/strong> 이렇게 하지 않도록 주의하자.\u003C/p>\\n\u003Cbr>\\n\u003Cp>변수가 Shadowing되는 것을 확인할 수 있는 명령어가 존재한다. 외부 모듈이므로 설치 후 사용해주어야 한다.\u003C/p>\\n\u003Cpre>\u003Ccode class=\\\"hljs language-bash\\\">go install golang.org/x/tools/go/analysis/passes/shadow/cmd/shadow@latest\\nshadow ./..\\n\u003C/code>\u003C/pre>\\n\u003Cp>위와 같이 설치 후, \u003Ccode>shadow\u003C/code> 명령어를 통해 검사를 실시하고자 하는 파일을 지정한다.\u003C/p>\\n\u003Cpre>\u003Ccode class=\\\"hljs language-bash\\\">declaration of \u003Cspan class=\\\"hljs-string\\\">\\\"x\\\"\u003C/span> shadows declaration at line 6\\n\u003C/code>\u003C/pre>\\n\u003Cp>\u003Cbr>\u003Cbr>\u003C/p>\\n\u003Ch2>if\u003C/h2>\\n\u003Chr>\\n\u003Cp>C 계열 프로그래밍 언어의 \u003Ccode>if\u003C/code>문과 크게 다르지 않다. 특이사항으로는 괄호를 생략한다.\u003C/p>\\n\u003Cpre>\u003Ccode class=\\\"hljs language-go\\\">n1 := \u003Cspan class=\\\"hljs-number\\\">7\u003C/span>\\n\u003Cspan class=\\\"hljs-keyword\\\">if\u003C/span> n1 == \u003Cspan class=\\\"hljs-number\\\">0\u003C/span> {        \u003Cspan class=\\\"hljs-comment\\\">// there is no parenthesis around the condition\u003C/span>\\n    fmt.Println(\u003Cspan class=\\\"hljs-string\\\">\\\"too low\\\"\u003C/span>)\\n} \u003Cspan class=\\\"hljs-keyword\\\">else\u003C/span> \u003Cspan class=\\\"hljs-keyword\\\">if\u003C/span> n1 > \u003Cspan class=\\\"hljs-number\\\">5\u003C/span> {\\n    fmt.Println(\u003Cspan class=\\\"hljs-string\\\">\\\"too big :\\\"\u003C/span>, n1)\\n} \u003Cspan class=\\\"hljs-keyword\\\">else\u003C/span> {\\n    fmt.Println(\u003Cspan class=\\\"hljs-string\\\">\\\"good :\\\"\u003C/span>, n1)\\n}\\n\u003C/code>\u003C/pre>\\n\u003Cbr>\\n\u003Cp>특이사항으로는 \u003Ccode>if\u003C/code>문의 조건 확인 구문 안에서 변수 선언을 동시에 할 수 있다.\u003C/p>\\n\u003Cpre>\u003Ccode class=\\\"hljs language-go\\\">\u003Cspan class=\\\"hljs-keyword\\\">if\u003C/span> n2 := \u003Cspan class=\\\"hljs-number\\\">4\u003C/span>; n2 == \u003Cspan class=\\\"hljs-number\\\">0\u003C/span> { \u003Cspan class=\\\"hljs-comment\\\">// both declaring variable and checking condition\u003C/span>\\n    fmt.Println(\u003Cspan class=\\\"hljs-string\\\">\\\"too low\\\"\u003C/span>)\\n} \u003Cspan class=\\\"hljs-keyword\\\">else\u003C/span> \u003Cspan class=\\\"hljs-keyword\\\">if\u003C/span> n2 > \u003Cspan class=\\\"hljs-number\\\">5\u003C/span> {\\n    fmt.Println(\u003Cspan class=\\\"hljs-string\\\">\\\"too big :\\\"\u003C/span>, n2)\\n} \u003Cspan class=\\\"hljs-keyword\\\">else\u003C/span> {\\n    fmt.Println(\u003Cspan class=\\\"hljs-string\\\">\\\"good :\\\"\u003C/span>, n2)\\n}\\n\\n\u003Cspan class=\\\"hljs-comment\\\">// fmt.Println(n2) // it causes error. once a if/else statement ends, n1 is not accessable.\u003C/span>\\n\u003C/code>\u003C/pre>\\n\u003Cp>단, 이렇게 선언된 변수는 \u003Ccode>if\u003C/code>문 밖에선 접근할 수 없다.\u003C/p>\\n\u003Cp>\u003Cbr>\u003Cbr>\u003C/p>\\n\u003Ch2>for\u003C/h2>\\n\u003Chr>\\n\u003Cp>Go의 \u003Ccode>for\u003C/code>문은 4가지 유형이 존재한다.\u003C/p>\\n\u003Col>\\n\u003Cli>일반적인 \u003Ccode>for\u003C/code>문과 유사함 => \u003Ccode>for(int i = 0; i &#x3C; n; i++) {}\u003C/code>\u003C/li>\\n\u003Cli>일반적인 while문과 유사함 => \u003Ccode>while(condition)\u003C/code>\u003C/li>\\n\u003Cli>무한 루프 => \u003Ccode>while(True)\u003C/code>\u003C/li>\\n\u003Cli>range-based의 foreach문 => \u003Ccode>for(const auto&#x26; element : containor) {}\u003C/code>\u003C/li>\\n\u003C/ol>\\n\u003Cp>하나씩 살펴보자.\u003C/p>\\n\u003Cp>\u003Cbr>\u003Cbr>\u003C/p>\\n\u003Ch3>The Complete for Statement\u003C/h3>\\n\u003Cpre>\u003Ccode class=\\\"hljs language-go\\\">\u003Cspan class=\\\"hljs-keyword\\\">for\u003C/span> i := \u003Cspan class=\\\"hljs-number\\\">0\u003C/span>; i &#x3C; \u003Cspan class=\\\"hljs-number\\\">10\u003C/span>; i++ {\\n    fmt.Print(i)\\n}\\n\u003C/code>\u003C/pre>\\n\u003Cp>\u003Ccode>if\u003C/code>문처럼 괄호를 사용하지 않는다. 또한 변수를 초기화할 때 \u003Ccode>var\u003C/code> 키워드를 사용하지 않고, \u003Ccode>:=\u003C/code> 연산자를 이용하여 초기화해야 한다.\u003C/p>\\n\u003Cbr>\\n\u003Ch3>condition-only statements\u003C/h3>\\n\u003Cpre>\u003Ccode class=\\\"hljs language-go\\\">i := \u003Cspan class=\\\"hljs-number\\\">1\u003C/span>\\n\u003Cspan class=\\\"hljs-keyword\\\">for\u003C/span> i &#x3C; \u003Cspan class=\\\"hljs-number\\\">100\u003C/span> {\\n    fmt.Print(i, \u003Cspan class=\\\"hljs-string\\\">\\\" \\\"\u003C/span>)\\n    i = i * \u003Cspan class=\\\"hljs-number\\\">2\u003C/span>\\n}\\n\u003C/code>\u003C/pre>\\n\u003Cp>변수의 선언과 증감이 생략된 형태로, 다른 언어의 while문과 유사한 형태이다.\u003C/p>\\n\u003Cbr>\\n\u003Ch3>infinite loop and break, continue statements\u003C/h3>\\n\u003Cpre>\u003Ccode class=\\\"hljs language-go\\\">j := \u003Cspan class=\\\"hljs-number\\\">0\u003C/span>\\n\u003Cspan class=\\\"hljs-keyword\\\">for\u003C/span> {\\n    \u003Cspan class=\\\"hljs-keyword\\\">if\u003C/span> j++; j > \u003Cspan class=\\\"hljs-number\\\">10\u003C/span> {\\n        \u003Cspan class=\\\"hljs-keyword\\\">break\u003C/span> \u003Cspan class=\\\"hljs-comment\\\">// if there is no break statement, loop will last until a keyboard interrupt(ctrl-c) occurs\u003C/span>\\n    } \u003Cspan class=\\\"hljs-keyword\\\">else\u003C/span> \u003Cspan class=\\\"hljs-keyword\\\">if\u003C/span> j%\u003Cspan class=\\\"hljs-number\\\">2\u003C/span> == \u003Cspan class=\\\"hljs-number\\\">0\u003C/span> {\\n        \u003Cspan class=\\\"hljs-keyword\\\">continue\u003C/span>\\n    }\\n    fmt.Print(i, \u003Cspan class=\\\"hljs-string\\\">\\\" \\\"\u003C/span>)\\n}\\n\u003C/code>\u003C/pre>\\n\u003Cp>\u003Ccode>for\u003C/code> 키워드 이후 아무런 표현식도 오지 않으면 무한루프를 돌게 된다. \u003Ccode>break\u003C/code>문과 \u003Ccode>contine\u003C/code>문도 사용 가능하다.\u003C/p>\\n\u003Cbr>\\n\u003Ch3>for-range loop\u003C/h3>\\n\u003Cpre>\u003Ccode class=\\\"hljs language-go\\\">\u003Cspan class=\\\"hljs-comment\\\">// for-range loop (array, slice, string)\u003C/span>\\nevenVals := []\u003Cspan class=\\\"hljs-keyword\\\">int\u003C/span>{\u003Cspan class=\\\"hljs-number\\\">2\u003C/span>, \u003Cspan class=\\\"hljs-number\\\">4\u003C/span>, \u003Cspan class=\\\"hljs-number\\\">6\u003C/span>, \u003Cspan class=\\\"hljs-number\\\">8\u003C/span>, \u003Cspan class=\\\"hljs-number\\\">10\u003C/span>, \u003Cspan class=\\\"hljs-number\\\">12\u003C/span>}\\n\u003Cspan class=\\\"hljs-keyword\\\">for\u003C/span> i, v := \u003Cspan class=\\\"hljs-keyword\\\">range\u003C/span> evenVals {\\n    fmt.Println(i, v) \u003Cspan class=\\\"hljs-comment\\\">// i is an key(index) of the data, v is value of the data\u003C/span>\\n}\\n\\n\u003Cspan class=\\\"hljs-comment\\\">// ignoring the key in a for-range loop\u003C/span>\\n\u003Cspan class=\\\"hljs-keyword\\\">for\u003C/span> _, v := \u003Cspan class=\\\"hljs-keyword\\\">range\u003C/span> evenVals { \u003Cspan class=\\\"hljs-comment\\\">// using underscore(_), we can only access the value\u003C/span>\\n    fmt.Print(v, \u003Cspan class=\\\"hljs-string\\\">\\\" \\\"\u003C/span>) \u003Cspan class=\\\"hljs-comment\\\">// if you want, it is also possible to ignore the value by using underscore\u003C/span>\\n}\\n\u003C/code>\u003C/pre>\\n\u003Cp>다른 언어에 존재하는 \u003Ccode>for-each\u003C/code> 형태의 반복문과 유사한 형태이다. \u003Ccode>range\u003C/code> 키워드를 통해 각각 인덱스와 값에 접근할 수 있다.\\n또한 변수 이름을 언더바(\u003Ccode>_\u003C/code>)로 설정하면, 해당 값을 사용하지 않고 넘긴다는 의미가 된다. 적절히 사용할 수 있도록 하자.\u003C/p>\\n\u003Cbr>\\n\u003Cp>\u003Ccode>map\u003C/code> 타입에 대해서도 for-range loop를 적용할 수 있다.\u003C/p>\\n\u003Cpre>\u003Ccode class=\\\"hljs language-go\\\">\u003Cspan class=\\\"hljs-comment\\\">// for-range loop (map)\u003C/span>\\nnames := \u003Cspan class=\\\"hljs-keyword\\\">map\u003C/span>[\u003Cspan class=\\\"hljs-keyword\\\">string\u003C/span>]\u003Cspan class=\\\"hljs-keyword\\\">bool\u003C/span>{\\n    \u003Cspan class=\\\"hljs-string\\\">\\\"Fred\\\"\u003C/span>: \u003Cspan class=\\\"hljs-literal\\\">true\u003C/span>,\\n    \u003Cspan class=\\\"hljs-string\\\">\\\"Raul\\\"\u003C/span>: \u003Cspan class=\\\"hljs-literal\\\">true\u003C/span>,\\n    \u003Cspan class=\\\"hljs-string\\\">\\\"Will\\\"\u003C/span>: \u003Cspan class=\\\"hljs-literal\\\">false\u003C/span>,\\n}\\n\\n\u003Cspan class=\\\"hljs-keyword\\\">for\u003C/span> k, v := \u003Cspan class=\\\"hljs-keyword\\\">range\u003C/span> names {\\n    fmt.Println(k, v)\\n}\\n\\n\u003Cspan class=\\\"hljs-keyword\\\">for\u003C/span> k := \u003Cspan class=\\\"hljs-keyword\\\">range\u003C/span> names { \u003Cspan class=\\\"hljs-comment\\\">// by leave off second variable, it is possible to get key only.\u003C/span>\\n    fmt.Println(k, names[k])\\n}\\n\u003C/code>\u003C/pre>\\n\u003Cp>대충 Python이랑 비슷한 것 같다.\u003C/p>\\n\u003Cbr>\\n\u003Cp>\u003Ccode>string\u003C/code>에 대해서도 for-range loop가 가능하다.\u003C/p>\\n\u003Cpre>\u003Ccode class=\\\"hljs language-go\\\">\u003Cspan class=\\\"hljs-comment\\\">// for-range loop (string)\u003C/span>\\nsamples := []\u003Cspan class=\\\"hljs-keyword\\\">string\u003C/span>{\u003Cspan class=\\\"hljs-string\\\">\\\"hello\\\"\u003C/span>, \u003Cspan class=\\\"hljs-string\\\">\\\"안녕하세요\\\"\u003C/span>}\\n\\n\u003Cspan class=\\\"hljs-keyword\\\">for\u003C/span> _, sample := \u003Cspan class=\\\"hljs-keyword\\\">range\u003C/span> samples {\\n    \u003Cspan class=\\\"hljs-keyword\\\">for\u003C/span> i, r := \u003Cspan class=\\\"hljs-keyword\\\">range\u003C/span> sample { \u003Cspan class=\\\"hljs-comment\\\">// it iterates over the runes, not bytes\u003C/span>\\n        fmt.Println(i, r, \u003Cspan class=\\\"hljs-keyword\\\">string\u003C/span>(r)) \u003Cspan class=\\\"hljs-comment\\\">// key is the number of byte from the beginning of the string, type of value is rune\u003C/span>\\n    }\\n}\\n\u003C/code>\u003C/pre>\\n\u003Cp>특이사항은 \u003Ccode>byte\u003C/code> 단위가 아닌 \u003Ccode>rune\u003C/code> 단위로 iterating한다는 것.\\n따라서 문자의 크기가 2바이트 이상인 경우, 인덱스가 점프하는 것을 확인할 수 있다.\u003C/p>\\n\u003Cbr>\\n\u003Cp>Go에서의 \u003Ccode>for\u003C/code>문은 \u003Cstrong>Labeling\u003C/strong>을 지원한다.\u003C/p>\\n\u003Cpre>\u003Ccode class=\\\"hljs language-go\\\">\u003Cspan class=\\\"hljs-function\\\">\u003Cspan class=\\\"hljs-keyword\\\">func\u003C/span> \u003Cspan class=\\\"hljs-title\\\">main\u003C/span>\u003Cspan class=\\\"hljs-params\\\">()\u003C/span>\u003C/span> {\\n\\tsamples := []\u003Cspan class=\\\"hljs-keyword\\\">string\u003C/span>{\u003Cspan class=\\\"hljs-string\\\">\\\"hello\\\"\u003C/span>, \u003Cspan class=\\\"hljs-string\\\">\\\"안녕hello\\\"\u003C/span>}\\n\\nouter: \u003Cspan class=\\\"hljs-comment\\\">// label of outer for-statements\u003C/span>\\n\\t\u003Cspan class=\\\"hljs-keyword\\\">for\u003C/span> _, sample := \u003Cspan class=\\\"hljs-keyword\\\">range\u003C/span> samples {\\n\\t\\t\u003Cspan class=\\\"hljs-keyword\\\">for\u003C/span> i, r := \u003Cspan class=\\\"hljs-keyword\\\">range\u003C/span> sample {\\n\\t\\t\\tfmt.Println(i, r, \u003Cspan class=\\\"hljs-keyword\\\">string\u003C/span>(r))\\n\\t\\t\\t\u003Cspan class=\\\"hljs-keyword\\\">if\u003C/span> r == \u003Cspan class=\\\"hljs-string\\\">'l'\u003C/span> {\\n\\t\\t\\t\\t\u003Cspan class=\\\"hljs-keyword\\\">continue\u003C/span> outer \u003Cspan class=\\\"hljs-comment\\\">// this leads to continue nested loop\u003C/span>\\n\\t\\t\\t}\\n\\t\\t}\\n\\t\\tfmt.Println() \u003Cspan class=\\\"hljs-comment\\\">// this line is not reached because all the strings contain 'l', and the process continued outer loop\u003C/span>\\n\\t}\\n}\\n\u003C/code>\u003C/pre>\\n\u003Cp>바깥쪽 반복문에 \u003Ccode>outer\u003C/code>라는 Label이 붙어있다.\\n그리고 안쪽 반복문에서 \u003Ccode>continue outer\u003C/code>를 통해 \u003Ccode>for i, r := range sample {}\u003C/code> 블록이 아닌, \u003Ccode>for _, sample := range samples\u003C/code> 블록의 시작점으로 되돌아가고 있다.\u003C/p>\\n\u003Cp>\u003Cbr>\u003Cbr>\u003C/p>\\n\u003Ch2>switch\u003C/h2>\\n\u003Chr>\\n\u003Cp>보통 제한적인 상황에서만 사용되거나 \u003Ccode>switch\u003C/code>문이 없는 다른 언어들과는 달리, Go는 \u003Ccode>switch\u003C/code>문이 엄청 잘되어있다.\u003C/p>\\n\u003Cpre>\u003Ccode class=\\\"hljs language-go\\\">words := []\u003Cspan class=\\\"hljs-keyword\\\">string\u003C/span>{\u003Cspan class=\\\"hljs-string\\\">\\\"a\\\"\u003C/span>, \u003Cspan class=\\\"hljs-string\\\">\\\"cow\\\"\u003C/span>, \u003Cspan class=\\\"hljs-string\\\">\\\"smile\\\"\u003C/span>, \u003Cspan class=\\\"hljs-string\\\">\\\"gopher\\\"\u003C/span>, \u003Cspan class=\\\"hljs-string\\\">\\\"octopus\\\"\u003C/span>, \u003Cspan class=\\\"hljs-string\\\">\\\"영어싫어\\\"\u003C/span>, \u003Cspan class=\\\"hljs-string\\\">\\\"\\\"\u003C/span>}\\n\\n\u003Cspan class=\\\"hljs-keyword\\\">for\u003C/span> _, word := \u003Cspan class=\\\"hljs-keyword\\\">range\u003C/span> words {\\n    \u003Cspan class=\\\"hljs-keyword\\\">switch\u003C/span> size := \u003Cspan class=\\\"hljs-built_in\\\">len\u003C/span>(word); size { \u003Cspan class=\\\"hljs-comment\\\">// as like if-statements, there is no parenthesis\u003C/span>\\n    \u003Cspan class=\\\"hljs-keyword\\\">case\u003C/span> \u003Cspan class=\\\"hljs-number\\\">1\u003C/span>, \u003Cspan class=\\\"hljs-number\\\">2\u003C/span>, \u003Cspan class=\\\"hljs-number\\\">3\u003C/span>, \u003Cspan class=\\\"hljs-number\\\">4\u003C/span>: \u003Cspan class=\\\"hljs-comment\\\">// using comma(,), we can make multiple matches\u003C/span>\\n        fmt.Println(word, \u003Cspan class=\\\"hljs-string\\\">\\\"is a short word!\\\"\u003C/span>)\\n    \u003Cspan class=\\\"hljs-keyword\\\">case\u003C/span> \u003Cspan class=\\\"hljs-number\\\">5\u003C/span>:\\n        fmt.Println(word, \u003Cspan class=\\\"hljs-string\\\">\\\"is exactly the right length:\\\"\u003C/span>, size)\\n        \u003Cspan class=\\\"hljs-keyword\\\">break\u003C/span>                         \u003Cspan class=\\\"hljs-comment\\\">// this makes it exits switch earlier\u003C/span>\\n        fmt.Println(\u003Cspan class=\\\"hljs-string\\\">\\\"not be printed\\\"\u003C/span>) \u003Cspan class=\\\"hljs-comment\\\">// because of break above, this line is unreachable\u003C/span>\\n    \u003Cspan class=\\\"hljs-keyword\\\">case\u003C/span> \u003Cspan class=\\\"hljs-number\\\">6\u003C/span>, \u003Cspan class=\\\"hljs-number\\\">7\u003C/span>, \u003Cspan class=\\\"hljs-number\\\">8\u003C/span>, \u003Cspan class=\\\"hljs-number\\\">9\u003C/span>: \u003Cspan class=\\\"hljs-comment\\\">// empty case (nothing happened)\u003C/span>\\n        \u003Cspan class=\\\"hljs-comment\\\">// fallthrough // if keyword `fallthrough` is here, as like other languages, run next case's block\u003C/span>\\n    \u003Cspan class=\\\"hljs-keyword\\\">default\u003C/span>:\\n        fmt.Println(word, \u003Cspan class=\\\"hljs-string\\\">\\\"is a wrong word\\\"\u003C/span>)\\n    }\\n}\\n\u003C/code>\u003C/pre>\\n\u003Cp>여러 값에 대해 적용되는 \u003Ccode>case\u003C/code>를 설정하려면 컴마(\u003Ccode>,\u003C/code>)로 값들을 구분지어서 나열하면 된다.\u003Cbr>\\n특이사항은 \u003Ccode>case\u003C/code> 블록에서 \u003Ccode>break\u003C/code>를 통한 탈출을 지원하긴 하지만, 다른 언어와 달리 반드시 사용하지 않아도 \u003Ccode>case\u003C/code> 블록이 끝나면 알아서 탈출해준다.\\n만약 \u003Ccode>case\u003C/code> 블록이 끝나고 아래 \u003Ccode>case\u003C/code> 블록도 실행되게끔 하고자 하는 경우, \u003Ccode>fallthrough\u003C/code> 키워드를 사용하면 된다 한다. 다만 권장되지는 않는 듯 하다.\u003C/p>\\n\u003Cbr>\\n\u003Cp>\u003Ccode>switch\u003C/code>문에 아무런 변수도 할당하지 않는 경우, boolean expression의 true/false 여부에 따라 \u003Ccode>case\u003C/code> 블록이 실행된다. \u003Ccode>if\u003C/code>/\u003Ccode>else\u003C/code>문이랑 비슷한듯.\u003C/p>\\n\u003Cpre>\u003Ccode class=\\\"hljs language-go\\\">\\t\u003Cspan class=\\\"hljs-comment\\\">// blank switch, break a loop in switch/case statements\u003C/span>\\nloop: \u003Cspan class=\\\"hljs-comment\\\">// to break in switch/case statement, attach a label to for-statements\u003C/span>\\n\\t\u003Cspan class=\\\"hljs-keyword\\\">for\u003C/span> i := \u003Cspan class=\\\"hljs-number\\\">0\u003C/span>; i &#x3C; \u003Cspan class=\\\"hljs-number\\\">10\u003C/span>; i++ {\\n\\t\\t\u003Cspan class=\\\"hljs-keyword\\\">switch\u003C/span> { \u003Cspan class=\\\"hljs-comment\\\">// this is a blank switch. no variable\u003C/span>\\n\\t\\t\u003Cspan class=\\\"hljs-keyword\\\">case\u003C/span> i%\u003Cspan class=\\\"hljs-number\\\">2\u003C/span> == \u003Cspan class=\\\"hljs-number\\\">0\u003C/span>: \u003Cspan class=\\\"hljs-comment\\\">// here can be boolean expression\u003C/span>\\n\\t\\t\\tfmt.Println(i, \u003Cspan class=\\\"hljs-string\\\">\\\"is even number\\\"\u003C/span>)\\n\\t\\t\u003Cspan class=\\\"hljs-keyword\\\">case\u003C/span> i%\u003Cspan class=\\\"hljs-number\\\">3\u003C/span> == \u003Cspan class=\\\"hljs-number\\\">0\u003C/span>:\\n\\t\\t\\tfmt.Println(i, \u003Cspan class=\\\"hljs-string\\\">\\\"is divisible by 3 but not 2\\\"\u003C/span>)\\n\\t\\t\u003Cspan class=\\\"hljs-keyword\\\">case\u003C/span> i%\u003Cspan class=\\\"hljs-number\\\">7\u003C/span> == \u003Cspan class=\\\"hljs-number\\\">0\u003C/span>:\\n\\t\\t\\tfmt.Println(\u003Cspan class=\\\"hljs-string\\\">\\\"exit the loop\\\"\u003C/span>)\\n\\t\\t\\t\u003Cspan class=\\\"hljs-keyword\\\">break\u003C/span> loop \u003Cspan class=\\\"hljs-comment\\\">// if this statement is just `break`, it cannot exit the loop. just proceed until the loop ends\u003C/span>\\n\\t\\t\u003Cspan class=\\\"hljs-keyword\\\">default\u003C/span>:\\n\\t\\t\\tfmt.Println(i, \u003Cspan class=\\\"hljs-string\\\">\\\"is boring\\\"\u003C/span>)\\n\\t\\t}\\n\\t}\\n\u003C/code>\u003C/pre>\\n\u003Cp>\u003Ccode>case\u003C/code>안에서 \u003Ccode>for\u003C/code>문을 탈출하려면 위처럼 \u003Ccode>break\u003C/code>문에 Label을 명시해주어야 한다.\u003C/p>\\n\u003Cp>\u003Cbr>\u003Cbr>\u003C/p>\\n\u003Ch2>goto\u003C/h2>\\n\u003Chr>\\n\u003Cp>놀랍게도 Go엔 \u003Ccode>goto\u003C/code>가 있다. \u003Ccode>goto\u003C/code> 자체가 가지고 있는 문제점을 해결하기 위해 몇 가지 보완이 이루어진 듯 하다.\u003C/p>\\n\u003Cpre>\u003Ccode class=\\\"hljs language-go\\\">\\ta := \u003Cspan class=\\\"hljs-number\\\">10\u003C/span>\\n\\t\u003Cspan class=\\\"hljs-comment\\\">// goto skip // cannot jump over variable declaration\u003C/span>\\n\\tb := \u003Cspan class=\\\"hljs-number\\\">20\u003C/span>\\n\\t\u003Cspan class=\\\"hljs-keyword\\\">goto\u003C/span> skip\\nskip:\\n\\tc := \u003Cspan class=\\\"hljs-number\\\">30\u003C/span>\\n\\n\\tfmt.Println(a, b, c)\\n\\t\u003Cspan class=\\\"hljs-keyword\\\">if\u003C/span> c > a {\\n\\t\\t\u003Cspan class=\\\"hljs-comment\\\">// goto inner // cannot jump into block\u003C/span>\\n\\t}\\n\\n\\t\u003Cspan class=\\\"hljs-keyword\\\">if\u003C/span> a &#x3C; b {\\n\\t\\t\u003Cspan class=\\\"hljs-keyword\\\">goto\u003C/span> inner\\n\\tinner:\\n\\t\\tfmt.Println(\u003Cspan class=\\\"hljs-string\\\">\\\"a is less than b\\\"\u003C/span>)\\n\\t}\\n\u003C/code>\u003C/pre>\\n\u003Cp>\u003Ccode>goto\u003C/code>를 통해 특정 block 안으로 들어가거나, 변수 선언 이전으로 되돌아가거나 할 수는 없다.\u003C/p>\\n\u003Cbr>\\n\u003Cp>\u003Ccode>goto\u003C/code>가 유용하게 쓰이는 경우가 한 가지 있다.\u003C/p>\\n\u003Cpre>\u003Ccode class=\\\"hljs language-go\\\">    x := rand.Intn(\u003Cspan class=\\\"hljs-number\\\">10\u003C/span>)\\n\\n\\t\u003Cspan class=\\\"hljs-keyword\\\">for\u003C/span> x &#x3C; \u003Cspan class=\\\"hljs-number\\\">100\u003C/span> {\\n\\t\\t\u003Cspan class=\\\"hljs-keyword\\\">if\u003C/span> a%\u003Cspan class=\\\"hljs-number\\\">5\u003C/span> == \u003Cspan class=\\\"hljs-number\\\">0\u003C/span> {\\n\\t\\t\\t\u003Cspan class=\\\"hljs-keyword\\\">goto\u003C/span> done \u003Cspan class=\\\"hljs-comment\\\">// in this case, instead of using boolean flag, using goto makes code clearer and readable\u003C/span>\\n\\t\\t}\\n\\t\\ta = a*\u003Cspan class=\\\"hljs-number\\\">2\u003C/span> + \u003Cspan class=\\\"hljs-number\\\">1\u003C/span>\\n\\t}\\n\\n\\tfmt.Println(\u003Cspan class=\\\"hljs-string\\\">\\\"do something when the loop completes normally\\\"\u003C/span>)\\ndone:\\n\\tfmt.Println(\u003Cspan class=\\\"hljs-string\\\">\\\"do complicated stuff no matter why we left the loop\\\"\u003C/span>)\\n\\tfmt.Println(a)\\n\u003C/code>\u003C/pre>\\n\u003Cp>위처럼 flag를 설정하여, flag의 여부에 따라 추가적으로 처리를 해주어야 하는 경우이다.\\n이 경우 위처럼 \u003Ccode>goto\u003C/code>를 사용하는 것이 \u003Ccode>if\u003C/code>를 사용하는 것보다 깔끔하다고 한다.\u003C/p>\\n\u003Cp>\u003Cbr>\u003Cbr>\u003C/p>\\n\u003Ch2>References\u003C/h2>\\n\u003Chr>\\n\u003Ccenter>\\n\u003Cp>\u003Ca href=\\\"https://learning.oreilly.com/library/view/learning-go/9781492077206/\\\">\u003Cimg src=\\\"https://learning.oreilly.com/covers/urn:orm:book:9781492077206/400w/\\\" alt=\\\"\\\">\u003C/a> \u003Cbr>\\n\u003Ca href=\\\"https://learning.oreilly.com/library/view/learning-go/9781492077206/\\\">Jon Bodner, 『Learning Go』, O'Reilly Media, Inc.\u003C/a>\u003C/p>\\n\u003C/center>\\n\u003Cp>\u003Cbr>\u003Cbr>\u003C/p>\",\"mainCategory\":\"Golang\",\"subCategory\":\"Golang Basics\"}"}</script></div>
    </body>
</html>
