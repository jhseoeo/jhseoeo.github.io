<!DOCTYPE html>
<html lang="en">
    <head>
        <meta charset="utf-8" />
        <link rel="icon" href="/favicon.ico" />
        <meta name="viewport" content="width=device-width, initial-scale=1" />
        <meta http-equiv="content-security-policy" content=""><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.7.1/styles/github.min.css" data-svelte="svelte-1pt6jb2"><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Overpass" data-svelte="svelte-1pt6jb2"><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Fira+Mono" data-svelte="svelte-1pt6jb2"><link rel="preconnect" href="https://fonts.gstatic.com" data-svelte="svelte-1pt6jb2"><link rel="stylesheet" href="https://fonts.googleapis.com/css2?family=Black+And+White+Picture&family=Black+Han+Sans&family=Cute+Font&family=Do+Hyeon&family=Dokdo&family=East+Sea+Dokdo&family=Gaegu&family=Gamja+Flower&family=Gothic+A1&family=Gugi&family=Hi+Melody&family=Jua&family=Kirang+Haerang&family=Nanum+Brush+Script&family=Nanum+Gothic&family=Nanum+Gothic+Coding&family=Nanum+Myeongjo&family=Nanum+Pen+Script&family=Noto+Sans+KR&family=Noto+Serif+KR&family=Poor+Story&family=Single+Day&family=Song+Myung&family=Stylish&family=Sunflower:wght@300&family=Yeon+Sung&display=swap" data-svelte="svelte-1pt6jb2">
	<link rel="stylesheet" href="/_app/immutable/assets/pages/__layout.svelte-866c92ea.css">
	<link rel="stylesheet" href="/_app/immutable/assets/IconBase-05c40767.css">
	<link rel="stylesheet" href="/_app/immutable/assets/pages/posts/_mainCategory_/_subCategory_/_slug_.svelte-1e6f5432.css">
	<link rel="modulepreload" href="/_app/immutable/start-d3635e20.js">
	<link rel="modulepreload" href="/_app/immutable/chunks/index-f3b79873.js">
	<link rel="modulepreload" href="/_app/immutable/chunks/paths-396f020f.js">
	<link rel="modulepreload" href="/_app/immutable/chunks/preload-helper-60cab3ee.js">
	<link rel="modulepreload" href="/_app/immutable/chunks/singletons-d1fb5791.js">
	<link rel="modulepreload" href="/_app/immutable/pages/__layout.svelte-b969548a.js">
	<link rel="modulepreload" href="/_app/immutable/chunks/IconBase-0ff4bf3c.js">
	<link rel="modulepreload" href="/_app/immutable/pages/posts/_mainCategory_/_subCategory_/_slug_.svelte-0c17fdf6.js">
	<link rel="modulepreload" href="/_app/immutable/chunks/FaAngleRight-57d996e3.js">
    </head>
    <body>
        <div id="svelte">




<div class="app svelte-174pa0l"><nav class="topbar svelte-1jxcbio"><div class="menu svelte-1jxcbio"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 512 512" class="svelte-c8tyih"><path d="M432 176H80c-8.8 0-16-7.2-16-16s7.2-16 16-16h352c8.8 0 16 7.2 16 16s-7.2 16-16 16zM432 272H80c-8.8 0-16-7.2-16-16s7.2-16 16-16h352c8.8 0 16 7.2 16 16s-7.2 16-16 16zM432 368H80c-8.8 0-16-7.2-16-16s7.2-16 16-16h352c8.8 0 16 7.2 16 16s-7.2 16-16 16z"></path></svg></div>
	<div><a class="title svelte-1jxcbio" href="/">집밥서선생</a></div>
	<div class="ghcorner svelte-1jxcbio">
<a href="https://github.com/junhyuk0801" class="github-corner svelte-1t9vm59" aria-label="View source on GitHub"><svg width="60" height="60" viewBox="0 0 250 250" style="fill:#444; color:#fff; position: absolute; top: 0; border: 0; right: 0;" aria-hidden="true"><path d="M0,0 L115,115 L130,115 L142,142 L250,250 L250,0 Z"></path><path d="M128.3,109.0 C113.8,99.7 119.0,89.6 119.0,89.6 C122.0,82.7 120.5,78.6 120.5,78.6 C119.2,72.0 123.4,76.3 123.4,76.3 C127.3,80.9 125.5,87.3 125.5,87.3 C122.9,97.6 130.6,101.9 134.4,103.2" fill="currentColor" style="transform-origin: 130px 106px;" class="octo-arm svelte-1t9vm59"></path><path d="M115.0,115.0 C114.9,115.1 118.7,116.5 119.8,115.4 L133.7,101.6 C136.9,99.2 139.9,98.4 142.2,98.6 C133.8,88.0 127.5,74.4 143.8,58.0 C148.5,53.4 154.0,51.2 159.7,51.0 C160.3,49.4 163.2,43.6 171.4,40.1 C171.4,40.1 176.1,42.5 178.8,56.2 C183.1,58.6 187.2,61.8 190.9,65.4 C194.5,69.0 197.7,73.2 200.1,77.6 C213.8,80.2 216.3,84.9 216.3,84.9 C212.7,93.1 206.9,96.0 205.4,96.6 C205.1,102.4 203.0,107.8 198.3,112.5 C181.9,128.9 168.3,122.5 157.7,114.1 C157.9,116.9 156.7,120.9 152.7,124.9 L141.0,136.5 C139.8,137.7 141.6,141.9 141.8,141.8 Z" fill="currentColor" class="octo-body"></path></svg>
</a></div></nav>


  
  <div class="g-app-wrapper svelte-174pa0l"><div class="contents svelte-174pa0l"><span class="svelte-166a0qx"><h1 class="title svelte-166a0qx">함수</h1>
  <a class="backto svelte-166a0qx" href="/posts/Golang/Golang Basics">Golang Basics
    <div class="ico svelte-166a0qx"><svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 256 512" class="svelte-c8tyih"><path d="M224.3 273l-136 136c-9.4 9.4-24.6 9.4-33.9 0l-22.6-22.6c-9.4-9.4-9.4-24.6 0-33.9l96.4-96.4-96.4-96.4c-9.4-9.4-9.4-24.6 0-33.9L54.3 103c9.4-9.4 24.6-9.4 33.9 0l136 136c9.5 9.4 9.5 24.6.1 34z"></path></svg></div></a></span>

<p class="info"><a href="https://github.com/junhyuk0801">JHSeo</a> JUL 31, 2022</p>

<div class="postContents"><!-- HTML_TAG_START --><br>
<p>본 글은 Golang을 공부하며 주요 내용이라 생각되는 것들을 기록해둔 자료이며, Ubuntu 20.04 LTS 기준으로 작성되었습니다.</p>
<p><br><br></p>
<h2>Functions</h2>
<hr>
<br>
<h3>Declaration and Invocation</h3>
<p>함수에는 파라미터들과 그 타입, 반환형의 타입을 명시한다. 파라미터의 타입은 변수 선언처럼 타입이 뒤에 온다.
파라미터와 함수 body 사이에 반환형이 위치한다.</p>
<pre><code class="hljs language-go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">div</span><span class="hljs-params">(numerator <span class="hljs-keyword">int</span>, denominator <span class="hljs-keyword">int</span>)</span> <span class="hljs-title">int</span></span> { <span class="hljs-comment">// parameters and each type of this, and the return type specified here</span>
	<span class="hljs-comment">// if there is no return type specified (as like main function), no return statement is needed in the function body.</span>
	<span class="hljs-keyword">if</span> denominator == <span class="hljs-number">0</span> {
		<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>
	}
	<span class="hljs-keyword">return</span> numerator / denominator
}

<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> {
	res := div(<span class="hljs-number">8</span>, <span class="hljs-number">5</span>)
	fmt.Println(res)
}
</code></pre>
<p>파라미터들의 타입이 중복되면 생략할 수 있다. 위 함수의 선언 부분을 <code>func div(numerator denominator int) int {</code>로 대체하여도 동일하게 동작한다.</p>
<p><br><br></p>
<h3>Emulating Named Parameters using Struct</h3>
<p>Go는 named parameter나, parameter의 default value를 지원하지 않는다(Optional parameter가 없다).
다시 말해, 함수가 있으면 그 함수의 모든 파라미터를 넘겨줘야 한다.</p>
<p>named parameter는 함수의 파라미터가 많을 때 유용하기 때문에, <code>struct</code>로 이를 대체할 수는 있다.
다만 애초에 함수의 파라미터가 많은 게 그리 이상적인 상황은 아니긴 하다.
아래의 코드는 <code>struct</code></p>
<pre><code class="hljs language-go"><span class="hljs-keyword">type</span> MyFuncOpts <span class="hljs-keyword">struct</span> {
	FirstName <span class="hljs-keyword">string</span>
	LastName  <span class="hljs-keyword">string</span>
	Age       <span class="hljs-keyword">int</span>
}

<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">MyFunc</span><span class="hljs-params">(opts MyFuncOpts)</span> <span class="hljs-title">string</span></span> {
	<span class="hljs-keyword">return</span> opts.FirstName + <span class="hljs-string">" "</span> + opts.LastName + <span class="hljs-string">"/"</span> + strconv.Itoa(opts.Age)
}
</code></pre>
<p><br><br></p>
<h3>Variadic Parameter</h3>
<p>파라미터의 타입 앞에 <code>...</code>를 붙여 variadic parameter로 만들 수 있다. Python의 *args랑 비슷하다.</p>
<pre><code class="hljs language-go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">addTo</span><span class="hljs-params">(base <span class="hljs-keyword">int</span>, vals ...<span class="hljs-keyword">int</span>)</span> <span class="hljs-title">int</span></span> { <span class="hljs-comment">// put three dots(...) before type to declare a parameter as variadic</span>
	<span class="hljs-keyword">var</span> res <span class="hljs-keyword">int</span>
	<span class="hljs-keyword">for</span> _, v := <span class="hljs-keyword">range</span> vals {
		res += v
	}
	<span class="hljs-keyword">return</span> res
}

<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> {
	addVal1 := addTo(<span class="hljs-number">1</span>, <span class="hljs-number">2</span>, <span class="hljs-number">3</span>, <span class="hljs-number">4</span>, <span class="hljs-number">5</span>)            <span class="hljs-comment">// we can pass parameters as multiple parameters</span>
	addVal2 := addTo(<span class="hljs-number">2</span>, []<span class="hljs-keyword">int</span>{<span class="hljs-number">4</span>, <span class="hljs-number">6</span>, <span class="hljs-number">8</span>, <span class="hljs-number">10</span>}...) <span class="hljs-comment">// we can pass parameters as slice, but must put three dots(...) after slice.</span>
	fmt.Println(addVal1, addVal2)
}
</code></pre>
<p>Slice의 뒤에 <code>...</code>를 붙여, variadic parameter와 대응시킬 수도 있다.</p>
<p><br><br></p>
<h3>Multiple Return Values</h3>
<p>Go의 특이한 점은 함수가 반환할 수 있는 값이 여러 개 존재한다는 것이다.
<code>Tuple</code>형으로 값을 반환하는 Python과 그나마 유사한데, 사실 이것도 <code>Tuple</code>로 묶어서 보내는 거라 엄연히 다르다.</p>
<p>반환 값을 여러개 설정하려면 반환형을 써야 할 위치에 반환형들을 순서대로 나열한 뒤 소괄호로 묶으면 된다.
<code>return</code>할 때 괄호로 묶어줄 필요는 없다.</p>
<pre><code class="hljs language-go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">divAndRemainder</span><span class="hljs-params">(numerator <span class="hljs-keyword">int</span>, denomiator <span class="hljs-keyword">int</span>)</span> <span class="hljs-params">(<span class="hljs-keyword">int</span>, <span class="hljs-keyword">int</span>, error)</span></span> {
	<span class="hljs-keyword">if</span> denomiator == <span class="hljs-number">0</span> {
		<span class="hljs-keyword">return</span> <span class="hljs-number">0</span>, <span class="hljs-number">0</span>, errors.New(<span class="hljs-string">"cannot divide by zero"</span>)
	} <span class="hljs-keyword">else</span> {
		<span class="hljs-keyword">return</span> numerator / denomiator, numerator % denomiator, <span class="hljs-literal">nil</span> <span class="hljs-comment">// must return all of return values, without parantheses</span>
		<span class="hljs-comment">// if there is no error, just return nil for error.</span>
	}
}

<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> {
	result1, remainder1, err1 := divAndRemainder(<span class="hljs-number">5</span>, <span class="hljs-number">2</span>) <span class="hljs-comment">// if we try assigning multiple return values into a single variable, there will be a compile-time error</span>
	result2, _, err2 := divAndRemainder_Named(<span class="hljs-number">5</span>, <span class="hljs-number">2</span>)    <span class="hljs-comment">// if we don't need to get remainder as variable, just using _, we can ignore it</span>
}
</code></pre>
<p>함수에서 반환된 값들을 변수에 저장할 때는 <code>range</code>를 쓸 때와 유사하게, 컴마(<code>,</code>)로 구분하여 순서대로 변수을 나열하면 된다.<br>
언더바(<code>_</code>)를 사용하면 저장할 필요 없는 변수는 생략할 수 있다. 이 역시도 앞서 봤던 패턴이다.</p>
<p><br><br></p>
<h3>Named Return Values</h3>
<p>반환할 값들을 변수로 지정할 수 있는데, 이를 <strong>Named return value</strong>라 한다.
Named return value들은 기본적으로 Zero value로 초기화된다.
또한 Named return value를 사용할 경우 반환할 값이 하나여도 소괄호로 둘러싸줘야 한다.</p>
<p>단, Named Return Value를 사용하면 두 가지 잠재적 문제점이 생길 수 있다.<br>
하나는 Named return value을 shadowing할 수도 있다는 문제이다.<br>
또 하나는 <code>return result, remainder, err</code> 대신에 <code>return 0, 0, errors.New("cannot divide by zero")</code> 이런 식으로
Named return value를 사용하지 않고 <code>return</code>하여도 문제가 없다.
이 때문에 코드가 일관적으로 작성되지 않을 수도 있다는 점이다.</p>
<pre><code class="hljs language-go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">divAndRemainder_Named</span><span class="hljs-params">(numerator <span class="hljs-keyword">int</span>, denomiator <span class="hljs-keyword">int</span>)</span> <span class="hljs-params">(result <span class="hljs-keyword">int</span>, remainder <span class="hljs-keyword">int</span>, err error)</span></span> {
	<span class="hljs-keyword">if</span> denomiator == <span class="hljs-number">0</span> {
		err = errors.New(<span class="hljs-string">"cannot divide by zero"</span>)
		<span class="hljs-keyword">return</span> result, remainder, err
		<span class="hljs-comment">// return 0, 0, errors.New("cannot divide by zero") // this statement is also legal. it is not essential to use name of return value</span>
	} <span class="hljs-keyword">else</span> {
		result = numerator / denomiator
		remainder = numerator % denomiator
		<span class="hljs-keyword">return</span> result, remainder, err
		<span class="hljs-comment">// return // blank return can reduce amount of typing, but it is less readable.</span>
	}
}
</code></pre>
<p>Named Return Value를 사용하면 <strong>Blank return</strong>이란 것이 가능한데,
<code>return result, remainder, err</code> 대신 <code>return</code>만 적어도 <code>result, remainder, err</code>가 반환된다.
Named return value가 명시된 순서대로 반환하는 것이다.</p>
<p><br><br></p>
<h3>Functions Are Value</h3>
<p>다른 많은 언어에서 그러하듯, Go에서 함수는 값으로 여겨진다. 다시 말해 변수에 집어넣거나 할 수 있다.</p>
<pre><code class="hljs language-go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">add</span><span class="hljs-params">(i <span class="hljs-keyword">int</span>, j <span class="hljs-keyword">int</span>)</span> <span class="hljs-title">int</span></span> { <span class="hljs-keyword">return</span> i + j }
<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">sub</span><span class="hljs-params">(i <span class="hljs-keyword">int</span>, j <span class="hljs-keyword">int</span>)</span> <span class="hljs-title">int</span></span> { <span class="hljs-keyword">return</span> i - j }
<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">mul</span><span class="hljs-params">(i <span class="hljs-keyword">int</span>, j <span class="hljs-keyword">int</span>)</span> <span class="hljs-title">int</span></span> { <span class="hljs-keyword">return</span> i * j }
<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">div</span><span class="hljs-params">(i <span class="hljs-keyword">int</span>, j <span class="hljs-keyword">int</span>)</span> <span class="hljs-title">int</span></span> { <span class="hljs-keyword">return</span> i / j }

<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> {
	<span class="hljs-keyword">var</span> opMap = <span class="hljs-keyword">map</span>[<span class="hljs-keyword">string</span>]<span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(<span class="hljs-keyword">int</span>, <span class="hljs-keyword">int</span>)</span> <span class="hljs-title">int</span></span>{
		<span class="hljs-string">"+"</span>: add,
		<span class="hljs-string">"-"</span>: sub,
		<span class="hljs-string">"*"</span>: mul,
		<span class="hljs-string">"/"</span>: div,
	}
}
</code></pre>
<p>예제는 4개의 함수를 <code>map</code>의 값으로 집어넣은 예제이다. 이 때 map의 value 타입은 <code>func(int, int), int</code>가 된다.</p>
<p>아래 예제처럼 <code>type</code> 키워드를 사용하여 타입을 간략화할 수도 있다.</p>
<pre><code class="hljs language-go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">add</span><span class="hljs-params">(i <span class="hljs-keyword">int</span>, j <span class="hljs-keyword">int</span>)</span> <span class="hljs-title">int</span></span> { <span class="hljs-keyword">return</span> i + j }
<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">sub</span><span class="hljs-params">(i <span class="hljs-keyword">int</span>, j <span class="hljs-keyword">int</span>)</span> <span class="hljs-title">int</span></span> { <span class="hljs-keyword">return</span> i - j }
<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">mul</span><span class="hljs-params">(i <span class="hljs-keyword">int</span>, j <span class="hljs-keyword">int</span>)</span> <span class="hljs-title">int</span></span> { <span class="hljs-keyword">return</span> i * j }
<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">div</span><span class="hljs-params">(i <span class="hljs-keyword">int</span>, j <span class="hljs-keyword">int</span>)</span> <span class="hljs-title">int</span></span> { <span class="hljs-keyword">return</span> i / j }

<span class="hljs-keyword">type</span> opFuncType <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(<span class="hljs-keyword">int</span>, <span class="hljs-keyword">int</span>)</span> <span class="hljs-title">int</span></span>

<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> {
	<span class="hljs-keyword">var</span> opMap = <span class="hljs-keyword">map</span>[<span class="hljs-keyword">string</span>]opFuncType{
		<span class="hljs-string">"+"</span>: add,
		<span class="hljs-string">"-"</span>: sub,
		<span class="hljs-string">"*"</span>: mul,
		<span class="hljs-string">"/"</span>: div,
	}
}
</code></pre>
<p><br><br></p>
<h3>Anonymous Function</h3>
<p>함수를 선언할 때 함수명만 지우면 익명함수가 된다. 익명함수를 즉시 호출하려면 익명함수 뒤에 소괄호를 붙여 파라미터만 보내주면 된다.</p>
<pre><code class="hljs language-go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> {
	pow := <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(num <span class="hljs-keyword">int</span>)</span> <span class="hljs-title">int</span></span> { <span class="hljs-comment">// using keyword `func`, we can declare an anonyymous function</span>
		<span class="hljs-comment">// if we put a function name on anonymous function, it will occur a compile-time error</span>
		<span class="hljs-keyword">return</span> num * num
	}

	<span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &#x3C; <span class="hljs-number">5</span>; i++ {
		<span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(j <span class="hljs-keyword">int</span>)</span></span> {
			fmt.Println(<span class="hljs-string">"Printing"</span>, pow(j), <span class="hljs-string">"from inside of an anonymous function"</span>)
		}(i) <span class="hljs-comment">// anonymous function are declared and called immediately</span>
	}
}
</code></pre>
<p><br><br></p>
<h2>Closure</h2>
<hr>
<p><strong>Closure</strong>란 특정한 함수 안에서 선언된 함수를 의미한다. 대체로 파라미터로 넘겨지거나, <code>return</code>을 통해 반환된다.</p>
<br>
<p><code>sort.Slice()</code>함수는 파라미터로 정렬할 데이터와 원소들의 대소를 비교하여 <code>bool</code>값을 반환하는 함수를 인자로 받는다.
이 함수의 <code>true</code> 및 <code>false</code> 여부에 따라 Slice가 정렬된다.</p>
<pre><code class="hljs language-go"><span class="hljs-keyword">type</span> Person <span class="hljs-keyword">struct</span> {
	FirstName <span class="hljs-keyword">string</span>
	LastName  <span class="hljs-keyword">string</span>
	Age       <span class="hljs-keyword">int</span>
}

people := []Person{
	{<span class="hljs-string">"Kimkim"</span>, <span class="hljs-string">"Kim"</span>, <span class="hljs-number">25</span>},
	{<span class="hljs-string">"Junhyuk"</span>, <span class="hljs-string">"Seo"</span>, <span class="hljs-number">24</span>},
	{<span class="hljs-string">"Leelee"</span>, <span class="hljs-string">"Lee"</span>, <span class="hljs-number">26</span>},
}

<span class="hljs-comment">// we can pass functions as parameter in Go</span>
sort.Slice(people, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(i <span class="hljs-keyword">int</span>, j <span class="hljs-keyword">int</span>)</span> <span class="hljs-title">bool</span></span> { <span class="hljs-comment">// sort.Slice sorts the slice using function that is passed in</span>
	<span class="hljs-keyword">return</span> people[i].Age &#x3C; people[j].Age <span class="hljs-comment">// sorting by Age field</span>
})
fmt.Println(people)

sort.Slice(people, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(i <span class="hljs-keyword">int</span>, j <span class="hljs-keyword">int</span>)</span> <span class="hljs-title">bool</span></span> {
	<span class="hljs-keyword">return</span> people[i].LastName &#x3C; people[j].LastName
})
fmt.Println(people)
</code></pre>
<p>ㅇㅇ</p>
<br>
<pre><code class="hljs language-go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">makeMult</span><span class="hljs-params">(base <span class="hljs-keyword">int</span>)</span> <span class="hljs-title">func</span><span class="hljs-params">(<span class="hljs-keyword">int</span>)</span> <span class="hljs-title">int</span></span> {
	<span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(factor <span class="hljs-keyword">int</span>)</span> <span class="hljs-title">int</span></span> {
		<span class="hljs-keyword">return</span> base * factor
	}
}

<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> {
	twoBase := makeMult(<span class="hljs-number">2</span>)
	threeBase := makeMult(<span class="hljs-number">3</span>)

	<span class="hljs-keyword">for</span> i := <span class="hljs-number">0</span>; i &#x3C; <span class="hljs-number">3</span>; i++ {
		fmt.Println(twoBase(i), threeBase(i))
	}
}
</code></pre>
<p>위 예제는 함수의 반환형이 Closure인 예제이다. 익명 함수로 반환되었다.</p>
<p><br><br></p>
<h2>defer</h2>
<hr>
<p>Go에는 <strong>defer</strong>라는 키워드가 존재한다. 다른 언어에는 없는데 Go에만 있는 것 같다.<br>
일반적으로 파일이나 네트워크 연결 등, 임시적으로 쓰이는 자원들을 다시 반납하기 위해 사용되는 것 같다.</p>
<pre><code class="hljs language-go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">getFile</span><span class="hljs-params">(name <span class="hljs-keyword">string</span>)</span> <span class="hljs-params">(*os.File, <span class="hljs-keyword">func</span>()</span>, <span class="hljs-title">error</span>)</span> {
	file, err := os.Open(name)
	<span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> {
		<span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>, <span class="hljs-literal">nil</span>, err
	} <span class="hljs-keyword">else</span> { <span class="hljs-comment">// it returns resource and a closure that cleans up the resource</span>
		<span class="hljs-keyword">return</span> file, <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> { file.Close() }, <span class="hljs-literal">nil</span>
	}
}

<span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> {
	_, closer, err := getFile(os.Args[<span class="hljs-number">1</span>])
	<span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> {
		log.Fatal(err)
	}
	<span class="hljs-keyword">defer</span> closer() <span class="hljs-comment">// releases the resource by using defer and closer function</span>
}
</code></pre>
<br>
<p><code>defer</code> 키워드가 쓰인 <em>Closure</em>는 값을 <code>return</code>한 후 해당 함수가 끝나기 직전 실행된다.</p>
<pre><code class="hljs language-go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span> {
	j := <span class="hljs-number">2</span>

	<span class="hljs-keyword">defer</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">(i <span class="hljs-keyword">int</span>)</span></span> {
		fmt.Println(i)
	}(j)

	j++
	fmt.Println(j)
}
</code></pre>
<p>위 코드의 실행 결과는 다음과 같다.</p>
<pre><code class="hljs language-go"><span class="hljs-number">3</span>
<span class="hljs-number">2</span>
</code></pre>
<p>먼저 <code>defer</code>에 의해 <code>2</code>를 출력하도록 예약된다. 이후 <code>j</code>가 <code>3</code>이 되어 출력이 되고, <code>main</code>함수가 끝나기 직전에 2가 출력되는 것이다.<br>
<code>j</code>값이 <code>3</code>으로 변했다고 <code>defer</code>에 의해 실행되는 <em>Closure</em>의 출력 결과가 3으로 바뀌지 않는다.</p>
<br>
<pre><code class="hljs language-go"><span class="hljs-function"><span class="hljs-keyword">func</span> <span class="hljs-title">DoSomeInserts</span><span class="hljs-params">(ctx context.Context, db *sql.DB, value1, value2 <span class="hljs-keyword">string</span>)</span></span>
                  (err error) {
    tx, err := db.BeginTx(ctx, <span class="hljs-literal">nil</span>)
    <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> {
        <span class="hljs-keyword">return</span> err
    }
    <span class="hljs-keyword">defer</span> <span class="hljs-function"><span class="hljs-keyword">func</span><span class="hljs-params">()</span></span> {
        <span class="hljs-keyword">if</span> err == <span class="hljs-literal">nil</span> {
            err = tx.Commit()
        }
        <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> {
            tx.Rollback()
        }
    }()
    _, err = tx.ExecContext(ctx, <span class="hljs-string">"INSERT INTO FOO (val) values $1"</span>, value1)
    <span class="hljs-keyword">if</span> err != <span class="hljs-literal">nil</span> {
        <span class="hljs-keyword">return</span> err
    }
    <span class="hljs-comment">// use tx to do more database inserts here</span>
    <span class="hljs-keyword">return</span> <span class="hljs-literal">nil</span>
}
</code></pre>
<p>위 예제는 <code>defer</code>가 DB write에 사용된 예제이다. db write 과정에서 에러가 발생하지 않았다면 <em>commit</em>, 에러가 발생하였다면 <em>rollback</em>한다.</p>
<p><br><br></p>
<h2>References</h2>
<hr>
<center>
<p><a href="https://learning.oreilly.com/library/view/learning-go/9781492077206/"><img src="https://learning.oreilly.com/covers/urn:orm:book:9781492077206/400w/" alt=""></a> <br>
<a href="https://learning.oreilly.com/library/view/learning-go/9781492077206/">Jon Bodner, 『Learning Go』, O'Reilly Media, Inc.</a></p>
</center>
<p><br><br></p><!-- HTML_TAG_END --></div>

</div>
    <footer class="site-footer svelte-174pa0l">© 2022 JHSeo. All rights reserved. <br><br></footer></div>
</div>


		<script type="module" data-sveltekit-hydrate="11dxen6">
		import { start } from "/_app/immutable/start-d3635e20.js";
		start({
			target: document.querySelector('[data-sveltekit-hydrate="11dxen6"]').parentNode,
			paths: {"base":"","assets":""},
			session: {},
			route: true,
			spa: false,
			trailing_slash: "never",
			hydrate: {
				status: 200,
				error: null,
				nodes: [0, 5],
				params: {mainCategory:"Golang",subCategory:"Golang Basics",slug:"GO5"},
				routeId: "posts/[mainCategory]/[subCategory]/[slug]"
			}
		});
	</script><script type="application/json" sveltekit:data-type="data" sveltekit:data-url="/posts/Golang/Golang Basics/GO5_json">{"status":200,"statusText":"","headers":{"content-type":"text/plain;charset=UTF-8"},"body":"{\"metadata\":{\"title\":\"함수\",\"date\":\"Jul 31, 2022\",\"excerpt\":\"Functions\"},\"content\":\"\u003Cbr>\\n\u003Cp>본 글은 Golang을 공부하며 주요 내용이라 생각되는 것들을 기록해둔 자료이며, Ubuntu 20.04 LTS 기준으로 작성되었습니다.\u003C/p>\\n\u003Cp>\u003Cbr>\u003Cbr>\u003C/p>\\n\u003Ch2>Functions\u003C/h2>\\n\u003Chr>\\n\u003Cbr>\\n\u003Ch3>Declaration and Invocation\u003C/h3>\\n\u003Cp>함수에는 파라미터들과 그 타입, 반환형의 타입을 명시한다. 파라미터의 타입은 변수 선언처럼 타입이 뒤에 온다.\\n파라미터와 함수 body 사이에 반환형이 위치한다.\u003C/p>\\n\u003Cpre>\u003Ccode class=\\\"hljs language-go\\\">\u003Cspan class=\\\"hljs-function\\\">\u003Cspan class=\\\"hljs-keyword\\\">func\u003C/span> \u003Cspan class=\\\"hljs-title\\\">div\u003C/span>\u003Cspan class=\\\"hljs-params\\\">(numerator \u003Cspan class=\\\"hljs-keyword\\\">int\u003C/span>, denominator \u003Cspan class=\\\"hljs-keyword\\\">int\u003C/span>)\u003C/span> \u003Cspan class=\\\"hljs-title\\\">int\u003C/span>\u003C/span> { \u003Cspan class=\\\"hljs-comment\\\">// parameters and each type of this, and the return type specified here\u003C/span>\\n\\t\u003Cspan class=\\\"hljs-comment\\\">// if there is no return type specified (as like main function), no return statement is needed in the function body.\u003C/span>\\n\\t\u003Cspan class=\\\"hljs-keyword\\\">if\u003C/span> denominator == \u003Cspan class=\\\"hljs-number\\\">0\u003C/span> {\\n\\t\\t\u003Cspan class=\\\"hljs-keyword\\\">return\u003C/span> \u003Cspan class=\\\"hljs-number\\\">0\u003C/span>\\n\\t}\\n\\t\u003Cspan class=\\\"hljs-keyword\\\">return\u003C/span> numerator / denominator\\n}\\n\\n\u003Cspan class=\\\"hljs-function\\\">\u003Cspan class=\\\"hljs-keyword\\\">func\u003C/span> \u003Cspan class=\\\"hljs-title\\\">main\u003C/span>\u003Cspan class=\\\"hljs-params\\\">()\u003C/span>\u003C/span> {\\n\\tres := div(\u003Cspan class=\\\"hljs-number\\\">8\u003C/span>, \u003Cspan class=\\\"hljs-number\\\">5\u003C/span>)\\n\\tfmt.Println(res)\\n}\\n\u003C/code>\u003C/pre>\\n\u003Cp>파라미터들의 타입이 중복되면 생략할 수 있다. 위 함수의 선언 부분을 \u003Ccode>func div(numerator denominator int) int {\u003C/code>로 대체하여도 동일하게 동작한다.\u003C/p>\\n\u003Cp>\u003Cbr>\u003Cbr>\u003C/p>\\n\u003Ch3>Emulating Named Parameters using Struct\u003C/h3>\\n\u003Cp>Go는 named parameter나, parameter의 default value를 지원하지 않는다(Optional parameter가 없다).\\n다시 말해, 함수가 있으면 그 함수의 모든 파라미터를 넘겨줘야 한다.\u003C/p>\\n\u003Cp>named parameter는 함수의 파라미터가 많을 때 유용하기 때문에, \u003Ccode>struct\u003C/code>로 이를 대체할 수는 있다.\\n다만 애초에 함수의 파라미터가 많은 게 그리 이상적인 상황은 아니긴 하다.\\n아래의 코드는 \u003Ccode>struct\u003C/code>\u003C/p>\\n\u003Cpre>\u003Ccode class=\\\"hljs language-go\\\">\u003Cspan class=\\\"hljs-keyword\\\">type\u003C/span> MyFuncOpts \u003Cspan class=\\\"hljs-keyword\\\">struct\u003C/span> {\\n\\tFirstName \u003Cspan class=\\\"hljs-keyword\\\">string\u003C/span>\\n\\tLastName  \u003Cspan class=\\\"hljs-keyword\\\">string\u003C/span>\\n\\tAge       \u003Cspan class=\\\"hljs-keyword\\\">int\u003C/span>\\n}\\n\\n\u003Cspan class=\\\"hljs-function\\\">\u003Cspan class=\\\"hljs-keyword\\\">func\u003C/span> \u003Cspan class=\\\"hljs-title\\\">MyFunc\u003C/span>\u003Cspan class=\\\"hljs-params\\\">(opts MyFuncOpts)\u003C/span> \u003Cspan class=\\\"hljs-title\\\">string\u003C/span>\u003C/span> {\\n\\t\u003Cspan class=\\\"hljs-keyword\\\">return\u003C/span> opts.FirstName + \u003Cspan class=\\\"hljs-string\\\">\\\" \\\"\u003C/span> + opts.LastName + \u003Cspan class=\\\"hljs-string\\\">\\\"/\\\"\u003C/span> + strconv.Itoa(opts.Age)\\n}\\n\u003C/code>\u003C/pre>\\n\u003Cp>\u003Cbr>\u003Cbr>\u003C/p>\\n\u003Ch3>Variadic Parameter\u003C/h3>\\n\u003Cp>파라미터의 타입 앞에 \u003Ccode>...\u003C/code>를 붙여 variadic parameter로 만들 수 있다. Python의 *args랑 비슷하다.\u003C/p>\\n\u003Cpre>\u003Ccode class=\\\"hljs language-go\\\">\u003Cspan class=\\\"hljs-function\\\">\u003Cspan class=\\\"hljs-keyword\\\">func\u003C/span> \u003Cspan class=\\\"hljs-title\\\">addTo\u003C/span>\u003Cspan class=\\\"hljs-params\\\">(base \u003Cspan class=\\\"hljs-keyword\\\">int\u003C/span>, vals ...\u003Cspan class=\\\"hljs-keyword\\\">int\u003C/span>)\u003C/span> \u003Cspan class=\\\"hljs-title\\\">int\u003C/span>\u003C/span> { \u003Cspan class=\\\"hljs-comment\\\">// put three dots(...) before type to declare a parameter as variadic\u003C/span>\\n\\t\u003Cspan class=\\\"hljs-keyword\\\">var\u003C/span> res \u003Cspan class=\\\"hljs-keyword\\\">int\u003C/span>\\n\\t\u003Cspan class=\\\"hljs-keyword\\\">for\u003C/span> _, v := \u003Cspan class=\\\"hljs-keyword\\\">range\u003C/span> vals {\\n\\t\\tres += v\\n\\t}\\n\\t\u003Cspan class=\\\"hljs-keyword\\\">return\u003C/span> res\\n}\\n\\n\u003Cspan class=\\\"hljs-function\\\">\u003Cspan class=\\\"hljs-keyword\\\">func\u003C/span> \u003Cspan class=\\\"hljs-title\\\">main\u003C/span>\u003Cspan class=\\\"hljs-params\\\">()\u003C/span>\u003C/span> {\\n\\taddVal1 := addTo(\u003Cspan class=\\\"hljs-number\\\">1\u003C/span>, \u003Cspan class=\\\"hljs-number\\\">2\u003C/span>, \u003Cspan class=\\\"hljs-number\\\">3\u003C/span>, \u003Cspan class=\\\"hljs-number\\\">4\u003C/span>, \u003Cspan class=\\\"hljs-number\\\">5\u003C/span>)            \u003Cspan class=\\\"hljs-comment\\\">// we can pass parameters as multiple parameters\u003C/span>\\n\\taddVal2 := addTo(\u003Cspan class=\\\"hljs-number\\\">2\u003C/span>, []\u003Cspan class=\\\"hljs-keyword\\\">int\u003C/span>{\u003Cspan class=\\\"hljs-number\\\">4\u003C/span>, \u003Cspan class=\\\"hljs-number\\\">6\u003C/span>, \u003Cspan class=\\\"hljs-number\\\">8\u003C/span>, \u003Cspan class=\\\"hljs-number\\\">10\u003C/span>}...) \u003Cspan class=\\\"hljs-comment\\\">// we can pass parameters as slice, but must put three dots(...) after slice.\u003C/span>\\n\\tfmt.Println(addVal1, addVal2)\\n}\\n\u003C/code>\u003C/pre>\\n\u003Cp>Slice의 뒤에 \u003Ccode>...\u003C/code>를 붙여, variadic parameter와 대응시킬 수도 있다.\u003C/p>\\n\u003Cp>\u003Cbr>\u003Cbr>\u003C/p>\\n\u003Ch3>Multiple Return Values\u003C/h3>\\n\u003Cp>Go의 특이한 점은 함수가 반환할 수 있는 값이 여러 개 존재한다는 것이다.\\n\u003Ccode>Tuple\u003C/code>형으로 값을 반환하는 Python과 그나마 유사한데, 사실 이것도 \u003Ccode>Tuple\u003C/code>로 묶어서 보내는 거라 엄연히 다르다.\u003C/p>\\n\u003Cp>반환 값을 여러개 설정하려면 반환형을 써야 할 위치에 반환형들을 순서대로 나열한 뒤 소괄호로 묶으면 된다.\\n\u003Ccode>return\u003C/code>할 때 괄호로 묶어줄 필요는 없다.\u003C/p>\\n\u003Cpre>\u003Ccode class=\\\"hljs language-go\\\">\u003Cspan class=\\\"hljs-function\\\">\u003Cspan class=\\\"hljs-keyword\\\">func\u003C/span> \u003Cspan class=\\\"hljs-title\\\">divAndRemainder\u003C/span>\u003Cspan class=\\\"hljs-params\\\">(numerator \u003Cspan class=\\\"hljs-keyword\\\">int\u003C/span>, denomiator \u003Cspan class=\\\"hljs-keyword\\\">int\u003C/span>)\u003C/span> \u003Cspan class=\\\"hljs-params\\\">(\u003Cspan class=\\\"hljs-keyword\\\">int\u003C/span>, \u003Cspan class=\\\"hljs-keyword\\\">int\u003C/span>, error)\u003C/span>\u003C/span> {\\n\\t\u003Cspan class=\\\"hljs-keyword\\\">if\u003C/span> denomiator == \u003Cspan class=\\\"hljs-number\\\">0\u003C/span> {\\n\\t\\t\u003Cspan class=\\\"hljs-keyword\\\">return\u003C/span> \u003Cspan class=\\\"hljs-number\\\">0\u003C/span>, \u003Cspan class=\\\"hljs-number\\\">0\u003C/span>, errors.New(\u003Cspan class=\\\"hljs-string\\\">\\\"cannot divide by zero\\\"\u003C/span>)\\n\\t} \u003Cspan class=\\\"hljs-keyword\\\">else\u003C/span> {\\n\\t\\t\u003Cspan class=\\\"hljs-keyword\\\">return\u003C/span> numerator / denomiator, numerator % denomiator, \u003Cspan class=\\\"hljs-literal\\\">nil\u003C/span> \u003Cspan class=\\\"hljs-comment\\\">// must return all of return values, without parantheses\u003C/span>\\n\\t\\t\u003Cspan class=\\\"hljs-comment\\\">// if there is no error, just return nil for error.\u003C/span>\\n\\t}\\n}\\n\\n\u003Cspan class=\\\"hljs-function\\\">\u003Cspan class=\\\"hljs-keyword\\\">func\u003C/span> \u003Cspan class=\\\"hljs-title\\\">main\u003C/span>\u003Cspan class=\\\"hljs-params\\\">()\u003C/span>\u003C/span> {\\n\\tresult1, remainder1, err1 := divAndRemainder(\u003Cspan class=\\\"hljs-number\\\">5\u003C/span>, \u003Cspan class=\\\"hljs-number\\\">2\u003C/span>) \u003Cspan class=\\\"hljs-comment\\\">// if we try assigning multiple return values into a single variable, there will be a compile-time error\u003C/span>\\n\\tresult2, _, err2 := divAndRemainder_Named(\u003Cspan class=\\\"hljs-number\\\">5\u003C/span>, \u003Cspan class=\\\"hljs-number\\\">2\u003C/span>)    \u003Cspan class=\\\"hljs-comment\\\">// if we don't need to get remainder as variable, just using _, we can ignore it\u003C/span>\\n}\\n\u003C/code>\u003C/pre>\\n\u003Cp>함수에서 반환된 값들을 변수에 저장할 때는 \u003Ccode>range\u003C/code>를 쓸 때와 유사하게, 컴마(\u003Ccode>,\u003C/code>)로 구분하여 순서대로 변수을 나열하면 된다.\u003Cbr>\\n언더바(\u003Ccode>_\u003C/code>)를 사용하면 저장할 필요 없는 변수는 생략할 수 있다. 이 역시도 앞서 봤던 패턴이다.\u003C/p>\\n\u003Cp>\u003Cbr>\u003Cbr>\u003C/p>\\n\u003Ch3>Named Return Values\u003C/h3>\\n\u003Cp>반환할 값들을 변수로 지정할 수 있는데, 이를 \u003Cstrong>Named return value\u003C/strong>라 한다.\\nNamed return value들은 기본적으로 Zero value로 초기화된다.\\n또한 Named return value를 사용할 경우 반환할 값이 하나여도 소괄호로 둘러싸줘야 한다.\u003C/p>\\n\u003Cp>단, Named Return Value를 사용하면 두 가지 잠재적 문제점이 생길 수 있다.\u003Cbr>\\n하나는 Named return value을 shadowing할 수도 있다는 문제이다.\u003Cbr>\\n또 하나는 \u003Ccode>return result, remainder, err\u003C/code> 대신에 \u003Ccode>return 0, 0, errors.New(\\\"cannot divide by zero\\\")\u003C/code> 이런 식으로\\nNamed return value를 사용하지 않고 \u003Ccode>return\u003C/code>하여도 문제가 없다.\\n이 때문에 코드가 일관적으로 작성되지 않을 수도 있다는 점이다.\u003C/p>\\n\u003Cpre>\u003Ccode class=\\\"hljs language-go\\\">\u003Cspan class=\\\"hljs-function\\\">\u003Cspan class=\\\"hljs-keyword\\\">func\u003C/span> \u003Cspan class=\\\"hljs-title\\\">divAndRemainder_Named\u003C/span>\u003Cspan class=\\\"hljs-params\\\">(numerator \u003Cspan class=\\\"hljs-keyword\\\">int\u003C/span>, denomiator \u003Cspan class=\\\"hljs-keyword\\\">int\u003C/span>)\u003C/span> \u003Cspan class=\\\"hljs-params\\\">(result \u003Cspan class=\\\"hljs-keyword\\\">int\u003C/span>, remainder \u003Cspan class=\\\"hljs-keyword\\\">int\u003C/span>, err error)\u003C/span>\u003C/span> {\\n\\t\u003Cspan class=\\\"hljs-keyword\\\">if\u003C/span> denomiator == \u003Cspan class=\\\"hljs-number\\\">0\u003C/span> {\\n\\t\\terr = errors.New(\u003Cspan class=\\\"hljs-string\\\">\\\"cannot divide by zero\\\"\u003C/span>)\\n\\t\\t\u003Cspan class=\\\"hljs-keyword\\\">return\u003C/span> result, remainder, err\\n\\t\\t\u003Cspan class=\\\"hljs-comment\\\">// return 0, 0, errors.New(\\\"cannot divide by zero\\\") // this statement is also legal. it is not essential to use name of return value\u003C/span>\\n\\t} \u003Cspan class=\\\"hljs-keyword\\\">else\u003C/span> {\\n\\t\\tresult = numerator / denomiator\\n\\t\\tremainder = numerator % denomiator\\n\\t\\t\u003Cspan class=\\\"hljs-keyword\\\">return\u003C/span> result, remainder, err\\n\\t\\t\u003Cspan class=\\\"hljs-comment\\\">// return // blank return can reduce amount of typing, but it is less readable.\u003C/span>\\n\\t}\\n}\\n\u003C/code>\u003C/pre>\\n\u003Cp>Named Return Value를 사용하면 \u003Cstrong>Blank return\u003C/strong>이란 것이 가능한데,\\n\u003Ccode>return result, remainder, err\u003C/code> 대신 \u003Ccode>return\u003C/code>만 적어도 \u003Ccode>result, remainder, err\u003C/code>가 반환된다.\\nNamed return value가 명시된 순서대로 반환하는 것이다.\u003C/p>\\n\u003Cp>\u003Cbr>\u003Cbr>\u003C/p>\\n\u003Ch3>Functions Are Value\u003C/h3>\\n\u003Cp>다른 많은 언어에서 그러하듯, Go에서 함수는 값으로 여겨진다. 다시 말해 변수에 집어넣거나 할 수 있다.\u003C/p>\\n\u003Cpre>\u003Ccode class=\\\"hljs language-go\\\">\u003Cspan class=\\\"hljs-function\\\">\u003Cspan class=\\\"hljs-keyword\\\">func\u003C/span> \u003Cspan class=\\\"hljs-title\\\">add\u003C/span>\u003Cspan class=\\\"hljs-params\\\">(i \u003Cspan class=\\\"hljs-keyword\\\">int\u003C/span>, j \u003Cspan class=\\\"hljs-keyword\\\">int\u003C/span>)\u003C/span> \u003Cspan class=\\\"hljs-title\\\">int\u003C/span>\u003C/span> { \u003Cspan class=\\\"hljs-keyword\\\">return\u003C/span> i + j }\\n\u003Cspan class=\\\"hljs-function\\\">\u003Cspan class=\\\"hljs-keyword\\\">func\u003C/span> \u003Cspan class=\\\"hljs-title\\\">sub\u003C/span>\u003Cspan class=\\\"hljs-params\\\">(i \u003Cspan class=\\\"hljs-keyword\\\">int\u003C/span>, j \u003Cspan class=\\\"hljs-keyword\\\">int\u003C/span>)\u003C/span> \u003Cspan class=\\\"hljs-title\\\">int\u003C/span>\u003C/span> { \u003Cspan class=\\\"hljs-keyword\\\">return\u003C/span> i - j }\\n\u003Cspan class=\\\"hljs-function\\\">\u003Cspan class=\\\"hljs-keyword\\\">func\u003C/span> \u003Cspan class=\\\"hljs-title\\\">mul\u003C/span>\u003Cspan class=\\\"hljs-params\\\">(i \u003Cspan class=\\\"hljs-keyword\\\">int\u003C/span>, j \u003Cspan class=\\\"hljs-keyword\\\">int\u003C/span>)\u003C/span> \u003Cspan class=\\\"hljs-title\\\">int\u003C/span>\u003C/span> { \u003Cspan class=\\\"hljs-keyword\\\">return\u003C/span> i * j }\\n\u003Cspan class=\\\"hljs-function\\\">\u003Cspan class=\\\"hljs-keyword\\\">func\u003C/span> \u003Cspan class=\\\"hljs-title\\\">div\u003C/span>\u003Cspan class=\\\"hljs-params\\\">(i \u003Cspan class=\\\"hljs-keyword\\\">int\u003C/span>, j \u003Cspan class=\\\"hljs-keyword\\\">int\u003C/span>)\u003C/span> \u003Cspan class=\\\"hljs-title\\\">int\u003C/span>\u003C/span> { \u003Cspan class=\\\"hljs-keyword\\\">return\u003C/span> i / j }\\n\\n\u003Cspan class=\\\"hljs-function\\\">\u003Cspan class=\\\"hljs-keyword\\\">func\u003C/span> \u003Cspan class=\\\"hljs-title\\\">main\u003C/span>\u003Cspan class=\\\"hljs-params\\\">()\u003C/span>\u003C/span> {\\n\\t\u003Cspan class=\\\"hljs-keyword\\\">var\u003C/span> opMap = \u003Cspan class=\\\"hljs-keyword\\\">map\u003C/span>[\u003Cspan class=\\\"hljs-keyword\\\">string\u003C/span>]\u003Cspan class=\\\"hljs-function\\\">\u003Cspan class=\\\"hljs-keyword\\\">func\u003C/span>\u003Cspan class=\\\"hljs-params\\\">(\u003Cspan class=\\\"hljs-keyword\\\">int\u003C/span>, \u003Cspan class=\\\"hljs-keyword\\\">int\u003C/span>)\u003C/span> \u003Cspan class=\\\"hljs-title\\\">int\u003C/span>\u003C/span>{\\n\\t\\t\u003Cspan class=\\\"hljs-string\\\">\\\"+\\\"\u003C/span>: add,\\n\\t\\t\u003Cspan class=\\\"hljs-string\\\">\\\"-\\\"\u003C/span>: sub,\\n\\t\\t\u003Cspan class=\\\"hljs-string\\\">\\\"*\\\"\u003C/span>: mul,\\n\\t\\t\u003Cspan class=\\\"hljs-string\\\">\\\"/\\\"\u003C/span>: div,\\n\\t}\\n}\\n\u003C/code>\u003C/pre>\\n\u003Cp>예제는 4개의 함수를 \u003Ccode>map\u003C/code>의 값으로 집어넣은 예제이다. 이 때 map의 value 타입은 \u003Ccode>func(int, int), int\u003C/code>가 된다.\u003C/p>\\n\u003Cp>아래 예제처럼 \u003Ccode>type\u003C/code> 키워드를 사용하여 타입을 간략화할 수도 있다.\u003C/p>\\n\u003Cpre>\u003Ccode class=\\\"hljs language-go\\\">\u003Cspan class=\\\"hljs-function\\\">\u003Cspan class=\\\"hljs-keyword\\\">func\u003C/span> \u003Cspan class=\\\"hljs-title\\\">add\u003C/span>\u003Cspan class=\\\"hljs-params\\\">(i \u003Cspan class=\\\"hljs-keyword\\\">int\u003C/span>, j \u003Cspan class=\\\"hljs-keyword\\\">int\u003C/span>)\u003C/span> \u003Cspan class=\\\"hljs-title\\\">int\u003C/span>\u003C/span> { \u003Cspan class=\\\"hljs-keyword\\\">return\u003C/span> i + j }\\n\u003Cspan class=\\\"hljs-function\\\">\u003Cspan class=\\\"hljs-keyword\\\">func\u003C/span> \u003Cspan class=\\\"hljs-title\\\">sub\u003C/span>\u003Cspan class=\\\"hljs-params\\\">(i \u003Cspan class=\\\"hljs-keyword\\\">int\u003C/span>, j \u003Cspan class=\\\"hljs-keyword\\\">int\u003C/span>)\u003C/span> \u003Cspan class=\\\"hljs-title\\\">int\u003C/span>\u003C/span> { \u003Cspan class=\\\"hljs-keyword\\\">return\u003C/span> i - j }\\n\u003Cspan class=\\\"hljs-function\\\">\u003Cspan class=\\\"hljs-keyword\\\">func\u003C/span> \u003Cspan class=\\\"hljs-title\\\">mul\u003C/span>\u003Cspan class=\\\"hljs-params\\\">(i \u003Cspan class=\\\"hljs-keyword\\\">int\u003C/span>, j \u003Cspan class=\\\"hljs-keyword\\\">int\u003C/span>)\u003C/span> \u003Cspan class=\\\"hljs-title\\\">int\u003C/span>\u003C/span> { \u003Cspan class=\\\"hljs-keyword\\\">return\u003C/span> i * j }\\n\u003Cspan class=\\\"hljs-function\\\">\u003Cspan class=\\\"hljs-keyword\\\">func\u003C/span> \u003Cspan class=\\\"hljs-title\\\">div\u003C/span>\u003Cspan class=\\\"hljs-params\\\">(i \u003Cspan class=\\\"hljs-keyword\\\">int\u003C/span>, j \u003Cspan class=\\\"hljs-keyword\\\">int\u003C/span>)\u003C/span> \u003Cspan class=\\\"hljs-title\\\">int\u003C/span>\u003C/span> { \u003Cspan class=\\\"hljs-keyword\\\">return\u003C/span> i / j }\\n\\n\u003Cspan class=\\\"hljs-keyword\\\">type\u003C/span> opFuncType \u003Cspan class=\\\"hljs-function\\\">\u003Cspan class=\\\"hljs-keyword\\\">func\u003C/span>\u003Cspan class=\\\"hljs-params\\\">(\u003Cspan class=\\\"hljs-keyword\\\">int\u003C/span>, \u003Cspan class=\\\"hljs-keyword\\\">int\u003C/span>)\u003C/span> \u003Cspan class=\\\"hljs-title\\\">int\u003C/span>\u003C/span>\\n\\n\u003Cspan class=\\\"hljs-function\\\">\u003Cspan class=\\\"hljs-keyword\\\">func\u003C/span> \u003Cspan class=\\\"hljs-title\\\">main\u003C/span>\u003Cspan class=\\\"hljs-params\\\">()\u003C/span>\u003C/span> {\\n\\t\u003Cspan class=\\\"hljs-keyword\\\">var\u003C/span> opMap = \u003Cspan class=\\\"hljs-keyword\\\">map\u003C/span>[\u003Cspan class=\\\"hljs-keyword\\\">string\u003C/span>]opFuncType{\\n\\t\\t\u003Cspan class=\\\"hljs-string\\\">\\\"+\\\"\u003C/span>: add,\\n\\t\\t\u003Cspan class=\\\"hljs-string\\\">\\\"-\\\"\u003C/span>: sub,\\n\\t\\t\u003Cspan class=\\\"hljs-string\\\">\\\"*\\\"\u003C/span>: mul,\\n\\t\\t\u003Cspan class=\\\"hljs-string\\\">\\\"/\\\"\u003C/span>: div,\\n\\t}\\n}\\n\u003C/code>\u003C/pre>\\n\u003Cp>\u003Cbr>\u003Cbr>\u003C/p>\\n\u003Ch3>Anonymous Function\u003C/h3>\\n\u003Cp>함수를 선언할 때 함수명만 지우면 익명함수가 된다. 익명함수를 즉시 호출하려면 익명함수 뒤에 소괄호를 붙여 파라미터만 보내주면 된다.\u003C/p>\\n\u003Cpre>\u003Ccode class=\\\"hljs language-go\\\">\u003Cspan class=\\\"hljs-function\\\">\u003Cspan class=\\\"hljs-keyword\\\">func\u003C/span> \u003Cspan class=\\\"hljs-title\\\">main\u003C/span>\u003Cspan class=\\\"hljs-params\\\">()\u003C/span>\u003C/span> {\\n\\tpow := \u003Cspan class=\\\"hljs-function\\\">\u003Cspan class=\\\"hljs-keyword\\\">func\u003C/span>\u003Cspan class=\\\"hljs-params\\\">(num \u003Cspan class=\\\"hljs-keyword\\\">int\u003C/span>)\u003C/span> \u003Cspan class=\\\"hljs-title\\\">int\u003C/span>\u003C/span> { \u003Cspan class=\\\"hljs-comment\\\">// using keyword `func`, we can declare an anonyymous function\u003C/span>\\n\\t\\t\u003Cspan class=\\\"hljs-comment\\\">// if we put a function name on anonymous function, it will occur a compile-time error\u003C/span>\\n\\t\\t\u003Cspan class=\\\"hljs-keyword\\\">return\u003C/span> num * num\\n\\t}\\n\\n\\t\u003Cspan class=\\\"hljs-keyword\\\">for\u003C/span> i := \u003Cspan class=\\\"hljs-number\\\">0\u003C/span>; i &#x3C; \u003Cspan class=\\\"hljs-number\\\">5\u003C/span>; i++ {\\n\\t\\t\u003Cspan class=\\\"hljs-function\\\">\u003Cspan class=\\\"hljs-keyword\\\">func\u003C/span>\u003Cspan class=\\\"hljs-params\\\">(j \u003Cspan class=\\\"hljs-keyword\\\">int\u003C/span>)\u003C/span>\u003C/span> {\\n\\t\\t\\tfmt.Println(\u003Cspan class=\\\"hljs-string\\\">\\\"Printing\\\"\u003C/span>, pow(j), \u003Cspan class=\\\"hljs-string\\\">\\\"from inside of an anonymous function\\\"\u003C/span>)\\n\\t\\t}(i) \u003Cspan class=\\\"hljs-comment\\\">// anonymous function are declared and called immediately\u003C/span>\\n\\t}\\n}\\n\u003C/code>\u003C/pre>\\n\u003Cp>\u003Cbr>\u003Cbr>\u003C/p>\\n\u003Ch2>Closure\u003C/h2>\\n\u003Chr>\\n\u003Cp>\u003Cstrong>Closure\u003C/strong>란 특정한 함수 안에서 선언된 함수를 의미한다. 대체로 파라미터로 넘겨지거나, \u003Ccode>return\u003C/code>을 통해 반환된다.\u003C/p>\\n\u003Cbr>\\n\u003Cp>\u003Ccode>sort.Slice()\u003C/code>함수는 파라미터로 정렬할 데이터와 원소들의 대소를 비교하여 \u003Ccode>bool\u003C/code>값을 반환하는 함수를 인자로 받는다.\\n이 함수의 \u003Ccode>true\u003C/code> 및 \u003Ccode>false\u003C/code> 여부에 따라 Slice가 정렬된다.\u003C/p>\\n\u003Cpre>\u003Ccode class=\\\"hljs language-go\\\">\u003Cspan class=\\\"hljs-keyword\\\">type\u003C/span> Person \u003Cspan class=\\\"hljs-keyword\\\">struct\u003C/span> {\\n\\tFirstName \u003Cspan class=\\\"hljs-keyword\\\">string\u003C/span>\\n\\tLastName  \u003Cspan class=\\\"hljs-keyword\\\">string\u003C/span>\\n\\tAge       \u003Cspan class=\\\"hljs-keyword\\\">int\u003C/span>\\n}\\n\\npeople := []Person{\\n\\t{\u003Cspan class=\\\"hljs-string\\\">\\\"Kimkim\\\"\u003C/span>, \u003Cspan class=\\\"hljs-string\\\">\\\"Kim\\\"\u003C/span>, \u003Cspan class=\\\"hljs-number\\\">25\u003C/span>},\\n\\t{\u003Cspan class=\\\"hljs-string\\\">\\\"Junhyuk\\\"\u003C/span>, \u003Cspan class=\\\"hljs-string\\\">\\\"Seo\\\"\u003C/span>, \u003Cspan class=\\\"hljs-number\\\">24\u003C/span>},\\n\\t{\u003Cspan class=\\\"hljs-string\\\">\\\"Leelee\\\"\u003C/span>, \u003Cspan class=\\\"hljs-string\\\">\\\"Lee\\\"\u003C/span>, \u003Cspan class=\\\"hljs-number\\\">26\u003C/span>},\\n}\\n\\n\u003Cspan class=\\\"hljs-comment\\\">// we can pass functions as parameter in Go\u003C/span>\\nsort.Slice(people, \u003Cspan class=\\\"hljs-function\\\">\u003Cspan class=\\\"hljs-keyword\\\">func\u003C/span>\u003Cspan class=\\\"hljs-params\\\">(i \u003Cspan class=\\\"hljs-keyword\\\">int\u003C/span>, j \u003Cspan class=\\\"hljs-keyword\\\">int\u003C/span>)\u003C/span> \u003Cspan class=\\\"hljs-title\\\">bool\u003C/span>\u003C/span> { \u003Cspan class=\\\"hljs-comment\\\">// sort.Slice sorts the slice using function that is passed in\u003C/span>\\n\\t\u003Cspan class=\\\"hljs-keyword\\\">return\u003C/span> people[i].Age &#x3C; people[j].Age \u003Cspan class=\\\"hljs-comment\\\">// sorting by Age field\u003C/span>\\n})\\nfmt.Println(people)\\n\\nsort.Slice(people, \u003Cspan class=\\\"hljs-function\\\">\u003Cspan class=\\\"hljs-keyword\\\">func\u003C/span>\u003Cspan class=\\\"hljs-params\\\">(i \u003Cspan class=\\\"hljs-keyword\\\">int\u003C/span>, j \u003Cspan class=\\\"hljs-keyword\\\">int\u003C/span>)\u003C/span> \u003Cspan class=\\\"hljs-title\\\">bool\u003C/span>\u003C/span> {\\n\\t\u003Cspan class=\\\"hljs-keyword\\\">return\u003C/span> people[i].LastName &#x3C; people[j].LastName\\n})\\nfmt.Println(people)\\n\u003C/code>\u003C/pre>\\n\u003Cp>ㅇㅇ\u003C/p>\\n\u003Cbr>\\n\u003Cpre>\u003Ccode class=\\\"hljs language-go\\\">\u003Cspan class=\\\"hljs-function\\\">\u003Cspan class=\\\"hljs-keyword\\\">func\u003C/span> \u003Cspan class=\\\"hljs-title\\\">makeMult\u003C/span>\u003Cspan class=\\\"hljs-params\\\">(base \u003Cspan class=\\\"hljs-keyword\\\">int\u003C/span>)\u003C/span> \u003Cspan class=\\\"hljs-title\\\">func\u003C/span>\u003Cspan class=\\\"hljs-params\\\">(\u003Cspan class=\\\"hljs-keyword\\\">int\u003C/span>)\u003C/span> \u003Cspan class=\\\"hljs-title\\\">int\u003C/span>\u003C/span> {\\n\\t\u003Cspan class=\\\"hljs-keyword\\\">return\u003C/span> \u003Cspan class=\\\"hljs-function\\\">\u003Cspan class=\\\"hljs-keyword\\\">func\u003C/span>\u003Cspan class=\\\"hljs-params\\\">(factor \u003Cspan class=\\\"hljs-keyword\\\">int\u003C/span>)\u003C/span> \u003Cspan class=\\\"hljs-title\\\">int\u003C/span>\u003C/span> {\\n\\t\\t\u003Cspan class=\\\"hljs-keyword\\\">return\u003C/span> base * factor\\n\\t}\\n}\\n\\n\u003Cspan class=\\\"hljs-function\\\">\u003Cspan class=\\\"hljs-keyword\\\">func\u003C/span> \u003Cspan class=\\\"hljs-title\\\">main\u003C/span>\u003Cspan class=\\\"hljs-params\\\">()\u003C/span>\u003C/span> {\\n\\ttwoBase := makeMult(\u003Cspan class=\\\"hljs-number\\\">2\u003C/span>)\\n\\tthreeBase := makeMult(\u003Cspan class=\\\"hljs-number\\\">3\u003C/span>)\\n\\n\\t\u003Cspan class=\\\"hljs-keyword\\\">for\u003C/span> i := \u003Cspan class=\\\"hljs-number\\\">0\u003C/span>; i &#x3C; \u003Cspan class=\\\"hljs-number\\\">3\u003C/span>; i++ {\\n\\t\\tfmt.Println(twoBase(i), threeBase(i))\\n\\t}\\n}\\n\u003C/code>\u003C/pre>\\n\u003Cp>위 예제는 함수의 반환형이 Closure인 예제이다. 익명 함수로 반환되었다.\u003C/p>\\n\u003Cp>\u003Cbr>\u003Cbr>\u003C/p>\\n\u003Ch2>defer\u003C/h2>\\n\u003Chr>\\n\u003Cp>Go에는 \u003Cstrong>defer\u003C/strong>라는 키워드가 존재한다. 다른 언어에는 없는데 Go에만 있는 것 같다.\u003Cbr>\\n일반적으로 파일이나 네트워크 연결 등, 임시적으로 쓰이는 자원들을 다시 반납하기 위해 사용되는 것 같다.\u003C/p>\\n\u003Cpre>\u003Ccode class=\\\"hljs language-go\\\">\u003Cspan class=\\\"hljs-function\\\">\u003Cspan class=\\\"hljs-keyword\\\">func\u003C/span> \u003Cspan class=\\\"hljs-title\\\">getFile\u003C/span>\u003Cspan class=\\\"hljs-params\\\">(name \u003Cspan class=\\\"hljs-keyword\\\">string\u003C/span>)\u003C/span> \u003Cspan class=\\\"hljs-params\\\">(*os.File, \u003Cspan class=\\\"hljs-keyword\\\">func\u003C/span>()\u003C/span>, \u003Cspan class=\\\"hljs-title\\\">error\u003C/span>)\u003C/span> {\\n\\tfile, err := os.Open(name)\\n\\t\u003Cspan class=\\\"hljs-keyword\\\">if\u003C/span> err != \u003Cspan class=\\\"hljs-literal\\\">nil\u003C/span> {\\n\\t\\t\u003Cspan class=\\\"hljs-keyword\\\">return\u003C/span> \u003Cspan class=\\\"hljs-literal\\\">nil\u003C/span>, \u003Cspan class=\\\"hljs-literal\\\">nil\u003C/span>, err\\n\\t} \u003Cspan class=\\\"hljs-keyword\\\">else\u003C/span> { \u003Cspan class=\\\"hljs-comment\\\">// it returns resource and a closure that cleans up the resource\u003C/span>\\n\\t\\t\u003Cspan class=\\\"hljs-keyword\\\">return\u003C/span> file, \u003Cspan class=\\\"hljs-function\\\">\u003Cspan class=\\\"hljs-keyword\\\">func\u003C/span>\u003Cspan class=\\\"hljs-params\\\">()\u003C/span>\u003C/span> { file.Close() }, \u003Cspan class=\\\"hljs-literal\\\">nil\u003C/span>\\n\\t}\\n}\\n\\n\u003Cspan class=\\\"hljs-function\\\">\u003Cspan class=\\\"hljs-keyword\\\">func\u003C/span> \u003Cspan class=\\\"hljs-title\\\">main\u003C/span>\u003Cspan class=\\\"hljs-params\\\">()\u003C/span>\u003C/span> {\\n\\t_, closer, err := getFile(os.Args[\u003Cspan class=\\\"hljs-number\\\">1\u003C/span>])\\n\\t\u003Cspan class=\\\"hljs-keyword\\\">if\u003C/span> err != \u003Cspan class=\\\"hljs-literal\\\">nil\u003C/span> {\\n\\t\\tlog.Fatal(err)\\n\\t}\\n\\t\u003Cspan class=\\\"hljs-keyword\\\">defer\u003C/span> closer() \u003Cspan class=\\\"hljs-comment\\\">// releases the resource by using defer and closer function\u003C/span>\\n}\\n\u003C/code>\u003C/pre>\\n\u003Cbr>\\n\u003Cp>\u003Ccode>defer\u003C/code> 키워드가 쓰인 \u003Cem>Closure\u003C/em>는 값을 \u003Ccode>return\u003C/code>한 후 해당 함수가 끝나기 직전 실행된다.\u003C/p>\\n\u003Cpre>\u003Ccode class=\\\"hljs language-go\\\">\u003Cspan class=\\\"hljs-function\\\">\u003Cspan class=\\\"hljs-keyword\\\">func\u003C/span> \u003Cspan class=\\\"hljs-title\\\">main\u003C/span>\u003Cspan class=\\\"hljs-params\\\">()\u003C/span>\u003C/span> {\\n\\tj := \u003Cspan class=\\\"hljs-number\\\">2\u003C/span>\\n\\n\\t\u003Cspan class=\\\"hljs-keyword\\\">defer\u003C/span> \u003Cspan class=\\\"hljs-function\\\">\u003Cspan class=\\\"hljs-keyword\\\">func\u003C/span>\u003Cspan class=\\\"hljs-params\\\">(i \u003Cspan class=\\\"hljs-keyword\\\">int\u003C/span>)\u003C/span>\u003C/span> {\\n\\t\\tfmt.Println(i)\\n\\t}(j)\\n\\n\\tj++\\n\\tfmt.Println(j)\\n}\\n\u003C/code>\u003C/pre>\\n\u003Cp>위 코드의 실행 결과는 다음과 같다.\u003C/p>\\n\u003Cpre>\u003Ccode class=\\\"hljs language-go\\\">\u003Cspan class=\\\"hljs-number\\\">3\u003C/span>\\n\u003Cspan class=\\\"hljs-number\\\">2\u003C/span>\\n\u003C/code>\u003C/pre>\\n\u003Cp>먼저 \u003Ccode>defer\u003C/code>에 의해 \u003Ccode>2\u003C/code>를 출력하도록 예약된다. 이후 \u003Ccode>j\u003C/code>가 \u003Ccode>3\u003C/code>이 되어 출력이 되고, \u003Ccode>main\u003C/code>함수가 끝나기 직전에 2가 출력되는 것이다.\u003Cbr>\\n\u003Ccode>j\u003C/code>값이 \u003Ccode>3\u003C/code>으로 변했다고 \u003Ccode>defer\u003C/code>에 의해 실행되는 \u003Cem>Closure\u003C/em>의 출력 결과가 3으로 바뀌지 않는다.\u003C/p>\\n\u003Cbr>\\n\u003Cpre>\u003Ccode class=\\\"hljs language-go\\\">\u003Cspan class=\\\"hljs-function\\\">\u003Cspan class=\\\"hljs-keyword\\\">func\u003C/span> \u003Cspan class=\\\"hljs-title\\\">DoSomeInserts\u003C/span>\u003Cspan class=\\\"hljs-params\\\">(ctx context.Context, db *sql.DB, value1, value2 \u003Cspan class=\\\"hljs-keyword\\\">string\u003C/span>)\u003C/span>\u003C/span>\\n                  (err error) {\\n    tx, err := db.BeginTx(ctx, \u003Cspan class=\\\"hljs-literal\\\">nil\u003C/span>)\\n    \u003Cspan class=\\\"hljs-keyword\\\">if\u003C/span> err != \u003Cspan class=\\\"hljs-literal\\\">nil\u003C/span> {\\n        \u003Cspan class=\\\"hljs-keyword\\\">return\u003C/span> err\\n    }\\n    \u003Cspan class=\\\"hljs-keyword\\\">defer\u003C/span> \u003Cspan class=\\\"hljs-function\\\">\u003Cspan class=\\\"hljs-keyword\\\">func\u003C/span>\u003Cspan class=\\\"hljs-params\\\">()\u003C/span>\u003C/span> {\\n        \u003Cspan class=\\\"hljs-keyword\\\">if\u003C/span> err == \u003Cspan class=\\\"hljs-literal\\\">nil\u003C/span> {\\n            err = tx.Commit()\\n        }\\n        \u003Cspan class=\\\"hljs-keyword\\\">if\u003C/span> err != \u003Cspan class=\\\"hljs-literal\\\">nil\u003C/span> {\\n            tx.Rollback()\\n        }\\n    }()\\n    _, err = tx.ExecContext(ctx, \u003Cspan class=\\\"hljs-string\\\">\\\"INSERT INTO FOO (val) values $1\\\"\u003C/span>, value1)\\n    \u003Cspan class=\\\"hljs-keyword\\\">if\u003C/span> err != \u003Cspan class=\\\"hljs-literal\\\">nil\u003C/span> {\\n        \u003Cspan class=\\\"hljs-keyword\\\">return\u003C/span> err\\n    }\\n    \u003Cspan class=\\\"hljs-comment\\\">// use tx to do more database inserts here\u003C/span>\\n    \u003Cspan class=\\\"hljs-keyword\\\">return\u003C/span> \u003Cspan class=\\\"hljs-literal\\\">nil\u003C/span>\\n}\\n\u003C/code>\u003C/pre>\\n\u003Cp>위 예제는 \u003Ccode>defer\u003C/code>가 DB write에 사용된 예제이다. db write 과정에서 에러가 발생하지 않았다면 \u003Cem>commit\u003C/em>, 에러가 발생하였다면 \u003Cem>rollback\u003C/em>한다.\u003C/p>\\n\u003Cp>\u003Cbr>\u003Cbr>\u003C/p>\\n\u003Ch2>References\u003C/h2>\\n\u003Chr>\\n\u003Ccenter>\\n\u003Cp>\u003Ca href=\\\"https://learning.oreilly.com/library/view/learning-go/9781492077206/\\\">\u003Cimg src=\\\"https://learning.oreilly.com/covers/urn:orm:book:9781492077206/400w/\\\" alt=\\\"\\\">\u003C/a> \u003Cbr>\\n\u003Ca href=\\\"https://learning.oreilly.com/library/view/learning-go/9781492077206/\\\">Jon Bodner, 『Learning Go』, O'Reilly Media, Inc.\u003C/a>\u003C/p>\\n\u003C/center>\\n\u003Cp>\u003Cbr>\u003Cbr>\u003C/p>\",\"mainCategory\":\"Golang\",\"subCategory\":\"Golang Basics\"}"}</script></div>
    </body>
</html>
