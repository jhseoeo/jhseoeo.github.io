{"metadata":{"title":"에러 처리","date":"Aug 19, 2022","excerpt":"Errors"},"content":"<br>\n<p>본 글은 Golang을 공부하며 주요 내용이라 생각되는 것들을 기록해둔 자료이며, Ubuntu 22.04 LTS 기준으로 작성되었습니다.</p>\n<p><br><br></p>\n<h2>Errors</h2>\n<hr>\n<p>다른 언어를 쓰다가 Go를 배워보면, Go의 에러 핸들링은 상당히 낯설게 느껴진다고 한다.\n에러를 핸들링하는 Go의 접근 방식에 대해 알아보고, <code>panic</code>과 <code>recover</code>에 대해 알아보자.</p>\n<p>Go는 함수에서 <code>error</code> 타입의 값을 리턴함으로써, 에러를 핸들링한다.\n만약 함수가 정상적으로 잘 동작했다면 <code>error</code> 파라미터로 <code>nil</code>을 리턴한다. 반면 함수가 함수가 무언가 잘못되었다면, 에러 값이 리턴된다.\n그 함수를 호출한 함수는 에러 변수를 <code>nil</code>과 비교하여 에러 여부를 판단함으로써 핸들링한다. 만약 에러가 발생했다면 리턴된 에러 변수를 그대로 리턴한다.\n이런 방식이 굉장히 낡은 방식이라고 느낄 수는 있는데, 동시에 가장 강력한 방식이다.</p>\n<pre><code class=\"hljs language-go\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">calcRemainderAndMod</span><span class=\"hljs-params\">(numerator, denomiator <span class=\"hljs-keyword\">int</span>)</span> <span class=\"hljs-params\">(<span class=\"hljs-keyword\">int</span>, <span class=\"hljs-keyword\">int</span>, error)</span></span> {\n\t<span class=\"hljs-keyword\">if</span> denomiator == <span class=\"hljs-number\">0</span> {\n\t\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">0</span>, errors.New(<span class=\"hljs-string\">\"denimiator is 0\"</span>)\n\t}\n\t<span class=\"hljs-keyword\">return</span> numerator / denomiator, numerator % denomiator, <span class=\"hljs-literal\">nil</span>\n}\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span></span> {\n\tnumerator, denomiator := <span class=\"hljs-number\">20</span>, <span class=\"hljs-number\">3</span>\n\tremainder, mod, err := calcRemainderAndMod(numerator, denomiator)\n\t<span class=\"hljs-keyword\">if</span> err != <span class=\"hljs-literal\">nil</span> {\n\t\tfmt.Println(err)\n\t\tos.Exit(<span class=\"hljs-number\">1</span>)\n\t}\n\tfmt.Println(remainder, mod)\n}\n</code></pre>\n<p>만약 파라미터로 받은 분모가 0일 경우, <code>errors</code> 패키지의 <code>New()</code> 함수로 새로운 에러를 생성한다.\n에러의 알파벳 앞 글자는 대문자를 사용하지 않고(not capitalized), 마침표(<code>.</code>)를 사용하거나, 개행을 하지 않는 게 국룰이라고 한다.\n또한 에러가 발생했을 시, 대부분의 경우 다른 리턴값은 Zero value로 리턴한다.</p>\n<p>다른 언어의 예외 처리 방법과는 달리, Go에서 특별히 에러를 확인하는 문법은 없다.\nif문을 사용하여 에러 변수가 <code>nil</code>인지 확인하는 것이 유일한 방법이다.</p>\n<br>\n<p><code>error</code>는 내부적으로 이렇게 생겼다.</p>\n<pre><code class=\"hljs language-go\"><span class=\"hljs-keyword\">type</span> error <span class=\"hljs-keyword\">interface</span> {\n    Error() <span class=\"hljs-keyword\">string</span>\n}\n</code></pre>\n<p><code>Error()</code>라는 한 개의 메소드가 존재하는 인터페이스로, 이 인터페이스를 충족시키는 모든 타입들은 에러로 간주된다.\n또한 에러가 발생하지 않았을 때 <code>nil</code>을 리턴하는 이유는 <code>nil</code>이 인터페이스의 Zero Value이기 때문.</p>\n<br>\n<p>이렇듯 Go가 일반적인 <code>Try</code>-<code>Catch</code>-<code>Throw</code> 방식의 예외처리가 아니라 <code>error</code>를 리턴하여 처리하는 방식을 택한 이유가 있다.\n첫 번째로, exception을 사용하면 코드가 진행되는 흐름이 또 한개 더 생겨버리게 되며, 이런 흐름들은 불분명한 경우가 많다.\n만일 exception이 제대로 처리되지 않으면 crash가 발생할 수도 있으며, crash가 밣생하지 않았지만 데이터가 제대로 처리되지 않을 수도 있다.</p>\n<p>두 번째로, Go 컴파일러에서는 모든 변수가 반드시 한 번씩은 레퍼런스가 되어야 한다.\n그래서 <code>error</code>를 리턴값으로 받으면 언더스코어(<code>_</code>)를 사용하여 명시적으로 에러를 무시하는 게 아닌 이상, 반드시 에러를 체크해야 한다.\n이러한 반드시 에러를 체크해야 한다는 점 때문에 개발자들에게 좋은 버릇을 들이게 되는 것 같다.</p>\n<br>\n<p>Exception Handling의 방식은 코드 길이는 확연히 짧아질 수 있지만, 그것이 코드를 이해하거나 유지보수 하기 쉽다는 뜻은 아니다.\n반면 Go의 에러 처리 방식이 라인 수는 다소 길 지언정 이해하기는 쉽다.</p>\n<p>Go의 에러 핸들링은 <code>if</code>문 내부에서 인덴트되며, 나머지 비즈니스 로직은 인덴트 바깥에 있다.\n그래서 시각적으로도 에러 조건을 확인하기가 더 용이하다고 한다.</p>\n<p><br><br></p>\n<h3>Use Strings for Simple Errors</h3>\n<p>Go의 표준 라이브러리는 두 가지 방식으로 <code>string</code>을 통해 에러를 생성할 수 있다.\n한 가지 방식은 앞서 보았듯, <code>errors.New()</code> 함수를 사용하는 것이다. <code>errors.New()</code>는 파라미터로 <code>string</code>을 받고 <code>error</code>를 리턴한다.\n이 때 보낸 <code>string</code>은 나중에 <code>fmt.Println()</code> 등으로 <code>error</code>를 출력할 때 <code>Error()</code> 메소드를 출력하면서 반환된다.</p>\n<pre><code class=\"hljs language-go\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">doubleEven1</span><span class=\"hljs-params\">(i <span class=\"hljs-keyword\">int</span>)</span> <span class=\"hljs-params\">(<span class=\"hljs-keyword\">int</span>, error)</span></span> {\n\t<span class=\"hljs-keyword\">if</span> i%<span class=\"hljs-number\">2</span> != <span class=\"hljs-number\">0</span> {\n\t\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>, errors.New(<span class=\"hljs-string\">\"only even numbers are processed\"</span>)\n\t}\n\t<span class=\"hljs-keyword\">return</span> i * <span class=\"hljs-number\">2</span>, <span class=\"hljs-literal\">nil</span>\n}\n</code></pre>\n<br>\n<p>또 다른 방식은 <code>fmt.Errorf()</code> 함수를 사용하는 것이다.\n이 함수는 <code>fmt.Printf()</code> 함수와 유사하게 <code>%d</code> 등 서식 기호를 사용하여 에러 메세지를 포매팅할 수 있다.\n함수를 호출하면 <code>errors.New()</code>처럼 <code>error</code>가 생성된다.</p>\n<pre><code class=\"hljs language-go\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">doubleEven1</span><span class=\"hljs-params\">(i <span class=\"hljs-keyword\">int</span>)</span> <span class=\"hljs-params\">(<span class=\"hljs-keyword\">int</span>, error)</span></span> {\n\t<span class=\"hljs-keyword\">if</span> i%<span class=\"hljs-number\">2</span> != <span class=\"hljs-number\">0</span> {\n\t\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>, errors.New(<span class=\"hljs-string\">\"only even numbers are processed\"</span>)\n\t}\n\t<span class=\"hljs-keyword\">return</span> i * <span class=\"hljs-number\">2</span>, <span class=\"hljs-literal\">nil</span>\n}\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">doubleEven2</span><span class=\"hljs-params\">(i <span class=\"hljs-keyword\">int</span>)</span> <span class=\"hljs-params\">(<span class=\"hljs-keyword\">int</span>, error)</span></span> {\n\t<span class=\"hljs-keyword\">if</span> i%<span class=\"hljs-number\">2</span> != <span class=\"hljs-number\">0</span> {\n\t\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>, fmt.Errorf(<span class=\"hljs-string\">\"%d isn't an even number\"</span>, i)\n\t}\n\t<span class=\"hljs-keyword\">return</span> i * <span class=\"hljs-number\">2</span>, <span class=\"hljs-literal\">nil</span>\n}\n</code></pre>\n<p><br><br></p>\n<h3>Sentinel Errors</h3>\n<p><strong>Sentinel Error</strong>는 패키지 레벨에서 정의되어 있는 에러로, 현 상태에서 특정한 문제로 인해 더 이상 프로세스의 진행이 불가능함을 나타낸다.\n대체로 <code>Err</code>로 시작하는 이름을 가지며(예외로 <code>io.EOF</code>가 있다), 읽기 전용이다.</p>\n<p><code>.zip</code> 파일을 처리하는 <code>archive/zip</code> 라이브러리에 존재하는 센티넬 에러 중에 <code>ErrFormat</code>이란 것이 있는데,\n이는 <code>.zip</code> 파일 형태가 아닌 데이터가 넘겨졌음을 나타낸다.</p>\n<pre><code class=\"hljs language-go\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span></span> {\n    data := []<span class=\"hljs-keyword\">byte</span>(<span class=\"hljs-string\">\"This is not a zip file\"</span>)\n    notAZipFile := bytes.NewReader(data)\n    _, err := zip.NewReader(notAZipFile, <span class=\"hljs-keyword\">int64</span>(<span class=\"hljs-built_in\">len</span>(data)))\n    <span class=\"hljs-keyword\">if</span> err == zip.ErrFormat {\n        fmt.Println(<span class=\"hljs-string\">\"Told you so\"</span>)\n    }\n}\n</code></pre>\n<br>\n<p>Sentinel Error의 또 다른 예는 <code>crypto/rsa</code> 패키지의 <code>rsa.ErrMessageTooLong</code>이다.\n현재 public key를 가지고 암호화하기에는 메시지의 크기가 너무 크다는 것을 나타낸다.\n그 이외에도 <code>context.Canceled</code>라는 센티넬 에러가 있는데, 12장에서 보게 될 것이다.</p>\n<p>Sentinel Error를 정의하기 이전에, 정의할 Sentinel Error가 정말 필요한 것인지 확실히 하는 것이 좋다.\n일단 에러를 정의하고 해당 버전을 커밋하면, 그 이후의 모든 릴리즈에서 이전 버전들과도 호환이 되도록 에러를 유지해야 한다.\n그러니 그냥 표준 라이브러리를 재사용하거나, 에러를 일으킨 원인에 대한 정보를 포함하는 <code>error</code> 타입을 정의한 후 이를 리턴하는 것이 나을 것이다.</p>\n<p>반면 Sentinel Error가 분명히 필요한 상황도 존재한다.\n더이상 프로세스를 진행할 수 없고, 에러 상태를 설명하기 위해 맥락에 대한 정보를 제공할 필요가 없으면, Sentinel Error를 선택하는 것이 좋다.</p>\n<p>앞선 예제에서 보았듯, <code>==</code>를 통해 Sentinel Error를 테스트할 수 있다.\n함수의 리턴값으로 받은 에러를, document에 명시된 Sentinel Error와 일치하는지 확인하는 것이다.</p>\n<p><br><br></p>\n<h3>Constant Errors</h3>\n<p>아래 예제와 같은 방식으로 Sentinel Error를 생성할 수 있다.</p>\n<pre><code class=\"hljs language-go\"><span class=\"hljs-keyword\">type</span> Sentinel <span class=\"hljs-keyword\">string</span>\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-params\">(s Sentinel)</span> <span class=\"hljs-title\">Error</span><span class=\"hljs-params\">()</span> <span class=\"hljs-title\">string</span></span> {\n\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-keyword\">string</span>(s)\n}\n\n<span class=\"hljs-keyword\">const</span> (\n\tErrFoo = Sentinel(<span class=\"hljs-string\">\"foo error\"</span>)\n\tErrBar = Sentinel(<span class=\"hljs-string\">\"bar error\"</span>)\n)\n</code></pre>\n<p>위 <code>Sentinel</code> 타입은 <code>error</code> 인터페이스를 지원하는 타입으로, <code>string</code> 리터럴을 <code>error</code>로써 사용할 수 있게 해준다.\n마치 함수 호출처럼 Sentinel Error를 생성할 수 있다는 장점이 있다. 아래 예제처럼 사용할 수 있다.</p>\n<pre><code class=\"hljs language-go\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">doubleEven1</span><span class=\"hljs-params\">(i <span class=\"hljs-keyword\">int</span>)</span> <span class=\"hljs-params\">(<span class=\"hljs-keyword\">int</span>, error)</span></span> {\n\t<span class=\"hljs-keyword\">if</span> i%<span class=\"hljs-number\">2</span> != <span class=\"hljs-number\">0</span> {\n\t\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>, ErrFoo\n\t}\n\t<span class=\"hljs-keyword\">return</span> i * <span class=\"hljs-number\">2</span>, <span class=\"hljs-literal\">nil</span>\n}\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span></span> {\n\ti, err := doubleEven1(<span class=\"hljs-number\">21</span>)\n\t<span class=\"hljs-keyword\">if</span> err == ErrFoo {\n\t\tfmt.Println(err)\n\t}\n\tfmt.Println(i)\n}\n</code></pre>\n<p>이 방식이 언뜻 보기에는 좋은 방법이라고 생각할 수 있지만, Go에서 이상적인 코드는 아니다.\n이렇게 생성한 에러 타입은 실질적으로는 <code>string</code>이며,\n만약 <span style=\"background-color: #FFF5B1\">에러 메시지가 동일하다면 동일한 에러로 인식</span>한다.\n설령 다른 패키지에 존재하는 에러라도, 동일한 에러 메시지를 가진다면 동일한 에러로 인식해버리고 마는 것이다.\n<code>errors.New()</code>로 생성한 에러 타입이 에러 메시지가 동일하더라도 서로 다른 에러로 인식하는 것과는 대조적이라고 할 수 있다.</p>\n<p>Go의 설계 철학상, Sentinel Error를 많이 만들어야 할 이유는 없다.\n애초에 프로세스를 진행하다 보면 빠질 수 있는 에러 상황을 나타내는 게 얘네들의 존재 의의인데,\n그런 상황이 몇 가지 안될 테니 많을 이유가 없는 것이 당연하다.</p>\n<p>Sentinel Error는 패키지 레벨에서 선언되는 public 변수일 수밖에 없는 이유는 자명하다.\n유저가 모든 상황에 대한 에러 변수를 생성하게끔 하기 보다는 그냥 이미 정의된 Sentinel Error를 가져다 쓰는 것이 더 편하기 때문이며,\n그러는 편이 언어가 더 단순해진다고 볼 수 있다.</p>\n<p><br><br></p>\n<h3>Errors Are Values</h3>\n<p><code>error</code>는 인터페이스이므로, 로깅이나 에러 핸들링을 위한 새로운 에러 타입을 직접 정의할 수 있다.\n이를테면 유저의 에러 리포트를 확인하기 위해 <em>status code</em>를 추가할 수 있다.\n그렇게 하면 에러 메시지만을 가지고 에러를 확인하는 것보단 훨씬 나을 것이다.</p>\n<p>직접 <em>status code</em>가 추가된 에러 타입을 만들어보자.</p>\n<p>먼저, <code>iota</code>로 각 <em>status code</em>를 정의해보자.</p>\n<pre><code class=\"hljs language-go\"><span class=\"hljs-keyword\">type</span> Status <span class=\"hljs-keyword\">int</span>\n\n<span class=\"hljs-keyword\">const</span> (\n\tInvalidLogin Status = <span class=\"hljs-literal\">iota</span> + <span class=\"hljs-number\">1</span>\n\tNotFound\n)\n</code></pre>\n<p>이제 이 <code>Status</code>들이 추가된 에러 타입을 정의해보자.</p>\n<pre><code class=\"hljs language-go\"><span class=\"hljs-keyword\">type</span> StatusErr <span class=\"hljs-keyword\">struct</span> {\n\tStatus  Status\n\tMessage <span class=\"hljs-keyword\">string</span>\n}\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-params\">(se StatusErr)</span> <span class=\"hljs-title\">Error</span><span class=\"hljs-params\">()</span> <span class=\"hljs-title\">string</span></span> {\n\t<span class=\"hljs-keyword\">return</span> fmt.Sprintf(<span class=\"hljs-string\">\"%d - %s\"</span>, se.Status, se.Message)\n}\n</code></pre>\n<p>이렇게 정의된 <code>StatusErr</code> 타입을 사용하면 에러에 대해 더 정확한 정보를 기록하고 확인할 수 있다.</p>\n<br>\n<pre><code class=\"hljs language-go\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">LoginAndGetData</span><span class=\"hljs-params\">(uid, pwd, file <span class=\"hljs-keyword\">string</span>)</span> <span class=\"hljs-params\">([]<span class=\"hljs-keyword\">byte</span>, error)</span></span> {\n    err := login(uid, pwd)\n    <span class=\"hljs-keyword\">if</span> err != <span class=\"hljs-literal\">nil</span> {\n        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">nil</span>, StatusErr{\n            Status:    InvalidLogin,\n            Message: fmt.Sprintf(<span class=\"hljs-string\">\"invalid credentials for user %s\"</span>, uid),\n        }\n    }\n    data, err := getData(file)\n    <span class=\"hljs-keyword\">if</span> err != <span class=\"hljs-literal\">nil</span> {\n        <span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">nil</span>, StatusErr{\n            Status:    NotFound,\n            Message: fmt.Sprintf(<span class=\"hljs-string\">\"file %s not found\"</span>, file),\n        }\n    }\n    <span class=\"hljs-keyword\">return</span> data, <span class=\"hljs-literal\">nil</span>\n}\n</code></pre>\n<p>위 예제는 <code>StatusErr</code> 에러 타입을 사용하는 예제 코드이다.</p>\n<p>주의해야 할 점이 있는데, <code>StatusErr</code>와 같이 직접 정의한 에러 타입을 사용할 때에도 리턴할 타입으로는 반드시 <code>error</code>를 사용해주어야 한다.\n이렇게 해야 함수를 호출할 때 특정 에러 타입에 종속되지 않으며, 함수에서 사용하는 여러 타입의 에러들을 모두 리턴할 수 있다.</p>\n<br>\n<p>에러 타입을 직접 정의해서 사용하는 경우 주의해야 할 것이 있다. 초기화되지 않은 에러 변수를 사용하면 안된다.\n다시 말해 에러 변수를 선언만 하고 초기화하지 않은 상태로 이를 리턴하면 안된다.</p>\n<p>하지 말라는데 굳이 해본 예제를 확인해보자.</p>\n<pre><code class=\"hljs language-go\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">GenerateWrongError</span><span class=\"hljs-params\">(flag <span class=\"hljs-keyword\">bool</span>)</span> <span class=\"hljs-title\">error</span></span> {\n\t<span class=\"hljs-keyword\">var</span> genErr StatusErr\n\t<span class=\"hljs-keyword\">if</span> flag {\n\t\tgenErr = StatusErr{\n\t\t\tStatus: NotFound,\n\t\t}\n\t}\n\t<span class=\"hljs-keyword\">return</span> genErr\n}\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span></span> {\n\terr := GenerateError(<span class=\"hljs-literal\">true</span>)\n\tfmt.Println(err != <span class=\"hljs-literal\">nil</span>)\n\terr = GenerateError(<span class=\"hljs-literal\">false</span>)\n\tfmt.Println(err != <span class=\"hljs-literal\">nil</span>)\n}\n</code></pre>\n<pre><code class=\"hljs language-bash\"><span class=\"hljs-literal\">true</span>\n<span class=\"hljs-literal\">true</span>\n</code></pre>\n<p>위 예제의 <code>err = GenerateError(false)</code>라인에서 파라미터로 <code>false</code>를 넘겨주었기 때문에, 리턴되는 에러 변수는 초기화되지 않았다.\n그럼에도 <code>err != nil</code>는 <code>true</code>로 처리되며, 이는 설령 <code>GenerateError()</code>의 <code>genErr</code>의 타입을 <code>*StatusErr</code>로 변경하더라도 마찬가지이다.</p>\n<p>원인을 떠올려 보자면, <code>error</code>는 인터페이스이니까 인터페이스가 <code>nil</code>이 되는 조건에 대해 생각해보면 된다.\n인터페이스가 <code>nil</code>이려면 가리키는 대상의 타입과 값이 모두 <code>nil</code>이어야 한다.\n위 경우 가리키는 대상의 값은 <code>nil</code>이지만, 타입이 <code>StatusErr</code> 또는 <code>*StatusErr</code>이기 때문에 <code>nil</code>이 아닌 것이다.</p>\n<br>\n<p>이런 코드는 두 가지 방법으로 고칠 수 있다. 하나는 <code>nil</code>을 직접 리턴하는 것이다.</p>\n<pre><code class=\"hljs language-go\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">GenerateError1</span><span class=\"hljs-params\">(flag <span class=\"hljs-keyword\">bool</span>)</span> <span class=\"hljs-title\">error</span></span> {\n\t<span class=\"hljs-keyword\">if</span> flag {\n\t\t<span class=\"hljs-keyword\">return</span> StatusErr{\n\t\t\tStatus: NotFound,\n\t\t}\n\t}\n\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">nil</span>\n}\n</code></pre>\n<p>이와 같은 방식은 <code>return</code>문 옆에 붙어있는 에러 변수가 제대로 초기화되었는지 굳이 확인해볼 필요가 없다는 장점이 있다.</p>\n<p>또 한가지 방식은 변수를 <code>error</code>로 선언하는 것이다.</p>\n<pre><code class=\"hljs language-go\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">GenerateError2</span><span class=\"hljs-params\">(flag <span class=\"hljs-keyword\">bool</span>)</span> <span class=\"hljs-title\">error</span></span> {\n\t<span class=\"hljs-keyword\">var</span> genErr error\n\t<span class=\"hljs-keyword\">if</span> flag {\n\t\tgenErr = StatusErr{\n\t\t\tStatus: NotFound,\n\t\t}\n\t}\n\t<span class=\"hljs-keyword\">return</span> genErr\n}\n</code></pre>\n<p>어차피 <code>error</code>는 인터페이스니까, 초기화 안한 상태로 리턴하면 <code>nil</code>로 리턴될 것이다.</p>\n<p>첫 번째와 두 번째 예제의 공통점은, 변수를 선언할 때 우리가 정의하였던 에러 타입으로 선언하지 않는다는 것이다.\n그렇게 하면 앞서 본 예제처럼, 문제를 일으킬 수 있다.</p>\n<br>\n<p>그리고 <code>error</code>가 인터페이스이기는 하지만, 직접 정의한 에러에 Type Assertion이나 Type Swtich를 사용하지 말자.\n대신 <code>errors.As()</code>를 사용한다. 사용하는 예제는 이후 다룰 것이다.</p>\n<p><br><br></p>\n<h2>Wrapping Errors</h2>\n<hr>\n<p>에러가 코드에서 코드로 전달되는데, 이때 각 맥락 정보를 에러에 추가하고 싶을 수 있다.\n이러한 맥락 정보는 이를테면, 어떤 함수인지나 어떤 라인에서 발생한 에러인지를 포함한다.\n이처럼 Go에서는 기존 에러에 맥락 정보를 추가하는 것을, 에러를 <em>Wrapping</em>한다고 한다.\n또한 이렇게 받은 여러 겹의 에러를 <em>error chain</em>이라고 한다.</p>\n<p>Go에 표준 라이브러리에도 Error Wrapping에 대한 함수가 있다.\n<code>fmt.Errorf()</code>가 바로 그것인데, 이 함수의 서식 문자 중 <code>%w</code>는 기존 에러가 포함하고 있던 에러 메시지를 의미한다.\n일반적으로는 에러 메시지의 끝에 <code>: %w</code>라고 적어서 기존 에러에 대한 정보도 함께 출력하는 것이 일반적이다.</p>\n<p>표준 라이브러리에는 에러를 Unwrapping하는 함수인 <code>errors.Unwrap()</code>도 있다.\n이 함수에 에러 타입을 보내면 Wrapping된 에러를 반환한다. 만약 더 이상 Wrapping된 에러가 없으면 <code>nil</code>을 반환한다.</p>\n<pre><code class=\"hljs language-go\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">fileChecker</span><span class=\"hljs-params\">(name <span class=\"hljs-keyword\">string</span>)</span> <span class=\"hljs-title\">error</span></span> {\n\tf, err := os.Open(name)\n\t<span class=\"hljs-keyword\">if</span> err != <span class=\"hljs-literal\">nil</span> {\n\t\t<span class=\"hljs-keyword\">return</span> fmt.Errorf(<span class=\"hljs-string\">\"in fileChecker: %w\"</span>, err)\n\t}\n\t<span class=\"hljs-keyword\">defer</span> f.Close()\n\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">nil</span>\n}\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span></span> {\n\terr := fileChecker(<span class=\"hljs-string\">\"nonExistFile.txt\"</span>)\n\t<span class=\"hljs-keyword\">if</span> err != <span class=\"hljs-literal\">nil</span> {\n\t\tfmt.Println(err)\n\t\t<span class=\"hljs-keyword\">if</span> wrappedErr := errors.Unwrap(err); wrappedErr != <span class=\"hljs-literal\">nil</span> {\n\t\t\tfmt.Println(wrappedErr)\n\t\t}\n\t}\n}\n</code></pre>\n<p>위 코드를 실횅시, 아래와 같은 결과를 확인할 수 있다.</p>\n<pre><code class=\"hljs language-bash\"><span class=\"hljs-keyword\">in</span> fileChecker: open nonExistFile.txt: no such file or directory\nopen nonExistFile.txt: no such file or directory\n</code></pre>\n<p>위처럼 <code>fileChecker()</code>에서 에러를 Wrapping하여 두 겹의 에러를 생성하였고, <code>errors.Unwrap()</code>으로 Wrapping된 에러를 확인할 수 있다.</p>\n<p>다만 <code>errors.Unwrap()</code> 함수보다는 <code>errors.Is()</code>나 <code>errors.As()</code>를 사용하는 것이 일반적이라고 한다. 이 두 함수에 대해서는 다음 섹션에서 다룬다.</p>\n<br>\n<p>이제 우리가 만든 에러 타입도 Wrapping이 가능하도록 만들어보자.\nWrapping이 가능하려면 Unwrap() 메소드를 추가해주어야 한다. 코드는 다음과 같다.</p>\n<pre><code class=\"hljs language-go\"><span class=\"hljs-keyword\">type</span> StatusErr <span class=\"hljs-keyword\">struct</span> {\n\tStatus  Status\n\tMessage <span class=\"hljs-keyword\">string</span>\n\tErr     error\n}\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-params\">(se StatusErr)</span> <span class=\"hljs-title\">Error</span><span class=\"hljs-params\">()</span> <span class=\"hljs-title\">string</span></span> {\n\t<span class=\"hljs-keyword\">return</span> se.Message\n}\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-params\">(se StatusErr)</span> <span class=\"hljs-title\">Unwrap</span><span class=\"hljs-params\">()</span> <span class=\"hljs-title\">error</span></span> {\n\t<span class=\"hljs-keyword\">return</span> se.Err\n}\n</code></pre>\n<p>StatusErr에 <code>error</code> 타입의 <code>Err</code>라는 필드가 추가되었으며, <code>Unwrap()</code>이라는 메소드가 추가되었다.</p>\n<pre><code class=\"hljs language-go\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">LoginAndGetData</span><span class=\"hljs-params\">(uid, pwd, file <span class=\"hljs-keyword\">string</span>)</span> <span class=\"hljs-params\">([]<span class=\"hljs-keyword\">byte</span>, error)</span></span> {\n\terr := login(uid, pwd)\n\t<span class=\"hljs-keyword\">if</span> err != <span class=\"hljs-literal\">nil</span> {\n\t\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">nil</span>, StatusErr{\n\t\t\tStatus:  InvalidLogin,\n\t\t\tMessage: fmt.Sprintf(<span class=\"hljs-string\">\"Invalid Credentials for user %s\"</span>, uid),\n\t\t\tErr:     err,\n\t\t}\n\t}\n\n\tdata, err := getData(file)\n\t<span class=\"hljs-keyword\">if</span> err != <span class=\"hljs-literal\">nil</span> {\n\t\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">nil</span>, StatusErr{\n\t\t\tStatus:  NotFound,\n\t\t\tMessage: fmt.Sprintf(<span class=\"hljs-string\">\"file %s is not found\"</span>, file),\n\t\t\tErr:     err,\n\t\t}\n\t}\n\n\t<span class=\"hljs-keyword\">return</span> data, <span class=\"hljs-literal\">nil</span>\n}\n</code></pre>\n<p>이렇게 에러 타입을 Wrapping이 가능하게 설계할 수 있다.</p>\n<p>다만 모든 상황에서 에러를 Wrapping해야 하는 것은 아니다.\n외부 라이브러리의 에러는 프로그램에서 굳이 필요하지 않은 내용까지 포함하는 경우가 있다.\n그럴 때는 그냥 에러를 새로 생성하여도 괜찮긴 하다.</p>\n<p>이전에 본 <code>fmt.Errorf()</code> 함수의 기능 중 그러한 기능이 있는데,\n서식 문자로 <code>%w</code> 대신 <code>%v</code>를 사용하면 기존 에러의 에러 메시지만 가져오고, 에러를 Wrapping하지는 않는다.</p>\n<p><br><br></p>\n<h3>Is</h3>\n<p>Wrapping하는 것은 에러에 정보를 추가적으로 담을 수 있다는 점에서 유용하지만, 문제를 야기할 수 있다.\n가령 Wrapping된 에러가 Sentinel Error라면, <code>==</code>로 에러를 체크하거나 Type Switch, Type Assertion을 사용할 수 없다.\n이와 같은 상황을 위해 존재하는 함수가 바로 <code>errors.Is()</code>와 <code>errors.As()</code>이다.</p>\n<p>먼저 <code>errors.Is()</code>는 에러가 어떤 Sentinel Error 인스턴스를 Wrapping하고 있는지 확인하기 위해 사용된다.\n<code>errors.Is()</code>는 체크할 에러와 비교 대상이 되는 Sentinel Error, 두 개의 에러를 파라미터로 받는다.\n만약 첫 번째 파라미터의 Error Chain 안에 일치하는 Sentinel Error가 있다면 <code>true</code>, 찾을 수 없다면 <code>false</code>를 반환한다.</p>\n<pre><code class=\"hljs language-go\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">fileChecker</span><span class=\"hljs-params\">(name <span class=\"hljs-keyword\">string</span>)</span> <span class=\"hljs-title\">error</span></span> {\n\tf, err := os.Open(name)\n\t<span class=\"hljs-keyword\">if</span> err != <span class=\"hljs-literal\">nil</span> {\n\t\t<span class=\"hljs-keyword\">return</span> fmt.Errorf(<span class=\"hljs-string\">\"in fileChecker: %w\"</span>, err)\n\t}\n\t<span class=\"hljs-keyword\">defer</span> f.Close()\n\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">nil</span>\n}\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span></span> {\n\terr := fileChecker(<span class=\"hljs-string\">\"nonExistFile.txt\"</span>)\n\t<span class=\"hljs-keyword\">if</span> err != <span class=\"hljs-literal\">nil</span> {\n\t\t<span class=\"hljs-keyword\">if</span> errors.Is(err, os.ErrNotExist) {\n\t\t\tfmt.Println(err)\n\t\t}\n\t}\n}\n</code></pre>\n<p>위 예제를 실행하면 다음의 결과를 얻을 수 있다.</p>\n<pre><code class=\"hljs language-bash\"><span class=\"hljs-keyword\">in</span> fileChecker: open nonExistFile.txt: no such file or directory\n</code></pre>\n<br>\n<p>기본적으로 <code>errors.Is()</code>는 <code>==</code> 연산을 통해 각 Wrapping된 에러들을 검사한다.\n그래서 직접 정의한 에러가 <code>==</code>연산을 통해 비교할 수 없는 경우, <code>Is()</code> 메소드를 추가해주어야 한다.</p>\n<pre><code class=\"hljs language-go\"><span class=\"hljs-keyword\">type</span> MyErr <span class=\"hljs-keyword\">struct</span> {\n\tCodes []<span class=\"hljs-keyword\">int</span>\n}\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-params\">(me MyErr)</span> <span class=\"hljs-title\">Error</span><span class=\"hljs-params\">()</span> <span class=\"hljs-title\">string</span></span> {\n\t<span class=\"hljs-keyword\">return</span> fmt.Sprintf(<span class=\"hljs-string\">\"codes: %v\"</span>, me.Codes)\n}\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-params\">(me MyErr)</span> <span class=\"hljs-title\">Is</span><span class=\"hljs-params\">(target error)</span> <span class=\"hljs-title\">bool</span></span> {\n\t<span class=\"hljs-keyword\">if</span> me2, ok := target.(MyErr); ok {\n\t\t<span class=\"hljs-keyword\">return</span> reflect.DeepEqual(me, me2)\n\t}\n\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">false</span>\n</code></pre>\n<p>예제에서는 Type Assertion을 통해 먼저 에러가 <code>MyErr</code> 타입인지 확인하고, 맞다면 <code>reflect.DeepEqual()</code>을 통해 비교를 진행한다.\n<code>slice</code>는 <code>==</code>로 비교 연산이 불가능하므로 <code>reflect.DeepEqual()</code>를 사용한다.</p>\n<br>\n<p>서로 다른 에러 인스턴스끼리 비교를 할 수 있도록 <code>Is()</code> 메소드를 추가하기도 한다.\n이를테면 특정한 에러들과 일치하는 패턴을 만드는 작업이라고 할 수 있는데,\n특정 필드값이 동일한지 검사하는 필터 역할의 필터 인스턴스를 만드는 것이다.</p>\n<pre><code class=\"hljs language-go\"><span class=\"hljs-keyword\">type</span> ResourceErr <span class=\"hljs-keyword\">struct</span> {\n\tResource <span class=\"hljs-keyword\">string</span>\n\tCode     <span class=\"hljs-keyword\">int</span>\n}\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-params\">(re ResourceErr)</span> <span class=\"hljs-title\">Error</span><span class=\"hljs-params\">()</span> <span class=\"hljs-title\">string</span></span> {\n\t<span class=\"hljs-keyword\">return</span> fmt.Sprintf(<span class=\"hljs-string\">\"%s: %d\"</span>, re.Resource, re.Code)\n}\n</code></pre>\n<p>위와 같은 <code>ResourceErr</code>에서, <code>Is()</code> 메소드를 직접 정의해보자.</p>\n<pre><code class=\"hljs language-go\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-params\">(re ResourceErr)</span> <span class=\"hljs-title\">Is</span><span class=\"hljs-params\">(target error)</span> <span class=\"hljs-title\">bool</span></span> {\n\t<span class=\"hljs-keyword\">if</span> other, ok := target.(ResourceErr); ok {\n\t\tignoreResource := other.Resource == <span class=\"hljs-string\">\"\"</span>\n\t\tignoreCode := other.Code == <span class=\"hljs-number\">0</span>\n\t\tmatchResource := other.Resource == re.Resource\n\t\tmatchCode := other.Code == re.Code\n\n\t\t<span class=\"hljs-keyword\">return</span> matchCode &#x26;&#x26; matchResource ||\n\t\t\tmatchCode &#x26;&#x26; ignoreResource ||\n\t\t\tignoreCode &#x26;&#x26; matchResource\n\t}\n\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">false</span>\n}\n</code></pre>\n<p>정의된 <code>Is()</code> 메소드는 먼저 에러 타입이 ResourceErr인지 확인하고,\n<code>Code</code>와 <code>Resource</code> 중 필드값이 하나라도 설정되면 그에 대하여 비교를 진행한다.</p>\n<p>이렇게 <code>Is()</code> 메소드를 직접 설정해주면, 아래 예제처럼 사용할 수 있다.</p>\n<pre><code class=\"hljs language-go\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span></span> {\n\terr := fileChecker(<span class=\"hljs-string\">\"nonExistFile.txt\"</span>)\n\t<span class=\"hljs-keyword\">if</span> err != <span class=\"hljs-literal\">nil</span> {\n\t\t<span class=\"hljs-keyword\">if</span> errors.Is(err, os.ErrNotExist) {\n\t\t\tfmt.Println(err)\n\t\t}\n\t}\n\n\tfmt.Println(<span class=\"hljs-string\">\"---------------------------\"</span>)\n\n\terr1 := ResourceErr{\n\t\tResource: <span class=\"hljs-string\">\"Database\"</span>,\n\t\tCode:     <span class=\"hljs-number\">123</span>,\n\t}\n\n\terr2 := ResourceErr{\n\t\tResource: <span class=\"hljs-string\">\"Network\"</span>,\n\t\tCode:     <span class=\"hljs-number\">456</span>,\n\t}\n\n\t<span class=\"hljs-keyword\">if</span> errors.Is(err1, ResourceErr{Resource: <span class=\"hljs-string\">\"Database\"</span>}) {\n\t\tfmt.Println(<span class=\"hljs-string\">\"The database is broken:\"</span>, err)\n\t}\n\n\t<span class=\"hljs-keyword\">if</span> errors.Is(err2, ResourceErr{Resource: <span class=\"hljs-string\">\"Database\"</span>}) {\n\t\tfmt.Println(<span class=\"hljs-string\">\"The database is broken:\"</span>, err)\n\t}\n\n\t<span class=\"hljs-keyword\">if</span> errors.Is(err1, ResourceErr{Code: <span class=\"hljs-number\">123</span>}) {\n\t\tfmt.Println(<span class=\"hljs-string\">\"Code 123 is triggered:\"</span>, err)\n\t}\n\n\t<span class=\"hljs-keyword\">if</span> errors.Is(err2, ResourceErr{Code: <span class=\"hljs-number\">123</span>}) {\n\t\tfmt.Println(<span class=\"hljs-string\">\"Code 123 is triggered:\"</span>, err)\n\t}\n\n\t<span class=\"hljs-keyword\">if</span> errors.Is(err1, ResourceErr{Resource: <span class=\"hljs-string\">\"Database\"</span>, Code: <span class=\"hljs-number\">123</span>}) {\n\t\tfmt.Println(<span class=\"hljs-string\">\"Database is broken and Code 123 is triggered\"</span>, err)\n\t}\n\n\t<span class=\"hljs-keyword\">if</span> errors.Is(err1, ResourceErr{Resource: <span class=\"hljs-string\">\"Network\"</span>, Code: <span class=\"hljs-number\">123</span>}) {\n\t\tfmt.Println(<span class=\"hljs-string\">\"Network is broken and Code 123 is triggered\"</span>, err)\n\t}\n}\n</code></pre>\n<p>위 코드의 실행 결과는 어렵지 않게 짐작할 수 있을 것이다.</p>\n<pre><code class=\"hljs language-bash\">The database is broken: Database: 123\nCode 123 is triggered: Database: 123\nDatabase is broken and Code 123 is triggered Database: 123\n</code></pre>\n<p><br><br></p>\n<h3>As</h3>\n<p><code>errors.As()</code>는 반환된 에러(또는 error chain중의 어느 에러)가 특정 타입과 일치하는지 확인하는 함수이다.</p>\n<p>이 함수는 두 개의 파라미터를 받는데, 각각 검사할 에러와, 특정 타입의 변수를 가리키는 포인터이다.\n만약 해당 첫 번째 파라미터의 error chain 안에 두 번째 파라미터와 일치하는 타입이 존재한다면 <code>true</code>를 반환하며,\n일치하지 않는다면 <code>false</code>를 반환한다.</p>\n<p>사용 예제는 아래와 같다.</p>\n<pre><code class=\"hljs language-go\">err := AFunctionThatReturnsAnError()\n<span class=\"hljs-keyword\">var</span> myErr MyErr\n<span class=\"hljs-keyword\">if</span> errors.As(err, &#x26;myErr) {\n    fmt.Println(myErr.Code)\n}\n</code></pre>\n<p>위처럼 <code>var</code> 키워드를 사용하여 Zero value인 에러를 선언하고, 이를 <code>errors.As()</code>에 pass by pointer로 넘길 수 있다.</p>\n<p>또한 두 번째 파라미터로 변수가 아니라 인터페이스를 넘길 수도 있는데, 이렇게 하면 해당 인터페이스를 충족시키는 에러 타입이 있는지 찾아낼 수 있다.</p>\n<pre><code class=\"hljs language-go\">err2 := AFunctionThatReturnsAnError()\n<span class=\"hljs-keyword\">var</span> coder <span class=\"hljs-keyword\">interface</span> {\n\tCode() <span class=\"hljs-keyword\">int</span>\n}\n\n<span class=\"hljs-keyword\">if</span> errors.As(err2, &#x26;coder) {\n\tfmt.Println(coder.Code())\n}\n</code></pre>\n<p>위 예제에서는 익명 인터페이스를 사용하였는데, 어떤 인터페이스 타입이든 상관 없다.</p>\n<p><code>errors.As()</code>의 두 번째 파라미터는 에러 타입이나 인터페이스에 대한 포인터만 올 수 있으며, 그 외에 것은 panic이 발생한다.</p>\n<p><code>errors.Is()</code>처럼, <code>As()</code> 메소드를 오버라이딩하면 <code>errors.As()</code>도 커스터마이징하여 사용할 수 있다.\n다만 <em>reflection</em>이 필요하며, 특수한 상황에서만 사용한다고 한다.</p>\n<p><br><br></p>\n<h3>Wrapping Errors with defer</h3>\n<p>아래와 같은 코드가 있다고 가정해보자.</p>\n<pre><code class=\"hljs language-go\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">doSomeThings_before</span><span class=\"hljs-params\">(val1, val2 <span class=\"hljs-keyword\">int</span>)</span> <span class=\"hljs-params\">(<span class=\"hljs-keyword\">int</span>, error)</span></span> {\n\tval3, err := doThing1(val1)\n\t<span class=\"hljs-keyword\">if</span> err != <span class=\"hljs-literal\">nil</span> {\n\t\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>, fmt.Errorf(<span class=\"hljs-string\">\"in DoSomeThings: %w\"</span>, err)\n\t}\n\n\tval4, err := doThing2(val2)\n\t<span class=\"hljs-keyword\">if</span> err != <span class=\"hljs-literal\">nil</span> {\n\t\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>, fmt.Errorf(<span class=\"hljs-string\">\"in DoSomeThings: %w\"</span>, err)\n\t}\n\n\tres, err := doThing3(val3, val4)\n\t<span class=\"hljs-keyword\">if</span> err != <span class=\"hljs-literal\">nil</span> {\n\t\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>, fmt.Errorf(<span class=\"hljs-string\">\"in DoSomeThings: %w\"</span>, err)\n\t}\n\t<span class=\"hljs-keyword\">return</span> res, <span class=\"hljs-literal\">nil</span>\n}\n</code></pre>\n<p>딱 봐도 <code>if</code>절이 반복되고 있는데, 이와 같은 반복은 <code>defer</code>를 통해 리팩토링할 수 있다.</p>\n<pre><code class=\"hljs language-go\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">doSomeThings_after</span><span class=\"hljs-params\">(val1, val2 <span class=\"hljs-keyword\">int</span>)</span> <span class=\"hljs-params\">(_ <span class=\"hljs-keyword\">int</span>, err error)</span></span> {\n\t<span class=\"hljs-keyword\">defer</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span><span class=\"hljs-params\">()</span></span> {\n\t\t<span class=\"hljs-keyword\">if</span> err != <span class=\"hljs-literal\">nil</span> {\n\t\t\terr = fmt.Errorf(<span class=\"hljs-string\">\"in DoSomeThings: %w\"</span>, err)\n\t\t}\n\t}()\n\n\tval3, err := doThing1(val1)\n\t<span class=\"hljs-keyword\">if</span> err != <span class=\"hljs-literal\">nil</span> {\n\t\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>, err\n\t}\n\n\tval4, err := doThing2(val2)\n\t<span class=\"hljs-keyword\">if</span> err != <span class=\"hljs-literal\">nil</span> {\n\t\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-number\">0</span>, err\n\t}\n\n\t<span class=\"hljs-keyword\">return</span> doThing3(val3, val4)\n}\n</code></pre>\n<p>비록 어느 정도 반복되는 구문이 여전히 남아있기는 하지만, 그래도 훨씬 더 보기 좋다.</p>\n<p><code>defer</code>를 썼기 때문에 반환할 named return value가 변경되고, 변경된 값을 그대로 반환한다.\n주목할 점은 첫 번째 리턴 변수의 이름을 <code>_</code>로 설정함으로써,\n해당 파라미터는 named return value를 사용하지 않는다는 것을 명시적으로 선언하였다는 점이다.</p>\n<p><code>defer</code>의 closure에서는 에러가 리턴되었는지 체크하며,\n만약 그렇다면 해당 에러에 어느 함수에서 에러를 확인했는지 정보를 추가하여 Wrapping한 새로운 에러를 반환한다.</p>\n<p>이러한 패턴은 모든 에러에 동일한 메시지를 출력하는 경우 용이하다.\n<code>fmt.Errorf()</code>와 서식 문자 <code>%w</code>를 사용하여, 에러가 발생한 맥락에 대해 추가적인 정보를 제공할 수 있다는 점은 기억할 수 있을 것 같다.</p>\n<p><br><br></p>\n<h2>panic and recover</h2>\n<hr>\n<p>Go에서는, 런타임에서 이 다음에 무슨 일이 일어날 지 밝혀낼 수 없는 상황일 때 <em>panic</em>을 발생시킨다.\n프로그래밍 에러(slice의 out of index)나 환경적인 요인(running out of memory) 등의 원인이 있다.</p>\n<p>Go에서는 <em>panic</em>이 발생하자마자 현재 실행중인 함수를 즉시 끝내고 현재 함수에 붙어있는 <code>defer</code>를 즉시 실행한다.\n<code>defer</code>가 끝나면 현재 함수를 실행한 또 다른 함수의 <code>defer</code>를 끝내고, <code>main()</code>함수에 도달할 때까지 이를 반복한다.\n그러면 프로그램이 종료되며, stack trace를 출력한다.</p>\n<p>우리가 짠 프로그램이 회복할 수 없는 상태에 빠진다면 <em>panic</em>을 일으킬 수 있다.\n<code>panic()</code> 함수는 에러 메세지 하나를 파라미터로 받아서 출력한다(보통 <code>string</code>이다).</p>\n<p>직접 <em>panic</em>을 일으키는 예제를 확인해보자</p>\n<pre><code class=\"hljs language-go\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">doPanic</span><span class=\"hljs-params\">(msg <span class=\"hljs-keyword\">string</span>)</span></span> {\n\t<span class=\"hljs-built_in\">panic</span>(msg)\n}\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span></span> {\n\tdoPanic(<span class=\"hljs-string\">\"응애앵\"</span>)\n}\n</code></pre>\n<p>위 예제를 실행하면 아래와 같은 결과를 얻는다.</p>\n<pre><code class=\"hljs language-bash\">panic: 응애앵\n\ngoroutine 1 [running]:\nmain.doPanic(...)\n        /home/junhyuk/Programming/Golang/8-errors/panic.go:6\nmain.main()\n        /home/junhyuk/Programming/Golang/8-errors/panic.go:10 +0x45\n<span class=\"hljs-built_in\">exit</span> status 2\n</code></pre>\n<p><em>panic</em>을 발생시킬 때 보냈던 메세지와, 어느 goroutine에서 발생한 패닉인지(goroutine은 나중에 나온다!),\n그리고 stacktrace가 나오는 것을 확인할 수 있다.</p>\n<br>\n<p>Go에는 <em>panic</em>을 캡쳐하여 프로그램을 조금 더 예쁘게 셧다운하거나, 혹은 셧다운하지 않게 해주는 빌트인 함수 <code>recover()</code>가 존재한다.\n<code>recover()</code> 함수가 <code>defer</code>의 closure에서 호출되면 <em>panic</em>이 발생했는지 확인한다.\n만약 <em>panic</em>이 발생하였으면 <code>recover()</code>의 리턴값은 panic에 할당된 값(아마 에러 메세지인듯?)이 되며,\n프로그램은 termination을 멈추고 계속 동작한다.</p>\n<p>아래 예제에서 <code>recover()</code>문을 사용하는 패턴을 확인할 수 있다.</p>\n<pre><code class=\"hljs language-go\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">div60</span><span class=\"hljs-params\">(i <span class=\"hljs-keyword\">int</span>)</span></span> {\n\t<span class=\"hljs-keyword\">defer</span> <span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span><span class=\"hljs-params\">()</span></span> {\n\t\t<span class=\"hljs-keyword\">if</span> v := <span class=\"hljs-built_in\">recover</span>(); v != <span class=\"hljs-literal\">nil</span> {\n\t\t\tfmt.Println(v)\n\t\t}\n\t}()\n\n\tfmt.Println(<span class=\"hljs-number\">60</span> / i)\n}\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span></span> {\n\t<span class=\"hljs-keyword\">for</span> _, val := <span class=\"hljs-keyword\">range</span> []<span class=\"hljs-keyword\">int</span>{<span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">0</span>, <span class=\"hljs-number\">6</span>} {\n\t\tdiv60(val)\n\t}\n}\n</code></pre>\n<p>panic이 발생하면 모두 건너뛰고 <code>defer</code>가 실행되기 때문에, <code>recover()</code>는 반드시 <code>defer</code>문 내에서만 호출되어야 한다.\n<code>if</code>문 내에서 <code>recover()</code>를 호출하는데, 이때 panic이 발생하였다면 <code>nil</code>이 아닌 값을 리턴받으므로 <code>if</code>문 내부를 실행한다.</p>\n<pre><code class=\"hljs language-bash\">60\n30\nruntime error: <span class=\"hljs-built_in\">integer</span> divide by zero\n10\n</code></pre>\n<p>만약 위 예제의 <code>div60()</code>함수에 <code>defer~recover</code> 구문이 없었다면 <code>div60(0)</code>이 실행될 때 panic이 발생하여 프로세스가 종료되었을 것이다.\n하지만 panic이 <code>recover()</code>문에 걸려 <code>runtime error: integer divide by zero</code>를 출력한 뒤,\n프로세스가 끝나지 않고 그 다음 호출인 <code>div60(6)</code>까지 호출한 것을 확인할 수 있다.</p>\n<p>panic과 recover는 다른 언어에서 Exception Handling을 하는 패턴과 유사하지만, 그런 패턴대로 사용하는 것은 별로 좋은 생각이 아니다.\npanic은 심각한 에러 상황에만 사용하고, recover로 그러한 예제를 처리할 떄는 매우 조심스럽게 접근해야 한다.</p>\n<p>특히 panic이 발생했을 때 recover를 이용하여 프로그램을 계속 실행시키려면, 많은 주의를 기울여야 한다.\n일반적으로 panic이 발생한 상황에서 프로그램을 계속 실행해야 하는 경우는 드물다.\n가령 메모리나 디스크 공간 부족 등의 이유로 panic이 발생한 경우,\nrecover로 현 상태를 기록하고 os.Exit(1)로 프로그램을 종료하는 게 최선의 방법이다.</p>\n<p>프로그래밍 에러로 인해 panic이 발생한 경우라면 프로그램을 계속 실행시킬 수는 있겠으나, 동일한 panic을 다시 겪게 될 가능성이 높다.\n따라서 위 예제의 경우에서라면 division by zero로 인해 panic이 발생하지 않게끔,\n먼저 파라미터 값이 0인지 확인하여 맞다면 <code>error</code>를 리턴하는 것이 좋을 것이다.</p>\n<p>panic과 recover에 의존하는 것을 권장하지 않는 이유는, recover의 한정적인 기능 때문이다.\n어떤 종류든 panic이 발생하면 recover로 메시지를 출력하고 프로그램을 계속 실행시킬 수 있지만, 특정 종류의 panic만 처리할 수는 없다.\nGo에서는 모든 것을 처리할 수 있는 짧은 코드보다는, 가능한 에러 조건들을 명시하는 코드를 더 이상적이라고 생각한다.</p>\n<p><code>recover</code>가 권장되는 한 가지 상황이 있다.\n서드 파티 라이브러리를 작성하는 경우인데, 이 경우 panic이 API 밖으로 벗어나면 안되기 때문이다.\n따라서 함수에서 <code>panic</code>을 처리하고, 이를 <code>error</code>로 변경하여 리턴하는 코드를 작성해 주어야 한다.</p>\n<p><br><br></p>\n<h3>Getting a Stack Trace from an Error</h3>\n<p><code>panic</code>과 <code>recover</code>는 Stack Trace를 제공하지 않는다.\n기본적으로는 Error Wrapping을 통해 직접 Error Stack을 쌓아나가는 방식을 택할 수 있지만,\n이러한 <a href=\"https://github.com/pkg/errors\">Error Stack을 자동으로 생성해주는 서드파티 라이브러리</a>가 존재한다.\n이 라이브러리는 stack trace를 할 수 있게 해주는 Error Wrapping 함수를 제공하는 것 같다.\n위 라이브러리를 임포트하여 <code>fmt.Printf()</code> 함수에서 서식 문자로 <code>%+v</code>를 사용하면 stack trace를 확인할 수 있을 것이다.</p>\n<p><br><br></p>\n<h2>References</h2>\n<hr>\n<center>\n<p><a href=\"https://learning.oreilly.com/library/view/learning-go/9781492077206/\"><img src=\"https://learning.oreilly.com/covers/urn:orm:book:9781492077206/400w/\" alt=\"\"></a> <br>\n<a href=\"https://learning.oreilly.com/library/view/learning-go/9781492077206/\">Jon Bodner, 『Learning Go』, O'Reilly Media, Inc.</a></p>\n</center>\n<p><br><br></p>","category":"Golang"}