{"metadata":{"title":"타입, 메소드, 인터페이스","date":"Aug 11, 2022","excerpt":"Types, Methods, Interfaces"},"content":"<br>\n<p>본 글은 Golang을 공부하며 주요 내용이라 생각되는 것들을 기록해둔 자료이며, Ubuntu 20.04 LTS 기준으로 작성되었습니다.</p>\n<p><br><br></p>\n<h2>Types</h2>\n<hr>\n<p>Go에는 Class나 상속과 같은 개념이 개념이 존재하지 않는다. 대신 타입을 정의하고자 하는 경우, <code>type</code> 키워드를 사용하여 정의한다.</p>\n<pre><code class=\"hljs language-go\"><span class=\"hljs-keyword\">type</span> Person <span class=\"hljs-keyword\">struct</span> {\n    FirstName <span class=\"hljs-keyword\">string</span>\n    LastName  <span class=\"hljs-keyword\">string</span>\n    Age       <span class=\"hljs-keyword\">int</span>\n}\n<span class=\"hljs-keyword\">type</span> Score <span class=\"hljs-keyword\">int</span>\n<span class=\"hljs-keyword\">type</span> Converter <span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span><span class=\"hljs-params\">(<span class=\"hljs-keyword\">string</span>)</span> <span class=\"hljs-title\">Score</span></span>\n<span class=\"hljs-keyword\">type</span> TeamScores <span class=\"hljs-keyword\">map</span>[<span class=\"hljs-keyword\">string</span>]Score\n<span class=\"hljs-keyword\">type</span> Employee Person\n</code></pre>\n<p>위처럼 정의된 타입들은 이들이 정의된 스코프 내에서만 정의 가능하다.</p>\n<br>\n<p>한 가지 짚고 넘어가야 할 점은, 위 예제의 <code>Score</code> 타입의 경우 사실상 <code>int</code>와 동일한 타입이다.\n그럼에도 위와 같이 타입명을 지정해준 것은 타입명 자체를 일종의 <strong>documentation</strong>으로 볼 수 있기 때문이다.</p>\n<p>이러한 타입 지정은 해당 타입의 변수 또는 인스턴스가 코드 내에서 어떠한 역할을 하며,\n어떠한 데이터를 저장할 지에 대한 정보를 제공할 수 있다.\n위 예제에서 <code>Score</code>는 <code>int</code>와 똑같은 정수 타입이기는 해도, 무식하게 큰 정수나 음수인 값에 대해서는 유효하지 않은 값임을 파악할 수 있을 것이다.</p>\n<p>위 예제의 <code>Employee</code>은 유저가 정의한 타입을 다시 정의한 경우인데, 이 또한 같은 맥락에서 바라볼 수 있다.\n저장하고 있는 데이터의 종류는 같을지라도, 이들이 사용되어야 할 적합한 맥락에 대해서 정보를 제공할 수 있다.</p>\n<p><br><br></p>\n<h3>Inheritance in Go?</h3>\n<p>Go에는 객체지향과 상속 개념이 없다. type을 선언할 수 있지만, 이는 말 그대로 어디까지나 선언만 할 수 있는 것이다.</p>\n<pre><code class=\"hljs language-go\"><span class=\"hljs-keyword\">type</span> HighScore Score\n<span class=\"hljs-keyword\">type</span> Employee Person\n</code></pre>\n<p>위와 같은 <code>type</code> 선언은 상속처럼 보일 수는 있지만, 엄연히 다르다. 실질적으로는 이름만 다른 동일한 타입이 두 개 선언되는 것.\n이들 사이에는 어떠한 계층 구조도 존재하지 않는다.</p>\n<p>객체지향에서 <em>child class</em>는 <em>parent class</em>가 가진 모든 메소드와 값들을 사용할 수 있어야 하며, parent class가 사용되는 곳 어디에든 사용될 수 있어야 한다.\n반면 Go에서는, 위 예제의 <code>Score</code> 인스턴스가 사용되는 상황에서 <code>HighScore</code> 인스턴스를 사용하려면 타입 변환을 해주어야 한다.</p>\n<pre><code class=\"hljs language-go\"><span class=\"hljs-comment\">// assigning untyped constants is valid</span>\n<span class=\"hljs-keyword\">var</span> i <span class=\"hljs-keyword\">int</span> = <span class=\"hljs-number\">300</span>\n<span class=\"hljs-keyword\">var</span> s Score = <span class=\"hljs-number\">100</span>\n<span class=\"hljs-keyword\">var</span> hs HighScore = <span class=\"hljs-number\">200</span>\nhs = s                  <span class=\"hljs-comment\">// compilation error!</span>\ns = i                   <span class=\"hljs-comment\">// compilation error!</span>\ns = Score(i)            <span class=\"hljs-comment\">// ok</span>\nhs = HighScore(s)       <span class=\"hljs-comment\">// ok</span>\n</code></pre>\n<p><br><br></p>\n<h3>Enumeration in Go - iota</h3>\n<p>여러 프로그래밍 언어에 존재하는 <em>Enumeration</em>에 대한 개념 대신, Go에는 <code>iota</code>가 존재한다. 바로 예제를 확인해보자.</p>\n<pre><code class=\"hljs language-go\">\t<span class=\"hljs-keyword\">type</span> MailCategory <span class=\"hljs-keyword\">int</span>\n\t<span class=\"hljs-keyword\">const</span> (\n\t\tUncategorized MailCategory = <span class=\"hljs-literal\">iota</span> <span class=\"hljs-comment\">// 0</span>\n\t\tPersonal                          <span class=\"hljs-comment\">// 1</span>\n\t\tSpam                              <span class=\"hljs-comment\">// 2</span>\n\t\tSocial                            <span class=\"hljs-comment\">// 3</span>\n\t\tAdvertisement                     <span class=\"hljs-comment\">// 4</span>\n\t)\n\n\tfmt.Println(Uncategorized, Personal, Spam, Social, Advertisement)\n</code></pre>\n<pre><code class=\"hljs language-bash\">0 1 2 3 4\n</code></pre>\n<p>위 예제의 실행 결과를 확인해보면, 0부터 4까지의 수가 순서대로 할당되었음을 알 수 있다.\n이는 <code>iota</code>가 첫 번째 상수인 <code>Uncategorized</code>에 0, 두 번째 상수인 <code>Personal</code>에 1, 이런 식으로 점점 증가되게끔 값을 할당하였기 때문이다.\n또한, 만일 새로운 <code>const</code> 선언 블록이 존재할 경우, iota는 0이 될 것이다.</p>\n<br>\n<pre><code class=\"hljs language-go\">\t<span class=\"hljs-keyword\">type</span> BitField <span class=\"hljs-keyword\">int</span>\n\t<span class=\"hljs-keyword\">const</span> (\n\t\tField1 BitField = <span class=\"hljs-number\">1</span> &#x3C;&#x3C; <span class=\"hljs-literal\">iota</span> <span class=\"hljs-comment\">// assigned 1</span>\n\t\tField2                      <span class=\"hljs-comment\">// assigned 2</span>\n\t\tField3                      <span class=\"hljs-comment\">// assigned 4</span>\n\t\tField4                      <span class=\"hljs-comment\">// assigned 8</span>\n\t\t_                           <span class=\"hljs-comment\">// passed 16</span>\n\t\tField6                      <span class=\"hljs-comment\">// assigned 32</span>\n\t)\n\n\tfmt.Println(Field1, Field2, Field3, Field4, Field6)\n</code></pre>\n<p><code>_</code>를 이용하면 iota로 할당되는 값을 건너뛸 수 있다.\n또한 <code>iota</code>를 사용할 때 위와 같은 표현식을 사용하여 값들을 할당할 수도 있다.\n다만 이런 경우, 무슨 목적으로 이런 코드를 짰는지 잘 명시해주는 것이 좋겠다.</p>\n<br>\n<p>단 <code>iota</code>를 사용하려면 <code>iota</code>에 의해서 할당되는 값이 큰 의미가 없는 경우여야 한다.\n0, 1, 2, ... 등 <code>iota</code>에 의해 할당되는 값들은 단순히 서로를 구분하기 위해서 사용되는 값일 뿐이며, 이 값을 직접적으로 사용해선 안된다.\n만일 <code>iota</code>를 사용하는 <code>const</code> 블록 중간에 새로운 상수를 추가하면 값들이 전체적으로 바뀔 것이다.\n이 때 <code>iota</code>에 의해 할당되는 값을 직접적으로 사용한다면 이에 영향을 받을 것이다.</p>\n<p>특정 인터페이스와 직접적으로 관련되어있지 않은 내부적인 로직에서 사용하는 것이 좋다.\n만약 어느 <code>struct</code> 타입에 <code>iota</code>를 사용하는 Enumeration 필드가 존재하고, 해당 인스턴스들이 DB에 저장되어있다고 가정해보자.\n그런데 <code>iota</code>를 사용하는 <code>const</code> 블록 중간에 새로운 상수를 추가하면 DB에 저장된 값들이 완전히 다른 값을 가리키게 될 것이다.</p>\n<p>따라서 상수의 값이 중요한 경우이거나 내부적인 로직에서 사용하는 것이 아니라면 <code>iota</code>를 쓰지 말고 그냥 값을 직접 할당해주는 편이 좋다.\n그게 아니라면 문서를 잘 써놓자.</p>\n<p><br><br></p>\n<h2>Methods</h2>\n<hr>\n<p>Go에서는 <em>User-defined type</em>에 대해 메소드를 생성할 수 있다.\n일반적인 함수 선언과 유사하지만, <code>func</code>와 메소드명 사이에 <strong>receiver</strong>를 명시해준다.\n보통의 변수 선언처럼 변수명을 먼저 적고 타입을 뒤에 적는다.\n일반적으로는 타입명의 맨 앞글자를 소문자로 적는다고 한다.</p>\n<pre><code class=\"hljs language-go\"><span class=\"hljs-keyword\">type</span> Person <span class=\"hljs-keyword\">struct</span> {\n\tFirstName <span class=\"hljs-keyword\">string</span>\n\tLastName  <span class=\"hljs-keyword\">string</span>\n\tAge       <span class=\"hljs-keyword\">int</span>\n}\n\n<span class=\"hljs-comment\">// defining methods for user-defined type</span>\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-params\">(p Person)</span> <span class=\"hljs-title\">String</span><span class=\"hljs-params\">()</span> <span class=\"hljs-title\">string</span></span> { <span class=\"hljs-comment\">// The receiver appears between the keyword func and the name of the method</span>\n\t<span class=\"hljs-keyword\">return</span> fmt.Sprintf(<span class=\"hljs-string\">\"%s %s, age %d\"</span>, p.FirstName, p.LastName, p.Age)\n}\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span></span> {\n\tp := Person{\n\t\tFirstName: <span class=\"hljs-string\">\"Fred\"</span>,\n\t\tLastName:  <span class=\"hljs-string\">\"Fredson\"</span>,\n\t\tAge:       <span class=\"hljs-number\">52</span>,\n\t}\n    <span class=\"hljs-comment\">// method invocations look familiar to those who have used methods in other languages</span>\n\toutput := p.String()\n\tfmt.Println(output)\n}\n</code></pre>\n<p>Go에서는 함수 오버로딩을 지원하지 않으며, 메소드도 동일하다.\n동일한 타입에서 두개 이상의 동일한 이름을 가진 메소드를 선언할 수 없다.</p>\n<p>또한 타입과 이에 대한 메소드가 선언된 파일을 서로 분리할 수는 있지만, 같은 파일 에서 함께 선언하는 것이 권장된다고 한다.</p>\n<p><br><br></p>\n<h3>Pointer Receivers</h3>\n<p>함수에서 포인터 파라미터를 사용할 때처럼, <em>Receiver</em>에도 포인터를 사용할 수 있다.\n이 때 <em>Value Receiver</em>를 사용할 때와의 차이점은 <em>Receiver</em>로 패스한 값이 변경될 수 있다는 것이다.</p>\n<p><em>Pointer Reciver</em>에 대한 몇 가지 규칙이 존재한다.</p>\n<ol>\n<li>메소드가 <em>Reciver</em> 값을 변경한다면, 반드시 <em>Pointer Reciver</em>를 사용한다.</li>\n<li>메소드가 <code>nil</code> 인스턴스를 다뤄야 한다면, 반드시 <em>Pointer Reciver</em>를 사용한다.</li>\n<li>메소드가 <em>Reciver</em> 값을 변경하지 않는다면, <em>Value Reciver</em>를 사용할 수 있다.</li>\n</ol>\n<p><em>Reciver</em> 값을 변경하지 않는 메소드에 대해서도 <em>Pointer Reciver</em>를 사용하는 것이 국룰이라고 한다.\n다만 난 잘 모르겠다. 개인적으로는 값을 변경하지 않는다면 명시적으로 <em>Value Reciver</em>를 써도 되는 거 아닌가 싶다.</p>\n<br>\n<pre><code class=\"hljs language-go\"><span class=\"hljs-keyword\">type</span> Counter <span class=\"hljs-keyword\">struct</span> {\n\ttotal       <span class=\"hljs-keyword\">int</span>\n\tlastUpdated time.Time\n}\n\n<span class=\"hljs-comment\">// pointer receiver should be used when the method modifies the receiver or handles nil instances</span>\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-params\">(c *Counter)</span> <span class=\"hljs-title\">Increment</span><span class=\"hljs-params\">()</span></span> {\n\tc.total++\n\tc.lastUpdated = time.Now()\n}\n\n<span class=\"hljs-comment\">// value receiver can be used when the method doesn't modify the receiver</span>\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-params\">(c Counter)</span> <span class=\"hljs-title\">String</span><span class=\"hljs-params\">()</span> <span class=\"hljs-title\">string</span></span> {\n\t<span class=\"hljs-keyword\">return</span> fmt.Sprintf(<span class=\"hljs-string\">\"total: %d, last updated: %v\"</span>, c.total, c.lastUpdated)\n}\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span></span> {\n\t<span class=\"hljs-keyword\">var</span> c Counter\n\tfmt.Println(c.String())\n\t<span class=\"hljs-comment\">// Go automatically converts it to a pointer type.</span>\n\tc.Increment() <span class=\"hljs-comment\">//c.Increment() is converted to (&#x26;c).Increment()</span>\n\tfmt.Println(c.String())\n}\n</code></pre>\n<p>함수에 포인터 파라미터를 넘길 때와는 달리, Receiver에 <code>&#x26;</code>를 붙이지 않아도 된다.\n위 <code>c.Increment()</code> 부분은 자동으로 <code>(&#x26;c).Increment()</code>로 변환된다.\n아래 코드는 예제의 실행 결과이다.</p>\n<pre><code class=\"hljs language-bash\">total: 0, last updated: 0001-01-01 00:00:00 +0000 UTC\ntotal: 1, last updated: 2022-08-10 17:54:27.046864964 +0900 KST m=+0.000053109\n</code></pre>\n<br>\n<p>이러한 규칙들에 대해 잘 이해하면, 아래 예제의 실행 결과도 알 수 있을 것이다.</p>\n<pre><code class=\"hljs language-go\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">doUpdateWrong</span><span class=\"hljs-params\">(c Counter)</span></span> {\n    c.Increment()\n    fmt.Println(<span class=\"hljs-string\">\"in doUpdateWrong:\"</span>, c.String())\n}\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">doUpdateRight</span><span class=\"hljs-params\">(c *Counter)</span></span> {\n    c.Increment()\n    fmt.Println(<span class=\"hljs-string\">\"in doUpdateRight:\"</span>, c.String())\n}\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span></span> {\n    <span class=\"hljs-keyword\">var</span> c Counter\n    doUpdateWrong(c)\n    fmt.Println(<span class=\"hljs-string\">\"in main:\"</span>, c.String())\n    doUpdateRight(&#x26;c)\n    fmt.Println(<span class=\"hljs-string\">\"in main:\"</span>, c.String())\n}\n</code></pre>\n<p><code>doUpdateWrong()</code> 함수의 스코프 내에서 <code>c.Increment()</code>를 호출시 <code>c</code>가 변경되고, 그 결과가 이후 출력에서 반영된다.\n하지만 <code>doUpdateWrong()</code> 함수는 파라미터인 <code>Counter</code>를 <em>pass by value</em>로 받았기 때문에 <code>main()</code> 함수로 되돌아왔을 때 변경사항이 유지되지 않는다.\n반면 <code>doUpdateWrong()</code> 함수는 파라미터를 <em>pass by pointer</em>로 받았기에, 변경사항이 유지된다.</p>\n<p>위 예제의 실행 결과는 아래와 같다.</p>\n<pre><code class=\"hljs language-bash\"><span class=\"hljs-keyword\">in</span> doUpdateWrong: total: 1, last updated: 2022-08-11 01:35:23.983808201 +0900 KST m=+0.000097936\n<span class=\"hljs-keyword\">in</span> main: total: 0, last updated: 0001-01-01 00:00:00 +0000 UTC\n<span class=\"hljs-keyword\">in</span> doUpdateRight: total: 1, last updated: 2022-08-11 01:35:23.983813841 +0900 KST m=+0.000103576\n<span class=\"hljs-keyword\">in</span> main: total: 1, last updated: 2022-08-11 01:35:23.983813841 +0900 KST m=+0.000103576\n</code></pre>\n<br>\n<p>이렇게 유저가 정의한 타입에 Method를 통해 <em>Getter</em>나, <em>Pointer Reciver</em>를 이용하여 <em>Setter</em>를 정의할 수는 있다.\n다만 필드에 직접 값을 할당하는 경우가 아니거나, 여러 필드를 한 번의 오퍼레이션으로 처리해야 하는 경우가 아니라면,\nGo에서는 되도록이면 필드값에 직접 접근하는 것을 권장한다.</p>\n<p><br><br></p>\n<p><em>Pointer Reciver</em>는 <code>nil</code> 인스턴스를 다뤄야 할 때 사용할 수 있다.</p>\n<p>다른 언어들의 경우 <code>null</code>이나 <code>None</code> 인스턴스에서 메소드를 호출하면 에러가 발생한다.\nGo에서도 <code>nil</code> 인스턴스에서 메소드를 호출할 때 <em>Value Reciver</em>인 경우에는 <em>panic</em>이 발생하지만, <em>Pointer Reciver</em>인 경우 메소드가 정상적으로 호출된다.\n이 경우, 메소드가 <code>nil</code> 인스턴스를 처리할 수 있게끔 작성되어 있어야 한다.</p>\n<pre><code class=\"hljs language-go\"><span class=\"hljs-keyword\">type</span> IntTree <span class=\"hljs-keyword\">struct</span> {\n\tval         <span class=\"hljs-keyword\">int</span>\n\tleft, right *IntTree\n}\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-params\">(it *IntTree)</span> <span class=\"hljs-title\">Insert</span><span class=\"hljs-params\">(val <span class=\"hljs-keyword\">int</span>)</span> *<span class=\"hljs-title\">IntTree</span></span> {\n\t<span class=\"hljs-keyword\">if</span> it == <span class=\"hljs-literal\">nil</span> { <span class=\"hljs-comment\">// case that handles when the receiver is a nil instance</span>\n\t\t<span class=\"hljs-keyword\">return</span> &#x26;IntTree{val: val} <span class=\"hljs-comment\">// cannot assign its address into receiver directly</span>\n\t}\n\t<span class=\"hljs-keyword\">if</span> val &#x3C; it.val {\n\t\tit.left = it.left.Insert(val)\n\t} <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> val > it.val {\n\t\tit.right = it.right.Insert(val)\n\t}\n\t<span class=\"hljs-keyword\">return</span> it\n}\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-params\">(it *IntTree)</span> <span class=\"hljs-title\">Contains</span><span class=\"hljs-params\">(val <span class=\"hljs-keyword\">int</span>)</span> <span class=\"hljs-title\">bool</span></span> {\n\t<span class=\"hljs-keyword\">switch</span> {\n\t<span class=\"hljs-keyword\">case</span> it == <span class=\"hljs-literal\">nil</span>: <span class=\"hljs-comment\">// case that handles when the receiver is a nil instance</span>\n\t\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">false</span>\n\t<span class=\"hljs-keyword\">case</span> val &#x3C; it.val:\n\t\t<span class=\"hljs-keyword\">return</span> it.left.Contains(val)\n\t<span class=\"hljs-keyword\">case</span> val > it.val:\n\t\t<span class=\"hljs-keyword\">return</span> it.right.Contains(val)\n\t<span class=\"hljs-keyword\">default</span>:\n\t\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-literal\">true</span>\n\t}\n}\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span></span> {\n\t<span class=\"hljs-keyword\">var</span> it *IntTree\n\tit = it.Insert(<span class=\"hljs-number\">5</span>)\n\tit = it.Insert(<span class=\"hljs-number\">3</span>)\n\tit = it.Insert(<span class=\"hljs-number\">10</span>)\n\tit = it.Insert(<span class=\"hljs-number\">2</span>)\n\tfmt.Println(it.Contains(<span class=\"hljs-number\">2</span>))  <span class=\"hljs-comment\">// true</span>\n\tfmt.Println(it.Contains(<span class=\"hljs-number\">12</span>)) <span class=\"hljs-comment\">// false</span>\n}\n</code></pre>\n<p>위 예제는 <code>nil</code> 인스턴스를 핸들링할 수 있는 정수형 바이너리 트리의 예제이다.</p>\n<p><code>IntTree.Contains()</code> 메소드는 현재 receiver가 <code>nil</code>인지에 따라 해당 값이 포함되어 있는가의 여부를 판단하며\n<code>IntTree.Insert()</code> 메소드는 현재 receiver가 <code>nil</code>일 경우 현 위치에 값을 추가한 값을 반환한다.\n단, 이때는 포인터 파라미터를 사용할 때처럼 receiver에 특정 주소값을 할당하여도, 원본 포인터가 변경되지는 않는다.</p>\n<p><br><br></p>\n<h3>Methods and Functions</h3>\n<p>Go에서 메소드는 함수와 유사한 점이 많다.</p>\n<pre><code class=\"hljs language-go\"><span class=\"hljs-keyword\">type</span> Adder <span class=\"hljs-keyword\">struct</span> {\n\tstart <span class=\"hljs-keyword\">int</span>\n}\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-params\">(a Adder)</span> <span class=\"hljs-title\">AddTo</span><span class=\"hljs-params\">(val <span class=\"hljs-keyword\">int</span>)</span> <span class=\"hljs-title\">int</span></span> {\n\t<span class=\"hljs-keyword\">return</span> a.start + val\n}\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span></span> {\n\tmyAdder := Adder{start: <span class=\"hljs-number\">10</span>}\n\tfmt.Println(myAdder.AddTo(<span class=\"hljs-number\">5</span>)) <span class=\"hljs-comment\">// prints 15</span>\n\n\tf1 := myAdder.AddTo           <span class=\"hljs-comment\">// We can also assign the method to a variable or pass it to a parameter of type func(int)int</span>\n\tfmt.Println(f1(<span class=\"hljs-number\">10</span>))           <span class=\"hljs-comment\">// prints 20</span>\n\n\tf2 := Adder.AddTo\n\tfmt.Println(f2(myAdder, <span class=\"hljs-number\">15</span>)) <span class=\"hljs-comment\">// prints 25</span>\n}\n</code></pre>\n<p>함수를 변수에 할당하여 사용할 수 있듯, 위 예제의 <code>f1</code>처럼 메소드도 변수에 할당하여 사용할 수 있다.\n이 때 이 메소드의 타입은 <code>func(int)int</code>가 되며, 이를 <em>method value</em>라 한다.</p>\n<p><em>method value</em>는 <em>closure</em>처럼 파라미터로 넘기거나 할 수도 있다.\n<em>method value</em>를 선언할 때 붙어있던 <em>receiver</em>가 고정되어 있기 때문에, 이를 호출할 경우 해당 <em>receiver</em>가 영향을 받는다.</p>\n<p>위 예제의 <code>f2</code>처럼 그냥 타입명에 메소드를 붙인 것을 변수에 할당할 수도 있다.\n이를 <em>method expression</em>이라 한다. 이 때 이 메소드의 타입은 <code>func(Adder, int) int</code>가 되며, 첫 번째 파라미터가 <em>receiver</em>가 된다.</p>\n<p>이렇게 Go에서는 메소드를 함수처럼 사용할 수 있기에 큰 차이가 없기에 어느 것을 사용해야 할지 혼동이 올 수 있다.\n만약 작성하고자 하는 로직이 입력 파라미터에 의해서만 영향을 받는다면 함수를 사용하는 것이 옳다.\n반면 프로그램이 실행되며 설정되고, 실행 중 계속 바뀌는 어떤 값에 의해 로직이 영향을 받을 수 있다.\n그러한 경우 이 값들은 <code>struct</code>에 저장되어야 하고 메소드를 사용하는 것이 좋다.</p>\n<p><br><br></p>\n<h2>Embedding</h2>\n<hr>\n<p>Go에는 상속이 없지만 <strong>Embedding</strong>을 통해 구조화된 <code>struct</code> 타입을 구성할 수 있다.</p>\n<p>기본적인 예제는 다음과 같다.</p>\n<pre><code class=\"hljs language-go\"><span class=\"hljs-keyword\">type</span> Employee <span class=\"hljs-keyword\">struct</span> {\n\tName <span class=\"hljs-keyword\">string</span>\n\tID   <span class=\"hljs-keyword\">string</span>\n}\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-params\">(e Employee)</span> <span class=\"hljs-title\">Description</span><span class=\"hljs-params\">()</span> <span class=\"hljs-title\">string</span></span> {\n\t<span class=\"hljs-keyword\">return</span> fmt.Sprintf(<span class=\"hljs-string\">\"%s (%s)\"</span>, e.Name, e.ID)\n}\n\n<span class=\"hljs-keyword\">type</span> Manager <span class=\"hljs-keyword\">struct</span> {\n\t<span class=\"hljs-comment\">// Employee as an embedded field</span>\n\tEmployee <span class=\"hljs-comment\">// no name assigned to this filed. only type.</span>\n\tReports  []Employee\n}\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-params\">(m Manager)</span> <span class=\"hljs-title\">FindNewEmployees</span><span class=\"hljs-params\">()</span> []<span class=\"hljs-title\">Employee</span></span> {\n\t<span class=\"hljs-comment\">// do business logic</span>\n\t<span class=\"hljs-keyword\">return</span> m.Reports\n}\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span></span> {\n\tm := Manager{\n\t\tEmployee: Employee{\n\t\t\tName: <span class=\"hljs-string\">\"Bob Bobson\"</span>,\n\t\t\tID:   <span class=\"hljs-string\">\"12345\"</span>,\n\t\t},\n\t\tReports: []Employee{},\n\t}\n\tfmt.Println(m.ID)            <span class=\"hljs-comment\">// prints 12345</span>\n\tfmt.Println(m.Description()) <span class=\"hljs-comment\">// prints Bob Bobson (12345)</span>\n}\n</code></pre>\n<p><code>Manager</code>를 정의할 때 <code>Employee</code>를 필드명 없이 선언해줌으로써, <code>Employee</code>는 <code>Manager</code>의 <strong>Embedded Field</strong>가 된다.\n<code>Manager</code>에서는 <code>Employee</code>의 필드에 접근할 수 있다.</p>\n<br>\n<pre><code class=\"hljs language-go\"><span class=\"hljs-keyword\">type</span> Inner <span class=\"hljs-keyword\">struct</span> {\n    X <span class=\"hljs-keyword\">int</span>\n}\n\n<span class=\"hljs-keyword\">type</span> Outer <span class=\"hljs-keyword\">struct</span> {\n    Inner\n    X <span class=\"hljs-keyword\">int</span>\n}\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span></span> {\n\to := Outer{\n\t\tInner: Inner{\n\t\t\tX: <span class=\"hljs-number\">10</span>,\n\t\t},\n\t\tX: <span class=\"hljs-number\">20</span>,\n\t}\n\tfmt.Println(o.X)       <span class=\"hljs-comment\">// prints 20</span>\n\tfmt.Println(o.Inner.X) <span class=\"hljs-comment\">// prints 10</span>\n}\n</code></pre>\n<p>위 예제처럼 <em>Embedding</em>된 구조체의 내부와 외부 양쪽에 동일한 필드명을 가진 상황이 생길 수 있다.</p>\n<p>이러한 경우, <code>Outer</code>에 있는 <code>Inner</code> 내부에 위치한 X에 접근하려고 할 때는 <code>Inner</code>를 명시해줘야 한다.</p>\n<p><br><br></p>\n<p><em>Embedding</em>은 다른 언어에서 찾기 힘든, 흔치 않은 개념이다. 그래서 구조적으로 비슷한 상속과 연관지어서 생각하곤 하는데, <em>Embedding</em>은 상속과는 명백하게 다르다.</p>\n<br>\n<p>위 <code>Manager</code>와 <code>Employee</code> 예제에 이어서, 아래 예제도 살펴보자.</p>\n<pre><code class=\"hljs language-go\"><span class=\"hljs-keyword\">var</span> m Manager := {<span class=\"hljs-comment\">/*fields*/</span>}\n<span class=\"hljs-keyword\">var</span> eFail Employee = m\t\t\t<span class=\"hljs-comment\">// complie error</span>\n<span class=\"hljs-keyword\">var</span> eOk Employee = m.Employee   <span class=\"hljs-comment\">// successfully compiled</span>\n</code></pre>\n<p>만약 상속이었다면 위 <code>var eFail Employee = m</code> 라인이 정상적으로 컴파일되었을 것이다.\n<code>Manager</code>를 <code>Employee</code>의 하위 개념으로 보기 때문.\n하지만 <em>Embedding</em>은 상속과는 차이가 있기 때문에 에러가 발생한다.</p>\n<br>\n<p>Go는 상속을 지원하지 않기 때문에 폴리모피즘과는 거리가 있고, <strong>Dynamic Dispatch</strong>(동적 디스패치)도 존재하지 않는다.</p>\n<pre><code class=\"hljs language-go\"><span class=\"hljs-keyword\">type</span> Inner <span class=\"hljs-keyword\">struct</span> {\n\tA <span class=\"hljs-keyword\">int</span>\n}\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-params\">(i Inner)</span> <span class=\"hljs-title\">IntPrinter</span><span class=\"hljs-params\">(val <span class=\"hljs-keyword\">int</span>)</span> <span class=\"hljs-title\">string</span></span> {\n\t<span class=\"hljs-keyword\">return</span> fmt.Sprintf(<span class=\"hljs-string\">\"Inner: %d\"</span>, val) <span class=\"hljs-comment\">// This always call Inner.IntPrinter()</span>\n}\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-params\">(i Inner)</span> <span class=\"hljs-title\">Double</span><span class=\"hljs-params\">()</span> <span class=\"hljs-title\">string</span></span> {\n\t<span class=\"hljs-keyword\">return</span> i.IntPrinter(i.A * <span class=\"hljs-number\">2</span>)\n}\n\n<span class=\"hljs-keyword\">type</span> Outer <span class=\"hljs-keyword\">struct</span> {\n\tInner\n\tS <span class=\"hljs-keyword\">string</span>\n}\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-params\">(o Outer)</span> <span class=\"hljs-title\">IntPrinter</span><span class=\"hljs-params\">(val <span class=\"hljs-keyword\">int</span>)</span> <span class=\"hljs-title\">string</span></span> {\n\t<span class=\"hljs-keyword\">return</span> fmt.Sprintf(<span class=\"hljs-string\">\"Outer: %d\"</span>, val)\n}\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span></span> {\n\to := Outer{\n\t\tInner: Inner{\n\t\t\tA: <span class=\"hljs-number\">10</span>,\n\t\t},\n\t\tS: <span class=\"hljs-string\">\"Hello\"</span>,\n\t}\n\n\tfmt.Println(o.Double())\n}\n</code></pre>\n<pre><code class=\"hljs language-bash\">Inner: 20\n</code></pre>\n<p>위 예제에서 <code>o.Double()</code>를 호출하면 겹치는 메소드명이 없기 때문에 <code>o.Inner.Double()</code>가 자동 호출된다.\n이 때 <code>o.Inner.Double()</code> 내부에서는 <code>o.Inner.IntPrinter()</code>를 호출하기 때문에, <code>Inner: 20</code>가 출력된 것이다.\n이렇듯 Go에서 메소드는 전혀 오버라이딩되지 않는다.</p>\n<p><br><br></p>\n<h2>Interface</h2>\n<hr>\n<p>책에서는 Go의 진정한 꽃이 Goroutine을 위시한 Concurrency가 아니라, 이 <em>Interface</em>라고 하는데, 대체 얼마나 맛집이기에..</p>\n<p>설명에 앞서 인터페이스는 아래와 같이 정의할 수 있다.</p>\n<pre><code class=\"hljs language-go\"><span class=\"hljs-keyword\">type</span> Stringer <span class=\"hljs-keyword\">interface</span> {\n\tString() <span class=\"hljs-keyword\">string</span>\n}\n</code></pre>\n<p><code>struct</code>를 정의하는 것과 큰 차이는 없는 것 같다.\n암묵적인 룰이 하나 있는데, 인터페이스의 이름은 대개 \"er\"로 끝난다.\n그 예로 <code>fmt.Stringer</code>, <code>io.Reader</code>, <code>io.Closer</code>, <code>io.ReadCloser</code>, <code>json.Marshaler</code>, <code>http.Handler</code> 등등이 있다.</p>\n<br>\n<p><em>Interface</em>는 객체지향의 <em>Abstract Class</em>와 유사하지만, 차이점이 있다.\n다른 객체지향 언어에서는 <em>Abstract Class</em>에서 선언된 메소드 등을 <em>Concrete Class</em>에서 구현한다.</p>\n<p>반면 Go의 인터페이스는 <span style=\"background-color: #FFF5B1\">암묵적</span>인 개념이다.\n<em>Concrete Type</em>에서는 인터페이스를 구현한다고 선언하지 않는다.\n만약 <em>Concrete Type</em>에서 구현하는 메소드들이 인터페이스에서 선언된 모든 메소드들을 포함한다면,\n그 때 <em>Concrete Type</em>가 인터페이스를 구현한다고 할 수 있으며, 이래서 암묵적이라는 표현을 사용하는 듯 하다.\n그래서 Go에서는 <em>Concrete Type</em>을 인터페이스에 할당한다는 느낌으로 받아들여야 하는 것 같다.</p>\n<p><em>Interface</em> 덕에 Type-Safe, 디커플링, 정적/동적 언어에서 기능을 연결하는 것이 가능해진다고 하는데, 이건 좀 더 해봐야 알 듯 하다.</p>\n<p>Javascript, Python 등의 동적 타입 언어에서는 인터페이스가 없는 대신 <em>Duck Typing</em>이란 것을 사용한다.\n<em>Duck Typing</em>은 어떤 인스턴스가 원하는 메소드(또는 필드)들을 가지고 있다면, 내가 원하는 타입으로 간주한다는 뜻이다.\n프로젝트의 규모가 너무 크거나, 프로젝트가 너무 오래되어서 의존성을 추적하기 어려운 경우 이런 방식을 사용한다.</p>\n<p>주로 정적 타입 언어를 사용하는 개발자라면 이런 방식에 대해 회의적이다.\n인스턴스의 타입을 명시하지 않으면 어떤 타입인지 확인하기도 어려울 것이며, 어떤 기능을 할 수 있을지 예측할 수 없으리라 생각한다.</p>\n<p>반면 Java에서는 다소 패턴이 다르다. 인터페이스의 정의와 구현이 각각 존재하지만, 인터페이스의 정의만 참조된다.\n주로 동적 타입 언어를 사용하는 개발자들은 이 방식에 대해, 인터페이스가 바뀔 때마다 코드를 다시 짜야 하는 불편한 방식이라고 생각한다.</p>\n<br>\n<p>만약 어플리케이션이 잠정적으로 개선될 여지가 있다면 코드에 유연성이 필요하다.\n하지만 코드가 하고 있는 일이 무엇인지에 대해 사람들이 이해할 수 있도록 하는 것도 중요하기에, 코드의 역할과 의존성 등을 명시할 필요도 있다.\nGo의 인터페이스는 양쪽 모두의 입장을 받아들인다.</p>\n<p>아래 예제에서 Interface가 사용된 예시를 확인할 수 있다.</p>\n<pre><code class=\"hljs language-go\"><span class=\"hljs-keyword\">type</span> LogicProvider <span class=\"hljs-keyword\">struct</span>{}\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-params\">(lp LogicProvider)</span> <span class=\"hljs-title\">Process</span><span class=\"hljs-params\">(data <span class=\"hljs-keyword\">string</span>)</span> <span class=\"hljs-title\">string</span></span> {\n\t<span class=\"hljs-comment\">// do some business logic</span>\n\t<span class=\"hljs-keyword\">return</span> data + <span class=\"hljs-string\">\"!\"</span>\n}\n\n<span class=\"hljs-keyword\">type</span> Logic <span class=\"hljs-keyword\">interface</span> {\n\tProcess(data <span class=\"hljs-keyword\">string</span>) <span class=\"hljs-keyword\">string</span>\n}\n\n<span class=\"hljs-keyword\">type</span> Client <span class=\"hljs-keyword\">struct</span> {\n\tL Logic\n}\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-params\">(c Client)</span> <span class=\"hljs-title\">Program</span><span class=\"hljs-params\">()</span></span> {\n\t<span class=\"hljs-comment\">// get data from somewhere</span>\n\tdata := <span class=\"hljs-string\">\"hello world\"</span>\n\trefinedData := c.L.Process(data)\n\tfmt.Println(refinedData)\n}\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span></span> {\n\tc := Client{\n\t\tL: LogicProvider{}, <span class=\"hljs-comment\">// concrete type assigned into Client's interface</span>\n\t}\n\tc.Program()\n}\n</code></pre>\n<p><em>Concrete Type</em> 역할을 하는 <code>LogicProvider</code>가 정의될 때, 이것이 <code>Logic</code>이라는 인터페이스에 관련된 것이라고 선언된 것은 없다.\n<code>Logic</code>과 <code>LogicProvider</code>이 연결되는 것은, <code>Client</code> 인스턴스인 <code>c</code>가 생성될 때이며,\n<code>LogicProvider</code>에는 <code>Logic</code>에서 정의된 것과 동일한 이름의 메소드인 <code>Process()</code>가 존재할 뿐이다.\n따라서 <code>LogicProvider</code>가 <code>Logic</code>이라는 인터페이스를 위한 <em>Concrete Type</em>임을 알 수 있도록, 잘 문서화할 필요가 있다.</p>\n<br>\n<p>Go에서는 <code>io.Reader</code>나 <code>io.Writer</code> 등, 스탠다드 인터페이스도 존재한다.\n스탠다드 인터페이스를 사용하는 것은 <em>decorator</em> 패턴과 유사한데,\n특정 인터페이스의 인스턴스를 받아서 동일한 인터페이스의 다른 인스턴스를 반환하는 <em>Factory Function</em>(객체를 반환하는 함수)를 자주 사용하기 때문.</p>\n<p>아래 예제를 확인하자.</p>\n<pre><code class=\"hljs language-go\">\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">process</span><span class=\"hljs-params\">(r io.Reader)</span> <span class=\"hljs-title\">error</span></span> {\n\t<span class=\"hljs-comment\">// do something</span>\n}\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">openfile</span><span class=\"hljs-params\">(fileName <span class=\"hljs-keyword\">string</span>)</span> <span class=\"hljs-title\">error</span></span> {\n\tr, err := os.Open(fileName)\n\t<span class=\"hljs-keyword\">if</span> err != <span class=\"hljs-literal\">nil</span> {\n\t\t<span class=\"hljs-keyword\">return</span> err\n\t}\n\t<span class=\"hljs-keyword\">defer</span> r.CLose()\n\t<span class=\"hljs-keyword\">return</span> process(r)\n}\n</code></pre>\n<p>위 코드에서 <code>os.Open()</code>에 의해 반환된 <code>os.File</code> 인스턴스는 <code>io.Reader</code> 인터페이스를 충족시킨다.\n따라서 <code>process()</code> 함수 내에서 파일의 데이터를 읽을 수 있다.</p>\n<p>아래 예제는 <code>gzip</code>을 통해 파일을 압축 해제할 수 있는 경우에, <code>gzip</code> 라이브러리를 사용하여 압축 해제하는 예제이다.</p>\n<pre><code class=\"hljs language-go\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">openfile</span><span class=\"hljs-params\">(fileName <span class=\"hljs-keyword\">string</span>)</span> <span class=\"hljs-title\">error</span></span> {\n\tr, err := os.Open(fileName)\n\t<span class=\"hljs-keyword\">if</span> err != <span class=\"hljs-literal\">nil</span> {\n\tr\teturn err\n\t}\n\t<span class=\"hljs-keyword\">defer</span> r.Close()\n\n\tgz, err = gzip.NewReader(r)\n\t<span class=\"hljs-keyword\">if</span> err != <span class=\"hljs-literal\">nil</span> {\n\t\t<span class=\"hljs-keyword\">return</span> err\n\t}\n\t<span class=\"hljs-keyword\">defer</span> gz.Close()\n\t<span class=\"hljs-keyword\">return</span> process(gz)\n}\n</code></pre>\n<p>위처럼 스탠다드 라이브러리의 인터페이스가 코드에 잘 어울릴 것 같으면, 사용하는 것이 좋다.</p>\n<p>예제에서는 <code>gzip</code>으로 압축 해제된 <code>io.Reader</code> 인터페이스의 인스턴스가 <code>gz</code>에 할당되고,\n그 <code>gz</code>가 다시 한번 <code>process()</code>함수에서 <code>io.Reader</code>의 인스턴스가 된다.</p>\n<p>어느 타입의 메소드들이 특정 인터페이스를 충족시키고도 남는 경우,\n즉 인터페이스에 명시된 것 외의 메소드들이 존재한다고 해도 그 타입은 인터페이스를 충족시킨다.\n이 때문에 한 타입이 두 개 이상의 인터페이스를 동시에 충족시킬 수 있다. 이 때 명시된 것 외의 메소드들은 무시한다.\n이를테면 <code>io.File</code> 타입은 <code>io.Reader</code>와 <code>io.Writer</code>를 동시에 충족시킨다.\n즉, <code>io.File</code> 한 가지 타입으로 읽고 쓰기가 동시에, 각각 지원되는 것이다.</p>\n<p><br><br></p>\n<h3>Embedding and Interfaces</h3>\n<p><code>struct</code> 타입을 Embedding하는 것처럼, 인터페이스도 인터페이스 안에 Embedding할 수 있다.\n스탠다드 라이브러리의 <code>io.ReadCloser</code>도 <code>io.Reader</code>와 <code>io.Closer</code>가 임베딩된 것이다.\n아래의 예제와 유사하다.</p>\n<pre><code class=\"hljs language-go\"><span class=\"hljs-keyword\">type</span> Reader <span class=\"hljs-keyword\">interface</span> {\n\tRead(p []<span class=\"hljs-keyword\">byte</span>) (n <span class=\"hljs-keyword\">int</span>, err error)\n}\n\n<span class=\"hljs-keyword\">type</span> Closer <span class=\"hljs-keyword\">interface</span> {\n\tClose() error\n}\n\n<span class=\"hljs-keyword\">type</span> ReadCloser <span class=\"hljs-keyword\">interface</span> {\n\tReader\n\tCloser\n}\n</code></pre>\n<p><br><br></p>\n<h3>Accept Interfaces, Return Structs</h3>\n<p>Go의 빡고수들이 버릇처럼 읊는 말이 <strong>Accept Interfaces, Return Structs</strong>라고 한다.\n이는 함수에 의해 호출되는 로직은 반드시 인터페이스를 통해 호출되어야 하며,\n함수의 결과값은 반드시 concrete type(struct)이어야 한다는 것이다.\n함수의 파라미터로 인터페이스를 받으면 어떤 기능을 사용할 것인지 명시적으로 선언하면서도, flexible함을 동시에 챙길 수 있다.</p>\n<p>만약 API가 (암묵적이어야 할) 인터페이스를 리턴한다면, 디커플링이라는 인터페이스의 장점을 잃는다.\n만약 그렇게 된다면 서드 파티 모듈의 인터페이스에 코드가 종속되는 결과를 낳게 된다.\n대개 서드 파티 인터페이스에 대한 클라이언트의 의존성을 줄이고자 하기 마련이다.\n이를 위해 또다른 인터페이스를 작성한 뒤, 타입 변환을 하는데(의존성 주입, Dependency Injection),\n이는 어플리케이션의 기능을 제약할 수도 있기에 좋은 방법은 아니다.</p>\n<p>인터페이스를 리턴하지 말아야 하는 또 다른 이유는 버전에 관련된 것이다.\nConcrete Type을 리턴하는 경우에는 기존 코드에 새로운 메소드나 필드가 별 문제 없이 추가될 수 있다.\n반면 인터페이스의 경우에는 새로운 메소드를 추가하려면 기존에 존재하는 모든 메소드들의 구현을 업데이트해야 한다.\n따라서 API를 롤백해야 하는 경우에도, major version number를 증가시켜야 한다.</p>\n<p>인터페이스가 정해져 있고 파라미터에 따라서 다른 인스턴스가 나오는 factory function을 짜는 것보다는,\n타입들을 분리하여 concrete type이 반환되는 각각의 함수를 작성하는 것이 좋다.</p>\n<p>웬만하면 인터페이스를 반환하지 않는 것이 좋긴 한데, 가끔 어쩔 수 없이 하는 경우가 있다. 대표적인 예시가 바로 에러이다.\nGo에서는 <code>error</code> 인터페이스를 반환하도록 선언되는 경우가 많다.\n이는 인터페이스가 Go에서 유일하게 사용할 수 있는 추상 유형이며. <code>error</code> 인터페이스의 다른 구현을 사용해야 하는 경우가 많기 때문이다.\n따라서 가능한 모든 옵션을 처리하기 위해 인터페이스를 사용해야 한다.</p>\n<p>다만 이러한 패턴의 잠재적인 문제점이 존재한다.\nconcrete type을 반환하는 경우 Heap 할당이 줄어들기에 가비지 콜렉터의 워크로드가 줄어든다.\n반면 인터페이스를 파라미터로 사용하는 함수의 경우, 각 인터페이스마다 Heap 할당되므로, 가비지 콜렉터가 힘들어한다.\n결국은 더 좋은 성능과 더 좋은 추상화 사이에 trade-off가 존재하는 셈이다.</p>\n<p>그렇기 때문에 되도록이면 코드를 예쁘게, 고치기 편하게 작성하는 것이 좋다.\n그래야 인터페이스로 인한 잠재적인 성능 문제가 발생하여도, 이를 concrete type으로 변경하는 등의 작업을 하기가 쉬워진다.</p>\n<p><br><br></p>\n<h3>Interfaces and nil</h3>\n<p>많이 봐왔듯, <code>nil</code>은 포인터의 Zero value이다.\n마찬가지로 <code>nil</code>은 인터페이스의 Zero value이긴 하지만, Concrete Type들에 비해 간단하지만은 않다.</p>\n<pre><code class=\"hljs language-go\">\t<span class=\"hljs-keyword\">var</span> s *<span class=\"hljs-keyword\">string</span>\n\tfmt.Println(s == <span class=\"hljs-literal\">nil</span>)\n\t<span class=\"hljs-keyword\">var</span> i <span class=\"hljs-keyword\">interface</span>{}\n\tfmt.Println(i == <span class=\"hljs-literal\">nil</span>)\n\ti = s\n\tfmt.Println(i, i == <span class=\"hljs-literal\">nil</span>)\n</code></pre>\n<pre><code class=\"hljs language-bash\">&#x3C;nil> <span class=\"hljs-literal\">true</span>\n&#x3C;nil> <span class=\"hljs-literal\">true</span>\n&#x3C;nil> <span class=\"hljs-literal\">false</span>\n</code></pre>\n<p>Go의 인터페이스는 내부적으로 두 쌍의 포인터로 구성되며, 각각 타입, 값을 가리킨다.\n만약 타입을 가리키는 포인터가 <code>nil</code>이 아니라면, 인터페이스는 <code>nil</code>이 아닌 것이다. 출력 결과의 세 번째 라인이 저 모양인 것이 이 때문.</p>\n<p>인터페이스에 할당된 concrete type에 따라 호출되는 메소드가 달라지듯, 인터페이스에서 <code>nil</code>은 메소드를 호출할 수 있는지 여부를 나타낸다.\n만약 인터페이스가 <code>nil</code>임에도 메소드를 호출하였다면, <em>panic</em>이 발생한다.\n만약 인터페이스가 <code>nil</code>이 아닌데 메소드를 호출하였다면, 메소드를 호출하려고 시도할 것이다.\n(다만 위 예제와 같은 경우 인터페이스에 연결된 값이 <code>nil</code>이기 때문에, 곧바로 <em>panic</em>이 발생할 것이다.)</p>\n<p>인터페이스 인스턴스의 타입을 나타내는 포인터가 <code>nil</code>이 아니라면, 이는 <code>nil</code>이 아닌 것이다.\n그렇다고 해서 이 인터페이스의 값이 <code>nil</code>인지는 확실하게 알 수 없기 때문에, 나중에 나올 <em>Reflection</em>을 사용해야 한다.</p>\n<p><br><br></p>\n<h3>The Empty Interface Says Nothing</h3>\n<p>정적 타입 언어에서도 아무 타입이나 다 집어넣을 수 있는 변수가 필요할 때가 있다.\n그러한 경우, Go에서는 <code>interface{}</code>를 사용할 수 있다.</p>\n<pre><code class=\"hljs language-go\"><span class=\"hljs-keyword\">var</span> i <span class=\"hljs-keyword\">interface</span>{} <span class=\"hljs-comment\">// empty interfece variable can store a value of any type</span>\n\ni = <span class=\"hljs-number\">20</span>\nfmt.Println(i)\n\ni = <span class=\"hljs-string\">\"hello\"</span>\nfmt.Println(i)\n\ni = <span class=\"hljs-keyword\">struct</span> {\n\tFirstName <span class=\"hljs-keyword\">string</span>\n\tLastName  <span class=\"hljs-keyword\">string</span>\n}{<span class=\"hljs-string\">\"Fred\"</span>, <span class=\"hljs-string\">\"Fredson\"</span>}\nfmt.Println(i)\n</code></pre>\n<p>비어 있는 인터페이스는 말 그대로 아무 값이나 다 저장할 수 있다.\n인터페이스가 비어 있다는 말은 0개 이상의 메소드가 있는 타입들을 가리킬 수 있다는 뜻이며,\n그래서 메소드가 없는 <code>int</code>, <code>string</code> 등의 Primitive Type들도 저장이 가능해진다.</p>\n<br>\n<p>비어 있는 인터페이스가 사용되는 예 중 하나는, JSON처럼 외부 소스에서 읽어온 불분명한 스키마의 placeholder로 사용하는 것이다.</p>\n<pre><code class=\"hljs language-go\">data := <span class=\"hljs-keyword\">map</span>[<span class=\"hljs-keyword\">string</span>]<span class=\"hljs-keyword\">interface</span>{}{}\n\ncontents, err := ioutil.ReadFile(<span class=\"hljs-string\">\"testdata/sample.json\"</span>)\n<span class=\"hljs-keyword\">if</span> err != <span class=\"hljs-literal\">nil</span> {\n    <span class=\"hljs-keyword\">return</span> err\n}\n<span class=\"hljs-keyword\">defer</span> contents.Close()\n\njson.Unmarshal(contents, &#x26;data)\n</code></pre>\n<p>위 코드를 실행하면 JSON 데이터가 <code>data</code> 변수에 저장된다.</p>\n<br>\n<p>또 다른 경우에는, 유저가 만든 자료구조에서 다양한 타입의 값을 저장하기 위해 사용된다.\nGo의 <code>slice</code>, <code>map</code> 등 타입들은 한 가지 타입밖에 저장하지 못하는데 비해, <code>interface{}</code>는 여러 타입을 가리킬 수 있기 때문.</p>\n<pre><code class=\"hljs language-go\"><span class=\"hljs-keyword\">type</span> LinkedList <span class=\"hljs-keyword\">struct</span> {\n    Value <span class=\"hljs-keyword\">interface</span>{}\n    Next    *LinkedList\n}\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-params\">(ll *LinkedList)</span> <span class=\"hljs-title\">Insert</span><span class=\"hljs-params\">(pos <span class=\"hljs-keyword\">int</span>, val <span class=\"hljs-keyword\">interface</span>{})</span> *<span class=\"hljs-title\">LinkedList</span></span> {\n    <span class=\"hljs-keyword\">if</span> ll == <span class=\"hljs-literal\">nil</span> || pos == <span class=\"hljs-number\">0</span> {\n        <span class=\"hljs-keyword\">return</span> &#x26;LinkedList{\n            Value: val,\n            Next:    ll,\n        }\n    }\n    ll.Next = ll.Next.Insert(pos<span class=\"hljs-number\">-1</span>, val)\n    <span class=\"hljs-keyword\">return</span> ll\n}\n</code></pre>\n<p>위 코드는 러프한 예시니까 실제로 사용하지는 말자.</p>\n<p>또 다른 사용예로는 함수의 파라미터로 <code>interface{}</code>를 받는 경우인데, <em>reflection</em>을 하기 위해 사용한다고 하는 것 같다.\n<em>reflection</em>은 나중에 나온다!</p>\n<br>\n<p>근데 <code>interface{}</code>를 되도록이면 사용하지 않는 게 좋다.\nGo는 기본적으로 정적 타입 언어로 디자인된 언어인 만큼, <code>interface{}</code>로 여러 타입들을 쑤시고 다니는 건 좋지 않다.\n<code>interface{}</code>를 사용하여 값들을 저장해야 할 상황에서, 값을 다시 읽어오려면 어떻게 해야 할까?\n그럴 때 바로 아래에서 설명할 <em>Type Assertions</em> 및 <em>Type Switches</em>를 사용해 보자.</p>\n<p><br><br></p>\n<h3>Type Assertions and Type Switches</h3>\n<p>Go에는 어떤 변수의 인터페이스가 가리키는 타입이 특정한 Concrete Type인지,\n혹은 Concrete Type이 또 다른 인터페이스를 구현하는지 확인할 수 있는 두 가지 방법이 있다.</p>\n<p>한 가지가 바로 <strong>Type Assertion</strong>이다.\n이는 어떤 인터페이스를 구현하는 Concrete Type에 이름을 붙이거나,\n또는 이 인터페이스를 구현하고 있는 Concrete Type이 구현하는 또 다른 인터페이스에 이름을 붙인다.</p>\n<pre><code class=\"hljs language-go\"><span class=\"hljs-keyword\">type</span> MyInt <span class=\"hljs-keyword\">int</span>\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span></span> {\n    <span class=\"hljs-keyword\">var</span> i <span class=\"hljs-keyword\">interface</span>{}\n    <span class=\"hljs-keyword\">var</span> mine MyInt = <span class=\"hljs-number\">20</span>\n    i = mine\n    i2 := i.(MyInt) <span class=\"hljs-comment\">// using type assertion, we can confine the type of concrete type that the interface indicates</span>\n    fmt.Println(i2 + <span class=\"hljs-number\">1</span>)\n}\n</code></pre>\n<p>이렇게 <em>Type Assertion</em>을 사용하여 <code>i</code>가 가리키고 있는 타입을 <code>MyInt</code>로 한정할 수 있다.\n위 예제에서 변수 <code>i2</code>의 타입은 <code>MyInt</code>가 된다.</p>\n<br>\n<p>만약 잘못된 타입으로 <em>Type Assertion</em>을 하면 <em>panic</em>이 발생한다.</p>\n<pre><code class=\"hljs language-go\">i3 := i.(<span class=\"hljs-keyword\">string</span>) <span class=\"hljs-comment\">// this line occurs a panic</span>\nfmt.Println(i3)\n</code></pre>\n<br>\n<p><code>int</code>와 <code>MyInt</code>는 본질적으론 같은 타입이지만, Go는 타입에 엄격하기 때문에 <em>Type Assertion</em>을 사용할 때 Concrete Type끼리 일치시켜주어야 한다.\n따라서 아래와 같은 예제는 <em>panic</em>이 발생한다.</p>\n<pre><code class=\"hljs language-go\">i4 := i.(<span class=\"hljs-keyword\">int</span>) <span class=\"hljs-comment\">// this line also occurs a panic</span>\nfmt.Println(i4)\n</code></pre>\n<br>\n<p><code>map</code>을 사용할 때 보았던 <em>comma ok idiom</em>을 사용하여 panic을 회피할 수 있다.</p>\n<pre><code class=\"hljs language-go\"><span class=\"hljs-comment\">// ok is set to true if the type conversion was successful.</span>\n<span class=\"hljs-comment\">// if it was not, ok is set to false and the other value is set to its zero value</span>\ni5, ok := i.(<span class=\"hljs-keyword\">int</span>) <span class=\"hljs-comment\">// i5 is set to 0, ok is set to false</span>\n<span class=\"hljs-keyword\">if</span> !ok {\n\tmsg := fmt.Errorf(<span class=\"hljs-string\">\"unexpected type for %v\"</span>, i5)\n\tfmt.Println(msg)\n}\n\ni6, ok := i.(MyInt)\n<span class=\"hljs-keyword\">if</span> !ok { <span class=\"hljs-comment\">// i6 is set to 20, ok is set to true</span>\n\t<span class=\"hljs-comment\">// this block is not reached</span>\n\tmsg := fmt.Errorf(<span class=\"hljs-string\">\"unexpected type for %v\"</span>, i6)\n\tfmt.Println(msg)\n}\n</code></pre>\n<p><code>map</code>에서 봤던 패턴과 유사하다.\n<em>Type Assertion</em>에 성공하면 변수 <code>ok</code>는 <code>true</code>가 되며, 나머지 변수는 인터페이스가 가리키는 값으로 초기화된다.<br>\n반면 실패하면 <code>ok</code>는 <code>false</code>가 되며, 나머지 변수는 해당 타입의 Zero value로 초기화된다.</p>\n<p>그렇게 얻은 <code>ok</code> 변수값을 통해 이를 <code>if</code>문으로 처리할 수는 있지만\nGo에서는 에러 핸들링을 통해 처리하는 것을 더 지향한다는 것 같다. 에러 핸들링은 다음 챕터에서 나온다!</p>\n<p>어찌 됐든, 인터페이스가 가리키고 있는 데이터의 타입이 확실하다고 생각해도 되도록이면 <em>comma ok idiom</em>를 쓰는 것이 좋다.\n다른 사람이나 미래의 내가 언제 이 코드를 다시 사용할 지도 모르는 일이며, 코드를 조금 수정했는데 런타임 에러가 날 수도 있으니 말이다.</p>\n<p><br><br></p>\n<p>어느 인터페이스의 타입에 여러 개의 후보군이 있다면, <em>Type Switch</em>를 써보도록 하자.</p>\n<pre><code class=\"hljs language-go\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">typeSwitch</span><span class=\"hljs-params\">(i <span class=\"hljs-keyword\">interface</span>{})</span></span> {\n\t<span class=\"hljs-keyword\">switch</span> i.(<span class=\"hljs-keyword\">type</span>) {\n\t<span class=\"hljs-keyword\">case</span> <span class=\"hljs-literal\">nil</span>:\n\t\tfmt.Println(<span class=\"hljs-string\">\"nil\"</span>)\n\t<span class=\"hljs-keyword\">case</span> <span class=\"hljs-keyword\">int</span>:\n\t\tfmt.Println(<span class=\"hljs-string\">\"int\"</span>)\n\t<span class=\"hljs-keyword\">case</span> MyInt:\n\t\tfmt.Println(<span class=\"hljs-string\">\"MyInt\"</span>)\n\t<span class=\"hljs-keyword\">case</span> <span class=\"hljs-keyword\">string</span>:\n\t\tfmt.Println(<span class=\"hljs-string\">\"string\"</span>)\n\t<span class=\"hljs-keyword\">case</span> <span class=\"hljs-keyword\">bool</span>, <span class=\"hljs-keyword\">rune</span>:\n\t\tfmt.Println(<span class=\"hljs-string\">\"bool or rune\"</span>)\n\t<span class=\"hljs-keyword\">default</span>:\n\t\tfmt.Println(<span class=\"hljs-string\">\"what is this\"</span>)\n\t}\n}\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span></span> {\n\t<span class=\"hljs-keyword\">var</span> a <span class=\"hljs-keyword\">int</span> = <span class=\"hljs-number\">12</span>\n\t<span class=\"hljs-keyword\">var</span> b MyInt = <span class=\"hljs-number\">23</span>\n\t<span class=\"hljs-keyword\">var</span> c *<span class=\"hljs-keyword\">string</span>\n\td := <span class=\"hljs-string\">\"asdasd\"</span>\n\te := <span class=\"hljs-keyword\">map</span>[<span class=\"hljs-keyword\">string</span>]<span class=\"hljs-keyword\">string</span>{\n\t\t<span class=\"hljs-string\">\"hi\"</span>: <span class=\"hljs-string\">\"there\"</span>,\n\t}\n\t<span class=\"hljs-keyword\">var</span> f <span class=\"hljs-keyword\">interface</span>{}\n\n\ttypeSwitch(a)\n\ttypeSwitch(b)\n\ttypeSwitch(c)\n\ttypeSwitch(d)\n\ttypeSwitch(e)\n\ttypeSwitch(f)\n}\n</code></pre>\n<pre><code class=\"hljs language-bash\">int\nMyInt\nwhat is this\nstring\nwhat is this\nnil\n</code></pre>\n<p>기본적으로 형태는 boolean 표현식이 사용되지 않는 일반적인 <code>switch</code>문의 형태와 유사하다.\n다만 switch문 이후에 <code>i.(type)</code>로, 인터페이스의 타입을 나타내어 주면 된다.\n이렇게 각 case문에 타입을 할당함으로써, 인터페이스의 타입에 따라 처리할 수 있다.</p>\n<p>실행 결과를 보면 대충 알 수 있겠지만, 3번째 줄의 경우 주의해야 할 것 같다.\n변수 <code>c</code>는 값이 <code>nil</code>인 것이지, 타입은 <code>nil</code>이 아니라 <code>*string</code>이다.\n실제로 <code>switch</code>문에서 <code>case nil</code>에 걸리는 경우는, 변수 <code>f</code>처럼 인터페이스가 가리키는 대상이 아무 것도 없을 때이다.</p>\n<p>인터페이스가 가리키는 타입에 대해 전혀 모를 경우, <em>reflection</em>을 사용하면 된다고 한다.\n나중에 나온다. 나중에...</p>\n<p><em>Type Assertion</em>과 <em>Type Switch</em>가 꽤나 유용한 기술처럼 보이는데, 자주 사용하면 안된다고 한다.\n웬만하면 함수의 파라미터나 리턴값은 특정한 몇 가지의 타입으로만 지정하는 것이 좋으며, 나머지 다른 타입들은 가능은 하더라도 안되게 해야 한다.\n그렇지 않으면 우리가 짜는 함수가 어떤 타입들을 지원하는지에 대해 정확히 명시하지 못할 수 있다.\n대충 <code>interface{}</code>를 사용하는 걸 지양하라는 말과 일맥상통하는 것 같다. <code>interface{}</code>를 안 쓰면 특정한 타입을 명시할 수밖에 없을 테니 말이다.</p>\n<br>\n<p><em>Type Assertion</em>과 <em>Type Switch</em>가 유용하게 사용되는 예제에 대해 알아보자.</p>\n<p>가장 일반적인 경우, 한 인터페이스가 가리키고 있는 concrete type을 보기 위해 사용되는데,\n이 concrete type은 다른 인터페이스에서도 가리킬 수 있는 경우이다.\n이를테면 <code>io</code> 라이브러리의 <code>io.File</code> 등 여러 타입들은 <code>io.Reader</code>와 <code>io.Writer</code> 두 가지 인터페이스를 모두 만족시킨다.\n그 때 <code>io.Reader</code>가 가리키고 있는 타입이 어떤 타입인지 확인하기 위해 사용할 수 있을 것이다.</p>\n<p><code>io.Copy()</code> 함수는 <code>io.Reader</code>와 <code>io.Writer</code> 인터페이스들을 파라미터로 받아, <code>io.copyBuffer()</code>함수를 실행한다.\n다만 이때 <code>io.Reader</code>의 파라미터가 <code>io.ReaderFrom</code>에서도 사용할 수 있거나, <code>io.Writer</code>의 파라미터가 <code>io.WriterTo</code>에서도 사용할 수 있다면,\n함수 내용 대부분이 생략될 수 있다.</p>\n<pre><code class=\"hljs language-go\"><span class=\"hljs-comment\">// copyBuffer is the actual implementation of Copy and CopyBuffer.</span>\n<span class=\"hljs-comment\">// if buf is nil, one is allocated.</span>\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">copyBuffer</span><span class=\"hljs-params\">(dst Writer, src Reader, buf []<span class=\"hljs-keyword\">byte</span>)</span> <span class=\"hljs-params\">(written <span class=\"hljs-keyword\">int64</span>, err error)</span></span> {\n    <span class=\"hljs-comment\">// If the reader has a WriteTo method, use it to do the copy.</span>\n    <span class=\"hljs-comment\">// Avoids an allocation and a copy.</span>\n    <span class=\"hljs-keyword\">if</span> wt, ok := src.(WriterTo); ok {\n        <span class=\"hljs-keyword\">return</span> wt.WriteTo(dst)\n    }\n    <span class=\"hljs-comment\">// Similarly, if the writer has a ReadFrom method, use it to do the copy.</span>\n    <span class=\"hljs-keyword\">if</span> rt, ok := dst.(ReaderFrom); ok {\n        <span class=\"hljs-keyword\">return</span> rt.ReadFrom(src)\n    }\n    <span class=\"hljs-comment\">// function continues...</span>\n}\n</code></pre>\n<br>\n<p>인터페이스는 API를 업그레이드할때도 사용된다고 한다.\n챕터 12에서 <em>context</em>에 대해 알아볼 텐데, <em>context</em>란 취소를 관리하는 표준적인 방법을 제시하는 파라미터이다.\nGo 버전 1.7부터 생긴 기능인지라, 이전 버전의 데이터베이스 드라이버 등에서는 지원하지 않는다.</p>\n<p>Go 1.8부터는 <code>database/sql/driver</code> 패키지에 기존에 존재하는 인터페이스에 대한 새로운 컨텍스트 인식 유사체가 정의되었다.\n이를테면 <code>StmtExecContext</code> 인터페이스에는 <code>ExecContext</code>라는 메소드가 있다.\n스탠다드 라이브러리 데이터베이스 코드에 <code>Stmt</code> 인터페이스의 타입이 통과될 경우,\n이 타입이 <code>StmtExecContext</code>에도 사용할 수 있는지 확인한다. 만약 그렇다면 <code>ExecContext</code>를 호출한다.\n만약 그렇지 않다면, fallback code를 실행한다.</p>\n<pre><code class=\"hljs language-go\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">ctxDriverStmtExec</span><span class=\"hljs-params\">(ctx context.Context, si driver.Stmt,\n                       nvdargs []driver.NamedValue)</span> <span class=\"hljs-params\">(driver.Result, error)</span></span> {\n    <span class=\"hljs-keyword\">if</span> siCtx, is := si.(driver.StmtExecContext); is {\n        <span class=\"hljs-keyword\">return</span> siCtx.ExecContext(ctx, nvdargs)\n    }\n    <span class=\"hljs-comment\">// fallback code is here</span>\n}\n</code></pre>\n<br>\n<p>이런 optional interface 기능에는 한 가지 단점이 존재한다.\n한 인터페이스로 여러 가지 타입을 사용하여 계층적 구조를 만드는 decorator 패턴을 사용하기 위해 인터페이스가 많이들 사용된다.\n이 때, 어느 optional interface가 이 타입들 중 한 가지라도 사용할 수 있다면, <em>Type Assertion</em>과 <em>Type Switch</em>으로 이를 감지할 수 없다.</p>\n<p>그 예로 <code>bufio</code>라는 표준 라이브러리는 buffered reader를 제공한다.\n이 때 <code>bufio.NewReader()</code> 함수에 <code>io.Reader</code>를 지원하는 타입을 파라미터로 통과시키면, <code>*bufio.Reader</code>를 리턴받는다.\n만약 파라미터로 넘겨진 <code>io.Reader</code>의 타입이 <code>io.ReaderFrom</code>도 지원하는 경우, 이를 buffered reader로 감싸게 되면 최적화가 되지 않는다.</p>\n<p>에러 핸들링 할때도 본 현상인데, 에러는 다른 에러를 감싸는 것을 통해 추가적인 정보를 포함할 수 있다.\n<em>Type Assertion</em>과 <em>Type Switch</em>로는 감싸진 에러를 확인할 수 없기 때문에,\n제대로 핸들링하기 위해 감싸진 에러에 접근하려면 <code>errors.Is()</code>나 <code>errors.As()</code>같은 함수를 사용해야 한다.</p>\n<br>\n<p><em>Type Switch</em>는 인터페이스를 지원하는 타입들이 여러 개 있고, 각 타입마다 다르게 처리해줘야 하는 경우 유용하다.\n그중 가장 유용한 경우는, 유효한 타입이 딱 한 개만 존재하는 경우이다.</p>\n<p>웬만하면 <code>switch</code>문에 <code>default</code>를 반드시 넣어주는 게 좋다.\n인터페이스를 지원하는 타입을 추가했는데 <code>switch</code>문을 업데이트하는 것을 까먹은 경우 <code>default</code> 블록에 걸리므로, 문제를 추적하기 쉬워질 것이다.</p>\n<p><br><br></p>\n<h3>Function Types Are a Bridge to Interfaces</h3>\n<p>Go에서는 함수를 비롯하여 유저가 정의한 타입이라면 어떠한 타입이든 메소드를 추가할 수 있으며, 이는 굉장히 유용하다.</p>\n<p>가장 일반적인 사례는 HTTP 요청을 처리하는 HTTP 핸들러이다. 이는 아래와 같이 인터페이스로 정의되어 있다.</p>\n<pre><code class=\"hljs language-go\"><span class=\"hljs-keyword\">type</span> Handler <span class=\"hljs-keyword\">interface</span> {\n    ServeHTTP(http.ResponseWriter, *http.Request)\n}\n</code></pre>\n<p><code>http.ResponseWriter</code>, <code>*http.Request</code>를 파라미터로 받는 함수들은 <code>HandlerFunc</code>로 타입 변환을 할 수 있다.\n그러면 <code>ServeHTTP()</code>를 호출할 수 있게 되며, <code>http.Handler</code> 인터페이스를 사용할 수 있게 된다.</p>\n<pre><code class=\"hljs language-go\"><span class=\"hljs-keyword\">type</span> HandlerFunc <span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span><span class=\"hljs-params\">(http.ResponseWriter, *http.Request)</span></span>\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-params\">(f HandlerFunc)</span> <span class=\"hljs-title\">ServeHTTP</span><span class=\"hljs-params\">(w http.ResponseWriter, r *http.Request)</span></span> {\n    f(w, r)\n}\n</code></pre>\n<p>이러한 방식을 통해 <code>http.Handler</code>의 인터페이스를 충족시키기만 하면 함수, 메소드, Closure를 HTTP 핸들러로 사용할 수 있다.</p>\n<br>\n<p>Go에서 함수는 가장 중요한 개념인 만큼, 또 다른 함수의 파라미터로 전달된다.\n한편으로, Go에서는 작은 인터페이스를 권장하며, 메소드가 하나 뿐인 인터페이스는 함수의 파라미터로 전달되는 함수를 대체할 수 있다.\n그렇다면 이런 질문이 생길 수 있다. 파라미터인 함수의 타입을 언제 명시해줘야 하며, 언제 인터페이스를 써야 할까?</p>\n<p>만약 함수가 다른 함수들이나, 파라미터가 아닌 state에 의존한다면,\n인터페이스 파라미터를 사용하고 인터페이스에 대한 bridge로써 함수 타입을 정의하는 것이 좋다고 한다.\n이를테면 이는 <code>http</code> 패키지에서 사용하는 방식이다. http 핸들러는 설정해주어야 하는 연쇄적인 함수 호출의 진입점일 가능성이 높다.\n반면 함수가 <code>sort.Slice()</code>처럼 간단한 함수일 경우, 인터페이스보단 그냥 함수를 넘기는 게 좋다고 한다.</p>\n<p><br><br></p>\n<h3>Implicit Interfaces Make Dependency Injection Easier</h3>\n<p><strong>Dependency Injection</strong>이란 코드가 수행하는 기능과 작업을 분명하게 명시해야 한다는 개념이다.\nGo의 인터페이스는 디커플링을 맛깔나게 잘 해줘서 Dependency Injection이 엄청 잘 된다고 한다.\n그래서 다른 언어에서 Dependency Injection를 위해 복잡한 프레임워크를 사용하는 반면,\nGo는 어떠한 외부 라이브러리도 사용하지 않는다.</p>\n<p>Dependency Injection이 어떻게 이루어지는지 보기 위해, 간단한 웹 서버 예제를 만들어보자.</p>\n<pre><code class=\"hljs language-go\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">LogOutput</span><span class=\"hljs-params\">(message <span class=\"hljs-keyword\">string</span>)</span></span> {\n    fmt.Println(message)\n}\n\n<span class=\"hljs-keyword\">type</span> SimpleDataStore <span class=\"hljs-keyword\">struct</span> {\n    userData <span class=\"hljs-keyword\">map</span>[<span class=\"hljs-keyword\">string</span>]<span class=\"hljs-keyword\">string</span>\n}\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-params\">(sds SimpleDataStore)</span> <span class=\"hljs-title\">UserNameForID</span><span class=\"hljs-params\">(userID <span class=\"hljs-keyword\">string</span>)</span> <span class=\"hljs-params\">(<span class=\"hljs-keyword\">string</span>, <span class=\"hljs-keyword\">bool</span>)</span></span> {\n    name, ok := sds.userData[userID]\n    <span class=\"hljs-keyword\">return</span> name, ok\n}\n</code></pre>\n<p>간단한 로깅 함수와 저장을 위한 데이터 타입, 및 데이터 탐색 메소드를 정의하였다.\n<code>SimpleDataStore</code> 인스턴스를 생성하는 factory function을 정의해보자.</p>\n<pre><code class=\"hljs language-go\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">NewSimpleDataStore</span><span class=\"hljs-params\">()</span> <span class=\"hljs-title\">SimpleDataStore</span></span> {\n\t<span class=\"hljs-keyword\">return</span> SimpleDataStore{\n\t\tuserData: <span class=\"hljs-keyword\">map</span>[<span class=\"hljs-keyword\">string</span>]<span class=\"hljs-keyword\">string</span>{\n\t\t\t<span class=\"hljs-string\">\"1\"</span>: <span class=\"hljs-string\">\"Fred\"</span>,\n\t\t\t<span class=\"hljs-string\">\"2\"</span>: <span class=\"hljs-string\">\"Mary\"</span>,\n\t\t\t<span class=\"hljs-string\">\"3\"</span>: <span class=\"hljs-string\">\"Pat\"</span>,\n\t\t},\n\t}\n}\n</code></pre>\n<br>\n<p>이제 유저에게 \"hello\" 또는 \"good bye\"라고 날리는 로직을 작성해 볼 것이다.\n이 로직은 유저에게 접근해야 하므로 접근 대상이 되는 자료구조와, 로깅을 하는 함수에 대한 의존성이 존재한다.\n하지만 우리는 <code>LogOutput()</code>이나 <code>SimpleDataStore</code>에 대한 직접적인 의존성을 만들고 싶지 않다.\n미래에 다른 자료구조나 로깅 함수를 사용할 수도 있기 때문이다.</p>\n<p>바로 이러한 경우, 인터페이스가 적절한 해법이 된다.</p>\n<pre><code class=\"hljs language-go\"><span class=\"hljs-keyword\">type</span> DataStore <span class=\"hljs-keyword\">interface</span> {\n\tUserNameForID(userID <span class=\"hljs-keyword\">string</span>) (<span class=\"hljs-keyword\">string</span>, <span class=\"hljs-keyword\">bool</span>)\n}\n\n<span class=\"hljs-keyword\">type</span> Logger <span class=\"hljs-keyword\">interface</span> {\n\tLog(message <span class=\"hljs-keyword\">string</span>)\n}\n\n<span class=\"hljs-keyword\">type</span> LoggerAdapter <span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span><span class=\"hljs-params\">(message <span class=\"hljs-keyword\">string</span>)</span></span>\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-params\">(lg LoggerAdapter)</span> <span class=\"hljs-title\">Log</span><span class=\"hljs-params\">(message <span class=\"hljs-keyword\">string</span>)</span></span> {\n\tlg(message)\n}\n</code></pre>\n<p><code>LoggerAdapter</code>를 선언해 <code>LogOutput()</code>함수를 <code>Logger</code>에 연결해 주었다.\n이제 우리의 비즈니스 로직은 인터페이스들을 사용하여 자료구조에 접근하고, 로깅을 할 수 있다.</p>\n<p>의존성이 정의되었으니, 비즈니스 로직을 완성해보자.</p>\n<pre><code class=\"hljs language-go\"><span class=\"hljs-keyword\">type</span> SimpleLogic <span class=\"hljs-keyword\">struct</span> {\n\tl  Logger\n\tds DataStore\n}\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-params\">(sl SimpleLogic)</span> <span class=\"hljs-title\">SayHello</span><span class=\"hljs-params\">(userID <span class=\"hljs-keyword\">string</span>)</span> <span class=\"hljs-params\">(<span class=\"hljs-keyword\">string</span>, error)</span></span> {\n\tsl.l.Log(<span class=\"hljs-string\">\"in say hello for \"</span> + userID)\n\tname, ok := sl.ds.UserNameForID(userID)\n\t<span class=\"hljs-keyword\">if</span> !ok {\n\t\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-string\">\"\"</span>, errors.New(<span class=\"hljs-string\">\"unknown user\"</span>)\n\t}\n\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-string\">\"Hello, \"</span> + name, <span class=\"hljs-literal\">nil</span>\n}\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-params\">(sl SimpleLogic)</span> <span class=\"hljs-title\">SayGoodbye</span><span class=\"hljs-params\">(userID <span class=\"hljs-keyword\">string</span>)</span> <span class=\"hljs-params\">(<span class=\"hljs-keyword\">string</span>, error)</span></span> {\n\tsl.l.Log(<span class=\"hljs-string\">\"in say goodbye for \"</span> + userID)\n\tname, ok := sl.ds.UserNameForID(userID)\n\t<span class=\"hljs-keyword\">if</span> !ok {\n\t\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-string\">\"\"</span>, errors.New(<span class=\"hljs-string\">\"unknown user\"</span>)\n\t}\n\t<span class=\"hljs-keyword\">return</span> <span class=\"hljs-string\">\"Goodbye, \"</span> + name, <span class=\"hljs-literal\">nil</span>\n}\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">NewSimpleLogic</span><span class=\"hljs-params\">(l Logger, ds DataStore)</span> <span class=\"hljs-title\">SimpleLogic</span></span> {\n    <span class=\"hljs-keyword\">return</span> SimpleLogic{\n        l:    l,\n        ds: ds,\n    }\n}\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">NewSimpleLogic</span><span class=\"hljs-params\">(l Logger, ds DataStore)</span> <span class=\"hljs-title\">SimpleLogic</span></span> {\n\t<span class=\"hljs-keyword\">return</span> SimpleLogic{\n\t\tl:  l,\n\t\tds: ds,\n\t}\n}\n</code></pre>\n<p><code>Logger</code>와 <code>DataStore</code>를 필드로 갖는 <code>SimpleLogic</code>이라는 <code>struct</code>와, factory function을 정의해주었다.\n이 <code>SimpleLogic</code> 내의 메소드는 다른 concrete type을 레퍼런스하지 않기 때문에, 의존성이 없다.\n그래서 차후 라이브러리를 교체하더라도 인터페이스는 라이브러리와 관련이 없기 때문에 문제가 발생하지 않는다.</p>\n<br>\n<p>이제 <code>/hello</code>라는 엔드포인트를 정의해볼 것이다. 이 엔드포인트에서는 유저의 ID가 같이 오면 인사를 할 것이다.\n<em>Controller</em>에게 인사를 할 로직을 쥐어주기 위해 인터페이스를 만들어주자.</p>\n<pre><code class=\"hljs language-go\"><span class=\"hljs-keyword\">type</span> Logic <span class=\"hljs-keyword\">interface</span> {\n    SayHello(userID <span class=\"hljs-keyword\">string</span>) (<span class=\"hljs-keyword\">string</span>, error)\n}\n</code></pre>\n<p>이 인터페이스는 <code>SimpleLogic</code>을 가리킬 수 있다.\n인터페이스는 클라이언트 코드에서 정의되기 때문에, 수정이 필요하다면 클라이언트 코드에서 수정하면 그만이다.\n따라서 <code>SimpleLogic</code>이 나중에 변경되거나, 혹은 새로운 로직이 추가되더라도 별다른 문제 없이 사용할 수 있다.</p>\n<pre><code class=\"hljs language-go\"><span class=\"hljs-keyword\">type</span> Controller <span class=\"hljs-keyword\">struct</span> {\n\tl     Logger\n\tlogic Logic\n}\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-params\">(c Controller)</span> <span class=\"hljs-title\">SayHello</span><span class=\"hljs-params\">(w http.ResponseWriter, r *http.Request)</span></span> {\n\tc.l.Log(<span class=\"hljs-string\">\"In sayhello\"</span>)\n\tuserID := r.URL.Query().get(<span class=\"hljs-string\">\"user_id\"</span>)\n\tmessage, err := c.logic.SayHello(userID)\n\t<span class=\"hljs-keyword\">if</span> err != <span class=\"hljs-literal\">nil</span> {\n\t\tw.WriteHeader(http.StatusBadRequest)\n\t\tw.Write([]<span class=\"hljs-keyword\">byte</span>(err.Error()))\n\t\t<span class=\"hljs-keyword\">return</span>\n\t}\n\tw.Write([]<span class=\"hljs-keyword\">byte</span>(message))\n}\n\n<span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">NewController</span><span class=\"hljs-params\">(l Logger, logic Logic)</span> <span class=\"hljs-title\">Controller</span></span> {\n\t<span class=\"hljs-keyword\">return</span> Controller{\n\t\tl:     l,\n\t\tlogic: logic,\n\t}\n}\n</code></pre>\n<br>\n<p>마지막으로, <code>main</code> 함수에서 모든 컴포넌트를 연결하고 서버를 열어보자.</p>\n<pre><code class=\"hljs language-go\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span></span> {\n\tl := LoggerAdapter(LogOutput)\n\tds := NewSimpleDataStore()\n\tlogic := NewSimpleLogic(l, ds)\n\tc := NewController(l, logic)\n\thttp.HandleFunc(<span class=\"hljs-string\">\"/hello\"</span>, c.SayHello)\n\thttp.ListenAndServe(<span class=\"hljs-string\">\":8080\"</span>, <span class=\"hljs-literal\">nil</span>)\n}\n</code></pre>\n<p>파일을 실행하여 서버를 연 뒤, 브라우저에서 <code>http://localhost:8080/hello?user_id=1</code> 및 <code>http://localhost:8080/hello?user_id=5</code> 등으로 접속해보자.</p>\n<p><code>http.HandleFunc(\"/hello\", c.SayHello)</code> 라인을 잘 살펴보면, 두 번째 <code>http.HandleFunc()</code>의 두 번째 파라미터로 <code>c.SayHello()</code> 메소드를 보냈다.\n이때 보내진 메소드는 <code>http.Handler</code> 인터페이스를 충족시키는 <code>http.HandlerFunc</code> 타입으로 변환이 된다.\n<code>NewController</code>의 메소드임을 유지한 채로 말이다.</p>\n<p><code>main</code> 함수는 concrete type들이 실제로 선언되는 유일한 영역이다.\n어느 타입 하나를 다른 타입으로 변경하고 싶다면, <code>main</code>에서만 변경해주면 된다.\n이렇게 Dependency Injection을 통해 의존성을 Externalizing함으로써, 코드를 업데이트 할 때 변경해야 할 내용을 최소화할 수 있다.</p>\n<p>Dependency Injection은 테스트를 더 쉽게 할 수 있도록 해주기도 한다.\n환경이 다르더라도, 입출력이 제한된 상황에서 unit test를 하는 것은 코드를 효과적으로 재사용한다.\n이를테면 위 예제에서 logger의 출력을 테스트하려고 한다면, logger의 출력을 capture하는 타입을 주입하고 인터페이스를 충족시켜주기만 하면 된다.</p>\n<br>\n<p>개인적으로는 Dependency Injection이 일단 짜놓으면 편하긴 한데, 직접 짜기에는 너무 복잡하고 양이 많아 보였다.\n그럴 때에는 구글님들이 <a href=\"https://github.com/google/wire\">Wire</a>라는, Dependency Injection을 도와주는 유틸리티가 있는데,\n자동적으로 concrete type 선언 코드를 만들어준다고 하니 필요하다면 잘 사용해보도록 하자.</p>\n<p><br><br></p>\n<h3>Go Isn’t Particularly Object-Oriented</h3>\n<p>Go라는 언어를 특정 스타일로 구분짓기는 어렵다.\n일단 절차지향은 아닌 듯 한데, 메소드 오버라이딩이나 상속도 없어서 객체지향이라기에도 애매하다.\n함수 타입과 closure가 있지만 함수형 언어도 아니다.\n만약 이러한 방법론에 맞춰서 Go 코드를 짜면, 아마 그게 이상적인 Go 코드는 아닐 것이다.</p>\n<p><br><br></p>\n<h2>Refereces</h2>\n<hr>\n<center>\n<p><a href=\"https://learning.oreilly.com/library/view/learning-go/9781492077206/\"><img src=\"https://learning.oreilly.com/covers/urn:orm:book:9781492077206/400w/\" alt=\"\"></a> <br>\n<a href=\"https://learning.oreilly.com/library/view/learning-go/9781492077206/\">Jon Bodner, 『Learning Go』, O'Reilly Media, Inc.</a></p>\n</center>\n<br>\n<p>이번 포스트는 의역이 너무 많아용</p>\n<p>원문 참조하시는 게 좋을듯함</p>\n<p><br><br></p>","category":"Golang"}