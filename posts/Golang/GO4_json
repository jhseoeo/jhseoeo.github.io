{"metadata":{"title":"블록, Shadowing, 흐름 제어문","date":"Jul 27, 2022","excerpt":"Blocks, Shadows, and Control Structures"},"content":"<br>\n<p>본 글은 Golang을 공부하며 주요 내용이라 생각되는 것들을 기록해둔 자료이며, Ubuntu 20.04 LTS 기준으로 작성되었습니다.</p>\n<p><br><br></p>\n<h2>Shadowing</h2>\n<hr>\n<p>Go에서 기본적으로 <code>Block</code>의 개념은 타 언어와 유사하다.\n<code>if</code>, <code>for</code> 등 흐름 제어 키워드들에 의해 중괄호가 시작되고, 해당 중괄호가 닫히는 영역까지를 <code>Block</code>이라 한다.</p>\n<pre><code class=\"hljs language-go\">x1 := <span class=\"hljs-number\">10</span> <span class=\"hljs-comment\">// shadowed variable.</span>\n<span class=\"hljs-keyword\">if</span> x1 > <span class=\"hljs-number\">5</span> {\n    fmt.Println(x1) <span class=\"hljs-comment\">// 10 => x1 is not yet shadowed</span>\n    x1 := <span class=\"hljs-number\">5</span>         <span class=\"hljs-comment\">// shadowing variable. from this line to end of this block</span>\n    fmt.Println(x1) <span class=\"hljs-comment\">// 5 => x1 is shadowed until if-blocks ends</span>\n}\nfmt.Println(x1) <span class=\"hljs-comment\">// 10 => if-block ends. x1 is not shadowed</span>\n</code></pre>\n<p>이전 챕터에서도 다루었지만, Shadowing이 발생하면 해당 블록이 끝날 때까지 Shadowing된 변수에 접근할 수 없다.</p>\n<br>\n<pre><code class=\"hljs language-go\">\t<span class=\"hljs-literal\">true</span>, <span class=\"hljs-keyword\">int</span> := <span class=\"hljs-number\">10</span>, <span class=\"hljs-string\">\"hi\"</span>\n\tfmt := <span class=\"hljs-string\">\"oops\"</span>    <span class=\"hljs-comment\">// fmt is shadowed</span>\n</code></pre>\n<p>이렇게 패키지명이나 <em>universe block</em>의 구분자들을 Shadowing하는 것이 문법적으로는 가능하지만, <strong>절대</strong> 이렇게 하지 않도록 주의하자.</p>\n<br>\n<p>변수가 Shadowing되는 것을 확인할 수 있는 명령어가 존재한다. 외부 모듈이므로 설치 후 사용해주어야 한다.</p>\n<pre><code class=\"hljs language-bash\">go install golang.org/x/tools/go/analysis/passes/shadow/cmd/shadow@latest\nshadow ./..\n</code></pre>\n<p>위와 같이 설치 후, <code>shadow</code> 명령어를 통해 검사를 실시하고자 하는 파일을 지정한다.</p>\n<pre><code class=\"hljs language-bash\">declaration of <span class=\"hljs-string\">\"x\"</span> shadows declaration at line 6\n</code></pre>\n<p><br><br></p>\n<h2>if</h2>\n<hr>\n<p>C 계열 프로그래밍 언어의 <code>if</code>문과 크게 다르지 않다. 특이사항으로는 괄호를 생략한다.</p>\n<pre><code class=\"hljs language-go\">n1 := <span class=\"hljs-number\">7</span>\n<span class=\"hljs-keyword\">if</span> n1 == <span class=\"hljs-number\">0</span> {        <span class=\"hljs-comment\">// there is no parenthesis around the condition</span>\n    fmt.Println(<span class=\"hljs-string\">\"too low\"</span>)\n} <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> n1 > <span class=\"hljs-number\">5</span> {\n    fmt.Println(<span class=\"hljs-string\">\"too big :\"</span>, n1)\n} <span class=\"hljs-keyword\">else</span> {\n    fmt.Println(<span class=\"hljs-string\">\"good :\"</span>, n1)\n}\n</code></pre>\n<br>\n<p>특이사항으로는 <code>if</code>문의 조건 확인 구문 안에서 변수 선언을 동시에 할 수 있다.</p>\n<pre><code class=\"hljs language-go\"><span class=\"hljs-keyword\">if</span> n2 := <span class=\"hljs-number\">4</span>; n2 == <span class=\"hljs-number\">0</span> { <span class=\"hljs-comment\">// both declaring variable and checking condition</span>\n    fmt.Println(<span class=\"hljs-string\">\"too low\"</span>)\n} <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> n2 > <span class=\"hljs-number\">5</span> {\n    fmt.Println(<span class=\"hljs-string\">\"too big :\"</span>, n2)\n} <span class=\"hljs-keyword\">else</span> {\n    fmt.Println(<span class=\"hljs-string\">\"good :\"</span>, n2)\n}\n\n<span class=\"hljs-comment\">// fmt.Println(n2) // it causes error. once a if/else statement ends, n1 is not accessable.</span>\n</code></pre>\n<p>단, 이렇게 선언된 변수는 <code>if</code>문 밖에선 접근할 수 없다.</p>\n<p><br><br></p>\n<h2>for</h2>\n<hr>\n<p>Go의 <code>for</code>문은 4가지 유형이 존재한다.</p>\n<ol>\n<li>일반적인 <code>for</code>문과 유사함 => <code>for(int i = 0; i &#x3C; n; i++) {}</code></li>\n<li>일반적인 while문과 유사함 => <code>while(condition)</code></li>\n<li>무한 루프 => <code>while(True)</code></li>\n<li>range-based의 foreach문 => <code>for(const auto&#x26; element : containor) {}</code></li>\n</ol>\n<p>하나씩 살펴보자.</p>\n<p><br><br></p>\n<h3>The Complete for Statement</h3>\n<pre><code class=\"hljs language-go\"><span class=\"hljs-keyword\">for</span> i := <span class=\"hljs-number\">0</span>; i &#x3C; <span class=\"hljs-number\">10</span>; i++ {\n    fmt.Print(i)\n}\n</code></pre>\n<p><code>if</code>문처럼 괄호를 사용하지 않는다. 또한 변수를 초기화할 때 <code>var</code> 키워드를 사용하지 않고, <code>:=</code> 연산자를 이용하여 초기화해야 한다.</p>\n<br>\n<h3>condition-only statements</h3>\n<pre><code class=\"hljs language-go\">i := <span class=\"hljs-number\">1</span>\n<span class=\"hljs-keyword\">for</span> i &#x3C; <span class=\"hljs-number\">100</span> {\n    fmt.Print(i, <span class=\"hljs-string\">\" \"</span>)\n    i = i * <span class=\"hljs-number\">2</span>\n}\n</code></pre>\n<p>변수의 선언과 증감이 생략된 형태로, 다른 언어의 while문과 유사한 형태이다.</p>\n<br>\n<h3>infinite loop and break, continue statements</h3>\n<pre><code class=\"hljs language-go\">j := <span class=\"hljs-number\">0</span>\n<span class=\"hljs-keyword\">for</span> {\n    <span class=\"hljs-keyword\">if</span> j++; j > <span class=\"hljs-number\">10</span> {\n        <span class=\"hljs-keyword\">break</span> <span class=\"hljs-comment\">// if there is no break statement, loop will last until a keyboard interrupt(ctrl-c) occurs</span>\n    } <span class=\"hljs-keyword\">else</span> <span class=\"hljs-keyword\">if</span> j%<span class=\"hljs-number\">2</span> == <span class=\"hljs-number\">0</span> {\n        <span class=\"hljs-keyword\">continue</span>\n    }\n    fmt.Print(i, <span class=\"hljs-string\">\" \"</span>)\n}\n</code></pre>\n<p><code>for</code> 키워드 이후 아무런 표현식도 오지 않으면 무한루프를 돌게 된다. <code>break</code>문과 <code>contine</code>문도 사용 가능하다.</p>\n<br>\n<h3>for-range loop</h3>\n<pre><code class=\"hljs language-go\"><span class=\"hljs-comment\">// for-range loop (array, slice, string)</span>\nevenVals := []<span class=\"hljs-keyword\">int</span>{<span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">4</span>, <span class=\"hljs-number\">6</span>, <span class=\"hljs-number\">8</span>, <span class=\"hljs-number\">10</span>, <span class=\"hljs-number\">12</span>}\n<span class=\"hljs-keyword\">for</span> i, v := <span class=\"hljs-keyword\">range</span> evenVals {\n    fmt.Println(i, v) <span class=\"hljs-comment\">// i is an key(index) of the data, v is value of the data</span>\n}\n\n<span class=\"hljs-comment\">// ignoring the key in a for-range loop</span>\n<span class=\"hljs-keyword\">for</span> _, v := <span class=\"hljs-keyword\">range</span> evenVals { <span class=\"hljs-comment\">// using underscore(_), we can only access the value</span>\n    fmt.Print(v, <span class=\"hljs-string\">\" \"</span>) <span class=\"hljs-comment\">// if you want, it is also possible to ignore the value by using underscore</span>\n}\n</code></pre>\n<p>다른 언어에 존재하는 <code>for-each</code> 형태의 반복문과 유사한 형태이다. <code>range</code> 키워드를 통해 각각 인덱스와 값에 접근할 수 있다.\n또한 변수 이름을 언더바(<code>_</code>)로 설정하면, 해당 값을 사용하지 않고 넘긴다는 의미가 된다. 적절히 사용할 수 있도록 하자.</p>\n<br>\n<p><code>map</code> 타입에 대해서도 for-range loop를 적용할 수 있다.</p>\n<pre><code class=\"hljs language-go\"><span class=\"hljs-comment\">// for-range loop (map)</span>\nnames := <span class=\"hljs-keyword\">map</span>[<span class=\"hljs-keyword\">string</span>]<span class=\"hljs-keyword\">bool</span>{\n    <span class=\"hljs-string\">\"Fred\"</span>: <span class=\"hljs-literal\">true</span>,\n    <span class=\"hljs-string\">\"Raul\"</span>: <span class=\"hljs-literal\">true</span>,\n    <span class=\"hljs-string\">\"Will\"</span>: <span class=\"hljs-literal\">false</span>,\n}\n\n<span class=\"hljs-keyword\">for</span> k, v := <span class=\"hljs-keyword\">range</span> names {\n    fmt.Println(k, v)\n}\n\n<span class=\"hljs-keyword\">for</span> k := <span class=\"hljs-keyword\">range</span> names { <span class=\"hljs-comment\">// by leave off second variable, it is possible to get key only.</span>\n    fmt.Println(k, names[k])\n}\n</code></pre>\n<p>대충 Python이랑 비슷한 것 같다.</p>\n<br>\n<p><code>string</code>에 대해서도 for-range loop가 가능하다.</p>\n<pre><code class=\"hljs language-go\"><span class=\"hljs-comment\">// for-range loop (string)</span>\nsamples := []<span class=\"hljs-keyword\">string</span>{<span class=\"hljs-string\">\"hello\"</span>, <span class=\"hljs-string\">\"안녕하세요\"</span>}\n\n<span class=\"hljs-keyword\">for</span> _, sample := <span class=\"hljs-keyword\">range</span> samples {\n    <span class=\"hljs-keyword\">for</span> i, r := <span class=\"hljs-keyword\">range</span> sample { <span class=\"hljs-comment\">// it iterates over the runes, not bytes</span>\n        fmt.Println(i, r, <span class=\"hljs-keyword\">string</span>(r)) <span class=\"hljs-comment\">// key is the number of byte from the beginning of the string, type of value is rune</span>\n    }\n}\n</code></pre>\n<p>특이사항은 <code>byte</code> 단위가 아닌 <code>rune</code> 단위로 iterating한다는 것.\n따라서 문자의 크기가 2바이트 이상인 경우, 인덱스가 점프하는 것을 확인할 수 있다.</p>\n<br>\n<p>Go에서의 <code>for</code>문은 <strong>Labeling</strong>을 지원한다.</p>\n<pre><code class=\"hljs language-go\"><span class=\"hljs-function\"><span class=\"hljs-keyword\">func</span> <span class=\"hljs-title\">main</span><span class=\"hljs-params\">()</span></span> {\n\tsamples := []<span class=\"hljs-keyword\">string</span>{<span class=\"hljs-string\">\"hello\"</span>, <span class=\"hljs-string\">\"안녕hello\"</span>}\n\nouter: <span class=\"hljs-comment\">// label of outer for-statements</span>\n\t<span class=\"hljs-keyword\">for</span> _, sample := <span class=\"hljs-keyword\">range</span> samples {\n\t\t<span class=\"hljs-keyword\">for</span> i, r := <span class=\"hljs-keyword\">range</span> sample {\n\t\t\tfmt.Println(i, r, <span class=\"hljs-keyword\">string</span>(r))\n\t\t\t<span class=\"hljs-keyword\">if</span> r == <span class=\"hljs-string\">'l'</span> {\n\t\t\t\t<span class=\"hljs-keyword\">continue</span> outer <span class=\"hljs-comment\">// this leads to continue nested loop</span>\n\t\t\t}\n\t\t}\n\t\tfmt.Println() <span class=\"hljs-comment\">// this line is not reached because all the strings contain 'l', and the process continued outer loop</span>\n\t}\n}\n</code></pre>\n<p>바깥쪽 반복문에 <code>outer</code>라는 Label이 붙어있다.\n그리고 안쪽 반복문에서 <code>continue outer</code>를 통해 <code>for i, r := range sample {}</code> 블록이 아닌, <code>for _, sample := range samples</code> 블록의 시작점으로 되돌아가고 있다.</p>\n<p><br><br></p>\n<h2>switch</h2>\n<hr>\n<p>보통 제한적인 상황에서만 사용되거나 <code>switch</code>문이 없는 다른 언어들과는 달리, Go는 <code>switch</code>문이 엄청 잘되어있다.</p>\n<pre><code class=\"hljs language-go\">words := []<span class=\"hljs-keyword\">string</span>{<span class=\"hljs-string\">\"a\"</span>, <span class=\"hljs-string\">\"cow\"</span>, <span class=\"hljs-string\">\"smile\"</span>, <span class=\"hljs-string\">\"gopher\"</span>, <span class=\"hljs-string\">\"octopus\"</span>, <span class=\"hljs-string\">\"영어싫어\"</span>, <span class=\"hljs-string\">\"\"</span>}\n\n<span class=\"hljs-keyword\">for</span> _, word := <span class=\"hljs-keyword\">range</span> words {\n    <span class=\"hljs-keyword\">switch</span> size := <span class=\"hljs-built_in\">len</span>(word); size { <span class=\"hljs-comment\">// as like if-statements, there is no parenthesis</span>\n    <span class=\"hljs-keyword\">case</span> <span class=\"hljs-number\">1</span>, <span class=\"hljs-number\">2</span>, <span class=\"hljs-number\">3</span>, <span class=\"hljs-number\">4</span>: <span class=\"hljs-comment\">// using comma(,), we can make multiple matches</span>\n        fmt.Println(word, <span class=\"hljs-string\">\"is a short word!\"</span>)\n    <span class=\"hljs-keyword\">case</span> <span class=\"hljs-number\">5</span>:\n        fmt.Println(word, <span class=\"hljs-string\">\"is exactly the right length:\"</span>, size)\n        <span class=\"hljs-keyword\">break</span>                         <span class=\"hljs-comment\">// this makes it exits switch earlier</span>\n        fmt.Println(<span class=\"hljs-string\">\"not be printed\"</span>) <span class=\"hljs-comment\">// because of break above, this line is unreachable</span>\n    <span class=\"hljs-keyword\">case</span> <span class=\"hljs-number\">6</span>, <span class=\"hljs-number\">7</span>, <span class=\"hljs-number\">8</span>, <span class=\"hljs-number\">9</span>: <span class=\"hljs-comment\">// empty case (nothing happened)</span>\n        <span class=\"hljs-comment\">// fallthrough // if keyword `fallthrough` is here, as like other languages, run next case's block</span>\n    <span class=\"hljs-keyword\">default</span>:\n        fmt.Println(word, <span class=\"hljs-string\">\"is a wrong word\"</span>)\n    }\n}\n</code></pre>\n<p>여러 값에 대해 적용되는 <code>case</code>를 설정하려면 컴마(<code>,</code>)로 값들을 구분지어서 나열하면 된다.<br>\n특이사항은 <code>case</code> 블록에서 <code>break</code>를 통한 탈출을 지원하긴 하지만, 다른 언어와 달리 반드시 사용하지 않아도 <code>case</code> 블록이 끝나면 알아서 탈출해준다.\n만약 <code>case</code> 블록이 끝나고 아래 <code>case</code> 블록도 실행되게끔 하고자 하는 경우, <code>fallthrough</code> 키워드를 사용하면 된다 한다. 다만 권장되지는 않는 듯 하다.</p>\n<br>\n<p><code>switch</code>문에 아무런 변수도 할당하지 않는 경우, boolean expression의 true/false 여부에 따라 <code>case</code> 블록이 실행된다. <code>if</code>/<code>else</code>문이랑 비슷한듯.</p>\n<pre><code class=\"hljs language-go\">\t<span class=\"hljs-comment\">// blank switch, break a loop in switch/case statements</span>\nloop: <span class=\"hljs-comment\">// to break in switch/case statement, attach a label to for-statements</span>\n\t<span class=\"hljs-keyword\">for</span> i := <span class=\"hljs-number\">0</span>; i &#x3C; <span class=\"hljs-number\">10</span>; i++ {\n\t\t<span class=\"hljs-keyword\">switch</span> { <span class=\"hljs-comment\">// this is a blank switch. no variable</span>\n\t\t<span class=\"hljs-keyword\">case</span> i%<span class=\"hljs-number\">2</span> == <span class=\"hljs-number\">0</span>: <span class=\"hljs-comment\">// here can be boolean expression</span>\n\t\t\tfmt.Println(i, <span class=\"hljs-string\">\"is even number\"</span>)\n\t\t<span class=\"hljs-keyword\">case</span> i%<span class=\"hljs-number\">3</span> == <span class=\"hljs-number\">0</span>:\n\t\t\tfmt.Println(i, <span class=\"hljs-string\">\"is divisible by 3 but not 2\"</span>)\n\t\t<span class=\"hljs-keyword\">case</span> i%<span class=\"hljs-number\">7</span> == <span class=\"hljs-number\">0</span>:\n\t\t\tfmt.Println(<span class=\"hljs-string\">\"exit the loop\"</span>)\n\t\t\t<span class=\"hljs-keyword\">break</span> loop <span class=\"hljs-comment\">// if this statement is just `break`, it cannot exit the loop. just proceed until the loop ends</span>\n\t\t<span class=\"hljs-keyword\">default</span>:\n\t\t\tfmt.Println(i, <span class=\"hljs-string\">\"is boring\"</span>)\n\t\t}\n\t}\n</code></pre>\n<p><code>case</code>안에서 <code>for</code>문을 탈출하려면 위처럼 <code>break</code>문에 Label을 명시해주어야 한다.</p>\n<p><br><br></p>\n<h2>goto</h2>\n<hr>\n<p>놀랍게도 Go엔 <code>goto</code>가 있다. <code>goto</code> 자체가 가지고 있는 문제점을 해결하기 위해 몇 가지 보완이 이루어진 듯 하다.</p>\n<pre><code class=\"hljs language-go\">\ta := <span class=\"hljs-number\">10</span>\n\t<span class=\"hljs-comment\">// goto skip // cannot jump over variable declaration</span>\n\tb := <span class=\"hljs-number\">20</span>\n\t<span class=\"hljs-keyword\">goto</span> skip\nskip:\n\tc := <span class=\"hljs-number\">30</span>\n\n\tfmt.Println(a, b, c)\n\t<span class=\"hljs-keyword\">if</span> c > a {\n\t\t<span class=\"hljs-comment\">// goto inner // cannot jump into block</span>\n\t}\n\n\t<span class=\"hljs-keyword\">if</span> a &#x3C; b {\n\t\t<span class=\"hljs-keyword\">goto</span> inner\n\tinner:\n\t\tfmt.Println(<span class=\"hljs-string\">\"a is less than b\"</span>)\n\t}\n</code></pre>\n<p><code>goto</code>를 통해 특정 block 안으로 들어가거나, 변수 선언 이전으로 되돌아가거나 할 수는 없다.</p>\n<br>\n<p><code>goto</code>가 유용하게 쓰이는 경우가 한 가지 있다.</p>\n<pre><code class=\"hljs language-go\">    x := rand.Intn(<span class=\"hljs-number\">10</span>)\n\n\t<span class=\"hljs-keyword\">for</span> x &#x3C; <span class=\"hljs-number\">100</span> {\n\t\t<span class=\"hljs-keyword\">if</span> a%<span class=\"hljs-number\">5</span> == <span class=\"hljs-number\">0</span> {\n\t\t\t<span class=\"hljs-keyword\">goto</span> done <span class=\"hljs-comment\">// in this case, instead of using boolean flag, using goto makes code clearer and readable</span>\n\t\t}\n\t\ta = a*<span class=\"hljs-number\">2</span> + <span class=\"hljs-number\">1</span>\n\t}\n\n\tfmt.Println(<span class=\"hljs-string\">\"do something when the loop completes normally\"</span>)\ndone:\n\tfmt.Println(<span class=\"hljs-string\">\"do complicated stuff no matter why we left the loop\"</span>)\n\tfmt.Println(a)\n</code></pre>\n<p>위처럼 flag를 설정하여, flag의 여부에 따라 추가적으로 처리를 해주어야 하는 경우이다.\n이 경우 위처럼 <code>goto</code>를 사용하는 것이 <code>if</code>를 사용하는 것보다 깔끔하다고 한다.</p>\n<p><br><br></p>\n<h2>References</h2>\n<hr>\n<center>\n<p><a href=\"https://learning.oreilly.com/library/view/learning-go/9781492077206/\"><img src=\"https://learning.oreilly.com/covers/urn:orm:book:9781492077206/400w/\" alt=\"\"></a> <br>\n<a href=\"https://learning.oreilly.com/library/view/learning-go/9781492077206/\">Jon Bodner, 『Learning Go』, O'Reilly Media, Inc.</a></p>\n</center>\n<p><br><br></p>","category":"Golang"}