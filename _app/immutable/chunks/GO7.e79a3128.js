import{S as VI,i as JI,s as XI,k as p,a as i,q as t,l as o,c as r,m as l,r as e,h as a,n as k,p as ZI,U as KI,b as u,E as s,M as rC}from"./index.5621e629.js";function QI(lM){let At,pr,Gt,S2,or,lr,cr,ur,Ps,Os,ze,M2,ir,rr,kr,Rs,I2,qe,L2,H2,fr,Aa,cM=`<code class="language-go"><span class="token keyword">type</span> Person <span class="token keyword">struct</span> <span class="token punctuation">&#123;</span>
    FirstName <span class="token builtin">string</span>
    LastName  <span class="token builtin">string</span>
    Age       <span class="token builtin">int</span>
<span class="token punctuation">&#125;</span>
<span class="token keyword">type</span> Score <span class="token builtin">int</span>
<span class="token keyword">type</span> Converter <span class="token keyword">func</span><span class="token punctuation">(</span><span class="token builtin">string</span><span class="token punctuation">)</span> Score
<span class="token keyword">type</span> TeamScores <span class="token keyword">map</span><span class="token punctuation">[</span><span class="token builtin">string</span><span class="token punctuation">]</span>Score
<span class="token keyword">type</span> Employee Person</code>`,dr,Bt,A2,Er,mr,vr,kn,G2,Ve,B2,x2,Je,N2,F2,Xe,W2,U2,_r,Ln,j2,Ze,z2,q2,Ke,V2,J2,yr,Ts,X2,Qe,Z2,K2,br,wr,Cr,Dr,Ss,Ms,Ye,Q2,Pr,xt,Y2,Or,Ga,uM=`<code class="language-go"><span class="token keyword">type</span> HighScore Score
<span class="token keyword">type</span> Employee Person</code>`,Rr,Is,$2,$e,h2,g2,Tr,q,nm,he,sm,am,ge,tm,em,np,pm,om,sp,lm,cm,Sr,Ba,iM=`<code class="language-go"><span class="token comment">// assigning untyped constants is valid</span>
<span class="token keyword">var</span> i <span class="token builtin">int</span> <span class="token operator">=</span> <span class="token number">300</span>
<span class="token keyword">var</span> s Score <span class="token operator">=</span> <span class="token number">100</span>
<span class="token keyword">var</span> hs HighScore <span class="token operator">=</span> <span class="token number">200</span>
hs <span class="token operator">=</span> s                  <span class="token comment">// compilation error!</span>
s <span class="token operator">=</span> i                   <span class="token comment">// compilation error!</span>
s <span class="token operator">=</span> <span class="token function">Score</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span>            <span class="token comment">// ok</span>
hs <span class="token operator">=</span> <span class="token function">HighScore</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span>       <span class="token comment">// ok</span></code>`,Mr,Ir,Lr,Hr,Ls,Hs,ap,um,Ar,Hn,im,tp,rm,km,ep,fm,dm,Gr,xa,rM=`<code class="language-go">	<span class="token keyword">type</span> MailCategory <span class="token builtin">int</span>
	<span class="token keyword">const</span> <span class="token punctuation">(</span>
		Uncategorized MailCategory <span class="token operator">=</span> <span class="token boolean">iota</span> <span class="token comment">// 0</span>
		Personal                          <span class="token comment">// 1</span>
		Spam                              <span class="token comment">// 2</span>
		Social                            <span class="token comment">// 3</span>
		Advertisement                     <span class="token comment">// 4</span>
	<span class="token punctuation">)</span>

	fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>Uncategorized<span class="token punctuation">,</span> Personal<span class="token punctuation">,</span> Spam<span class="token punctuation">,</span> Social<span class="token punctuation">,</span> Advertisement<span class="token punctuation">)</span></code>`,Br,Na,kM='<code class="language-bash"><span class="token number">0</span> <span class="token number">1</span> <span class="token number">2</span> <span class="token number">3</span> <span class="token number">4</span></code>',xr,V,Em,pp,mm,vm,op,_m,ym,lp,bm,wm,cp,Cm,Dm,Nr,Fr,Wr,Fa,fM=`<code class="language-go">	<span class="token keyword">type</span> BitField <span class="token builtin">int</span>
	<span class="token keyword">const</span> <span class="token punctuation">(</span>
		Field1 BitField <span class="token operator">=</span> <span class="token number">1</span> <span class="token operator">&lt;&lt;</span> <span class="token boolean">iota</span> <span class="token comment">// assigned 1</span>
		Field2                      <span class="token comment">// assigned 2</span>
		Field3                      <span class="token comment">// assigned 4</span>
		Field4                      <span class="token comment">// assigned 8</span>
		<span class="token boolean">_</span>                           <span class="token comment">// passed 16</span>
		Field6                      <span class="token comment">// assigned 32</span>
	<span class="token punctuation">)</span>

	fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>Field1<span class="token punctuation">,</span> Field2<span class="token punctuation">,</span> Field3<span class="token punctuation">,</span> Field4<span class="token punctuation">,</span> Field6<span class="token punctuation">)</span></code>`,Ur,us,up,Pm,Om,ip,Rm,Tm,jr,zr,qr,D,Sm,rp,Mm,Im,kp,Lm,Hm,fp,Am,Gm,dp,Bm,xm,Ep,Nm,Fm,mp,Wm,Um,Vr,J,jm,vp,zm,qm,_p,Vm,Jm,yp,Xm,Zm,bp,Km,Qm,Jr,As,Ym,wp,$m,hm,Xr,Zr,Kr,Qr,Gs,Bs,Cp,gm,Yr,$r,hr,fn,nv,Dp,sv,av,Pp,tv,ev,Op,pv,ov,gr,Wa,dM=`<code class="language-go"><span class="token keyword">type</span> Person <span class="token keyword">struct</span> <span class="token punctuation">&#123;</span>
	FirstName <span class="token builtin">string</span>
	LastName  <span class="token builtin">string</span>
	Age       <span class="token builtin">int</span>
<span class="token punctuation">&#125;</span>

<span class="token comment">// defining methods for user-defined type</span>
<span class="token keyword">func</span> <span class="token punctuation">(</span>p Person<span class="token punctuation">)</span> <span class="token function">String</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token builtin">string</span> <span class="token punctuation">&#123;</span> <span class="token comment">// The receiver appears between the keyword func and the name of the method</span>
	<span class="token keyword">return</span> fmt<span class="token punctuation">.</span><span class="token function">Sprintf</span><span class="token punctuation">(</span><span class="token string">"%s %s, age %d"</span><span class="token punctuation">,</span> p<span class="token punctuation">.</span>FirstName<span class="token punctuation">,</span> p<span class="token punctuation">.</span>LastName<span class="token punctuation">,</span> p<span class="token punctuation">.</span>Age<span class="token punctuation">)</span>
<span class="token punctuation">&#125;</span>

<span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
	p <span class="token operator">:=</span> Person<span class="token punctuation">&#123;</span>
		FirstName<span class="token punctuation">:</span> <span class="token string">"Fred"</span><span class="token punctuation">,</span>
		LastName<span class="token punctuation">:</span>  <span class="token string">"Fredson"</span><span class="token punctuation">,</span>
		Age<span class="token punctuation">:</span>       <span class="token number">52</span><span class="token punctuation">,</span>
	<span class="token punctuation">&#125;</span>
    <span class="token comment">// method invocations look familiar to those who have used methods in other languages</span>
	output <span class="token operator">:=</span> p<span class="token punctuation">.</span><span class="token function">String</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
	fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>output<span class="token punctuation">)</span>
<span class="token punctuation">&#125;</span></code>`,nk,Nt,lv,sk,Ft,cv,ak,tk,ek,pk,xs,Ns,Rp,uv,ok,dn,iv,Tp,rv,kv,Sp,fv,dv,Mp,Ev,mv,lk,Ua,Ip,vv,_v,ck,An,is,yv,Lp,bv,wv,Hp,Cv,Dv,Pv,rs,Ov,Ap,Rv,Tv,Gp,Sv,Mv,Iv,ks,Lv,Bp,Hv,Av,xp,Gv,Bv,uk,Rn,Np,xv,Nv,Fp,Fv,Wv,Wp,Uv,jv,ik,rk,kk,ja,EM=`<code class="language-go"><span class="token keyword">type</span> Counter <span class="token keyword">struct</span> <span class="token punctuation">&#123;</span>
	total       <span class="token builtin">int</span>
	lastUpdated time<span class="token punctuation">.</span>Time
<span class="token punctuation">&#125;</span>

<span class="token comment">// pointer receiver should be used when the method modifies the receiver or handles nil instances</span>
<span class="token keyword">func</span> <span class="token punctuation">(</span>c <span class="token operator">*</span>Counter<span class="token punctuation">)</span> <span class="token function">Increment</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
	c<span class="token punctuation">.</span>total<span class="token operator">++</span>
	c<span class="token punctuation">.</span>lastUpdated <span class="token operator">=</span> time<span class="token punctuation">.</span><span class="token function">Now</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">&#125;</span>

<span class="token comment">// value receiver can be used when the method doesn't modify the receiver</span>
<span class="token keyword">func</span> <span class="token punctuation">(</span>c Counter<span class="token punctuation">)</span> <span class="token function">String</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token builtin">string</span> <span class="token punctuation">&#123;</span>
	<span class="token keyword">return</span> fmt<span class="token punctuation">.</span><span class="token function">Sprintf</span><span class="token punctuation">(</span><span class="token string">"total: %d, last updated: %v"</span><span class="token punctuation">,</span> c<span class="token punctuation">.</span>total<span class="token punctuation">,</span> c<span class="token punctuation">.</span>lastUpdated<span class="token punctuation">)</span>
<span class="token punctuation">&#125;</span>

<span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
	<span class="token keyword">var</span> c Counter
	fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>c<span class="token punctuation">.</span><span class="token function">String</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
	<span class="token comment">// Go automatically converts it to a pointer type.</span>
	c<span class="token punctuation">.</span><span class="token function">Increment</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">//c.Increment() is converted to (&amp;c).Increment()</span>
	fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>c<span class="token punctuation">.</span><span class="token function">String</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token punctuation">&#125;</span></code>`,fk,En,zv,Up,qv,Vv,jp,Jv,Xv,zp,Zv,Kv,dk,za,mM=`<code class="language-bash">total: <span class="token number">0</span>, last updated: 0001-01-01 00:00:00 +0000 UTC
total: <span class="token number">1</span>, last updated: <span class="token number">2022</span>-08-10 <span class="token number">17</span>:54:27.046864964 +0900 KST <span class="token assign-left variable">m</span><span class="token operator">=</span>+0.000053109</code>`,Ek,mk,vk,Wt,Qv,_k,qa,vM=`<code class="language-go"><span class="token keyword">func</span> <span class="token function">doUpdateWrong</span><span class="token punctuation">(</span>c Counter<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    c<span class="token punctuation">.</span><span class="token function">Increment</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"in doUpdateWrong:"</span><span class="token punctuation">,</span> c<span class="token punctuation">.</span><span class="token function">String</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token punctuation">&#125;</span>

<span class="token keyword">func</span> <span class="token function">doUpdateRight</span><span class="token punctuation">(</span>c <span class="token operator">*</span>Counter<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    c<span class="token punctuation">.</span><span class="token function">Increment</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"in doUpdateRight:"</span><span class="token punctuation">,</span> c<span class="token punctuation">.</span><span class="token function">String</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token punctuation">&#125;</span>

<span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">var</span> c Counter
    <span class="token function">doUpdateWrong</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span>
    fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"in main:"</span><span class="token punctuation">,</span> c<span class="token punctuation">.</span><span class="token function">String</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
    <span class="token function">doUpdateRight</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>c<span class="token punctuation">)</span>
    fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"in main:"</span><span class="token punctuation">,</span> c<span class="token punctuation">.</span><span class="token function">String</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token punctuation">&#125;</span></code>`,yk,E,qp,Yv,$v,Vp,hv,gv,Jp,n3,s3,Xp,a3,t3,Zp,e3,p3,Kp,o3,l3,Qp,c3,u3,Yp,i3,r3,$p,k3,f3,bk,Ut,d3,wk,Va,_M=`<code class="language-bash"><span class="token keyword">in</span> doUpdateWrong: total: <span class="token number">1</span>, last updated: <span class="token number">2022</span>-08-11 01:35:23.983808201 +0900 KST <span class="token assign-left variable">m</span><span class="token operator">=</span>+0.000097936
<span class="token keyword">in</span> main: total: <span class="token number">0</span>, last updated: 0001-01-01 00:00:00 +0000 UTC
<span class="token keyword">in</span> doUpdateRight: total: <span class="token number">1</span>, last updated: <span class="token number">2022</span>-08-11 01:35:23.983813841 +0900 KST <span class="token assign-left variable">m</span><span class="token operator">=</span>+0.000103576
<span class="token keyword">in</span> main: total: <span class="token number">1</span>, last updated: <span class="token number">2022</span>-08-11 01:35:23.983813841 +0900 KST <span class="token assign-left variable">m</span><span class="token operator">=</span>+0.000103576</code>`,Ck,Dk,Pk,mn,E3,hp,m3,v3,gp,_3,y3,no,b3,w3,Ok,Rk,Tk,Sk,fs,so,C3,D3,ao,P3,O3,Mk,v,R3,to,T3,S3,eo,M3,I3,po,L3,H3,oo,A3,G3,lo,B3,x3,co,N3,F3,uo,W3,U3,Ik,Ja,yM=`<code class="language-go"><span class="token keyword">type</span> IntTree <span class="token keyword">struct</span> <span class="token punctuation">&#123;</span>
	val         <span class="token builtin">int</span>
	left<span class="token punctuation">,</span> right <span class="token operator">*</span>IntTree
<span class="token punctuation">&#125;</span>

<span class="token keyword">func</span> <span class="token punctuation">(</span>it <span class="token operator">*</span>IntTree<span class="token punctuation">)</span> <span class="token function">Insert</span><span class="token punctuation">(</span>val <span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token operator">*</span>IntTree <span class="token punctuation">&#123;</span>
	<span class="token keyword">if</span> it <span class="token operator">==</span> <span class="token boolean">nil</span> <span class="token punctuation">&#123;</span> <span class="token comment">// case that handles when the receiver is a nil instance</span>
		<span class="token keyword">return</span> <span class="token operator">&amp;</span>IntTree<span class="token punctuation">&#123;</span>val<span class="token punctuation">:</span> val<span class="token punctuation">&#125;</span> <span class="token comment">// cannot assign its address into receiver directly</span>
	<span class="token punctuation">&#125;</span>
	<span class="token keyword">if</span> val <span class="token operator">&lt;</span> it<span class="token punctuation">.</span>val <span class="token punctuation">&#123;</span>
		it<span class="token punctuation">.</span>left <span class="token operator">=</span> it<span class="token punctuation">.</span>left<span class="token punctuation">.</span><span class="token function">Insert</span><span class="token punctuation">(</span>val<span class="token punctuation">)</span>
	<span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token keyword">if</span> val <span class="token operator">></span> it<span class="token punctuation">.</span>val <span class="token punctuation">&#123;</span>
		it<span class="token punctuation">.</span>right <span class="token operator">=</span> it<span class="token punctuation">.</span>right<span class="token punctuation">.</span><span class="token function">Insert</span><span class="token punctuation">(</span>val<span class="token punctuation">)</span>
	<span class="token punctuation">&#125;</span>
	<span class="token keyword">return</span> it
<span class="token punctuation">&#125;</span>

<span class="token keyword">func</span> <span class="token punctuation">(</span>it <span class="token operator">*</span>IntTree<span class="token punctuation">)</span> <span class="token function">Contains</span><span class="token punctuation">(</span>val <span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token builtin">bool</span> <span class="token punctuation">&#123;</span>
	<span class="token keyword">switch</span> <span class="token punctuation">&#123;</span>
	<span class="token keyword">case</span> it <span class="token operator">==</span> <span class="token boolean">nil</span><span class="token punctuation">:</span> <span class="token comment">// case that handles when the receiver is a nil instance</span>
		<span class="token keyword">return</span> <span class="token boolean">false</span>
	<span class="token keyword">case</span> val <span class="token operator">&lt;</span> it<span class="token punctuation">.</span>val<span class="token punctuation">:</span>
		<span class="token keyword">return</span> it<span class="token punctuation">.</span>left<span class="token punctuation">.</span><span class="token function">Contains</span><span class="token punctuation">(</span>val<span class="token punctuation">)</span>
	<span class="token keyword">case</span> val <span class="token operator">></span> it<span class="token punctuation">.</span>val<span class="token punctuation">:</span>
		<span class="token keyword">return</span> it<span class="token punctuation">.</span>right<span class="token punctuation">.</span><span class="token function">Contains</span><span class="token punctuation">(</span>val<span class="token punctuation">)</span>
	<span class="token keyword">default</span><span class="token punctuation">:</span>
		<span class="token keyword">return</span> <span class="token boolean">true</span>
	<span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span>

<span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
	<span class="token keyword">var</span> it <span class="token operator">*</span>IntTree
	it <span class="token operator">=</span> it<span class="token punctuation">.</span><span class="token function">Insert</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span>
	it <span class="token operator">=</span> it<span class="token punctuation">.</span><span class="token function">Insert</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span>
	it <span class="token operator">=</span> it<span class="token punctuation">.</span><span class="token function">Insert</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span>
	it <span class="token operator">=</span> it<span class="token punctuation">.</span><span class="token function">Insert</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span>
	fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>it<span class="token punctuation">.</span><span class="token function">Contains</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">)</span>  <span class="token comment">// true</span>
	fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>it<span class="token punctuation">.</span><span class="token function">Contains</span><span class="token punctuation">(</span><span class="token number">12</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment">// false</span>
<span class="token punctuation">&#125;</span></code>`,Lk,Fs,j3,io,z3,q3,Hk,pn,ro,V3,J3,ko,X3,Z3,fo,K3,Q3,Eo,Y3,$3,Ak,Gk,Bk,xk,Ws,Us,mo,h3,Nk,jt,g3,Fk,Xa,bM=`<code class="language-go"><span class="token keyword">type</span> Adder <span class="token keyword">struct</span> <span class="token punctuation">&#123;</span>
	start <span class="token builtin">int</span>
<span class="token punctuation">&#125;</span>

<span class="token keyword">func</span> <span class="token punctuation">(</span>a Adder<span class="token punctuation">)</span> <span class="token function">AddTo</span><span class="token punctuation">(</span>val <span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token builtin">int</span> <span class="token punctuation">&#123;</span>
	<span class="token keyword">return</span> a<span class="token punctuation">.</span>start <span class="token operator">+</span> val
<span class="token punctuation">&#125;</span>

<span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
	myAdder <span class="token operator">:=</span> Adder<span class="token punctuation">&#123;</span>start<span class="token punctuation">:</span> <span class="token number">10</span><span class="token punctuation">&#125;</span>
	fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>myAdder<span class="token punctuation">.</span><span class="token function">AddTo</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment">// prints 15</span>

	f1 <span class="token operator">:=</span> myAdder<span class="token punctuation">.</span>AddTo           <span class="token comment">// We can also assign the method to a variable or pass it to a parameter of type func(int)int</span>
	fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token function">f1</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">)</span>           <span class="token comment">// prints 20</span>

	f2 <span class="token operator">:=</span> Adder<span class="token punctuation">.</span>AddTo
	fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token function">f2</span><span class="token punctuation">(</span>myAdder<span class="token punctuation">,</span> <span class="token number">15</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment">// prints 25</span>
<span class="token punctuation">&#125;</span></code>`,Wk,vn,n5,vo,s5,a5,_o,t5,e5,yo,p5,o5,Uk,N,bo,l5,c5,wo,u5,i5,Co,r5,k5,Do,f5,d5,Po,E5,m5,jk,X,v5,Oo,_5,y5,Ro,b5,w5,To,C5,D5,So,P5,O5,zk,js,R5,Mo,T5,S5,qk,Vk,Jk,Xk,zs,qs,Io,M5,Zk,Kk,Qk,Gn,I5,Lo,L5,H5,Ho,A5,G5,Yk,zt,B5,$k,Za,wM=`<code class="language-go"><span class="token keyword">type</span> Employee <span class="token keyword">struct</span> <span class="token punctuation">&#123;</span>
	Name <span class="token builtin">string</span>
	ID   <span class="token builtin">string</span>
<span class="token punctuation">&#125;</span>

<span class="token keyword">func</span> <span class="token punctuation">(</span>e Employee<span class="token punctuation">)</span> <span class="token function">Description</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token builtin">string</span> <span class="token punctuation">&#123;</span>
	<span class="token keyword">return</span> fmt<span class="token punctuation">.</span><span class="token function">Sprintf</span><span class="token punctuation">(</span><span class="token string">"%s (%s)"</span><span class="token punctuation">,</span> e<span class="token punctuation">.</span>Name<span class="token punctuation">,</span> e<span class="token punctuation">.</span>ID<span class="token punctuation">)</span>
<span class="token punctuation">&#125;</span>

<span class="token keyword">type</span> Manager <span class="token keyword">struct</span> <span class="token punctuation">&#123;</span>
	<span class="token comment">// Employee as an embedded field</span>
	Employee <span class="token comment">// no name assigned to this filed. only type.</span>
	Reports  <span class="token punctuation">[</span><span class="token punctuation">]</span>Employee
<span class="token punctuation">&#125;</span>

<span class="token keyword">func</span> <span class="token punctuation">(</span>m Manager<span class="token punctuation">)</span> <span class="token function">FindNewEmployees</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>Employee <span class="token punctuation">&#123;</span>
	<span class="token comment">// do business logic</span>
	<span class="token keyword">return</span> m<span class="token punctuation">.</span>Reports
<span class="token punctuation">&#125;</span>

<span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
	m <span class="token operator">:=</span> Manager<span class="token punctuation">&#123;</span>
		Employee<span class="token punctuation">:</span> Employee<span class="token punctuation">&#123;</span>
			Name<span class="token punctuation">:</span> <span class="token string">"Bob Bobson"</span><span class="token punctuation">,</span>
			ID<span class="token punctuation">:</span>   <span class="token string">"12345"</span><span class="token punctuation">,</span>
		<span class="token punctuation">&#125;</span><span class="token punctuation">,</span>
		Reports<span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>Employee<span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token punctuation">,</span>
	<span class="token punctuation">&#125;</span>
	fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>m<span class="token punctuation">.</span>ID<span class="token punctuation">)</span>            <span class="token comment">// prints 12345</span>
	fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>m<span class="token punctuation">.</span><span class="token function">Description</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment">// prints Bob Bobson (12345)</span>
<span class="token punctuation">&#125;</span></code>`,hk,y,Ao,x5,N5,Go,F5,W5,Bo,U5,j5,xo,z5,q5,No,V5,J5,Fo,X5,Z5,Wo,K5,Q5,gk,nf,sf,Ka,CM=`<code class="language-go"><span class="token keyword">type</span> Inner <span class="token keyword">struct</span> <span class="token punctuation">&#123;</span>
    X <span class="token builtin">int</span>
<span class="token punctuation">&#125;</span>

<span class="token keyword">type</span> Outer <span class="token keyword">struct</span> <span class="token punctuation">&#123;</span>
    Inner
    X <span class="token builtin">int</span>
<span class="token punctuation">&#125;</span>

<span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
	o <span class="token operator">:=</span> Outer<span class="token punctuation">&#123;</span>
		Inner<span class="token punctuation">:</span> Inner<span class="token punctuation">&#123;</span>
			X<span class="token punctuation">:</span> <span class="token number">10</span><span class="token punctuation">,</span>
		<span class="token punctuation">&#125;</span><span class="token punctuation">,</span>
		X<span class="token punctuation">:</span> <span class="token number">20</span><span class="token punctuation">,</span>
	<span class="token punctuation">&#125;</span>
	fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>o<span class="token punctuation">.</span>X<span class="token punctuation">)</span>       <span class="token comment">// prints 20</span>
	fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>o<span class="token punctuation">.</span>Inner<span class="token punctuation">.</span>X<span class="token punctuation">)</span> <span class="token comment">// prints 10</span>
<span class="token punctuation">&#125;</span></code>`,af,Vs,Y5,Uo,$5,h5,tf,_n,g5,jo,n_,s_,zo,a_,t_,qo,e_,p_,ef,pf,of,lf,ds,Vo,o_,l_,Jo,c_,u_,cf,uf,rf,Bn,i_,Xo,r_,k_,Zo,f_,d_,kf,Qa,DM=`<code class="language-go"><span class="token keyword">var</span> m Manager <span class="token operator">:=</span> <span class="token punctuation">&#123;</span><span class="token comment">/*fields*/</span><span class="token punctuation">&#125;</span>
<span class="token keyword">var</span> eFail Employee <span class="token operator">=</span> m			<span class="token comment">// complie error</span>
<span class="token keyword">var</span> eOk Employee <span class="token operator">=</span> m<span class="token punctuation">.</span>Employee   <span class="token comment">// successfully compiled</span></code>`,ff,Z,E_,Ko,m_,v_,Qo,__,y_,Yo,b_,w_,$o,C_,D_,df,Ef,mf,Js,P_,ho,O_,R_,vf,Ya,PM=`<code class="language-go"><span class="token keyword">type</span> Inner <span class="token keyword">struct</span> <span class="token punctuation">&#123;</span>
	A <span class="token builtin">int</span>
<span class="token punctuation">&#125;</span>

<span class="token keyword">func</span> <span class="token punctuation">(</span>i Inner<span class="token punctuation">)</span> <span class="token function">IntPrinter</span><span class="token punctuation">(</span>val <span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token builtin">string</span> <span class="token punctuation">&#123;</span>
	<span class="token keyword">return</span> fmt<span class="token punctuation">.</span><span class="token function">Sprintf</span><span class="token punctuation">(</span><span class="token string">"Inner: %d"</span><span class="token punctuation">,</span> val<span class="token punctuation">)</span> <span class="token comment">// This always call Inner.IntPrinter()</span>
<span class="token punctuation">&#125;</span>

<span class="token keyword">func</span> <span class="token punctuation">(</span>i Inner<span class="token punctuation">)</span> <span class="token function">Double</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token builtin">string</span> <span class="token punctuation">&#123;</span>
	<span class="token keyword">return</span> i<span class="token punctuation">.</span><span class="token function">IntPrinter</span><span class="token punctuation">(</span>i<span class="token punctuation">.</span>A <span class="token operator">*</span> <span class="token number">2</span><span class="token punctuation">)</span>
<span class="token punctuation">&#125;</span>

<span class="token keyword">type</span> Outer <span class="token keyword">struct</span> <span class="token punctuation">&#123;</span>
	Inner
	S <span class="token builtin">string</span>
<span class="token punctuation">&#125;</span>

<span class="token keyword">func</span> <span class="token punctuation">(</span>o Outer<span class="token punctuation">)</span> <span class="token function">IntPrinter</span><span class="token punctuation">(</span>val <span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token builtin">string</span> <span class="token punctuation">&#123;</span>
	<span class="token keyword">return</span> fmt<span class="token punctuation">.</span><span class="token function">Sprintf</span><span class="token punctuation">(</span><span class="token string">"Outer: %d"</span><span class="token punctuation">,</span> val<span class="token punctuation">)</span>
<span class="token punctuation">&#125;</span>

<span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
	o <span class="token operator">:=</span> Outer<span class="token punctuation">&#123;</span>
		Inner<span class="token punctuation">:</span> Inner<span class="token punctuation">&#123;</span>
			A<span class="token punctuation">:</span> <span class="token number">10</span><span class="token punctuation">,</span>
		<span class="token punctuation">&#125;</span><span class="token punctuation">,</span>
		S<span class="token punctuation">:</span> <span class="token string">"Hello"</span><span class="token punctuation">,</span>
	<span class="token punctuation">&#125;</span>

	fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>o<span class="token punctuation">.</span><span class="token function">Double</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token punctuation">&#125;</span></code>`,_f,$a,OM='<code class="language-bash">Inner: <span class="token number">20</span></code>',yf,I,T_,go,S_,M_,nl,I_,L_,sl,H_,A_,al,G_,B_,tl,x_,N_,bf,wf,Cf,Df,Xs,Zs,el,F_,Pf,Of,Rf,Ks,W_,pl,U_,j_,Tf,qt,z_,Sf,ha,RM=`<code class="language-go"><span class="token keyword">type</span> Stringer <span class="token keyword">interface</span> <span class="token punctuation">&#123;</span>
	<span class="token function">String</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token builtin">string</span>
<span class="token punctuation">&#125;</span></code>`,Mf,b,ol,q_,V_,ll,J_,X_,cl,Z_,K_,ul,Q_,Y_,il,$_,h_,rl,g_,n0,kl,s0,a0,If,Lf,Hf,on,fl,t0,e0,dl,p0,o0,El,l0,c0,ml,u0,i0,Af,L,r0,Vt,k0,f0,vl,d0,E0,_l,m0,v0,yl,_0,y0,bl,b0,w0,Gf,ga,wl,C0,D0,Bf,xn,P0,Cl,O0,R0,Dl,T0,S0,xf,Jt,M0,Nf,Xt,I0,Ff,Wf,Uf,Zt,L0,jf,Kt,H0,zf,nt,TM=`<code class="language-go"><span class="token keyword">type</span> LogicProvider <span class="token keyword">struct</span><span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span>

<span class="token keyword">func</span> <span class="token punctuation">(</span>lp LogicProvider<span class="token punctuation">)</span> <span class="token function">Process</span><span class="token punctuation">(</span>data <span class="token builtin">string</span><span class="token punctuation">)</span> <span class="token builtin">string</span> <span class="token punctuation">&#123;</span>
	<span class="token comment">// do some business logic</span>
	<span class="token keyword">return</span> data <span class="token operator">+</span> <span class="token string">"!"</span>
<span class="token punctuation">&#125;</span>

<span class="token keyword">type</span> Logic <span class="token keyword">interface</span> <span class="token punctuation">&#123;</span>
	<span class="token function">Process</span><span class="token punctuation">(</span>data <span class="token builtin">string</span><span class="token punctuation">)</span> <span class="token builtin">string</span>
<span class="token punctuation">&#125;</span>

<span class="token keyword">type</span> Client <span class="token keyword">struct</span> <span class="token punctuation">&#123;</span>
	L Logic
<span class="token punctuation">&#125;</span>

<span class="token keyword">func</span> <span class="token punctuation">(</span>c Client<span class="token punctuation">)</span> <span class="token function">Program</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
	<span class="token comment">// get data from somewhere</span>
	data <span class="token operator">:=</span> <span class="token string">"hello world"</span>
	refinedData <span class="token operator">:=</span> c<span class="token punctuation">.</span>L<span class="token punctuation">.</span><span class="token function">Process</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span>
	fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>refinedData<span class="token punctuation">)</span>
<span class="token punctuation">&#125;</span>

<span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
	c <span class="token operator">:=</span> Client<span class="token punctuation">&#123;</span>
		L<span class="token punctuation">:</span> LogicProvider<span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token punctuation">,</span> <span class="token comment">// concrete type assigned into Client's interface</span>
	<span class="token punctuation">&#125;</span>
	c<span class="token punctuation">.</span><span class="token function">Program</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">&#125;</span></code>`,qf,f,Pl,A0,G0,Ol,B0,x0,Rl,N0,F0,Tl,W0,U0,Sl,j0,z0,Ml,q0,V0,Il,J0,X0,Ll,Z0,K0,Hl,Q0,Y0,Al,$0,h0,Gl,g0,n4,Bl,s4,a4,xl,t4,e4,Vf,Jf,Xf,K,p4,Nl,o4,l4,Fl,c4,u4,Wl,i4,r4,Ul,k4,f4,Zf,Qt,d4,Kf,st,SM=`<code class="language-go">
<span class="token keyword">func</span> <span class="token function">process</span><span class="token punctuation">(</span>r io<span class="token punctuation">.</span>Reader<span class="token punctuation">)</span> <span class="token builtin">error</span> <span class="token punctuation">&#123;</span>
	<span class="token comment">// do something</span>
<span class="token punctuation">&#125;</span>

<span class="token keyword">func</span> <span class="token function">openfile</span><span class="token punctuation">(</span>fileName <span class="token builtin">string</span><span class="token punctuation">)</span> <span class="token builtin">error</span> <span class="token punctuation">&#123;</span>
	r<span class="token punctuation">,</span> err <span class="token operator">:=</span> os<span class="token punctuation">.</span><span class="token function">Open</span><span class="token punctuation">(</span>fileName<span class="token punctuation">)</span>
	<span class="token keyword">if</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">&#123;</span>
		<span class="token keyword">return</span> err
	<span class="token punctuation">&#125;</span>
	<span class="token keyword">defer</span> r<span class="token punctuation">.</span><span class="token function">CLose</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
	<span class="token keyword">return</span> <span class="token function">process</span><span class="token punctuation">(</span>r<span class="token punctuation">)</span>
<span class="token punctuation">&#125;</span></code>`,Qf,Q,E4,jl,m4,v4,zl,_4,y4,ql,b4,w4,Vl,C4,D4,Yf,Nn,P4,Jl,O4,R4,Xl,T4,S4,$f,at,MM=`<code class="language-go"><span class="token keyword">func</span> <span class="token function">openfile</span><span class="token punctuation">(</span>fileName <span class="token builtin">string</span><span class="token punctuation">)</span> <span class="token builtin">error</span> <span class="token punctuation">&#123;</span>
	r<span class="token punctuation">,</span> err <span class="token operator">:=</span> os<span class="token punctuation">.</span><span class="token function">Open</span><span class="token punctuation">(</span>fileName<span class="token punctuation">)</span>
	<span class="token keyword">if</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">&#123;</span>
	r	eturn err
	<span class="token punctuation">&#125;</span>
	<span class="token keyword">defer</span> r<span class="token punctuation">.</span><span class="token function">Close</span><span class="token punctuation">(</span><span class="token punctuation">)</span>

	gz<span class="token punctuation">,</span> err <span class="token operator">=</span> gzip<span class="token punctuation">.</span><span class="token function">NewReader</span><span class="token punctuation">(</span>r<span class="token punctuation">)</span>
	<span class="token keyword">if</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">&#123;</span>
		<span class="token keyword">return</span> err
	<span class="token punctuation">&#125;</span>
	<span class="token keyword">defer</span> gz<span class="token punctuation">.</span><span class="token function">Close</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
	<span class="token keyword">return</span> <span class="token function">process</span><span class="token punctuation">(</span>gz<span class="token punctuation">)</span>
<span class="token punctuation">&#125;</span></code>`,hf,Yt,M4,gf,P,I4,Zl,L4,H4,Kl,A4,G4,Ql,B4,x4,Yl,N4,F4,$l,W4,U4,hl,j4,z4,n1,Y,q4,gl,V4,J4,nc,X4,Z4,sc,K4,Q4,ac,Y4,$4,s1,a1,t1,e1,Qs,Ys,tc,h4,p1,ln,ec,g4,ny,pc,sy,ay,oc,ty,ey,lc,py,oy,o1,tt,IM=`<code class="language-go"><span class="token keyword">type</span> Reader <span class="token keyword">interface</span> <span class="token punctuation">&#123;</span>
	<span class="token function">Read</span><span class="token punctuation">(</span>p <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">byte</span><span class="token punctuation">)</span> <span class="token punctuation">(</span>n <span class="token builtin">int</span><span class="token punctuation">,</span> err <span class="token builtin">error</span><span class="token punctuation">)</span>
<span class="token punctuation">&#125;</span>

<span class="token keyword">type</span> Closer <span class="token keyword">interface</span> <span class="token punctuation">&#123;</span>
	<span class="token function">Close</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token builtin">error</span>
<span class="token punctuation">&#125;</span>

<span class="token keyword">type</span> ReadCloser <span class="token keyword">interface</span> <span class="token punctuation">&#123;</span>
	Reader
	Closer
<span class="token punctuation">&#125;</span></code>`,l1,c1,u1,i1,$s,hs,cc,ly,r1,gs,cy,uc,uy,iy,k1,$t,ry,f1,ht,ky,d1,gt,fy,E1,Fn,dy,ic,Ey,my,rc,vy,_y,m1,ne,yy,v1,se,by,_1,y1,b1,w1,na,sa,kc,wy,C1,Wn,Cy,fc,Dy,Py,dc,Oy,Ry,D1,et,LM=`<code class="language-go">	<span class="token keyword">var</span> s <span class="token operator">*</span><span class="token builtin">string</span>
	fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>s <span class="token operator">==</span> <span class="token boolean">nil</span><span class="token punctuation">)</span>
	<span class="token keyword">var</span> i <span class="token keyword">interface</span><span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span>
	fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>i <span class="token operator">==</span> <span class="token boolean">nil</span><span class="token punctuation">)</span>
	i <span class="token operator">=</span> s
	fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span> i <span class="token operator">==</span> <span class="token boolean">nil</span><span class="token punctuation">)</span></code>`,P1,pt,HM=`<code class="language-bash"><span class="token operator">&lt;</span>nil<span class="token operator">></span> <span class="token boolean">true</span>
<span class="token operator">&lt;</span>nil<span class="token operator">></span> <span class="token boolean">true</span>
<span class="token operator">&lt;</span>nil<span class="token operator">></span> <span class="token boolean">false</span></code>`,O1,Un,Ty,Ec,Sy,My,mc,Iy,Ly,R1,O,Hy,vc,Ay,Gy,_c,By,xy,yc,Ny,Fy,bc,Wy,Uy,wc,jy,zy,Cc,qy,Vy,T1,$,Jy,Dc,Xy,Zy,Pc,Ky,Qy,Oc,Yy,$y,Rc,hy,gy,S1,M1,I1,L1,aa,ta,Tc,n6,H1,ea,s6,Sc,a6,t6,A1,ot,AM=`<code class="language-go"><span class="token keyword">var</span> i <span class="token keyword">interface</span><span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span> <span class="token comment">// empty interfece variable can store a value of any type</span>

i <span class="token operator">=</span> <span class="token number">20</span>
fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span>

i <span class="token operator">=</span> <span class="token string">"hello"</span>
fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span>

i <span class="token operator">=</span> <span class="token keyword">struct</span> <span class="token punctuation">&#123;</span>
	FirstName <span class="token builtin">string</span>
	LastName  <span class="token builtin">string</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">&#123;</span><span class="token string">"Fred"</span><span class="token punctuation">,</span> <span class="token string">"Fredson"</span><span class="token punctuation">&#125;</span>
fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span></code>`,G1,jn,e6,Mc,p6,o6,Ic,l6,c6,B1,x1,N1,ae,u6,F1,lt,GM=`<code class="language-go">data <span class="token operator">:=</span> <span class="token keyword">map</span><span class="token punctuation">[</span><span class="token builtin">string</span><span class="token punctuation">]</span><span class="token keyword">interface</span><span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span>

contents<span class="token punctuation">,</span> err <span class="token operator">:=</span> ioutil<span class="token punctuation">.</span><span class="token function">ReadFile</span><span class="token punctuation">(</span><span class="token string">"testdata/sample.json"</span><span class="token punctuation">)</span>
<span class="token keyword">if</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">return</span> err
<span class="token punctuation">&#125;</span>
<span class="token keyword">defer</span> contents<span class="token punctuation">.</span><span class="token function">Close</span><span class="token punctuation">(</span><span class="token punctuation">)</span>

json<span class="token punctuation">.</span><span class="token function">Unmarshal</span><span class="token punctuation">(</span>contents<span class="token punctuation">,</span> <span class="token operator">&amp;</span>data<span class="token punctuation">)</span></code>`,W1,pa,i6,Lc,r6,k6,U1,j1,z1,yn,f6,Hc,d6,E6,Ac,m6,v6,Gc,_6,y6,q1,ct,BM=`<code class="language-go"><span class="token keyword">type</span> LinkedList <span class="token keyword">struct</span> <span class="token punctuation">&#123;</span>
    Value <span class="token keyword">interface</span><span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span>
    Next    <span class="token operator">*</span>LinkedList
<span class="token punctuation">&#125;</span>

<span class="token keyword">func</span> <span class="token punctuation">(</span>ll <span class="token operator">*</span>LinkedList<span class="token punctuation">)</span> <span class="token function">Insert</span><span class="token punctuation">(</span>pos <span class="token builtin">int</span><span class="token punctuation">,</span> val <span class="token keyword">interface</span><span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span> <span class="token operator">*</span>LinkedList <span class="token punctuation">&#123;</span>
    <span class="token keyword">if</span> ll <span class="token operator">==</span> <span class="token boolean">nil</span> <span class="token operator">||</span> pos <span class="token operator">==</span> <span class="token number">0</span> <span class="token punctuation">&#123;</span>
        <span class="token keyword">return</span> <span class="token operator">&amp;</span>LinkedList<span class="token punctuation">&#123;</span>
            Value<span class="token punctuation">:</span> val<span class="token punctuation">,</span>
            Next<span class="token punctuation">:</span>    ll<span class="token punctuation">,</span>
        <span class="token punctuation">&#125;</span>
    <span class="token punctuation">&#125;</span>
    ll<span class="token punctuation">.</span>Next <span class="token operator">=</span> ll<span class="token punctuation">.</span>Next<span class="token punctuation">.</span><span class="token function">Insert</span><span class="token punctuation">(</span>pos<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> val<span class="token punctuation">)</span>
    <span class="token keyword">return</span> ll
<span class="token punctuation">&#125;</span></code>`,V1,te,b6,J1,bn,w6,Bc,C6,D6,xc,P6,O6,Nc,R6,T6,X1,Z1,K1,H,S6,Fc,M6,I6,Wc,L6,H6,Uc,A6,G6,jc,B6,x6,zc,N6,F6,Q1,Y1,$1,h1,oa,la,qc,W6,g1,ee,U6,nd,ca,j6,Vc,z6,q6,sd,ut,xM=`<code class="language-go"><span class="token keyword">type</span> MyInt <span class="token builtin">int</span>

<span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">var</span> i <span class="token keyword">interface</span><span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span>
    <span class="token keyword">var</span> mine MyInt <span class="token operator">=</span> <span class="token number">20</span>
    i <span class="token operator">=</span> mine
    i2 <span class="token operator">:=</span> i<span class="token punctuation">.</span><span class="token punctuation">(</span>MyInt<span class="token punctuation">)</span> <span class="token comment">// using type assertion, we can confine the type of concrete type that the interface indicates</span>
    fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>i2 <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span>
<span class="token punctuation">&#125;</span></code>`,ad,A,V6,Jc,J6,X6,Xc,Z6,K6,Zc,Q6,Y6,Kc,$6,h6,Qc,g6,n7,td,ed,pd,zn,s7,Yc,a7,t7,$c,e7,p7,od,it,NM=`<code class="language-go">i3 <span class="token operator">:=</span> i<span class="token punctuation">.</span><span class="token punctuation">(</span><span class="token builtin">string</span><span class="token punctuation">)</span> <span class="token comment">// this line occurs a panic</span>
fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>i3<span class="token punctuation">)</span></code>`,ld,cd,ud,cn,hc,o7,l7,gc,c7,u7,nu,i7,r7,su,k7,f7,id,rt,FM=`<code class="language-go">i4 <span class="token operator">:=</span> i<span class="token punctuation">.</span><span class="token punctuation">(</span><span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token comment">// this line also occurs a panic</span>
fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>i4<span class="token punctuation">)</span></code>`,rd,kd,fd,Es,au,d7,E7,tu,m7,v7,dd,kt,WM=`<code class="language-go"><span class="token comment">// ok is set to true if the type conversion was successful.</span>
<span class="token comment">// if it was not, ok is set to false and the other value is set to its zero value</span>
i5<span class="token punctuation">,</span> ok <span class="token operator">:=</span> i<span class="token punctuation">.</span><span class="token punctuation">(</span><span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token comment">// i5 is set to 0, ok is set to false</span>
<span class="token keyword">if</span> <span class="token operator">!</span>ok <span class="token punctuation">&#123;</span>
	msg <span class="token operator">:=</span> fmt<span class="token punctuation">.</span><span class="token function">Errorf</span><span class="token punctuation">(</span><span class="token string">"unexpected type for %v"</span><span class="token punctuation">,</span> i5<span class="token punctuation">)</span>
	fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>msg<span class="token punctuation">)</span>
<span class="token punctuation">&#125;</span>

i6<span class="token punctuation">,</span> ok <span class="token operator">:=</span> i<span class="token punctuation">.</span><span class="token punctuation">(</span>MyInt<span class="token punctuation">)</span>
<span class="token keyword">if</span> <span class="token operator">!</span>ok <span class="token punctuation">&#123;</span> <span class="token comment">// i6 is set to 20, ok is set to true</span>
	<span class="token comment">// this block is not reached</span>
	msg <span class="token operator">:=</span> fmt<span class="token punctuation">.</span><span class="token function">Errorf</span><span class="token punctuation">(</span><span class="token string">"unexpected type for %v"</span><span class="token punctuation">,</span> i6<span class="token punctuation">)</span>
	fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>msg<span class="token punctuation">)</span>
<span class="token punctuation">&#125;</span></code>`,Ed,w,eu,_7,y7,pu,b7,w7,ou,C7,D7,lu,P7,O7,R7,T7,cu,S7,M7,uu,I7,L7,md,qn,H7,iu,A7,G7,ru,B7,x7,vd,ua,N7,ku,F7,W7,_d,yd,bd,wd,ia,U7,fu,j7,z7,Cd,ft,UM=`<code class="language-go"><span class="token keyword">func</span> <span class="token function">typeSwitch</span><span class="token punctuation">(</span>i <span class="token keyword">interface</span><span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
	<span class="token keyword">switch</span> i<span class="token punctuation">.</span><span class="token punctuation">(</span><span class="token keyword">type</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
	<span class="token keyword">case</span> <span class="token boolean">nil</span><span class="token punctuation">:</span>
		fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"nil"</span><span class="token punctuation">)</span>
	<span class="token keyword">case</span> <span class="token builtin">int</span><span class="token punctuation">:</span>
		fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"int"</span><span class="token punctuation">)</span>
	<span class="token keyword">case</span> MyInt<span class="token punctuation">:</span>
		fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"MyInt"</span><span class="token punctuation">)</span>
	<span class="token keyword">case</span> <span class="token builtin">string</span><span class="token punctuation">:</span>
		fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"string"</span><span class="token punctuation">)</span>
	<span class="token keyword">case</span> <span class="token builtin">bool</span><span class="token punctuation">,</span> <span class="token builtin">rune</span><span class="token punctuation">:</span>
		fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"bool or rune"</span><span class="token punctuation">)</span>
	<span class="token keyword">default</span><span class="token punctuation">:</span>
		fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"what is this"</span><span class="token punctuation">)</span>
	<span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span>

<span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
	<span class="token keyword">var</span> a <span class="token builtin">int</span> <span class="token operator">=</span> <span class="token number">12</span>
	<span class="token keyword">var</span> b MyInt <span class="token operator">=</span> <span class="token number">23</span>
	<span class="token keyword">var</span> c <span class="token operator">*</span><span class="token builtin">string</span>
	d <span class="token operator">:=</span> <span class="token string">"asdasd"</span>
	e <span class="token operator">:=</span> <span class="token keyword">map</span><span class="token punctuation">[</span><span class="token builtin">string</span><span class="token punctuation">]</span><span class="token builtin">string</span><span class="token punctuation">&#123;</span>
		<span class="token string">"hi"</span><span class="token punctuation">:</span> <span class="token string">"there"</span><span class="token punctuation">,</span>
	<span class="token punctuation">&#125;</span>
	<span class="token keyword">var</span> f <span class="token keyword">interface</span><span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span>

	<span class="token function">typeSwitch</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span>
	<span class="token function">typeSwitch</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span>
	<span class="token function">typeSwitch</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span>
	<span class="token function">typeSwitch</span><span class="token punctuation">(</span>d<span class="token punctuation">)</span>
	<span class="token function">typeSwitch</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span>
	<span class="token function">typeSwitch</span><span class="token punctuation">(</span>f<span class="token punctuation">)</span>
<span class="token punctuation">&#125;</span></code>`,Dd,dt,jM=`<code class="language-bash">int
MyInt
what is this
string
what is this
nil</code>`,Pd,Vn,q7,du,V7,J7,Eu,X7,Z7,Od,_,K7,mu,Q7,Y7,vu,$7,h7,_u,g7,n8,yu,s8,a8,bu,t8,e8,wu,p8,o8,Cu,l8,c8,Rd,ra,u8,Du,i8,r8,Td,un,Pu,k8,f8,Ou,d8,E8,Ru,m8,v8,Tu,_8,y8,Sd,Md,Id,ms,Su,b8,w8,Mu,C8,D8,Ld,G,P8,Iu,O8,R8,Lu,T8,S8,Hu,M8,I8,Au,L8,H8,Gu,A8,G8,Hd,m,Bu,B8,x8,xu,N8,F8,Nu,W8,U8,Fu,j8,z8,Wu,q8,V8,Uu,J8,X8,ju,Z8,K8,zu,Q8,Y8,Ad,Et,zM=`<code class="language-go"><span class="token comment">// copyBuffer is the actual implementation of Copy and CopyBuffer.</span>
<span class="token comment">// if buf is nil, one is allocated.</span>
<span class="token keyword">func</span> <span class="token function">copyBuffer</span><span class="token punctuation">(</span>dst Writer<span class="token punctuation">,</span> src Reader<span class="token punctuation">,</span> buf <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">byte</span><span class="token punctuation">)</span> <span class="token punctuation">(</span>written <span class="token builtin">int64</span><span class="token punctuation">,</span> err <span class="token builtin">error</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token comment">// If the reader has a WriteTo method, use it to do the copy.</span>
    <span class="token comment">// Avoids an allocation and a copy.</span>
    <span class="token keyword">if</span> wt<span class="token punctuation">,</span> ok <span class="token operator">:=</span> src<span class="token punctuation">.</span><span class="token punctuation">(</span>WriterTo<span class="token punctuation">)</span><span class="token punctuation">;</span> ok <span class="token punctuation">&#123;</span>
        <span class="token keyword">return</span> wt<span class="token punctuation">.</span><span class="token function">WriteTo</span><span class="token punctuation">(</span>dst<span class="token punctuation">)</span>
    <span class="token punctuation">&#125;</span>
    <span class="token comment">// Similarly, if the writer has a ReadFrom method, use it to do the copy.</span>
    <span class="token keyword">if</span> rt<span class="token punctuation">,</span> ok <span class="token operator">:=</span> dst<span class="token punctuation">.</span><span class="token punctuation">(</span>ReaderFrom<span class="token punctuation">)</span><span class="token punctuation">;</span> ok <span class="token punctuation">&#123;</span>
        <span class="token keyword">return</span> rt<span class="token punctuation">.</span><span class="token function">ReadFrom</span><span class="token punctuation">(</span>src<span class="token punctuation">)</span>
    <span class="token punctuation">&#125;</span>
    <span class="token comment">// function continues...</span>
<span class="token punctuation">&#125;</span></code>`,Gd,Bd,xd,Jn,$8,qu,h8,g8,Vu,n9,s9,Nd,R,a9,Ju,t9,e9,Xu,p9,o9,Zu,l9,c9,Ku,u9,i9,Qu,r9,k9,Yu,f9,d9,Fd,mt,qM=`<code class="language-go"><span class="token keyword">func</span> <span class="token function">ctxDriverStmtExec</span><span class="token punctuation">(</span>ctx context<span class="token punctuation">.</span>Context<span class="token punctuation">,</span> si driver<span class="token punctuation">.</span>Stmt<span class="token punctuation">,</span>
                       nvdargs <span class="token punctuation">[</span><span class="token punctuation">]</span>driver<span class="token punctuation">.</span>NamedValue<span class="token punctuation">)</span> <span class="token punctuation">(</span>driver<span class="token punctuation">.</span>Result<span class="token punctuation">,</span> <span class="token builtin">error</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">if</span> siCtx<span class="token punctuation">,</span> is <span class="token operator">:=</span> si<span class="token punctuation">.</span><span class="token punctuation">(</span>driver<span class="token punctuation">.</span>StmtExecContext<span class="token punctuation">)</span><span class="token punctuation">;</span> is <span class="token punctuation">&#123;</span>
        <span class="token keyword">return</span> siCtx<span class="token punctuation">.</span><span class="token function">ExecContext</span><span class="token punctuation">(</span>ctx<span class="token punctuation">,</span> nvdargs<span class="token punctuation">)</span>
    <span class="token punctuation">&#125;</span>
    <span class="token comment">// fallback code is here</span>
<span class="token punctuation">&#125;</span></code>`,Wd,Ud,jd,Xn,E9,$u,m9,v9,hu,_9,y9,zd,T,b9,gu,w9,C9,ni,D9,P9,si,O9,R9,ai,T9,S9,ti,M9,I9,ei,L9,H9,qd,h,A9,pi,G9,B9,oi,x9,N9,li,F9,W9,ci,U9,j9,Vd,Jd,Xd,vt,ui,z9,q9,Zd,g,V9,ii,J9,X9,ri,Z9,K9,ki,Q9,Y9,fi,$9,h9,Kd,Qd,Yd,$d,ka,fa,di,g9,hd,pe,nb,gd,oe,sb,nE,_t,VM=`<code class="language-go"><span class="token keyword">type</span> Handler <span class="token keyword">interface</span> <span class="token punctuation">&#123;</span>
    <span class="token function">ServeHTTP</span><span class="token punctuation">(</span>http<span class="token punctuation">.</span>ResponseWriter<span class="token punctuation">,</span> <span class="token operator">*</span>http<span class="token punctuation">.</span>Request<span class="token punctuation">)</span>
<span class="token punctuation">&#125;</span></code>`,sE,F,Ei,ab,tb,mi,eb,pb,vi,ob,lb,_i,cb,ub,yi,ib,rb,aE,yt,JM=`<code class="language-go"><span class="token keyword">type</span> HandlerFunc <span class="token keyword">func</span><span class="token punctuation">(</span>http<span class="token punctuation">.</span>ResponseWriter<span class="token punctuation">,</span> <span class="token operator">*</span>http<span class="token punctuation">.</span>Request<span class="token punctuation">)</span>

<span class="token keyword">func</span> <span class="token punctuation">(</span>f HandlerFunc<span class="token punctuation">)</span> <span class="token function">ServeHTTP</span><span class="token punctuation">(</span>w http<span class="token punctuation">.</span>ResponseWriter<span class="token punctuation">,</span> r <span class="token operator">*</span>http<span class="token punctuation">.</span>Request<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token function">f</span><span class="token punctuation">(</span>w<span class="token punctuation">,</span> r<span class="token punctuation">)</span>
<span class="token punctuation">&#125;</span></code>`,tE,da,kb,bi,fb,db,eE,pE,oE,le,Eb,lE,Zn,mb,wi,vb,_b,Ci,yb,bb,cE,uE,iE,rE,Ea,ma,Di,wb,kE,bt,Pi,Cb,Db,fE,ce,Pb,dE,wt,XM=`<code class="language-go"><span class="token keyword">func</span> <span class="token function">LogOutput</span><span class="token punctuation">(</span>message <span class="token builtin">string</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>message<span class="token punctuation">)</span>
<span class="token punctuation">&#125;</span>

<span class="token keyword">type</span> SimpleDataStore <span class="token keyword">struct</span> <span class="token punctuation">&#123;</span>
    userData <span class="token keyword">map</span><span class="token punctuation">[</span><span class="token builtin">string</span><span class="token punctuation">]</span><span class="token builtin">string</span>
<span class="token punctuation">&#125;</span>

<span class="token keyword">func</span> <span class="token punctuation">(</span>sds SimpleDataStore<span class="token punctuation">)</span> <span class="token function">UserNameForID</span><span class="token punctuation">(</span>userID <span class="token builtin">string</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token builtin">string</span><span class="token punctuation">,</span> <span class="token builtin">bool</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    name<span class="token punctuation">,</span> ok <span class="token operator">:=</span> sds<span class="token punctuation">.</span>userData<span class="token punctuation">[</span>userID<span class="token punctuation">]</span>
    <span class="token keyword">return</span> name<span class="token punctuation">,</span> ok
<span class="token punctuation">&#125;</span></code>`,EE,va,Ob,Oi,Rb,Tb,mE,Ct,ZM=`<code class="language-go"><span class="token keyword">func</span> <span class="token function">NewSimpleDataStore</span><span class="token punctuation">(</span><span class="token punctuation">)</span> SimpleDataStore <span class="token punctuation">&#123;</span>
	<span class="token keyword">return</span> SimpleDataStore<span class="token punctuation">&#123;</span>
		userData<span class="token punctuation">:</span> <span class="token keyword">map</span><span class="token punctuation">[</span><span class="token builtin">string</span><span class="token punctuation">]</span><span class="token builtin">string</span><span class="token punctuation">&#123;</span>
			<span class="token string">"1"</span><span class="token punctuation">:</span> <span class="token string">"Fred"</span><span class="token punctuation">,</span>
			<span class="token string">"2"</span><span class="token punctuation">:</span> <span class="token string">"Mary"</span><span class="token punctuation">,</span>
			<span class="token string">"3"</span><span class="token punctuation">:</span> <span class="token string">"Pat"</span><span class="token punctuation">,</span>
		<span class="token punctuation">&#125;</span><span class="token punctuation">,</span>
	<span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span></code>`,vE,_E,yE,Kn,Sb,Ri,Mb,Ib,Ti,Lb,Hb,bE,ue,Ab,wE,Dt,KM=`<code class="language-go"><span class="token keyword">type</span> DataStore <span class="token keyword">interface</span> <span class="token punctuation">&#123;</span>
	<span class="token function">UserNameForID</span><span class="token punctuation">(</span>userID <span class="token builtin">string</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token builtin">string</span><span class="token punctuation">,</span> <span class="token builtin">bool</span><span class="token punctuation">)</span>
<span class="token punctuation">&#125;</span>

<span class="token keyword">type</span> Logger <span class="token keyword">interface</span> <span class="token punctuation">&#123;</span>
	<span class="token function">Log</span><span class="token punctuation">(</span>message <span class="token builtin">string</span><span class="token punctuation">)</span>
<span class="token punctuation">&#125;</span>

<span class="token keyword">type</span> LoggerAdapter <span class="token keyword">func</span><span class="token punctuation">(</span>message <span class="token builtin">string</span><span class="token punctuation">)</span>

<span class="token keyword">func</span> <span class="token punctuation">(</span>lg LoggerAdapter<span class="token punctuation">)</span> <span class="token function">Log</span><span class="token punctuation">(</span>message <span class="token builtin">string</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
	<span class="token function">lg</span><span class="token punctuation">(</span>message<span class="token punctuation">)</span>
<span class="token punctuation">&#125;</span></code>`,CE,Tn,Si,Gb,Bb,Mi,xb,Nb,Ii,Fb,Wb,DE,ie,Ub,PE,Pt,QM=`<code class="language-go"><span class="token keyword">type</span> SimpleLogic <span class="token keyword">struct</span> <span class="token punctuation">&#123;</span>
	l  Logger
	ds DataStore
<span class="token punctuation">&#125;</span>

<span class="token keyword">func</span> <span class="token punctuation">(</span>sl SimpleLogic<span class="token punctuation">)</span> <span class="token function">SayHello</span><span class="token punctuation">(</span>userID <span class="token builtin">string</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token builtin">string</span><span class="token punctuation">,</span> <span class="token builtin">error</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
	sl<span class="token punctuation">.</span>l<span class="token punctuation">.</span><span class="token function">Log</span><span class="token punctuation">(</span><span class="token string">"in say hello for "</span> <span class="token operator">+</span> userID<span class="token punctuation">)</span>
	name<span class="token punctuation">,</span> ok <span class="token operator">:=</span> sl<span class="token punctuation">.</span>ds<span class="token punctuation">.</span><span class="token function">UserNameForID</span><span class="token punctuation">(</span>userID<span class="token punctuation">)</span>
	<span class="token keyword">if</span> <span class="token operator">!</span>ok <span class="token punctuation">&#123;</span>
		<span class="token keyword">return</span> <span class="token string">""</span><span class="token punctuation">,</span> errors<span class="token punctuation">.</span><span class="token function">New</span><span class="token punctuation">(</span><span class="token string">"unknown user"</span><span class="token punctuation">)</span>
	<span class="token punctuation">&#125;</span>
	<span class="token keyword">return</span> <span class="token string">"Hello, "</span> <span class="token operator">+</span> name<span class="token punctuation">,</span> <span class="token boolean">nil</span>
<span class="token punctuation">&#125;</span>

<span class="token keyword">func</span> <span class="token punctuation">(</span>sl SimpleLogic<span class="token punctuation">)</span> <span class="token function">SayGoodbye</span><span class="token punctuation">(</span>userID <span class="token builtin">string</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token builtin">string</span><span class="token punctuation">,</span> <span class="token builtin">error</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
	sl<span class="token punctuation">.</span>l<span class="token punctuation">.</span><span class="token function">Log</span><span class="token punctuation">(</span><span class="token string">"in say goodbye for "</span> <span class="token operator">+</span> userID<span class="token punctuation">)</span>
	name<span class="token punctuation">,</span> ok <span class="token operator">:=</span> sl<span class="token punctuation">.</span>ds<span class="token punctuation">.</span><span class="token function">UserNameForID</span><span class="token punctuation">(</span>userID<span class="token punctuation">)</span>
	<span class="token keyword">if</span> <span class="token operator">!</span>ok <span class="token punctuation">&#123;</span>
		<span class="token keyword">return</span> <span class="token string">""</span><span class="token punctuation">,</span> errors<span class="token punctuation">.</span><span class="token function">New</span><span class="token punctuation">(</span><span class="token string">"unknown user"</span><span class="token punctuation">)</span>
	<span class="token punctuation">&#125;</span>
	<span class="token keyword">return</span> <span class="token string">"Goodbye, "</span> <span class="token operator">+</span> name<span class="token punctuation">,</span> <span class="token boolean">nil</span>
<span class="token punctuation">&#125;</span>

<span class="token keyword">func</span> <span class="token function">NewSimpleLogic</span><span class="token punctuation">(</span>l Logger<span class="token punctuation">,</span> ds DataStore<span class="token punctuation">)</span> SimpleLogic <span class="token punctuation">&#123;</span>
    <span class="token keyword">return</span> SimpleLogic<span class="token punctuation">&#123;</span>
        l<span class="token punctuation">:</span>    l<span class="token punctuation">,</span>
        ds<span class="token punctuation">:</span> ds<span class="token punctuation">,</span>
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span>

<span class="token keyword">func</span> <span class="token function">NewSimpleLogic</span><span class="token punctuation">(</span>l Logger<span class="token punctuation">,</span> ds DataStore<span class="token punctuation">)</span> SimpleLogic <span class="token punctuation">&#123;</span>
	<span class="token keyword">return</span> SimpleLogic<span class="token punctuation">&#123;</span>
		l<span class="token punctuation">:</span>  l<span class="token punctuation">,</span>
		ds<span class="token punctuation">:</span> ds<span class="token punctuation">,</span>
	<span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span></code>`,OE,W,Li,jb,zb,Hi,qb,Vb,Ai,Jb,Xb,Gi,Zb,Kb,Bi,Qb,Yb,RE,TE,SE,Qn,$b,xi,hb,gb,Ni,nw,sw,ME,Ot,YM=`<code class="language-go"><span class="token keyword">type</span> Logic <span class="token keyword">interface</span> <span class="token punctuation">&#123;</span>
    <span class="token function">SayHello</span><span class="token punctuation">(</span>userID <span class="token builtin">string</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token builtin">string</span><span class="token punctuation">,</span> <span class="token builtin">error</span><span class="token punctuation">)</span>
<span class="token punctuation">&#125;</span></code>`,IE,Yn,aw,Fi,tw,ew,Wi,pw,ow,LE,Rt,$M=`<code class="language-go"><span class="token keyword">type</span> Controller <span class="token keyword">struct</span> <span class="token punctuation">&#123;</span>
	l     Logger
	logic Logic
<span class="token punctuation">&#125;</span>

<span class="token keyword">func</span> <span class="token punctuation">(</span>c Controller<span class="token punctuation">)</span> <span class="token function">SayHello</span><span class="token punctuation">(</span>w http<span class="token punctuation">.</span>ResponseWriter<span class="token punctuation">,</span> r <span class="token operator">*</span>http<span class="token punctuation">.</span>Request<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
	c<span class="token punctuation">.</span>l<span class="token punctuation">.</span><span class="token function">Log</span><span class="token punctuation">(</span><span class="token string">"In sayhello"</span><span class="token punctuation">)</span>
	userID <span class="token operator">:=</span> r<span class="token punctuation">.</span>URL<span class="token punctuation">.</span><span class="token function">Query</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token string">"user_id"</span><span class="token punctuation">)</span>
	message<span class="token punctuation">,</span> err <span class="token operator">:=</span> c<span class="token punctuation">.</span>logic<span class="token punctuation">.</span><span class="token function">SayHello</span><span class="token punctuation">(</span>userID<span class="token punctuation">)</span>
	<span class="token keyword">if</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">&#123;</span>
		w<span class="token punctuation">.</span><span class="token function">WriteHeader</span><span class="token punctuation">(</span>http<span class="token punctuation">.</span>StatusBadRequest<span class="token punctuation">)</span>
		w<span class="token punctuation">.</span><span class="token function">Write</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token function">byte</span><span class="token punctuation">(</span>err<span class="token punctuation">.</span><span class="token function">Error</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
		<span class="token keyword">return</span>
	<span class="token punctuation">&#125;</span>
	w<span class="token punctuation">.</span><span class="token function">Write</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token function">byte</span><span class="token punctuation">(</span>message<span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token punctuation">&#125;</span>

<span class="token keyword">func</span> <span class="token function">NewController</span><span class="token punctuation">(</span>l Logger<span class="token punctuation">,</span> logic Logic<span class="token punctuation">)</span> Controller <span class="token punctuation">&#123;</span>
	<span class="token keyword">return</span> Controller<span class="token punctuation">&#123;</span>
		l<span class="token punctuation">:</span>     l<span class="token punctuation">,</span>
		logic<span class="token punctuation">:</span> logic<span class="token punctuation">,</span>
	<span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span></code>`,HE,AE,GE,_a,lw,Ui,cw,uw,BE,Tt,hM=`<code class="language-go"><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
	l <span class="token operator">:=</span> <span class="token function">LoggerAdapter</span><span class="token punctuation">(</span>LogOutput<span class="token punctuation">)</span>
	ds <span class="token operator">:=</span> <span class="token function">NewSimpleDataStore</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
	logic <span class="token operator">:=</span> <span class="token function">NewSimpleLogic</span><span class="token punctuation">(</span>l<span class="token punctuation">,</span> ds<span class="token punctuation">)</span>
	c <span class="token operator">:=</span> <span class="token function">NewController</span><span class="token punctuation">(</span>l<span class="token punctuation">,</span> logic<span class="token punctuation">)</span>
	http<span class="token punctuation">.</span><span class="token function">HandleFunc</span><span class="token punctuation">(</span><span class="token string">"/hello"</span><span class="token punctuation">,</span> c<span class="token punctuation">.</span>SayHello<span class="token punctuation">)</span>
	http<span class="token punctuation">.</span><span class="token function">ListenAndServe</span><span class="token punctuation">(</span><span class="token string">":8080"</span><span class="token punctuation">,</span> <span class="token boolean">nil</span><span class="token punctuation">)</span>
<span class="token punctuation">&#125;</span></code>`,xE,$n,iw,ji,rw,kw,zi,fw,dw,NE,S,qi,Ew,mw,Vi,vw,_w,Ji,yw,bw,Xi,ww,Cw,Zi,Dw,Pw,Ki,Ow,Rw,FE,vs,Qi,Tw,Sw,Yi,Mw,Iw,WE,re,Lw,UE,jE,zE,ya,Hw,St,Aw,Gw,qE,VE,JE,XE,ba,wa,$i,Bw,ZE,ke,xw,KE,QE,YE,$E,Ca,Da,hi,Nw,hE,gE,n2,fe,_s,Mt,de,kC,Fw,Ww,Uw,It,jw,s2,a2,t2,Ee,zw,e2,me,qw,p2,o2,l2;return{c(){At=p("br"),pr=i(),Gt=p("p"),S2=t("본 글은 Golang을 공부하며 주요 내용이라 생각되는 것들을 기록해둔 자료이며, Ubuntu 20.04 LTS 기준으로 작성되었습니다."),or=i(),lr=p("br"),cr=p("br"),ur=i(),Ps=p("h2"),Os=p("a"),ze=p("span"),M2=t("Types"),ir=i(),rr=p("hr"),kr=i(),Rs=p("p"),I2=t("Go에는 Class나 상속과 같은 개념이 개념이 존재하지 않는다. 대신 타입을 정의하고자 하는 경우, "),qe=p("code"),L2=t("type"),H2=t(" 키워드를 사용하여 정의한다."),fr=i(),Aa=p("pre"),dr=i(),Bt=p("p"),A2=t("위처럼 정의된 타입들은 이들이 정의된 스코프 내에서만 정의 가능하다."),Er=i(),mr=p("br"),vr=i(),kn=p("p"),G2=t("한 가지 짚고 넘어가야 할 점은, 위 예제의 "),Ve=p("code"),B2=t("Score"),x2=t(" 타입의 경우 사실상 "),Je=p("code"),N2=t("int"),F2=t(`와 동일한 타입이다.
그럼에도 위와 같이 타입명을 지정해준 것은 타입명 자체를 일종의 `),Xe=p("strong"),W2=t("documentation"),U2=t("으로 볼 수 있기 때문이다."),_r=i(),Ln=p("p"),j2=t(`이러한 타입 지정은 해당 타입의 변수 또는 인스턴스가 코드 내에서 어떠한 역할을 하며,
어떠한 데이터를 저장할 지에 대한 정보를 제공할 수 있다.
위 예제에서 `),Ze=p("code"),z2=t("Score"),q2=t("는 "),Ke=p("code"),V2=t("int"),J2=t("와 똑같은 정수 타입이기는 해도, 무식하게 큰 정수나 음수인 값에 대해서는 유효하지 않은 값임을 파악할 수 있을 것이다."),yr=i(),Ts=p("p"),X2=t("위 예제의 "),Qe=p("code"),Z2=t("Employee"),K2=t(`은 유저가 정의한 타입을 다시 정의한 경우인데, 이 또한 같은 맥락에서 바라볼 수 있다.
저장하고 있는 데이터의 종류는 같을지라도, 이들이 사용되어야 할 적합한 맥락에 대해서 정보를 제공할 수 있다.`),br=i(),wr=p("br"),Cr=p("br"),Dr=i(),Ss=p("h3"),Ms=p("a"),Ye=p("span"),Q2=t("Inheritance in Go?"),Pr=i(),xt=p("p"),Y2=t("Go에는 객체지향과 상속 개념이 없다. type을 선언할 수 있지만, 이는 말 그대로 어디까지나 선언만 할 수 있는 것이다."),Or=i(),Ga=p("pre"),Rr=i(),Is=p("p"),$2=t("위와 같은 "),$e=p("code"),h2=t("type"),g2=t(` 선언은 상속처럼 보일 수는 있지만, 엄연히 다르다. 실질적으로는 이름만 다른 동일한 타입이 두 개 선언되는 것.
이들 사이에는 어떠한 계층 구조도 존재하지 않는다.`),Tr=i(),q=p("p"),nm=t("객체지향에서 "),he=p("em"),sm=t("child class"),am=t("는 "),ge=p("em"),tm=t("parent class"),em=t(`가 가진 모든 메소드와 값들을 사용할 수 있어야 하며, parent class가 사용되는 곳 어디에든 사용될 수 있어야 한다.
반면 Go에서는, 위 예제의 `),np=p("code"),pm=t("Score"),om=t(" 인스턴스가 사용되는 상황에서 "),sp=p("code"),lm=t("HighScore"),cm=t(" 인스턴스를 사용하려면 타입 변환을 해주어야 한다."),Sr=i(),Ba=p("pre"),Mr=i(),Ir=p("br"),Lr=p("br"),Hr=i(),Ls=p("h3"),Hs=p("a"),ap=p("span"),um=t("Enumeration in Go - iota"),Ar=i(),Hn=p("p"),im=t("여러 프로그래밍 언어에 존재하는 "),tp=p("em"),rm=t("Enumeration"),km=t("에 대한 개념 대신, Go에는 "),ep=p("code"),fm=t("iota"),dm=t("가 존재한다. 바로 예제를 확인해보자."),Gr=i(),xa=p("pre"),Br=i(),Na=p("pre"),xr=i(),V=p("p"),Em=t(`위 예제의 실행 결과를 확인해보면, 0부터 4까지의 수가 순서대로 할당되었음을 알 수 있다.
이는 `),pp=p("code"),mm=t("iota"),vm=t("가 첫 번째 상수인 "),op=p("code"),_m=t("Uncategorized"),ym=t("에 0, 두 번째 상수인 "),lp=p("code"),bm=t("Personal"),wm=t(`에 1, 이런 식으로 점점 증가되게끔 값을 할당하였기 때문이다.
또한, 만일 새로운 `),cp=p("code"),Cm=t("const"),Dm=t(" 선언 블록이 존재할 경우, iota는 0이 될 것이다."),Nr=i(),Fr=p("br"),Wr=i(),Fa=p("pre"),Ur=i(),us=p("p"),up=p("code"),Pm=t("_"),Om=t(`를 이용하면 iota로 할당되는 값을 건너뛸 수 있다.
또한 `),ip=p("code"),Rm=t("iota"),Tm=t(`를 사용할 때 위와 같은 표현식을 사용하여 값들을 할당할 수도 있다.
다만 이런 경우, 무슨 목적으로 이런 코드를 짰는지 잘 명시해주는 것이 좋겠다.`),jr=i(),zr=p("br"),qr=i(),D=p("p"),Sm=t("단 "),rp=p("code"),Mm=t("iota"),Im=t("를 사용하려면 "),kp=p("code"),Lm=t("iota"),Hm=t(`에 의해서 할당되는 값이 큰 의미가 없는 경우여야 한다.
0, 1, 2, … 등 `),fp=p("code"),Am=t("iota"),Gm=t(`에 의해 할당되는 값들은 단순히 서로를 구분하기 위해서 사용되는 값일 뿐이며, 이 값을 직접적으로 사용해선 안된다.
만일 `),dp=p("code"),Bm=t("iota"),xm=t("를 사용하는 "),Ep=p("code"),Nm=t("const"),Fm=t(` 블록 중간에 새로운 상수를 추가하면 값들이 전체적으로 바뀔 것이다.
이 때 `),mp=p("code"),Wm=t("iota"),Um=t("에 의해 할당되는 값을 직접적으로 사용한다면 이에 영향을 받을 것이다."),Vr=i(),J=p("p"),jm=t(`특정 인터페이스와 직접적으로 관련되어있지 않은 내부적인 로직에서 사용하는 것이 좋다.
만약 어느 `),vp=p("code"),zm=t("struct"),qm=t(" 타입에 "),_p=p("code"),Vm=t("iota"),Jm=t(`를 사용하는 Enumeration 필드가 존재하고, 해당 인스턴스들이 DB에 저장되어있다고 가정해보자.
그런데 `),yp=p("code"),Xm=t("iota"),Zm=t("를 사용하는 "),bp=p("code"),Km=t("const"),Qm=t(" 블록 중간에 새로운 상수를 추가하면 DB에 저장된 값들이 완전히 다른 값을 가리키게 될 것이다."),Jr=i(),As=p("p"),Ym=t("따라서 상수의 값이 중요한 경우이거나 내부적인 로직에서 사용하는 것이 아니라면 "),wp=p("code"),$m=t("iota"),hm=t(`를 쓰지 말고 그냥 값을 직접 할당해주는 편이 좋다.
그게 아니라면 문서를 잘 써놓자.`),Xr=i(),Zr=p("br"),Kr=p("br"),Qr=i(),Gs=p("h2"),Bs=p("a"),Cp=p("span"),gm=t("Methods"),Yr=i(),$r=p("hr"),hr=i(),fn=p("p"),nv=t("Go에서는 "),Dp=p("em"),sv=t("User-defined type"),av=t(`에 대해 메소드를 생성할 수 있다.
일반적인 함수 선언과 유사하지만, `),Pp=p("code"),tv=t("func"),ev=t("와 메소드명 사이에 "),Op=p("strong"),pv=t("receiver"),ov=t(`를 명시해준다.
보통의 변수 선언처럼 변수명을 먼저 적고 타입을 뒤에 적는다.
일반적으로는 타입명의 맨 앞글자를 소문자로 적는다고 한다.`),gr=i(),Wa=p("pre"),nk=i(),Nt=p("p"),lv=t(`Go에서는 함수 오버로딩을 지원하지 않으며, 메소드도 동일하다.
동일한 타입에서 두개 이상의 동일한 이름을 가진 메소드를 선언할 수 없다.`),sk=i(),Ft=p("p"),cv=t("또한 타입과 이에 대한 메소드가 선언된 파일을 서로 분리할 수는 있지만, 같은 파일 에서 함께 선언하는 것이 권장된다고 한다."),ak=i(),tk=p("br"),ek=p("br"),pk=i(),xs=p("h3"),Ns=p("a"),Rp=p("span"),uv=t("Pointer Receivers"),ok=i(),dn=p("p"),iv=t("함수에서 포인터 파라미터를 사용할 때처럼, "),Tp=p("em"),rv=t("Receiver"),kv=t(`에도 포인터를 사용할 수 있다.
이 때 `),Sp=p("em"),fv=t("Value Receiver"),dv=t("를 사용할 때와의 차이점은 "),Mp=p("em"),Ev=t("Receiver"),mv=t("로 패스한 값이 변경될 수 있다는 것이다."),lk=i(),Ua=p("p"),Ip=p("em"),vv=t("Pointer Reciver"),_v=t("에 대한 몇 가지 규칙이 존재한다."),ck=i(),An=p("ol"),is=p("li"),yv=t("메소드가 "),Lp=p("em"),bv=t("Reciver"),wv=t(" 값을 변경한다면, 반드시 "),Hp=p("em"),Cv=t("Pointer Reciver"),Dv=t("를 사용한다."),Pv=i(),rs=p("li"),Ov=t("메소드가 "),Ap=p("code"),Rv=t("nil"),Tv=t(" 인스턴스를 다뤄야 한다면, 반드시 "),Gp=p("em"),Sv=t("Pointer Reciver"),Mv=t("를 사용한다."),Iv=i(),ks=p("li"),Lv=t("메소드가 "),Bp=p("em"),Hv=t("Reciver"),Av=t(" 값을 변경하지 않는다면, "),xp=p("em"),Gv=t("Value Reciver"),Bv=t("를 사용할 수 있다."),uk=i(),Rn=p("p"),Np=p("em"),xv=t("Reciver"),Nv=t(" 값을 변경하지 않는 메소드에 대해서도 "),Fp=p("em"),Fv=t("Pointer Reciver"),Wv=t(`를 사용하는 것이 국룰이라고 한다.
다만 난 잘 모르겠다. 개인적으로는 값을 변경하지 않는다면 명시적으로 `),Wp=p("em"),Uv=t("Value Reciver"),jv=t("를 써도 되는 거 아닌가 싶다."),ik=i(),rk=p("br"),kk=i(),ja=p("pre"),fk=i(),En=p("p"),zv=t("함수에 포인터 파라미터를 넘길 때와는 달리, Receiver에 "),Up=p("code"),qv=t("&"),Vv=t(`를 붙이지 않아도 된다.
위 `),jp=p("code"),Jv=t("c.Increment()"),Xv=t(" 부분은 자동으로 "),zp=p("code"),Zv=t("(&c).Increment()"),Kv=t(`로 변환된다.
아래 코드는 예제의 실행 결과이다.`),dk=i(),za=p("pre"),Ek=i(),mk=p("br"),vk=i(),Wt=p("p"),Qv=t("이러한 규칙들에 대해 잘 이해하면, 아래 예제의 실행 결과도 알 수 있을 것이다."),_k=i(),qa=p("pre"),yk=i(),E=p("p"),qp=p("code"),Yv=t("doUpdateWrong()"),$v=t(" 함수의 스코프 내에서 "),Vp=p("code"),hv=t("c.Increment()"),gv=t("를 호출시 "),Jp=p("code"),n3=t("c"),s3=t(`가 변경되고, 그 결과가 이후 출력에서 반영된다.
하지만 `),Xp=p("code"),a3=t("doUpdateWrong()"),t3=t(" 함수는 파라미터인 "),Zp=p("code"),e3=t("Counter"),p3=t("를 "),Kp=p("em"),o3=t("pass by value"),l3=t("로 받았기 때문에 "),Qp=p("code"),c3=t("main()"),u3=t(` 함수로 되돌아왔을 때 변경사항이 유지되지 않는다.
반면 `),Yp=p("code"),i3=t("doUpdateWrong()"),r3=t(" 함수는 파라미터를 "),$p=p("em"),k3=t("pass by pointer"),f3=t("로 받았기에, 변경사항이 유지된다."),bk=i(),Ut=p("p"),d3=t("위 예제의 실행 결과는 아래와 같다."),wk=i(),Va=p("pre"),Ck=i(),Dk=p("br"),Pk=i(),mn=p("p"),E3=t("이렇게 유저가 정의한 타입에 Method를 통해 "),hp=p("em"),m3=t("Getter"),v3=t("나, "),gp=p("em"),_3=t("Pointer Reciver"),y3=t("를 이용하여 "),no=p("em"),b3=t("Setter"),w3=t(`를 정의할 수는 있다.
다만 필드에 직접 값을 할당하는 경우가 아니거나, 여러 필드를 한 번의 오퍼레이션으로 처리해야 하는 경우가 아니라면,
Go에서는 되도록이면 필드값에 직접 접근하는 것을 권장한다.`),Ok=i(),Rk=p("br"),Tk=p("br"),Sk=i(),fs=p("p"),so=p("em"),C3=t("Pointer Reciver"),D3=t("는 "),ao=p("code"),P3=t("nil"),O3=t(" 인스턴스를 다뤄야 할 때 사용할 수 있다."),Mk=i(),v=p("p"),R3=t("다른 언어들의 경우 "),to=p("code"),T3=t("null"),S3=t("이나 "),eo=p("code"),M3=t("None"),I3=t(` 인스턴스에서 메소드를 호출하면 에러가 발생한다.
Go에서도 `),po=p("code"),L3=t("nil"),H3=t(" 인스턴스에서 메소드를 호출할 때 "),oo=p("em"),A3=t("Value Reciver"),G3=t("인 경우에는 "),lo=p("em"),B3=t("panic"),x3=t("이 발생하지만, "),co=p("em"),N3=t("Pointer Reciver"),F3=t(`인 경우 메소드가 정상적으로 호출된다.
이 경우, 메소드가 `),uo=p("code"),W3=t("nil"),U3=t(" 인스턴스를 처리할 수 있게끔 작성되어 있어야 한다."),Ik=i(),Ja=p("pre"),Lk=i(),Fs=p("p"),j3=t("위 예제는 "),io=p("code"),z3=t("nil"),q3=t(" 인스턴스를 핸들링할 수 있는 정수형 바이너리 트리의 예제이다."),Hk=i(),pn=p("p"),ro=p("code"),V3=t("IntTree.Contains()"),J3=t(" 메소드는 현재 receiver가 "),ko=p("code"),X3=t("nil"),Z3=t(`인지에 따라 해당 값이 포함되어 있는가의 여부를 판단하며
`),fo=p("code"),K3=t("IntTree.Insert()"),Q3=t(" 메소드는 현재 receiver가 "),Eo=p("code"),Y3=t("nil"),$3=t(`일 경우 현 위치에 값을 추가한 값을 반환한다.
단, 이때는 포인터 파라미터를 사용할 때처럼 receiver에 특정 주소값을 할당하여도, 원본 포인터가 변경되지는 않는다.`),Ak=i(),Gk=p("br"),Bk=p("br"),xk=i(),Ws=p("h3"),Us=p("a"),mo=p("span"),h3=t("Methods and Functions"),Nk=i(),jt=p("p"),g3=t("Go에서 메소드는 함수와 유사한 점이 많다."),Fk=i(),Xa=p("pre"),Wk=i(),vn=p("p"),n5=t("함수를 변수에 할당하여 사용할 수 있듯, 위 예제의 "),vo=p("code"),s5=t("f1"),a5=t(`처럼 메소드도 변수에 할당하여 사용할 수 있다.
이 때 이 메소드의 타입은 `),_o=p("code"),t5=t("func(int)int"),e5=t("가 되며, 이를 "),yo=p("em"),p5=t("method value"),o5=t("라 한다."),Uk=i(),N=p("p"),bo=p("em"),l5=t("method value"),c5=t("는 "),wo=p("em"),u5=t("closure"),i5=t(`처럼 파라미터로 넘기거나 할 수도 있다.
`),Co=p("em"),r5=t("method value"),k5=t("를 선언할 때 붙어있던 "),Do=p("em"),f5=t("receiver"),d5=t("가 고정되어 있기 때문에, 이를 호출할 경우 해당 "),Po=p("em"),E5=t("receiver"),m5=t("가 영향을 받는다."),jk=i(),X=p("p"),v5=t("위 예제의 "),Oo=p("code"),_5=t("f2"),y5=t(`처럼 그냥 타입명에 메소드를 붙인 것을 변수에 할당할 수도 있다.
이를 `),Ro=p("em"),b5=t("method expression"),w5=t("이라 한다. 이 때 이 메소드의 타입은 "),To=p("code"),C5=t("func(Adder, int) int"),D5=t("가 되며, 첫 번째 파라미터가 "),So=p("em"),P5=t("receiver"),O5=t("가 된다."),zk=i(),js=p("p"),R5=t(`이렇게 Go에서는 메소드를 함수처럼 사용할 수 있기에 큰 차이가 없기에 어느 것을 사용해야 할지 혼동이 올 수 있다.
만약 작성하고자 하는 로직이 입력 파라미터에 의해서만 영향을 받는다면 함수를 사용하는 것이 옳다.
반면 프로그램이 실행되며 설정되고, 실행 중 계속 바뀌는 어떤 값에 의해 로직이 영향을 받을 수 있다.
그러한 경우 이 값들은 `),Mo=p("code"),T5=t("struct"),S5=t("에 저장되어야 하고 메소드를 사용하는 것이 좋다."),qk=i(),Vk=p("br"),Jk=p("br"),Xk=i(),zs=p("h2"),qs=p("a"),Io=p("span"),M5=t("Embedding"),Zk=i(),Kk=p("hr"),Qk=i(),Gn=p("p"),I5=t("Go에는 상속이 없지만 "),Lo=p("strong"),L5=t("Embedding"),H5=t("을 통해 구조화된 "),Ho=p("code"),A5=t("struct"),G5=t(" 타입을 구성할 수 있다."),Yk=i(),zt=p("p"),B5=t("기본적인 예제는 다음과 같다."),$k=i(),Za=p("pre"),hk=i(),y=p("p"),Ao=p("code"),x5=t("Manager"),N5=t("를 정의할 때 "),Go=p("code"),F5=t("Employee"),W5=t("를 필드명 없이 선언해줌으로써, "),Bo=p("code"),U5=t("Employee"),j5=t("는 "),xo=p("code"),z5=t("Manager"),q5=t("의 "),No=p("strong"),V5=t("Embedded Field"),J5=t(`가 된다.
`),Fo=p("code"),X5=t("Manager"),Z5=t("에서는 "),Wo=p("code"),K5=t("Employee"),Q5=t("의 필드에 접근할 수 있다."),gk=i(),nf=p("br"),sf=i(),Ka=p("pre"),af=i(),Vs=p("p"),Y5=t("위 예제처럼 "),Uo=p("em"),$5=t("Embedding"),h5=t("된 구조체의 내부와 외부 양쪽에 동일한 필드명을 가진 상황이 생길 수 있다."),tf=i(),_n=p("p"),g5=t("이러한 경우, "),jo=p("code"),n_=t("Outer"),s_=t("에 있는 "),zo=p("code"),a_=t("Inner"),t_=t(" 내부에 위치한 X에 접근하려고 할 때는 "),qo=p("code"),e_=t("Inner"),p_=t("를 명시해줘야 한다."),ef=i(),pf=p("br"),of=p("br"),lf=i(),ds=p("p"),Vo=p("em"),o_=t("Embedding"),l_=t("은 다른 언어에서 찾기 힘든, 흔치 않은 개념이다. 그래서 구조적으로 비슷한 상속과 연관지어서 생각하곤 하는데, "),Jo=p("em"),c_=t("Embedding"),u_=t("은 상속과는 명백하게 다르다."),cf=i(),uf=p("br"),rf=i(),Bn=p("p"),i_=t("위 "),Xo=p("code"),r_=t("Manager"),k_=t("와 "),Zo=p("code"),f_=t("Employee"),d_=t(" 예제에 이어서, 아래 예제도 살펴보자."),kf=i(),Qa=p("pre"),ff=i(),Z=p("p"),E_=t("만약 상속이었다면 위 "),Ko=p("code"),m_=t("var eFail Employee = m"),v_=t(` 라인이 정상적으로 컴파일되었을 것이다.
`),Qo=p("code"),__=t("Manager"),y_=t("를 "),Yo=p("code"),b_=t("Employee"),w_=t(`의 하위 개념으로 보기 때문.
하지만 `),$o=p("em"),C_=t("Embedding"),D_=t("은 상속과는 차이가 있기 때문에 에러가 발생한다."),df=i(),Ef=p("br"),mf=i(),Js=p("p"),P_=t("Go는 상속을 지원하지 않기 때문에 폴리모피즘과는 거리가 있고, "),ho=p("strong"),O_=t("Dynamic Dispatch"),R_=t("(동적 디스패치)도 존재하지 않는다."),vf=i(),Ya=p("pre"),_f=i(),$a=p("pre"),yf=i(),I=p("p"),T_=t("위 예제에서 "),go=p("code"),S_=t("o.Double()"),M_=t("를 호출하면 겹치는 메소드명이 없기 때문에 "),nl=p("code"),I_=t("o.Inner.Double()"),L_=t(`가 자동 호출된다.
이 때 `),sl=p("code"),H_=t("o.Inner.Double()"),A_=t(" 내부에서는 "),al=p("code"),G_=t("o.Inner.IntPrinter()"),B_=t("를 호출하기 때문에, "),tl=p("code"),x_=t("Inner: 20"),N_=t(`가 출력된 것이다.
이렇듯 Go에서 메소드는 전혀 오버라이딩되지 않는다.`),bf=i(),wf=p("br"),Cf=p("br"),Df=i(),Xs=p("h2"),Zs=p("a"),el=p("span"),F_=t("Interface"),Pf=i(),Of=p("hr"),Rf=i(),Ks=p("p"),W_=t("책에서는 Go의 진정한 꽃이 Goroutine을 위시한 Concurrency가 아니라, 이 "),pl=p("em"),U_=t("Interface"),j_=t("라고 하는데, 대체 얼마나 맛집이기에.."),Tf=i(),qt=p("p"),z_=t("설명에 앞서 인터페이스는 아래와 같이 정의할 수 있다."),Sf=i(),ha=p("pre"),Mf=i(),b=p("p"),ol=p("code"),q_=t("struct"),V_=t(`를 정의하는 것과 큰 차이는 없는 것 같다.
암묵적인 룰이 하나 있는데, 인터페이스의 이름은 대개 “er”로 끝난다.
그 예로 `),ll=p("code"),J_=t("fmt.Stringer"),X_=t(", "),cl=p("code"),Z_=t("io.Reader"),K_=t(", "),ul=p("code"),Q_=t("io.Closer"),Y_=t(", "),il=p("code"),$_=t("io.ReadCloser"),h_=t(", "),rl=p("code"),g_=t("json.Marshaler"),n0=t(", "),kl=p("code"),s0=t("http.Handler"),a0=t(" 등등이 있다."),If=i(),Lf=p("br"),Hf=i(),on=p("p"),fl=p("em"),t0=t("Interface"),e0=t("는 객체지향의 "),dl=p("em"),p0=t("Abstract Class"),o0=t(`와 유사하지만, 차이점이 있다.
다른 객체지향 언어에서는 `),El=p("em"),l0=t("Abstract Class"),c0=t("에서 선언된 메소드 등을 "),ml=p("em"),u0=t("Concrete Class"),i0=t("에서 구현한다."),Af=i(),L=p("p"),r0=t("반면 Go의 인터페이스는 "),Vt=p("span"),k0=t("암묵적"),f0=t(`인 개념이다.
`),vl=p("em"),d0=t("Concrete Type"),E0=t(`에서는 인터페이스를 구현한다고 선언하지 않는다.
만약 `),_l=p("em"),m0=t("Concrete Type"),v0=t(`에서 구현하는 메소드들이 인터페이스에서 선언된 모든 메소드들을 포함한다면,
그 때 `),yl=p("em"),_0=t("Concrete Type"),y0=t(`가 인터페이스를 구현한다고 할 수 있으며, 이래서 암묵적이라는 표현을 사용하는 듯 하다.
그래서 Go에서는 `),bl=p("em"),b0=t("Concrete Type"),w0=t("을 인터페이스에 할당한다는 느낌으로 받아들여야 하는 것 같다."),Gf=i(),ga=p("p"),wl=p("em"),C0=t("Interface"),D0=t(" 덕에 Type-Safe, 디커플링, 정적/동적 언어에서 기능을 연결하는 것이 가능해진다고 하는데, 이건 좀 더 해봐야 알 듯 하다."),Bf=i(),xn=p("p"),P0=t("Javascript, Python 등의 동적 타입 언어에서는 인터페이스가 없는 대신 "),Cl=p("em"),O0=t("Duck Typing"),R0=t(`이란 것을 사용한다.
`),Dl=p("em"),T0=t("Duck Typing"),S0=t(`은 어떤 인스턴스가 원하는 메소드(또는 필드)들을 가지고 있다면, 내가 원하는 타입으로 간주한다는 뜻이다.
프로젝트의 규모가 너무 크거나, 프로젝트가 너무 오래되어서 의존성을 추적하기 어려운 경우 이런 방식을 사용한다.`),xf=i(),Jt=p("p"),M0=t(`주로 정적 타입 언어를 사용하는 개발자라면 이런 방식에 대해 회의적이다.
인스턴스의 타입을 명시하지 않으면 어떤 타입인지 확인하기도 어려울 것이며, 어떤 기능을 할 수 있을지 예측할 수 없으리라 생각한다.`),Nf=i(),Xt=p("p"),I0=t(`반면 Java에서는 다소 패턴이 다르다. 인터페이스의 정의와 구현이 각각 존재하지만, 인터페이스의 정의만 참조된다.
주로 동적 타입 언어를 사용하는 개발자들은 이 방식에 대해, 인터페이스가 바뀔 때마다 코드를 다시 짜야 하는 불편한 방식이라고 생각한다.`),Ff=i(),Wf=p("br"),Uf=i(),Zt=p("p"),L0=t(`만약 어플리케이션이 잠정적으로 개선될 여지가 있다면 코드에 유연성이 필요하다.
하지만 코드가 하고 있는 일이 무엇인지에 대해 사람들이 이해할 수 있도록 하는 것도 중요하기에, 코드의 역할과 의존성 등을 명시할 필요도 있다.
Go의 인터페이스는 양쪽 모두의 입장을 받아들인다.`),jf=i(),Kt=p("p"),H0=t("아래 예제에서 Interface가 사용된 예시를 확인할 수 있다."),zf=i(),nt=p("pre"),qf=i(),f=p("p"),Pl=p("em"),A0=t("Concrete Type"),G0=t(" 역할을 하는 "),Ol=p("code"),B0=t("LogicProvider"),x0=t("가 정의될 때, 이것이 "),Rl=p("code"),N0=t("Logic"),F0=t(`이라는 인터페이스에 관련된 것이라고 선언된 것은 없다.
`),Tl=p("code"),W0=t("Logic"),U0=t("과 "),Sl=p("code"),j0=t("LogicProvider"),z0=t("이 연결되는 것은, "),Ml=p("code"),q0=t("Client"),V0=t(" 인스턴스인 "),Il=p("code"),J0=t("c"),X0=t(`가 생성될 때이며,
`),Ll=p("code"),Z0=t("LogicProvider"),K0=t("에는 "),Hl=p("code"),Q0=t("Logic"),Y0=t("에서 정의된 것과 동일한 이름의 메소드인 "),Al=p("code"),$0=t("Process()"),h0=t(`가 존재할 뿐이다.
따라서 `),Gl=p("code"),g0=t("LogicProvider"),n4=t("가 "),Bl=p("code"),s4=t("Logic"),a4=t("이라는 인터페이스를 위한 "),xl=p("em"),t4=t("Concrete Type"),e4=t("임을 알 수 있도록, 잘 문서화할 필요가 있다."),Vf=i(),Jf=p("br"),Xf=i(),K=p("p"),p4=t("Go에서는 "),Nl=p("code"),o4=t("io.Reader"),l4=t("나 "),Fl=p("code"),c4=t("io.Writer"),u4=t(` 등, 스탠다드 인터페이스도 존재한다.
스탠다드 인터페이스를 사용하는 것은 `),Wl=p("em"),i4=t("decorator"),r4=t(` 패턴과 유사한데,
특정 인터페이스의 인스턴스를 받아서 동일한 인터페이스의 다른 인스턴스를 반환하는 `),Ul=p("em"),k4=t("Factory Function"),f4=t("(객체를 반환하는 함수)를 자주 사용하기 때문."),Zf=i(),Qt=p("p"),d4=t("아래 예제를 확인하자."),Kf=i(),st=p("pre"),Qf=i(),Q=p("p"),E4=t("위 코드에서 "),jl=p("code"),m4=t("os.Open()"),v4=t("에 의해 반환된 "),zl=p("code"),_4=t("os.File"),y4=t(" 인스턴스는 "),ql=p("code"),b4=t("io.Reader"),w4=t(` 인터페이스를 충족시킨다.
따라서 `),Vl=p("code"),C4=t("process()"),D4=t(" 함수 내에서 파일의 데이터를 읽을 수 있다."),Yf=i(),Nn=p("p"),P4=t("아래 예제는 "),Jl=p("code"),O4=t("gzip"),R4=t("을 통해 파일을 압축 해제할 수 있는 경우에, "),Xl=p("code"),T4=t("gzip"),S4=t(" 라이브러리를 사용하여 압축 해제하는 예제이다."),$f=i(),at=p("pre"),hf=i(),Yt=p("p"),M4=t("위처럼 스탠다드 라이브러리의 인터페이스가 코드에 잘 어울릴 것 같으면, 사용하는 것이 좋다."),gf=i(),P=p("p"),I4=t("예제에서는 "),Zl=p("code"),L4=t("gzip"),H4=t("으로 압축 해제된 "),Kl=p("code"),A4=t("io.Reader"),G4=t(" 인터페이스의 인스턴스가 "),Ql=p("code"),B4=t("gz"),x4=t(`에 할당되고,
그 `),Yl=p("code"),N4=t("gz"),F4=t("가 다시 한번 "),$l=p("code"),W4=t("process()"),U4=t("함수에서 "),hl=p("code"),j4=t("io.Reader"),z4=t("의 인스턴스가 된다."),n1=i(),Y=p("p"),q4=t(`어느 타입의 메소드들이 특정 인터페이스를 충족시키고도 남는 경우,
즉 인터페이스에 명시된 것 외의 메소드들이 존재한다고 해도 그 타입은 인터페이스를 충족시킨다.
이 때문에 한 타입이 두 개 이상의 인터페이스를 동시에 충족시킬 수 있다. 이 때 명시된 것 외의 메소드들은 무시한다.
이를테면 `),gl=p("code"),V4=t("io.File"),J4=t(" 타입은 "),nc=p("code"),X4=t("io.Reader"),Z4=t("와 "),sc=p("code"),K4=t("io.Writer"),Q4=t(`를 동시에 충족시킨다.
즉, `),ac=p("code"),Y4=t("io.File"),$4=t(" 한 가지 타입으로 읽고 쓰기가 동시에, 각각 지원되는 것이다."),s1=i(),a1=p("br"),t1=p("br"),e1=i(),Qs=p("h3"),Ys=p("a"),tc=p("span"),h4=t("Embedding and Interfaces"),p1=i(),ln=p("p"),ec=p("code"),g4=t("struct"),ny=t(` 타입을 Embedding하는 것처럼, 인터페이스도 인터페이스 안에 Embedding할 수 있다.
스탠다드 라이브러리의 `),pc=p("code"),sy=t("io.ReadCloser"),ay=t("도 "),oc=p("code"),ty=t("io.Reader"),ey=t("와 "),lc=p("code"),py=t("io.Closer"),oy=t(`가 임베딩된 것이다.
아래의 예제와 유사하다.`),o1=i(),tt=p("pre"),l1=i(),c1=p("br"),u1=p("br"),i1=i(),$s=p("h3"),hs=p("a"),cc=p("span"),ly=t("Accept Interfaces, Return Structs"),r1=i(),gs=p("p"),cy=t("Go의 빡고수들이 버릇처럼 읊는 말이 "),uc=p("strong"),uy=t("Accept Interfaces, Return Structs"),iy=t(`라고 한다.
이는 함수에 의해 호출되는 로직은 반드시 인터페이스를 통해 호출되어야 하며,
함수의 결과값은 반드시 concrete type(struct)이어야 한다는 것이다.
함수의 파라미터로 인터페이스를 받으면 어떤 기능을 사용할 것인지 명시적으로 선언하면서도, flexible함을 동시에 챙길 수 있다.`),k1=i(),$t=p("p"),ry=t(`만약 API가 (암묵적이어야 할) 인터페이스를 리턴한다면, 디커플링이라는 인터페이스의 장점을 잃는다.
만약 그렇게 된다면 서드 파티 모듈의 인터페이스에 코드가 종속되는 결과를 낳게 된다.
대개 서드 파티 인터페이스에 대한 클라이언트의 의존성을 줄이고자 하기 마련이다.
이를 위해 또다른 인터페이스를 작성한 뒤, 타입 변환을 하는데(의존성 주입, Dependency Injection),
이는 어플리케이션의 기능을 제약할 수도 있기에 좋은 방법은 아니다.`),f1=i(),ht=p("p"),ky=t(`인터페이스를 리턴하지 말아야 하는 또 다른 이유는 버전에 관련된 것이다.
Concrete Type을 리턴하는 경우에는 기존 코드에 새로운 메소드나 필드가 별 문제 없이 추가될 수 있다.
반면 인터페이스의 경우에는 새로운 메소드를 추가하려면 기존에 존재하는 모든 메소드들의 구현을 업데이트해야 한다.
따라서 API를 롤백해야 하는 경우에도, major version number를 증가시켜야 한다.`),d1=i(),gt=p("p"),fy=t(`인터페이스가 정해져 있고 파라미터에 따라서 다른 인스턴스가 나오는 factory function을 짜는 것보다는,
타입들을 분리하여 concrete type이 반환되는 각각의 함수를 작성하는 것이 좋다.`),E1=i(),Fn=p("p"),dy=t(`웬만하면 인터페이스를 반환하지 않는 것이 좋긴 한데, 가끔 어쩔 수 없이 하는 경우가 있다. 대표적인 예시가 바로 에러이다.
Go에서는 `),ic=p("code"),Ey=t("error"),my=t(` 인터페이스를 반환하도록 선언되는 경우가 많다.
이는 인터페이스가 Go에서 유일하게 사용할 수 있는 추상 유형이며. `),rc=p("code"),vy=t("error"),_y=t(` 인터페이스의 다른 구현을 사용해야 하는 경우가 많기 때문이다.
따라서 가능한 모든 옵션을 처리하기 위해 인터페이스를 사용해야 한다.`),m1=i(),ne=p("p"),yy=t(`다만 이러한 패턴의 잠재적인 문제점이 존재한다.
concrete type을 반환하는 경우 Heap 할당이 줄어들기에 가비지 콜렉터의 워크로드가 줄어든다.
반면 인터페이스를 파라미터로 사용하는 함수의 경우, 각 인터페이스마다 Heap 할당되므로, 가비지 콜렉터가 힘들어한다.
결국은 더 좋은 성능과 더 좋은 추상화 사이에 trade-off가 존재하는 셈이다.`),v1=i(),se=p("p"),by=t(`그렇기 때문에 되도록이면 코드를 예쁘게, 고치기 편하게 작성하는 것이 좋다.
그래야 인터페이스로 인한 잠재적인 성능 문제가 발생하여도, 이를 concrete type으로 변경하는 등의 작업을 하기가 쉬워진다.`),_1=i(),y1=p("br"),b1=p("br"),w1=i(),na=p("h3"),sa=p("a"),kc=p("span"),wy=t("Interfaces and nil"),C1=i(),Wn=p("p"),Cy=t("많이 봐왔듯, "),fc=p("code"),Dy=t("nil"),Py=t(`은 포인터의 Zero value이다.
마찬가지로 `),dc=p("code"),Oy=t("nil"),Ry=t("은 인터페이스의 Zero value이긴 하지만, Concrete Type들에 비해 간단하지만은 않다."),D1=i(),et=p("pre"),P1=i(),pt=p("pre"),O1=i(),Un=p("p"),Ty=t(`Go의 인터페이스는 내부적으로 두 쌍의 포인터로 구성되며, 각각 타입, 값을 가리킨다.
만약 타입을 가리키는 포인터가 `),Ec=p("code"),Sy=t("nil"),My=t("이 아니라면, 인터페이스는 "),mc=p("code"),Iy=t("nil"),Ly=t("이 아닌 것이다. 출력 결과의 세 번째 라인이 저 모양인 것이 이 때문."),R1=i(),O=p("p"),Hy=t("인터페이스에 할당된 concrete type에 따라 호출되는 메소드가 달라지듯, 인터페이스에서 "),vc=p("code"),Ay=t("nil"),Gy=t(`은 메소드를 호출할 수 있는지 여부를 나타낸다.
만약 인터페이스가 `),_c=p("code"),By=t("nil"),xy=t("임에도 메소드를 호출하였다면, "),yc=p("em"),Ny=t("panic"),Fy=t(`이 발생한다.
만약 인터페이스가 `),bc=p("code"),Wy=t("nil"),Uy=t(`이 아닌데 메소드를 호출하였다면, 메소드를 호출하려고 시도할 것이다.
(다만 위 예제와 같은 경우 인터페이스에 연결된 값이 `),wc=p("code"),jy=t("nil"),zy=t("이기 때문에, 곧바로 "),Cc=p("em"),qy=t("panic"),Vy=t("이 발생할 것이다.)"),T1=i(),$=p("p"),Jy=t("인터페이스 인스턴스의 타입을 나타내는 포인터가 "),Dc=p("code"),Xy=t("nil"),Zy=t("이 아니라면, 이는 "),Pc=p("code"),Ky=t("nil"),Qy=t(`이 아닌 것이다.
그렇다고 해서 이 인터페이스의 값이 `),Oc=p("code"),Yy=t("nil"),$y=t("인지는 확실하게 알 수 없기 때문에, 나중에 나올 "),Rc=p("em"),hy=t("Reflection"),gy=t("을 사용해야 한다."),S1=i(),M1=p("br"),I1=p("br"),L1=i(),aa=p("h3"),ta=p("a"),Tc=p("span"),n6=t("The Empty Interface Says Nothing"),H1=i(),ea=p("p"),s6=t(`정적 타입 언어에서도 아무 타입이나 다 집어넣을 수 있는 변수가 필요할 때가 있다.
그러한 경우, Go에서는 `),Sc=p("code"),a6=t("interface{}"),t6=t("를 사용할 수 있다."),A1=i(),ot=p("pre"),G1=i(),jn=p("p"),e6=t(`비어 있는 인터페이스는 말 그대로 아무 값이나 다 저장할 수 있다.
인터페이스가 비어 있다는 말은 0개 이상의 메소드가 있는 타입들을 가리킬 수 있다는 뜻이며,
그래서 메소드가 없는 `),Mc=p("code"),p6=t("int"),o6=t(", "),Ic=p("code"),l6=t("string"),c6=t(" 등의 Primitive Type들도 저장이 가능해진다."),B1=i(),x1=p("br"),N1=i(),ae=p("p"),u6=t("비어 있는 인터페이스가 사용되는 예 중 하나는, JSON처럼 외부 소스에서 읽어온 불분명한 스키마의 placeholder로 사용하는 것이다."),F1=i(),lt=p("pre"),W1=i(),pa=p("p"),i6=t("위 코드를 실행하면 JSON 데이터가 "),Lc=p("code"),r6=t("data"),k6=t(" 변수에 저장된다."),U1=i(),j1=p("br"),z1=i(),yn=p("p"),f6=t(`또 다른 경우에는, 유저가 만든 자료구조에서 다양한 타입의 값을 저장하기 위해 사용된다.
Go의 `),Hc=p("code"),d6=t("slice"),E6=t(", "),Ac=p("code"),m6=t("map"),v6=t(" 등 타입들은 한 가지 타입밖에 저장하지 못하는데 비해, "),Gc=p("code"),_6=t("interface{}"),y6=t("는 여러 타입을 가리킬 수 있기 때문."),q1=i(),ct=p("pre"),V1=i(),te=p("p"),b6=t("위 코드는 러프한 예시니까 실제로 사용하지는 말자."),J1=i(),bn=p("p"),w6=t("또 다른 사용예로는 함수의 파라미터로 "),Bc=p("code"),C6=t("interface{}"),D6=t("를 받는 경우인데, "),xc=p("em"),P6=t("reflection"),O6=t(`을 하기 위해 사용한다고 하는 것 같다.
`),Nc=p("em"),R6=t("reflection"),T6=t("은 나중에 나온다!"),X1=i(),Z1=p("br"),K1=i(),H=p("p"),S6=t("근데 "),Fc=p("code"),M6=t("interface{}"),I6=t(`를 되도록이면 사용하지 않는 게 좋다.
Go는 기본적으로 정적 타입 언어로 디자인된 언어인 만큼, `),Wc=p("code"),L6=t("interface{}"),H6=t(`로 여러 타입들을 쑤시고 다니는 건 좋지 않다.
`),Uc=p("code"),A6=t("interface{}"),G6=t(`를 사용하여 값들을 저장해야 할 상황에서, 값을 다시 읽어오려면 어떻게 해야 할까?
그럴 때 바로 아래에서 설명할 `),jc=p("em"),B6=t("Type Assertions"),x6=t(" 및 "),zc=p("em"),N6=t("Type Switches"),F6=t("를 사용해 보자."),Q1=i(),Y1=p("br"),$1=p("br"),h1=i(),oa=p("h3"),la=p("a"),qc=p("span"),W6=t("Type Assertions and Type Switches"),g1=i(),ee=p("p"),U6=t(`Go에는 어떤 변수의 인터페이스가 가리키는 타입이 특정한 Concrete Type인지,
혹은 Concrete Type이 또 다른 인터페이스를 구현하는지 확인할 수 있는 두 가지 방법이 있다.`),nd=i(),ca=p("p"),j6=t("한 가지가 바로 "),Vc=p("strong"),z6=t("Type Assertion"),q6=t(`이다.
이는 어떤 인터페이스를 구현하는 Concrete Type에 이름을 붙이거나,
또는 이 인터페이스를 구현하고 있는 Concrete Type이 구현하는 또 다른 인터페이스에 이름을 붙인다.`),sd=i(),ut=p("pre"),ad=i(),A=p("p"),V6=t("이렇게 "),Jc=p("em"),J6=t("Type Assertion"),X6=t("을 사용하여 "),Xc=p("code"),Z6=t("i"),K6=t("가 가리키고 있는 타입을 "),Zc=p("code"),Q6=t("MyInt"),Y6=t(`로 한정할 수 있다.
위 예제에서 변수 `),Kc=p("code"),$6=t("i2"),h6=t("의 타입은 "),Qc=p("code"),g6=t("MyInt"),n7=t("가 된다."),td=i(),ed=p("br"),pd=i(),zn=p("p"),s7=t("만약 잘못된 타입으로 "),Yc=p("em"),a7=t("Type Assertion"),t7=t("을 하면 "),$c=p("em"),e7=t("panic"),p7=t("이 발생한다."),od=i(),it=p("pre"),ld=i(),cd=p("br"),ud=i(),cn=p("p"),hc=p("code"),o7=t("int"),l7=t("와 "),gc=p("code"),c7=t("MyInt"),u7=t("는 본질적으론 같은 타입이지만, Go는 타입에 엄격하기 때문에 "),nu=p("em"),i7=t("Type Assertion"),r7=t(`을 사용할 때 Concrete Type끼리 일치시켜주어야 한다.
따라서 아래와 같은 예제는 `),su=p("em"),k7=t("panic"),f7=t("이 발생한다."),id=i(),rt=p("pre"),rd=i(),kd=p("br"),fd=i(),Es=p("p"),au=p("code"),d7=t("map"),E7=t("을 사용할 때 보았던 "),tu=p("em"),m7=t("comma ok idiom"),v7=t("을 사용하여 panic을 회피할 수 있다."),dd=i(),kt=p("pre"),Ed=i(),w=p("p"),eu=p("code"),_7=t("map"),y7=t(`에서 봤던 패턴과 유사하다.
`),pu=p("em"),b7=t("Type Assertion"),w7=t("에 성공하면 변수 "),ou=p("code"),C7=t("ok"),D7=t("는 "),lu=p("code"),P7=t("true"),O7=t("가 되며, 나머지 변수는 인터페이스가 가리키는 값으로 초기화된다."),R7=p("br"),T7=t(`
반면 실패하면 `),cu=p("code"),S7=t("ok"),M7=t("는 "),uu=p("code"),I7=t("false"),L7=t("가 되며, 나머지 변수는 해당 타입의 Zero value로 초기화된다."),md=i(),qn=p("p"),H7=t("그렇게 얻은 "),iu=p("code"),A7=t("ok"),G7=t(" 변수값을 통해 이를 "),ru=p("code"),B7=t("if"),x7=t(`문으로 처리할 수는 있지만
Go에서는 에러 핸들링을 통해 처리하는 것을 더 지향한다는 것 같다. 에러 핸들링은 다음 챕터에서 나온다!`),vd=i(),ua=p("p"),N7=t("어찌 됐든, 인터페이스가 가리키고 있는 데이터의 타입이 확실하다고 생각해도 되도록이면 "),ku=p("em"),F7=t("comma ok idiom"),W7=t(`를 쓰는 것이 좋다.
다른 사람이나 미래의 내가 언제 이 코드를 다시 사용할 지도 모르는 일이며, 코드를 조금 수정했는데 런타임 에러가 날 수도 있으니 말이다.`),_d=i(),yd=p("br"),bd=p("br"),wd=i(),ia=p("p"),U7=t("어느 인터페이스의 타입에 여러 개의 후보군이 있다면, "),fu=p("em"),j7=t("Type Switch"),z7=t("를 써보도록 하자."),Cd=i(),ft=p("pre"),Dd=i(),dt=p("pre"),Pd=i(),Vn=p("p"),q7=t("기본적으로 형태는 boolean 표현식이 사용되지 않는 일반적인 "),du=p("code"),V7=t("switch"),J7=t(`문의 형태와 유사하다.
다만 switch문 이후에 `),Eu=p("code"),X7=t("i.(type)"),Z7=t(`로, 인터페이스의 타입을 나타내어 주면 된다.
이렇게 각 case문에 타입을 할당함으로써, 인터페이스의 타입에 따라 처리할 수 있다.`),Od=i(),_=p("p"),K7=t(`실행 결과를 보면 대충 알 수 있겠지만, 3번째 줄의 경우 주의해야 할 것 같다.
변수 `),mu=p("code"),Q7=t("c"),Y7=t("는 값이 "),vu=p("code"),$7=t("nil"),h7=t("인 것이지, 타입은 "),_u=p("code"),g7=t("nil"),n8=t("이 아니라 "),yu=p("code"),s8=t("*string"),a8=t(`이다.
실제로 `),bu=p("code"),t8=t("switch"),e8=t("문에서 "),wu=p("code"),p8=t("case nil"),o8=t("에 걸리는 경우는, 변수 "),Cu=p("code"),l8=t("f"),c8=t("처럼 인터페이스가 가리키는 대상이 아무 것도 없을 때이다."),Rd=i(),ra=p("p"),u8=t("인터페이스가 가리키는 타입에 대해 전혀 모를 경우, "),Du=p("em"),i8=t("reflection"),r8=t(`을 사용하면 된다고 한다.
나중에 나온다. 나중에…`),Td=i(),un=p("p"),Pu=p("em"),k8=t("Type Assertion"),f8=t("과 "),Ou=p("em"),d8=t("Type Switch"),E8=t(`가 꽤나 유용한 기술처럼 보이는데, 자주 사용하면 안된다고 한다.
웬만하면 함수의 파라미터나 리턴값은 특정한 몇 가지의 타입으로만 지정하는 것이 좋으며, 나머지 다른 타입들은 가능은 하더라도 안되게 해야 한다.
그렇지 않으면 우리가 짜는 함수가 어떤 타입들을 지원하는지에 대해 정확히 명시하지 못할 수 있다.
대충 `),Ru=p("code"),m8=t("interface{}"),v8=t("를 사용하는 걸 지양하라는 말과 일맥상통하는 것 같다. "),Tu=p("code"),_8=t("interface{}"),y8=t("를 안 쓰면 특정한 타입을 명시할 수밖에 없을 테니 말이다."),Sd=i(),Md=p("br"),Id=i(),ms=p("p"),Su=p("em"),b8=t("Type Assertion"),w8=t("과 "),Mu=p("em"),C8=t("Type Switch"),D8=t("가 유용하게 사용되는 예제에 대해 알아보자."),Ld=i(),G=p("p"),P8=t(`가장 일반적인 경우, 한 인터페이스가 가리키고 있는 concrete type을 보기 위해 사용되는데,
이 concrete type은 다른 인터페이스에서도 가리킬 수 있는 경우이다.
이를테면 `),Iu=p("code"),O8=t("io"),R8=t(" 라이브러리의 "),Lu=p("code"),T8=t("io.File"),S8=t(" 등 여러 타입들은 "),Hu=p("code"),M8=t("io.Reader"),I8=t("와 "),Au=p("code"),L8=t("io.Writer"),H8=t(` 두 가지 인터페이스를 모두 만족시킨다.
그 때 `),Gu=p("code"),A8=t("io.Reader"),G8=t("가 가리키고 있는 타입이 어떤 타입인지 확인하기 위해 사용할 수 있을 것이다."),Hd=i(),m=p("p"),Bu=p("code"),B8=t("io.Copy()"),x8=t(" 함수는 "),xu=p("code"),N8=t("io.Reader"),F8=t("와 "),Nu=p("code"),W8=t("io.Writer"),U8=t(" 인터페이스들을 파라미터로 받아, "),Fu=p("code"),j8=t("io.copyBuffer()"),z8=t(`함수를 실행한다.
다만 이때 `),Wu=p("code"),q8=t("io.Reader"),V8=t("의 파라미터가 "),Uu=p("code"),J8=t("io.ReaderFrom"),X8=t("에서도 사용할 수 있거나, "),ju=p("code"),Z8=t("io.Writer"),K8=t("의 파라미터가 "),zu=p("code"),Q8=t("io.WriterTo"),Y8=t(`에서도 사용할 수 있다면,
함수 내용 대부분이 생략될 수 있다.`),Ad=i(),Et=p("pre"),Gd=i(),Bd=p("br"),xd=i(),Jn=p("p"),$8=t(`인터페이스는 API를 업그레이드할때도 사용된다고 한다.
챕터 12에서 `),qu=p("em"),h8=t("context"),g8=t("에 대해 알아볼 텐데, "),Vu=p("em"),n9=t("context"),s9=t(`란 취소를 관리하는 표준적인 방법을 제시하는 파라미터이다.
Go 버전 1.7부터 생긴 기능인지라, 이전 버전의 데이터베이스 드라이버 등에서는 지원하지 않는다.`),Nd=i(),R=p("p"),a9=t("Go 1.8부터는 "),Ju=p("code"),t9=t("database/sql/driver"),e9=t(` 패키지에 기존에 존재하는 인터페이스에 대한 새로운 컨텍스트 인식 유사체가 정의되었다.
이를테면 `),Xu=p("code"),p9=t("StmtExecContext"),o9=t(" 인터페이스에는 "),Zu=p("code"),l9=t("ExecContext"),c9=t(`라는 메소드가 있다.
스탠다드 라이브러리 데이터베이스 코드에 `),Ku=p("code"),u9=t("Stmt"),i9=t(` 인터페이스의 타입이 통과될 경우,
이 타입이 `),Qu=p("code"),r9=t("StmtExecContext"),k9=t("에도 사용할 수 있는지 확인한다. 만약 그렇다면 "),Yu=p("code"),f9=t("ExecContext"),d9=t(`를 호출한다.
만약 그렇지 않다면, fallback code를 실행한다.`),Fd=i(),mt=p("pre"),Wd=i(),Ud=p("br"),jd=i(),Xn=p("p"),E9=t(`이런 optional interface 기능에는 한 가지 단점이 존재한다.
한 인터페이스로 여러 가지 타입을 사용하여 계층적 구조를 만드는 decorator 패턴을 사용하기 위해 인터페이스가 많이들 사용된다.
이 때, 어느 optional interface가 이 타입들 중 한 가지라도 사용할 수 있다면, `),$u=p("em"),m9=t("Type Assertion"),v9=t("과 "),hu=p("em"),_9=t("Type Switch"),y9=t("으로 이를 감지할 수 없다."),zd=i(),T=p("p"),b9=t("그 예로 "),gu=p("code"),w9=t("bufio"),C9=t(`라는 표준 라이브러리는 buffered reader를 제공한다.
이 때 `),ni=p("code"),D9=t("bufio.NewReader()"),P9=t(" 함수에 "),si=p("code"),O9=t("io.Reader"),R9=t("를 지원하는 타입을 파라미터로 통과시키면, "),ai=p("code"),T9=t("*bufio.Reader"),S9=t(`를 리턴받는다.
만약 파라미터로 넘겨진 `),ti=p("code"),M9=t("io.Reader"),I9=t("의 타입이 "),ei=p("code"),L9=t("io.ReaderFrom"),H9=t("도 지원하는 경우, 이를 buffered reader로 감싸게 되면 최적화가 되지 않는다."),qd=i(),h=p("p"),A9=t(`에러 핸들링 할때도 본 현상인데, 에러는 다른 에러를 감싸는 것을 통해 추가적인 정보를 포함할 수 있다.
`),pi=p("em"),G9=t("Type Assertion"),B9=t("과 "),oi=p("em"),x9=t("Type Switch"),N9=t(`로는 감싸진 에러를 확인할 수 없기 때문에,
제대로 핸들링하기 위해 감싸진 에러에 접근하려면 `),li=p("code"),F9=t("errors.Is()"),W9=t("나 "),ci=p("code"),U9=t("errors.As()"),j9=t("같은 함수를 사용해야 한다."),Vd=i(),Jd=p("br"),Xd=i(),vt=p("p"),ui=p("em"),z9=t("Type Switch"),q9=t(`는 인터페이스를 지원하는 타입들이 여러 개 있고, 각 타입마다 다르게 처리해줘야 하는 경우 유용하다.
그중 가장 유용한 경우는, 유효한 타입이 딱 한 개만 존재하는 경우이다.`),Zd=i(),g=p("p"),V9=t("웬만하면 "),ii=p("code"),J9=t("switch"),X9=t("문에 "),ri=p("code"),Z9=t("default"),K9=t(`를 반드시 넣어주는 게 좋다.
인터페이스를 지원하는 타입을 추가했는데 `),ki=p("code"),Q9=t("switch"),Y9=t("문을 업데이트하는 것을 까먹은 경우 "),fi=p("code"),$9=t("default"),h9=t(" 블록에 걸리므로, 문제를 추적하기 쉬워질 것이다."),Kd=i(),Qd=p("br"),Yd=p("br"),$d=i(),ka=p("h3"),fa=p("a"),di=p("span"),g9=t("Function Types Are a Bridge to Interfaces"),hd=i(),pe=p("p"),nb=t("Go에서는 함수를 비롯하여 유저가 정의한 타입이라면 어떠한 타입이든 메소드를 추가할 수 있으며, 이는 굉장히 유용하다."),gd=i(),oe=p("p"),sb=t("가장 일반적인 사례는 HTTP 요청을 처리하는 HTTP 핸들러이다. 이는 아래와 같이 인터페이스로 정의되어 있다."),nE=i(),_t=p("pre"),sE=i(),F=p("p"),Ei=p("code"),ab=t("http.ResponseWriter"),tb=t(", "),mi=p("code"),eb=t("*http.Request"),pb=t("를 파라미터로 받는 함수들은 "),vi=p("code"),ob=t("HandlerFunc"),lb=t(`로 타입 변환을 할 수 있다.
그러면 `),_i=p("code"),cb=t("ServeHTTP()"),ub=t("를 호출할 수 있게 되며, "),yi=p("code"),ib=t("http.Handler"),rb=t(" 인터페이스를 사용할 수 있게 된다."),aE=i(),yt=p("pre"),tE=i(),da=p("p"),kb=t("이러한 방식을 통해 "),bi=p("code"),fb=t("http.Handler"),db=t("의 인터페이스를 충족시키기만 하면 함수, 메소드, Closure를 HTTP 핸들러로 사용할 수 있다."),eE=i(),pE=p("br"),oE=i(),le=p("p"),Eb=t(`Go에서 함수는 가장 중요한 개념인 만큼, 또 다른 함수의 파라미터로 전달된다.
한편으로, Go에서는 작은 인터페이스를 권장하며, 메소드가 하나 뿐인 인터페이스는 함수의 파라미터로 전달되는 함수를 대체할 수 있다.
그렇다면 이런 질문이 생길 수 있다. 파라미터인 함수의 타입을 언제 명시해줘야 하며, 언제 인터페이스를 써야 할까?`),lE=i(),Zn=p("p"),mb=t(`만약 함수가 다른 함수들이나, 파라미터가 아닌 state에 의존한다면,
인터페이스 파라미터를 사용하고 인터페이스에 대한 bridge로써 함수 타입을 정의하는 것이 좋다고 한다.
이를테면 이는 `),wi=p("code"),vb=t("http"),_b=t(` 패키지에서 사용하는 방식이다. http 핸들러는 설정해주어야 하는 연쇄적인 함수 호출의 진입점일 가능성이 높다.
반면 함수가 `),Ci=p("code"),yb=t("sort.Slice()"),bb=t("처럼 간단한 함수일 경우, 인터페이스보단 그냥 함수를 넘기는 게 좋다고 한다."),cE=i(),uE=p("br"),iE=p("br"),rE=i(),Ea=p("h3"),ma=p("a"),Di=p("span"),wb=t("Implicit Interfaces Make Dependency Injection Easier"),kE=i(),bt=p("p"),Pi=p("strong"),Cb=t("Dependency Injection"),Db=t(`이란 코드가 수행하는 기능과 작업을 분명하게 명시해야 한다는 개념이다.
Go의 인터페이스는 디커플링을 맛깔나게 잘 해줘서 Dependency Injection이 엄청 잘 된다고 한다.
그래서 다른 언어에서 Dependency Injection를 위해 복잡한 프레임워크를 사용하는 반면,
Go는 어떠한 외부 라이브러리도 사용하지 않는다.`),fE=i(),ce=p("p"),Pb=t("Dependency Injection이 어떻게 이루어지는지 보기 위해, 간단한 웹 서버 예제를 만들어보자."),dE=i(),wt=p("pre"),EE=i(),va=p("p"),Ob=t(`간단한 로깅 함수와 저장을 위한 데이터 타입, 및 데이터 탐색 메소드를 정의하였다.
`),Oi=p("code"),Rb=t("SimpleDataStore"),Tb=t(" 인스턴스를 생성하는 factory function을 정의해보자."),mE=i(),Ct=p("pre"),vE=i(),_E=p("br"),yE=i(),Kn=p("p"),Sb=t(`이제 유저에게 “hello” 또는 “good bye”라고 날리는 로직을 작성해 볼 것이다.
이 로직은 유저에게 접근해야 하므로 접근 대상이 되는 자료구조와, 로깅을 하는 함수에 대한 의존성이 존재한다.
하지만 우리는 `),Ri=p("code"),Mb=t("LogOutput()"),Ib=t("이나 "),Ti=p("code"),Lb=t("SimpleDataStore"),Hb=t(`에 대한 직접적인 의존성을 만들고 싶지 않다.
미래에 다른 자료구조나 로깅 함수를 사용할 수도 있기 때문이다.`),bE=i(),ue=p("p"),Ab=t("바로 이러한 경우, 인터페이스가 적절한 해법이 된다."),wE=i(),Dt=p("pre"),CE=i(),Tn=p("p"),Si=p("code"),Gb=t("LoggerAdapter"),Bb=t("를 선언해 "),Mi=p("code"),xb=t("LogOutput()"),Nb=t("함수를 "),Ii=p("code"),Fb=t("Logger"),Wb=t(`에 연결해 주었다.
이제 우리의 비즈니스 로직은 인터페이스들을 사용하여 자료구조에 접근하고, 로깅을 할 수 있다.`),DE=i(),ie=p("p"),Ub=t("의존성이 정의되었으니, 비즈니스 로직을 완성해보자."),PE=i(),Pt=p("pre"),OE=i(),W=p("p"),Li=p("code"),jb=t("Logger"),zb=t("와 "),Hi=p("code"),qb=t("DataStore"),Vb=t("를 필드로 갖는 "),Ai=p("code"),Jb=t("SimpleLogic"),Xb=t("이라는 "),Gi=p("code"),Zb=t("struct"),Kb=t(`와, factory function을 정의해주었다.
이 `),Bi=p("code"),Qb=t("SimpleLogic"),Yb=t(` 내의 메소드는 다른 concrete type을 레퍼런스하지 않기 때문에, 의존성이 없다.
그래서 차후 라이브러리를 교체하더라도 인터페이스는 라이브러리와 관련이 없기 때문에 문제가 발생하지 않는다.`),RE=i(),TE=p("br"),SE=i(),Qn=p("p"),$b=t("이제 "),xi=p("code"),hb=t("/hello"),gb=t(`라는 엔드포인트를 정의해볼 것이다. 이 엔드포인트에서는 유저의 ID가 같이 오면 인사를 할 것이다.
`),Ni=p("em"),nw=t("Controller"),sw=t("에게 인사를 할 로직을 쥐어주기 위해 인터페이스를 만들어주자."),ME=i(),Ot=p("pre"),IE=i(),Yn=p("p"),aw=t("이 인터페이스는 "),Fi=p("code"),tw=t("SimpleLogic"),ew=t(`을 가리킬 수 있다.
인터페이스는 클라이언트 코드에서 정의되기 때문에, 수정이 필요하다면 클라이언트 코드에서 수정하면 그만이다.
따라서 `),Wi=p("code"),pw=t("SimpleLogic"),ow=t("이 나중에 변경되거나, 혹은 새로운 로직이 추가되더라도 별다른 문제 없이 사용할 수 있다."),LE=i(),Rt=p("pre"),HE=i(),AE=p("br"),GE=i(),_a=p("p"),lw=t("마지막으로, "),Ui=p("code"),cw=t("main"),uw=t(" 함수에서 모든 컴포넌트를 연결하고 서버를 열어보자."),BE=i(),Tt=p("pre"),xE=i(),$n=p("p"),iw=t("파일을 실행하여 서버를 연 뒤, 브라우저에서 "),ji=p("code"),rw=t("http://localhost:8080/hello?user_id=1"),kw=t(" 및 "),zi=p("code"),fw=t("http://localhost:8080/hello?user_id=5"),dw=t(" 등으로 접속해보자."),NE=i(),S=p("p"),qi=p("code"),Ew=t('http.HandleFunc("/hello", c.SayHello)'),mw=t(" 라인을 잘 살펴보면, 두 번째 "),Vi=p("code"),vw=t("http.HandleFunc()"),_w=t("의 두 번째 파라미터로 "),Ji=p("code"),yw=t("c.SayHello()"),bw=t(` 메소드를 보냈다.
이때 보내진 메소드는 `),Xi=p("code"),ww=t("http.Handler"),Cw=t(" 인터페이스를 충족시키는 "),Zi=p("code"),Dw=t("http.HandlerFunc"),Pw=t(` 타입으로 변환이 된다.
`),Ki=p("code"),Ow=t("NewController"),Rw=t("의 메소드임을 유지한 채로 말이다."),FE=i(),vs=p("p"),Qi=p("code"),Tw=t("main"),Sw=t(` 함수는 concrete type들이 실제로 선언되는 유일한 영역이다.
어느 타입 하나를 다른 타입으로 변경하고 싶다면, `),Yi=p("code"),Mw=t("main"),Iw=t(`에서만 변경해주면 된다.
이렇게 Dependency Injection을 통해 의존성을 Externalizing함으로써, 코드를 업데이트 할 때 변경해야 할 내용을 최소화할 수 있다.`),WE=i(),re=p("p"),Lw=t(`Dependency Injection은 테스트를 더 쉽게 할 수 있도록 해주기도 한다.
환경이 다르더라도, 입출력이 제한된 상황에서 unit test를 하는 것은 코드를 효과적으로 재사용한다.
이를테면 위 예제에서 logger의 출력을 테스트하려고 한다면, logger의 출력을 capture하는 타입을 주입하고 인터페이스를 충족시켜주기만 하면 된다.`),UE=i(),jE=p("br"),zE=i(),ya=p("p"),Hw=t(`개인적으로는 Dependency Injection이 일단 짜놓으면 편하긴 한데, 직접 짜기에는 너무 복잡하고 양이 많아 보였다.
그럴 때에는 구글님들이 `),St=p("a"),Aw=t("Wire"),Gw=t(`라는, Dependency Injection을 도와주는 유틸리티가 있는데,
자동적으로 concrete type 선언 코드를 만들어준다고 하니 필요하다면 잘 사용해보도록 하자.`),qE=i(),VE=p("br"),JE=p("br"),XE=i(),ba=p("h3"),wa=p("a"),$i=p("span"),Bw=t("Go Isn’t Particularly Object-Oriented"),ZE=i(),ke=p("p"),xw=t(`Go라는 언어를 특정 스타일로 구분짓기는 어렵다.
일단 절차지향은 아닌 듯 한데, 메소드 오버라이딩이나 상속도 없어서 객체지향이라기에도 애매하다.
함수 타입과 closure가 있지만 함수형 언어도 아니다.
만약 이러한 방법론에 맞춰서 Go 코드를 짜면, 아마 그게 이상적인 Go 코드는 아닐 것이다.`),KE=i(),QE=p("br"),YE=p("br"),$E=i(),Ca=p("h2"),Da=p("a"),hi=p("span"),Nw=t("Refereces"),hE=i(),gE=p("hr"),n2=i(),fe=p("center"),_s=p("p"),Mt=p("a"),de=p("img"),Fw=i(),Ww=p("br"),Uw=i(),It=p("a"),jw=t("Jon Bodner, 『Learning Go』, O’Reilly Media, Inc."),s2=i(),a2=p("br"),t2=i(),Ee=p("p"),zw=t("이번 포스트는 의역이 너무 많아용"),e2=i(),me=p("p"),qw=t("원문 참조하시는 게 좋을듯함"),p2=i(),o2=p("br"),l2=p("br"),this.h()},l(n){At=o(n,"BR",{}),pr=r(n),Gt=o(n,"P",{});var c=l(Gt);S2=e(c,"본 글은 Golang을 공부하며 주요 내용이라 생각되는 것들을 기록해둔 자료이며, Ubuntu 20.04 LTS 기준으로 작성되었습니다."),c.forEach(a),or=r(n),lr=o(n,"BR",{}),cr=o(n,"BR",{}),ur=r(n),Ps=o(n,"H2",{id:!0});var Vw=l(Ps);Os=o(Vw,"A",{"aria-hidden":!0,tabindex:!0,href:!0});var fC=l(Os);ze=o(fC,"SPAN",{class:!0}),l(ze).forEach(a),fC.forEach(a),M2=e(Vw,"Types"),Vw.forEach(a),ir=r(n),rr=o(n,"HR",{}),kr=r(n),Rs=o(n,"P",{});var c2=l(Rs);I2=e(c2,"Go에는 Class나 상속과 같은 개념이 개념이 존재하지 않는다. 대신 타입을 정의하고자 하는 경우, "),qe=o(c2,"CODE",{});var dC=l(qe);L2=e(dC,"type"),dC.forEach(a),H2=e(c2," 키워드를 사용하여 정의한다."),c2.forEach(a),fr=r(n),Aa=o(n,"PRE",{class:!0});var gM=l(Aa);gM.forEach(a),dr=r(n),Bt=o(n,"P",{});var EC=l(Bt);A2=e(EC,"위처럼 정의된 타입들은 이들이 정의된 스코프 내에서만 정의 가능하다."),EC.forEach(a),Er=r(n),mr=o(n,"BR",{}),vr=r(n),kn=o(n,"P",{});var Pa=l(kn);G2=e(Pa,"한 가지 짚고 넘어가야 할 점은, 위 예제의 "),Ve=o(Pa,"CODE",{});var mC=l(Ve);B2=e(mC,"Score"),mC.forEach(a),x2=e(Pa," 타입의 경우 사실상 "),Je=o(Pa,"CODE",{});var vC=l(Je);N2=e(vC,"int"),vC.forEach(a),F2=e(Pa,`와 동일한 타입이다.
그럼에도 위와 같이 타입명을 지정해준 것은 타입명 자체를 일종의 `),Xe=o(Pa,"STRONG",{});var _C=l(Xe);W2=e(_C,"documentation"),_C.forEach(a),U2=e(Pa,"으로 볼 수 있기 때문이다."),Pa.forEach(a),_r=r(n),Ln=o(n,"P",{});var ve=l(Ln);j2=e(ve,`이러한 타입 지정은 해당 타입의 변수 또는 인스턴스가 코드 내에서 어떠한 역할을 하며,
어떠한 데이터를 저장할 지에 대한 정보를 제공할 수 있다.
위 예제에서 `),Ze=o(ve,"CODE",{});var yC=l(Ze);z2=e(yC,"Score"),yC.forEach(a),q2=e(ve,"는 "),Ke=o(ve,"CODE",{});var bC=l(Ke);V2=e(bC,"int"),bC.forEach(a),J2=e(ve,"와 똑같은 정수 타입이기는 해도, 무식하게 큰 정수나 음수인 값에 대해서는 유효하지 않은 값임을 파악할 수 있을 것이다."),ve.forEach(a),yr=r(n),Ts=o(n,"P",{});var u2=l(Ts);X2=e(u2,"위 예제의 "),Qe=o(u2,"CODE",{});var wC=l(Qe);Z2=e(wC,"Employee"),wC.forEach(a),K2=e(u2,`은 유저가 정의한 타입을 다시 정의한 경우인데, 이 또한 같은 맥락에서 바라볼 수 있다.
저장하고 있는 데이터의 종류는 같을지라도, 이들이 사용되어야 할 적합한 맥락에 대해서 정보를 제공할 수 있다.`),u2.forEach(a),br=r(n),wr=o(n,"BR",{}),Cr=o(n,"BR",{}),Dr=r(n),Ss=o(n,"H3",{id:!0});var Jw=l(Ss);Ms=o(Jw,"A",{"aria-hidden":!0,tabindex:!0,href:!0});var CC=l(Ms);Ye=o(CC,"SPAN",{class:!0}),l(Ye).forEach(a),CC.forEach(a),Q2=e(Jw,"Inheritance in Go?"),Jw.forEach(a),Pr=r(n),xt=o(n,"P",{});var DC=l(xt);Y2=e(DC,"Go에는 객체지향과 상속 개념이 없다. type을 선언할 수 있지만, 이는 말 그대로 어디까지나 선언만 할 수 있는 것이다."),DC.forEach(a),Or=r(n),Ga=o(n,"PRE",{class:!0});var nI=l(Ga);nI.forEach(a),Rr=r(n),Is=o(n,"P",{});var i2=l(Is);$2=e(i2,"위와 같은 "),$e=o(i2,"CODE",{});var PC=l($e);h2=e(PC,"type"),PC.forEach(a),g2=e(i2,` 선언은 상속처럼 보일 수는 있지만, 엄연히 다르다. 실질적으로는 이름만 다른 동일한 타입이 두 개 선언되는 것.
이들 사이에는 어떠한 계층 구조도 존재하지 않는다.`),i2.forEach(a),Tr=r(n),q=o(n,"P",{});var hn=l(q);nm=e(hn,"객체지향에서 "),he=o(hn,"EM",{});var OC=l(he);sm=e(OC,"child class"),OC.forEach(a),am=e(hn,"는 "),ge=o(hn,"EM",{});var RC=l(ge);tm=e(RC,"parent class"),RC.forEach(a),em=e(hn,`가 가진 모든 메소드와 값들을 사용할 수 있어야 하며, parent class가 사용되는 곳 어디에든 사용될 수 있어야 한다.
반면 Go에서는, 위 예제의 `),np=o(hn,"CODE",{});var TC=l(np);pm=e(TC,"Score"),TC.forEach(a),om=e(hn," 인스턴스가 사용되는 상황에서 "),sp=o(hn,"CODE",{});var SC=l(sp);lm=e(SC,"HighScore"),SC.forEach(a),cm=e(hn," 인스턴스를 사용하려면 타입 변환을 해주어야 한다."),hn.forEach(a),Sr=r(n),Ba=o(n,"PRE",{class:!0});var sI=l(Ba);sI.forEach(a),Mr=r(n),Ir=o(n,"BR",{}),Lr=o(n,"BR",{}),Hr=r(n),Ls=o(n,"H3",{id:!0});var Xw=l(Ls);Hs=o(Xw,"A",{"aria-hidden":!0,tabindex:!0,href:!0});var MC=l(Hs);ap=o(MC,"SPAN",{class:!0}),l(ap).forEach(a),MC.forEach(a),um=e(Xw,"Enumeration in Go - iota"),Xw.forEach(a),Ar=r(n),Hn=o(n,"P",{});var _e=l(Hn);im=e(_e,"여러 프로그래밍 언어에 존재하는 "),tp=o(_e,"EM",{});var IC=l(tp);rm=e(IC,"Enumeration"),IC.forEach(a),km=e(_e,"에 대한 개념 대신, Go에는 "),ep=o(_e,"CODE",{});var LC=l(ep);fm=e(LC,"iota"),LC.forEach(a),dm=e(_e,"가 존재한다. 바로 예제를 확인해보자."),_e.forEach(a),Gr=r(n),xa=o(n,"PRE",{class:!0});var aI=l(xa);aI.forEach(a),Br=r(n),Na=o(n,"PRE",{class:!0});var tI=l(Na);tI.forEach(a),xr=r(n),V=o(n,"P",{});var gn=l(V);Em=e(gn,`위 예제의 실행 결과를 확인해보면, 0부터 4까지의 수가 순서대로 할당되었음을 알 수 있다.
이는 `),pp=o(gn,"CODE",{});var HC=l(pp);mm=e(HC,"iota"),HC.forEach(a),vm=e(gn,"가 첫 번째 상수인 "),op=o(gn,"CODE",{});var AC=l(op);_m=e(AC,"Uncategorized"),AC.forEach(a),ym=e(gn,"에 0, 두 번째 상수인 "),lp=o(gn,"CODE",{});var GC=l(lp);bm=e(GC,"Personal"),GC.forEach(a),wm=e(gn,`에 1, 이런 식으로 점점 증가되게끔 값을 할당하였기 때문이다.
또한, 만일 새로운 `),cp=o(gn,"CODE",{});var BC=l(cp);Cm=e(BC,"const"),BC.forEach(a),Dm=e(gn," 선언 블록이 존재할 경우, iota는 0이 될 것이다."),gn.forEach(a),Nr=r(n),Fr=o(n,"BR",{}),Wr=r(n),Fa=o(n,"PRE",{class:!0});var eI=l(Fa);eI.forEach(a),Ur=r(n),us=o(n,"P",{});var gi=l(us);up=o(gi,"CODE",{});var xC=l(up);Pm=e(xC,"_"),xC.forEach(a),Om=e(gi,`를 이용하면 iota로 할당되는 값을 건너뛸 수 있다.
또한 `),ip=o(gi,"CODE",{});var NC=l(ip);Rm=e(NC,"iota"),NC.forEach(a),Tm=e(gi,`를 사용할 때 위와 같은 표현식을 사용하여 값들을 할당할 수도 있다.
다만 이런 경우, 무슨 목적으로 이런 코드를 짰는지 잘 명시해주는 것이 좋겠다.`),gi.forEach(a),jr=r(n),zr=o(n,"BR",{}),qr=r(n),D=o(n,"P",{});var nn=l(D);Sm=e(nn,"단 "),rp=o(nn,"CODE",{});var FC=l(rp);Mm=e(FC,"iota"),FC.forEach(a),Im=e(nn,"를 사용하려면 "),kp=o(nn,"CODE",{});var WC=l(kp);Lm=e(WC,"iota"),WC.forEach(a),Hm=e(nn,`에 의해서 할당되는 값이 큰 의미가 없는 경우여야 한다.
0, 1, 2, … 등 `),fp=o(nn,"CODE",{});var UC=l(fp);Am=e(UC,"iota"),UC.forEach(a),Gm=e(nn,`에 의해 할당되는 값들은 단순히 서로를 구분하기 위해서 사용되는 값일 뿐이며, 이 값을 직접적으로 사용해선 안된다.
만일 `),dp=o(nn,"CODE",{});var jC=l(dp);Bm=e(jC,"iota"),jC.forEach(a),xm=e(nn,"를 사용하는 "),Ep=o(nn,"CODE",{});var zC=l(Ep);Nm=e(zC,"const"),zC.forEach(a),Fm=e(nn,` 블록 중간에 새로운 상수를 추가하면 값들이 전체적으로 바뀔 것이다.
이 때 `),mp=o(nn,"CODE",{});var qC=l(mp);Wm=e(qC,"iota"),qC.forEach(a),Um=e(nn,"에 의해 할당되는 값을 직접적으로 사용한다면 이에 영향을 받을 것이다."),nn.forEach(a),Vr=r(n),J=o(n,"P",{});var ns=l(J);jm=e(ns,`특정 인터페이스와 직접적으로 관련되어있지 않은 내부적인 로직에서 사용하는 것이 좋다.
만약 어느 `),vp=o(ns,"CODE",{});var VC=l(vp);zm=e(VC,"struct"),VC.forEach(a),qm=e(ns," 타입에 "),_p=o(ns,"CODE",{});var JC=l(_p);Vm=e(JC,"iota"),JC.forEach(a),Jm=e(ns,`를 사용하는 Enumeration 필드가 존재하고, 해당 인스턴스들이 DB에 저장되어있다고 가정해보자.
그런데 `),yp=o(ns,"CODE",{});var XC=l(yp);Xm=e(XC,"iota"),XC.forEach(a),Zm=e(ns,"를 사용하는 "),bp=o(ns,"CODE",{});var ZC=l(bp);Km=e(ZC,"const"),ZC.forEach(a),Qm=e(ns," 블록 중간에 새로운 상수를 추가하면 DB에 저장된 값들이 완전히 다른 값을 가리키게 될 것이다."),ns.forEach(a),Jr=r(n),As=o(n,"P",{});var r2=l(As);Ym=e(r2,"따라서 상수의 값이 중요한 경우이거나 내부적인 로직에서 사용하는 것이 아니라면 "),wp=o(r2,"CODE",{});var KC=l(wp);$m=e(KC,"iota"),KC.forEach(a),hm=e(r2,`를 쓰지 말고 그냥 값을 직접 할당해주는 편이 좋다.
그게 아니라면 문서를 잘 써놓자.`),r2.forEach(a),Xr=r(n),Zr=o(n,"BR",{}),Kr=o(n,"BR",{}),Qr=r(n),Gs=o(n,"H2",{id:!0});var Zw=l(Gs);Bs=o(Zw,"A",{"aria-hidden":!0,tabindex:!0,href:!0});var QC=l(Bs);Cp=o(QC,"SPAN",{class:!0}),l(Cp).forEach(a),QC.forEach(a),gm=e(Zw,"Methods"),Zw.forEach(a),Yr=r(n),$r=o(n,"HR",{}),hr=r(n),fn=o(n,"P",{});var Oa=l(fn);nv=e(Oa,"Go에서는 "),Dp=o(Oa,"EM",{});var YC=l(Dp);sv=e(YC,"User-defined type"),YC.forEach(a),av=e(Oa,`에 대해 메소드를 생성할 수 있다.
일반적인 함수 선언과 유사하지만, `),Pp=o(Oa,"CODE",{});var $C=l(Pp);tv=e($C,"func"),$C.forEach(a),ev=e(Oa,"와 메소드명 사이에 "),Op=o(Oa,"STRONG",{});var hC=l(Op);pv=e(hC,"receiver"),hC.forEach(a),ov=e(Oa,`를 명시해준다.
보통의 변수 선언처럼 변수명을 먼저 적고 타입을 뒤에 적는다.
일반적으로는 타입명의 맨 앞글자를 소문자로 적는다고 한다.`),Oa.forEach(a),gr=r(n),Wa=o(n,"PRE",{class:!0});var pI=l(Wa);pI.forEach(a),nk=r(n),Nt=o(n,"P",{});var gC=l(Nt);lv=e(gC,`Go에서는 함수 오버로딩을 지원하지 않으며, 메소드도 동일하다.
동일한 타입에서 두개 이상의 동일한 이름을 가진 메소드를 선언할 수 없다.`),gC.forEach(a),sk=r(n),Ft=o(n,"P",{});var nD=l(Ft);cv=e(nD,"또한 타입과 이에 대한 메소드가 선언된 파일을 서로 분리할 수는 있지만, 같은 파일 에서 함께 선언하는 것이 권장된다고 한다."),nD.forEach(a),ak=r(n),tk=o(n,"BR",{}),ek=o(n,"BR",{}),pk=r(n),xs=o(n,"H3",{id:!0});var Kw=l(xs);Ns=o(Kw,"A",{"aria-hidden":!0,tabindex:!0,href:!0});var sD=l(Ns);Rp=o(sD,"SPAN",{class:!0}),l(Rp).forEach(a),sD.forEach(a),uv=e(Kw,"Pointer Receivers"),Kw.forEach(a),ok=r(n),dn=o(n,"P",{});var Ra=l(dn);iv=e(Ra,"함수에서 포인터 파라미터를 사용할 때처럼, "),Tp=o(Ra,"EM",{});var aD=l(Tp);rv=e(aD,"Receiver"),aD.forEach(a),kv=e(Ra,`에도 포인터를 사용할 수 있다.
이 때 `),Sp=o(Ra,"EM",{});var tD=l(Sp);fv=e(tD,"Value Receiver"),tD.forEach(a),dv=e(Ra,"를 사용할 때와의 차이점은 "),Mp=o(Ra,"EM",{});var eD=l(Mp);Ev=e(eD,"Receiver"),eD.forEach(a),mv=e(Ra,"로 패스한 값이 변경될 수 있다는 것이다."),Ra.forEach(a),lk=r(n),Ua=o(n,"P",{});var Qw=l(Ua);Ip=o(Qw,"EM",{});var pD=l(Ip);vv=e(pD,"Pointer Reciver"),pD.forEach(a),_v=e(Qw,"에 대한 몇 가지 규칙이 존재한다."),Qw.forEach(a),ck=r(n),An=o(n,"OL",{});var ye=l(An);is=o(ye,"LI",{});var be=l(is);yv=e(be,"메소드가 "),Lp=o(be,"EM",{});var oD=l(Lp);bv=e(oD,"Reciver"),oD.forEach(a),wv=e(be," 값을 변경한다면, 반드시 "),Hp=o(be,"EM",{});var lD=l(Hp);Cv=e(lD,"Pointer Reciver"),lD.forEach(a),Dv=e(be,"를 사용한다."),be.forEach(a),Pv=r(ye),rs=o(ye,"LI",{});var we=l(rs);Ov=e(we,"메소드가 "),Ap=o(we,"CODE",{});var cD=l(Ap);Rv=e(cD,"nil"),cD.forEach(a),Tv=e(we," 인스턴스를 다뤄야 한다면, 반드시 "),Gp=o(we,"EM",{});var uD=l(Gp);Sv=e(uD,"Pointer Reciver"),uD.forEach(a),Mv=e(we,"를 사용한다."),we.forEach(a),Iv=r(ye),ks=o(ye,"LI",{});var Ce=l(ks);Lv=e(Ce,"메소드가 "),Bp=o(Ce,"EM",{});var iD=l(Bp);Hv=e(iD,"Reciver"),iD.forEach(a),Av=e(Ce," 값을 변경하지 않는다면, "),xp=o(Ce,"EM",{});var rD=l(xp);Gv=e(rD,"Value Reciver"),rD.forEach(a),Bv=e(Ce,"를 사용할 수 있다."),Ce.forEach(a),ye.forEach(a),uk=r(n),Rn=o(n,"P",{});var Lt=l(Rn);Np=o(Lt,"EM",{});var kD=l(Np);xv=e(kD,"Reciver"),kD.forEach(a),Nv=e(Lt," 값을 변경하지 않는 메소드에 대해서도 "),Fp=o(Lt,"EM",{});var fD=l(Fp);Fv=e(fD,"Pointer Reciver"),fD.forEach(a),Wv=e(Lt,`를 사용하는 것이 국룰이라고 한다.
다만 난 잘 모르겠다. 개인적으로는 값을 변경하지 않는다면 명시적으로 `),Wp=o(Lt,"EM",{});var dD=l(Wp);Uv=e(dD,"Value Reciver"),dD.forEach(a),jv=e(Lt,"를 써도 되는 거 아닌가 싶다."),Lt.forEach(a),ik=r(n),rk=o(n,"BR",{}),kk=r(n),ja=o(n,"PRE",{class:!0});var oI=l(ja);oI.forEach(a),fk=r(n),En=o(n,"P",{});var Ta=l(En);zv=e(Ta,"함수에 포인터 파라미터를 넘길 때와는 달리, Receiver에 "),Up=o(Ta,"CODE",{});var ED=l(Up);qv=e(ED,"&"),ED.forEach(a),Vv=e(Ta,`를 붙이지 않아도 된다.
위 `),jp=o(Ta,"CODE",{});var mD=l(jp);Jv=e(mD,"c.Increment()"),mD.forEach(a),Xv=e(Ta," 부분은 자동으로 "),zp=o(Ta,"CODE",{});var vD=l(zp);Zv=e(vD,"(&c).Increment()"),vD.forEach(a),Kv=e(Ta,`로 변환된다.
아래 코드는 예제의 실행 결과이다.`),Ta.forEach(a),dk=r(n),za=o(n,"PRE",{class:!0});var lI=l(za);lI.forEach(a),Ek=r(n),mk=o(n,"BR",{}),vk=r(n),Wt=o(n,"P",{});var _D=l(Wt);Qv=e(_D,"이러한 규칙들에 대해 잘 이해하면, 아래 예제의 실행 결과도 알 수 있을 것이다."),_D.forEach(a),_k=r(n),qa=o(n,"PRE",{class:!0});var cI=l(qa);cI.forEach(a),yk=r(n),E=o(n,"P",{});var C=l(E);qp=o(C,"CODE",{});var yD=l(qp);Yv=e(yD,"doUpdateWrong()"),yD.forEach(a),$v=e(C," 함수의 스코프 내에서 "),Vp=o(C,"CODE",{});var bD=l(Vp);hv=e(bD,"c.Increment()"),bD.forEach(a),gv=e(C,"를 호출시 "),Jp=o(C,"CODE",{});var wD=l(Jp);n3=e(wD,"c"),wD.forEach(a),s3=e(C,`가 변경되고, 그 결과가 이후 출력에서 반영된다.
하지만 `),Xp=o(C,"CODE",{});var CD=l(Xp);a3=e(CD,"doUpdateWrong()"),CD.forEach(a),t3=e(C," 함수는 파라미터인 "),Zp=o(C,"CODE",{});var DD=l(Zp);e3=e(DD,"Counter"),DD.forEach(a),p3=e(C,"를 "),Kp=o(C,"EM",{});var PD=l(Kp);o3=e(PD,"pass by value"),PD.forEach(a),l3=e(C,"로 받았기 때문에 "),Qp=o(C,"CODE",{});var OD=l(Qp);c3=e(OD,"main()"),OD.forEach(a),u3=e(C,` 함수로 되돌아왔을 때 변경사항이 유지되지 않는다.
반면 `),Yp=o(C,"CODE",{});var RD=l(Yp);i3=e(RD,"doUpdateWrong()"),RD.forEach(a),r3=e(C," 함수는 파라미터를 "),$p=o(C,"EM",{});var TD=l($p);k3=e(TD,"pass by pointer"),TD.forEach(a),f3=e(C,"로 받았기에, 변경사항이 유지된다."),C.forEach(a),bk=r(n),Ut=o(n,"P",{});var SD=l(Ut);d3=e(SD,"위 예제의 실행 결과는 아래와 같다."),SD.forEach(a),wk=r(n),Va=o(n,"PRE",{class:!0});var uI=l(Va);uI.forEach(a),Ck=r(n),Dk=o(n,"BR",{}),Pk=r(n),mn=o(n,"P",{});var Sa=l(mn);E3=e(Sa,"이렇게 유저가 정의한 타입에 Method를 통해 "),hp=o(Sa,"EM",{});var MD=l(hp);m3=e(MD,"Getter"),MD.forEach(a),v3=e(Sa,"나, "),gp=o(Sa,"EM",{});var ID=l(gp);_3=e(ID,"Pointer Reciver"),ID.forEach(a),y3=e(Sa,"를 이용하여 "),no=o(Sa,"EM",{});var LD=l(no);b3=e(LD,"Setter"),LD.forEach(a),w3=e(Sa,`를 정의할 수는 있다.
다만 필드에 직접 값을 할당하는 경우가 아니거나, 여러 필드를 한 번의 오퍼레이션으로 처리해야 하는 경우가 아니라면,
Go에서는 되도록이면 필드값에 직접 접근하는 것을 권장한다.`),Sa.forEach(a),Ok=r(n),Rk=o(n,"BR",{}),Tk=o(n,"BR",{}),Sk=r(n),fs=o(n,"P",{});var nr=l(fs);so=o(nr,"EM",{});var HD=l(so);C3=e(HD,"Pointer Reciver"),HD.forEach(a),D3=e(nr,"는 "),ao=o(nr,"CODE",{});var AD=l(ao);P3=e(AD,"nil"),AD.forEach(a),O3=e(nr," 인스턴스를 다뤄야 할 때 사용할 수 있다."),nr.forEach(a),Mk=r(n),v=o(n,"P",{});var B=l(v);R3=e(B,"다른 언어들의 경우 "),to=o(B,"CODE",{});var GD=l(to);T3=e(GD,"null"),GD.forEach(a),S3=e(B,"이나 "),eo=o(B,"CODE",{});var BD=l(eo);M3=e(BD,"None"),BD.forEach(a),I3=e(B,` 인스턴스에서 메소드를 호출하면 에러가 발생한다.
Go에서도 `),po=o(B,"CODE",{});var xD=l(po);L3=e(xD,"nil"),xD.forEach(a),H3=e(B," 인스턴스에서 메소드를 호출할 때 "),oo=o(B,"EM",{});var ND=l(oo);A3=e(ND,"Value Reciver"),ND.forEach(a),G3=e(B,"인 경우에는 "),lo=o(B,"EM",{});var FD=l(lo);B3=e(FD,"panic"),FD.forEach(a),x3=e(B,"이 발생하지만, "),co=o(B,"EM",{});var WD=l(co);N3=e(WD,"Pointer Reciver"),WD.forEach(a),F3=e(B,`인 경우 메소드가 정상적으로 호출된다.
이 경우, 메소드가 `),uo=o(B,"CODE",{});var UD=l(uo);W3=e(UD,"nil"),UD.forEach(a),U3=e(B," 인스턴스를 처리할 수 있게끔 작성되어 있어야 한다."),B.forEach(a),Ik=r(n),Ja=o(n,"PRE",{class:!0});var iI=l(Ja);iI.forEach(a),Lk=r(n),Fs=o(n,"P",{});var k2=l(Fs);j3=e(k2,"위 예제는 "),io=o(k2,"CODE",{});var jD=l(io);z3=e(jD,"nil"),jD.forEach(a),q3=e(k2," 인스턴스를 핸들링할 수 있는 정수형 바이너리 트리의 예제이다."),k2.forEach(a),Hk=r(n),pn=o(n,"P",{});var ys=l(pn);ro=o(ys,"CODE",{});var zD=l(ro);V3=e(zD,"IntTree.Contains()"),zD.forEach(a),J3=e(ys," 메소드는 현재 receiver가 "),ko=o(ys,"CODE",{});var qD=l(ko);X3=e(qD,"nil"),qD.forEach(a),Z3=e(ys,`인지에 따라 해당 값이 포함되어 있는가의 여부를 판단하며
`),fo=o(ys,"CODE",{});var VD=l(fo);K3=e(VD,"IntTree.Insert()"),VD.forEach(a),Q3=e(ys," 메소드는 현재 receiver가 "),Eo=o(ys,"CODE",{});var JD=l(Eo);Y3=e(JD,"nil"),JD.forEach(a),$3=e(ys,`일 경우 현 위치에 값을 추가한 값을 반환한다.
단, 이때는 포인터 파라미터를 사용할 때처럼 receiver에 특정 주소값을 할당하여도, 원본 포인터가 변경되지는 않는다.`),ys.forEach(a),Ak=r(n),Gk=o(n,"BR",{}),Bk=o(n,"BR",{}),xk=r(n),Ws=o(n,"H3",{id:!0});var Yw=l(Ws);Us=o(Yw,"A",{"aria-hidden":!0,tabindex:!0,href:!0});var XD=l(Us);mo=o(XD,"SPAN",{class:!0}),l(mo).forEach(a),XD.forEach(a),h3=e(Yw,"Methods and Functions"),Yw.forEach(a),Nk=r(n),jt=o(n,"P",{});var ZD=l(jt);g3=e(ZD,"Go에서 메소드는 함수와 유사한 점이 많다."),ZD.forEach(a),Fk=r(n),Xa=o(n,"PRE",{class:!0});var rI=l(Xa);rI.forEach(a),Wk=r(n),vn=o(n,"P",{});var Ma=l(vn);n5=e(Ma,"함수를 변수에 할당하여 사용할 수 있듯, 위 예제의 "),vo=o(Ma,"CODE",{});var KD=l(vo);s5=e(KD,"f1"),KD.forEach(a),a5=e(Ma,`처럼 메소드도 변수에 할당하여 사용할 수 있다.
이 때 이 메소드의 타입은 `),_o=o(Ma,"CODE",{});var QD=l(_o);t5=e(QD,"func(int)int"),QD.forEach(a),e5=e(Ma,"가 되며, 이를 "),yo=o(Ma,"EM",{});var YD=l(yo);p5=e(YD,"method value"),YD.forEach(a),o5=e(Ma,"라 한다."),Ma.forEach(a),Uk=r(n),N=o(n,"P",{});var Sn=l(N);bo=o(Sn,"EM",{});var $D=l(bo);l5=e($D,"method value"),$D.forEach(a),c5=e(Sn,"는 "),wo=o(Sn,"EM",{});var hD=l(wo);u5=e(hD,"closure"),hD.forEach(a),i5=e(Sn,`처럼 파라미터로 넘기거나 할 수도 있다.
`),Co=o(Sn,"EM",{});var gD=l(Co);r5=e(gD,"method value"),gD.forEach(a),k5=e(Sn,"를 선언할 때 붙어있던 "),Do=o(Sn,"EM",{});var nP=l(Do);f5=e(nP,"receiver"),nP.forEach(a),d5=e(Sn,"가 고정되어 있기 때문에, 이를 호출할 경우 해당 "),Po=o(Sn,"EM",{});var sP=l(Po);E5=e(sP,"receiver"),sP.forEach(a),m5=e(Sn,"가 영향을 받는다."),Sn.forEach(a),jk=r(n),X=o(n,"P",{});var ss=l(X);v5=e(ss,"위 예제의 "),Oo=o(ss,"CODE",{});var aP=l(Oo);_5=e(aP,"f2"),aP.forEach(a),y5=e(ss,`처럼 그냥 타입명에 메소드를 붙인 것을 변수에 할당할 수도 있다.
이를 `),Ro=o(ss,"EM",{});var tP=l(Ro);b5=e(tP,"method expression"),tP.forEach(a),w5=e(ss,"이라 한다. 이 때 이 메소드의 타입은 "),To=o(ss,"CODE",{});var eP=l(To);C5=e(eP,"func(Adder, int) int"),eP.forEach(a),D5=e(ss,"가 되며, 첫 번째 파라미터가 "),So=o(ss,"EM",{});var pP=l(So);P5=e(pP,"receiver"),pP.forEach(a),O5=e(ss,"가 된다."),ss.forEach(a),zk=r(n),js=o(n,"P",{});var f2=l(js);R5=e(f2,`이렇게 Go에서는 메소드를 함수처럼 사용할 수 있기에 큰 차이가 없기에 어느 것을 사용해야 할지 혼동이 올 수 있다.
만약 작성하고자 하는 로직이 입력 파라미터에 의해서만 영향을 받는다면 함수를 사용하는 것이 옳다.
반면 프로그램이 실행되며 설정되고, 실행 중 계속 바뀌는 어떤 값에 의해 로직이 영향을 받을 수 있다.
그러한 경우 이 값들은 `),Mo=o(f2,"CODE",{});var oP=l(Mo);T5=e(oP,"struct"),oP.forEach(a),S5=e(f2,"에 저장되어야 하고 메소드를 사용하는 것이 좋다."),f2.forEach(a),qk=r(n),Vk=o(n,"BR",{}),Jk=o(n,"BR",{}),Xk=r(n),zs=o(n,"H2",{id:!0});var $w=l(zs);qs=o($w,"A",{"aria-hidden":!0,tabindex:!0,href:!0});var lP=l(qs);Io=o(lP,"SPAN",{class:!0}),l(Io).forEach(a),lP.forEach(a),M5=e($w,"Embedding"),$w.forEach(a),Zk=r(n),Kk=o(n,"HR",{}),Qk=r(n),Gn=o(n,"P",{});var De=l(Gn);I5=e(De,"Go에는 상속이 없지만 "),Lo=o(De,"STRONG",{});var cP=l(Lo);L5=e(cP,"Embedding"),cP.forEach(a),H5=e(De,"을 통해 구조화된 "),Ho=o(De,"CODE",{});var uP=l(Ho);A5=e(uP,"struct"),uP.forEach(a),G5=e(De," 타입을 구성할 수 있다."),De.forEach(a),Yk=r(n),zt=o(n,"P",{});var iP=l(zt);B5=e(iP,"기본적인 예제는 다음과 같다."),iP.forEach(a),$k=r(n),Za=o(n,"PRE",{class:!0});var kI=l(Za);kI.forEach(a),hk=r(n),y=o(n,"P",{});var U=l(y);Ao=o(U,"CODE",{});var rP=l(Ao);x5=e(rP,"Manager"),rP.forEach(a),N5=e(U,"를 정의할 때 "),Go=o(U,"CODE",{});var kP=l(Go);F5=e(kP,"Employee"),kP.forEach(a),W5=e(U,"를 필드명 없이 선언해줌으로써, "),Bo=o(U,"CODE",{});var fP=l(Bo);U5=e(fP,"Employee"),fP.forEach(a),j5=e(U,"는 "),xo=o(U,"CODE",{});var dP=l(xo);z5=e(dP,"Manager"),dP.forEach(a),q5=e(U,"의 "),No=o(U,"STRONG",{});var EP=l(No);V5=e(EP,"Embedded Field"),EP.forEach(a),J5=e(U,`가 된다.
`),Fo=o(U,"CODE",{});var mP=l(Fo);X5=e(mP,"Manager"),mP.forEach(a),Z5=e(U,"에서는 "),Wo=o(U,"CODE",{});var vP=l(Wo);K5=e(vP,"Employee"),vP.forEach(a),Q5=e(U,"의 필드에 접근할 수 있다."),U.forEach(a),gk=r(n),nf=o(n,"BR",{}),sf=r(n),Ka=o(n,"PRE",{class:!0});var fI=l(Ka);fI.forEach(a),af=r(n),Vs=o(n,"P",{});var d2=l(Vs);Y5=e(d2,"위 예제처럼 "),Uo=o(d2,"EM",{});var _P=l(Uo);$5=e(_P,"Embedding"),_P.forEach(a),h5=e(d2,"된 구조체의 내부와 외부 양쪽에 동일한 필드명을 가진 상황이 생길 수 있다."),d2.forEach(a),tf=r(n),_n=o(n,"P",{});var Ia=l(_n);g5=e(Ia,"이러한 경우, "),jo=o(Ia,"CODE",{});var yP=l(jo);n_=e(yP,"Outer"),yP.forEach(a),s_=e(Ia,"에 있는 "),zo=o(Ia,"CODE",{});var bP=l(zo);a_=e(bP,"Inner"),bP.forEach(a),t_=e(Ia," 내부에 위치한 X에 접근하려고 할 때는 "),qo=o(Ia,"CODE",{});var wP=l(qo);e_=e(wP,"Inner"),wP.forEach(a),p_=e(Ia,"를 명시해줘야 한다."),Ia.forEach(a),ef=r(n),pf=o(n,"BR",{}),of=o(n,"BR",{}),lf=r(n),ds=o(n,"P",{});var sr=l(ds);Vo=o(sr,"EM",{});var CP=l(Vo);o_=e(CP,"Embedding"),CP.forEach(a),l_=e(sr,"은 다른 언어에서 찾기 힘든, 흔치 않은 개념이다. 그래서 구조적으로 비슷한 상속과 연관지어서 생각하곤 하는데, "),Jo=o(sr,"EM",{});var DP=l(Jo);c_=e(DP,"Embedding"),DP.forEach(a),u_=e(sr,"은 상속과는 명백하게 다르다."),sr.forEach(a),cf=r(n),uf=o(n,"BR",{}),rf=r(n),Bn=o(n,"P",{});var Pe=l(Bn);i_=e(Pe,"위 "),Xo=o(Pe,"CODE",{});var PP=l(Xo);r_=e(PP,"Manager"),PP.forEach(a),k_=e(Pe,"와 "),Zo=o(Pe,"CODE",{});var OP=l(Zo);f_=e(OP,"Employee"),OP.forEach(a),d_=e(Pe," 예제에 이어서, 아래 예제도 살펴보자."),Pe.forEach(a),kf=r(n),Qa=o(n,"PRE",{class:!0});var dI=l(Qa);dI.forEach(a),ff=r(n),Z=o(n,"P",{});var as=l(Z);E_=e(as,"만약 상속이었다면 위 "),Ko=o(as,"CODE",{});var RP=l(Ko);m_=e(RP,"var eFail Employee = m"),RP.forEach(a),v_=e(as,` 라인이 정상적으로 컴파일되었을 것이다.
`),Qo=o(as,"CODE",{});var TP=l(Qo);__=e(TP,"Manager"),TP.forEach(a),y_=e(as,"를 "),Yo=o(as,"CODE",{});var SP=l(Yo);b_=e(SP,"Employee"),SP.forEach(a),w_=e(as,`의 하위 개념으로 보기 때문.
하지만 `),$o=o(as,"EM",{});var MP=l($o);C_=e(MP,"Embedding"),MP.forEach(a),D_=e(as,"은 상속과는 차이가 있기 때문에 에러가 발생한다."),as.forEach(a),df=r(n),Ef=o(n,"BR",{}),mf=r(n),Js=o(n,"P",{});var E2=l(Js);P_=e(E2,"Go는 상속을 지원하지 않기 때문에 폴리모피즘과는 거리가 있고, "),ho=o(E2,"STRONG",{});var IP=l(ho);O_=e(IP,"Dynamic Dispatch"),IP.forEach(a),R_=e(E2,"(동적 디스패치)도 존재하지 않는다."),E2.forEach(a),vf=r(n),Ya=o(n,"PRE",{class:!0});var EI=l(Ya);EI.forEach(a),_f=r(n),$a=o(n,"PRE",{class:!0});var mI=l($a);mI.forEach(a),yf=r(n),I=o(n,"P",{});var wn=l(I);T_=e(wn,"위 예제에서 "),go=o(wn,"CODE",{});var LP=l(go);S_=e(LP,"o.Double()"),LP.forEach(a),M_=e(wn,"를 호출하면 겹치는 메소드명이 없기 때문에 "),nl=o(wn,"CODE",{});var HP=l(nl);I_=e(HP,"o.Inner.Double()"),HP.forEach(a),L_=e(wn,`가 자동 호출된다.
이 때 `),sl=o(wn,"CODE",{});var AP=l(sl);H_=e(AP,"o.Inner.Double()"),AP.forEach(a),A_=e(wn," 내부에서는 "),al=o(wn,"CODE",{});var GP=l(al);G_=e(GP,"o.Inner.IntPrinter()"),GP.forEach(a),B_=e(wn,"를 호출하기 때문에, "),tl=o(wn,"CODE",{});var BP=l(tl);x_=e(BP,"Inner: 20"),BP.forEach(a),N_=e(wn,`가 출력된 것이다.
이렇듯 Go에서 메소드는 전혀 오버라이딩되지 않는다.`),wn.forEach(a),bf=r(n),wf=o(n,"BR",{}),Cf=o(n,"BR",{}),Df=r(n),Xs=o(n,"H2",{id:!0});var hw=l(Xs);Zs=o(hw,"A",{"aria-hidden":!0,tabindex:!0,href:!0});var xP=l(Zs);el=o(xP,"SPAN",{class:!0}),l(el).forEach(a),xP.forEach(a),F_=e(hw,"Interface"),hw.forEach(a),Pf=r(n),Of=o(n,"HR",{}),Rf=r(n),Ks=o(n,"P",{});var m2=l(Ks);W_=e(m2,"책에서는 Go의 진정한 꽃이 Goroutine을 위시한 Concurrency가 아니라, 이 "),pl=o(m2,"EM",{});var NP=l(pl);U_=e(NP,"Interface"),NP.forEach(a),j_=e(m2,"라고 하는데, 대체 얼마나 맛집이기에.."),m2.forEach(a),Tf=r(n),qt=o(n,"P",{});var FP=l(qt);z_=e(FP,"설명에 앞서 인터페이스는 아래와 같이 정의할 수 있다."),FP.forEach(a),Sf=r(n),ha=o(n,"PRE",{class:!0});var vI=l(ha);vI.forEach(a),Mf=r(n),b=o(n,"P",{});var j=l(b);ol=o(j,"CODE",{});var WP=l(ol);q_=e(WP,"struct"),WP.forEach(a),V_=e(j,`를 정의하는 것과 큰 차이는 없는 것 같다.
암묵적인 룰이 하나 있는데, 인터페이스의 이름은 대개 “er”로 끝난다.
그 예로 `),ll=o(j,"CODE",{});var UP=l(ll);J_=e(UP,"fmt.Stringer"),UP.forEach(a),X_=e(j,", "),cl=o(j,"CODE",{});var jP=l(cl);Z_=e(jP,"io.Reader"),jP.forEach(a),K_=e(j,", "),ul=o(j,"CODE",{});var zP=l(ul);Q_=e(zP,"io.Closer"),zP.forEach(a),Y_=e(j,", "),il=o(j,"CODE",{});var qP=l(il);$_=e(qP,"io.ReadCloser"),qP.forEach(a),h_=e(j,", "),rl=o(j,"CODE",{});var VP=l(rl);g_=e(VP,"json.Marshaler"),VP.forEach(a),n0=e(j,", "),kl=o(j,"CODE",{});var JP=l(kl);s0=e(JP,"http.Handler"),JP.forEach(a),a0=e(j," 등등이 있다."),j.forEach(a),If=r(n),Lf=o(n,"BR",{}),Hf=r(n),on=o(n,"P",{});var bs=l(on);fl=o(bs,"EM",{});var XP=l(fl);t0=e(XP,"Interface"),XP.forEach(a),e0=e(bs,"는 객체지향의 "),dl=o(bs,"EM",{});var ZP=l(dl);p0=e(ZP,"Abstract Class"),ZP.forEach(a),o0=e(bs,`와 유사하지만, 차이점이 있다.
다른 객체지향 언어에서는 `),El=o(bs,"EM",{});var KP=l(El);l0=e(KP,"Abstract Class"),KP.forEach(a),c0=e(bs,"에서 선언된 메소드 등을 "),ml=o(bs,"EM",{});var QP=l(ml);u0=e(QP,"Concrete Class"),QP.forEach(a),i0=e(bs,"에서 구현한다."),bs.forEach(a),Af=r(n),L=o(n,"P",{});var Cn=l(L);r0=e(Cn,"반면 Go의 인터페이스는 "),Vt=o(Cn,"SPAN",{style:!0});var YP=l(Vt);k0=e(YP,"암묵적"),YP.forEach(a),f0=e(Cn,`인 개념이다.
`),vl=o(Cn,"EM",{});var $P=l(vl);d0=e($P,"Concrete Type"),$P.forEach(a),E0=e(Cn,`에서는 인터페이스를 구현한다고 선언하지 않는다.
만약 `),_l=o(Cn,"EM",{});var hP=l(_l);m0=e(hP,"Concrete Type"),hP.forEach(a),v0=e(Cn,`에서 구현하는 메소드들이 인터페이스에서 선언된 모든 메소드들을 포함한다면,
그 때 `),yl=o(Cn,"EM",{});var gP=l(yl);_0=e(gP,"Concrete Type"),gP.forEach(a),y0=e(Cn,`가 인터페이스를 구현한다고 할 수 있으며, 이래서 암묵적이라는 표현을 사용하는 듯 하다.
그래서 Go에서는 `),bl=o(Cn,"EM",{});var nO=l(bl);b0=e(nO,"Concrete Type"),nO.forEach(a),w0=e(Cn,"을 인터페이스에 할당한다는 느낌으로 받아들여야 하는 것 같다."),Cn.forEach(a),Gf=r(n),ga=o(n,"P",{});var gw=l(ga);wl=o(gw,"EM",{});var sO=l(wl);C0=e(sO,"Interface"),sO.forEach(a),D0=e(gw," 덕에 Type-Safe, 디커플링, 정적/동적 언어에서 기능을 연결하는 것이 가능해진다고 하는데, 이건 좀 더 해봐야 알 듯 하다."),gw.forEach(a),Bf=r(n),xn=o(n,"P",{});var Oe=l(xn);P0=e(Oe,"Javascript, Python 등의 동적 타입 언어에서는 인터페이스가 없는 대신 "),Cl=o(Oe,"EM",{});var aO=l(Cl);O0=e(aO,"Duck Typing"),aO.forEach(a),R0=e(Oe,`이란 것을 사용한다.
`),Dl=o(Oe,"EM",{});var tO=l(Dl);T0=e(tO,"Duck Typing"),tO.forEach(a),S0=e(Oe,`은 어떤 인스턴스가 원하는 메소드(또는 필드)들을 가지고 있다면, 내가 원하는 타입으로 간주한다는 뜻이다.
프로젝트의 규모가 너무 크거나, 프로젝트가 너무 오래되어서 의존성을 추적하기 어려운 경우 이런 방식을 사용한다.`),Oe.forEach(a),xf=r(n),Jt=o(n,"P",{});var eO=l(Jt);M0=e(eO,`주로 정적 타입 언어를 사용하는 개발자라면 이런 방식에 대해 회의적이다.
인스턴스의 타입을 명시하지 않으면 어떤 타입인지 확인하기도 어려울 것이며, 어떤 기능을 할 수 있을지 예측할 수 없으리라 생각한다.`),eO.forEach(a),Nf=r(n),Xt=o(n,"P",{});var pO=l(Xt);I0=e(pO,`반면 Java에서는 다소 패턴이 다르다. 인터페이스의 정의와 구현이 각각 존재하지만, 인터페이스의 정의만 참조된다.
주로 동적 타입 언어를 사용하는 개발자들은 이 방식에 대해, 인터페이스가 바뀔 때마다 코드를 다시 짜야 하는 불편한 방식이라고 생각한다.`),pO.forEach(a),Ff=r(n),Wf=o(n,"BR",{}),Uf=r(n),Zt=o(n,"P",{});var oO=l(Zt);L0=e(oO,`만약 어플리케이션이 잠정적으로 개선될 여지가 있다면 코드에 유연성이 필요하다.
하지만 코드가 하고 있는 일이 무엇인지에 대해 사람들이 이해할 수 있도록 하는 것도 중요하기에, 코드의 역할과 의존성 등을 명시할 필요도 있다.
Go의 인터페이스는 양쪽 모두의 입장을 받아들인다.`),oO.forEach(a),jf=r(n),Kt=o(n,"P",{});var lO=l(Kt);H0=e(lO,"아래 예제에서 Interface가 사용된 예시를 확인할 수 있다."),lO.forEach(a),zf=r(n),nt=o(n,"PRE",{class:!0});var _I=l(nt);_I.forEach(a),qf=r(n),f=o(n,"P",{});var d=l(f);Pl=o(d,"EM",{});var cO=l(Pl);A0=e(cO,"Concrete Type"),cO.forEach(a),G0=e(d," 역할을 하는 "),Ol=o(d,"CODE",{});var uO=l(Ol);B0=e(uO,"LogicProvider"),uO.forEach(a),x0=e(d,"가 정의될 때, 이것이 "),Rl=o(d,"CODE",{});var iO=l(Rl);N0=e(iO,"Logic"),iO.forEach(a),F0=e(d,`이라는 인터페이스에 관련된 것이라고 선언된 것은 없다.
`),Tl=o(d,"CODE",{});var rO=l(Tl);W0=e(rO,"Logic"),rO.forEach(a),U0=e(d,"과 "),Sl=o(d,"CODE",{});var kO=l(Sl);j0=e(kO,"LogicProvider"),kO.forEach(a),z0=e(d,"이 연결되는 것은, "),Ml=o(d,"CODE",{});var fO=l(Ml);q0=e(fO,"Client"),fO.forEach(a),V0=e(d," 인스턴스인 "),Il=o(d,"CODE",{});var dO=l(Il);J0=e(dO,"c"),dO.forEach(a),X0=e(d,`가 생성될 때이며,
`),Ll=o(d,"CODE",{});var EO=l(Ll);Z0=e(EO,"LogicProvider"),EO.forEach(a),K0=e(d,"에는 "),Hl=o(d,"CODE",{});var mO=l(Hl);Q0=e(mO,"Logic"),mO.forEach(a),Y0=e(d,"에서 정의된 것과 동일한 이름의 메소드인 "),Al=o(d,"CODE",{});var vO=l(Al);$0=e(vO,"Process()"),vO.forEach(a),h0=e(d,`가 존재할 뿐이다.
따라서 `),Gl=o(d,"CODE",{});var _O=l(Gl);g0=e(_O,"LogicProvider"),_O.forEach(a),n4=e(d,"가 "),Bl=o(d,"CODE",{});var yO=l(Bl);s4=e(yO,"Logic"),yO.forEach(a),a4=e(d,"이라는 인터페이스를 위한 "),xl=o(d,"EM",{});var bO=l(xl);t4=e(bO,"Concrete Type"),bO.forEach(a),e4=e(d,"임을 알 수 있도록, 잘 문서화할 필요가 있다."),d.forEach(a),Vf=r(n),Jf=o(n,"BR",{}),Xf=r(n),K=o(n,"P",{});var ts=l(K);p4=e(ts,"Go에서는 "),Nl=o(ts,"CODE",{});var wO=l(Nl);o4=e(wO,"io.Reader"),wO.forEach(a),l4=e(ts,"나 "),Fl=o(ts,"CODE",{});var CO=l(Fl);c4=e(CO,"io.Writer"),CO.forEach(a),u4=e(ts,` 등, 스탠다드 인터페이스도 존재한다.
스탠다드 인터페이스를 사용하는 것은 `),Wl=o(ts,"EM",{});var DO=l(Wl);i4=e(DO,"decorator"),DO.forEach(a),r4=e(ts,` 패턴과 유사한데,
특정 인터페이스의 인스턴스를 받아서 동일한 인터페이스의 다른 인스턴스를 반환하는 `),Ul=o(ts,"EM",{});var PO=l(Ul);k4=e(PO,"Factory Function"),PO.forEach(a),f4=e(ts,"(객체를 반환하는 함수)를 자주 사용하기 때문."),ts.forEach(a),Zf=r(n),Qt=o(n,"P",{});var OO=l(Qt);d4=e(OO,"아래 예제를 확인하자."),OO.forEach(a),Kf=r(n),st=o(n,"PRE",{class:!0});var yI=l(st);yI.forEach(a),Qf=r(n),Q=o(n,"P",{});var es=l(Q);E4=e(es,"위 코드에서 "),jl=o(es,"CODE",{});var RO=l(jl);m4=e(RO,"os.Open()"),RO.forEach(a),v4=e(es,"에 의해 반환된 "),zl=o(es,"CODE",{});var TO=l(zl);_4=e(TO,"os.File"),TO.forEach(a),y4=e(es," 인스턴스는 "),ql=o(es,"CODE",{});var SO=l(ql);b4=e(SO,"io.Reader"),SO.forEach(a),w4=e(es,` 인터페이스를 충족시킨다.
따라서 `),Vl=o(es,"CODE",{});var MO=l(Vl);C4=e(MO,"process()"),MO.forEach(a),D4=e(es," 함수 내에서 파일의 데이터를 읽을 수 있다."),es.forEach(a),Yf=r(n),Nn=o(n,"P",{});var Re=l(Nn);P4=e(Re,"아래 예제는 "),Jl=o(Re,"CODE",{});var IO=l(Jl);O4=e(IO,"gzip"),IO.forEach(a),R4=e(Re,"을 통해 파일을 압축 해제할 수 있는 경우에, "),Xl=o(Re,"CODE",{});var LO=l(Xl);T4=e(LO,"gzip"),LO.forEach(a),S4=e(Re," 라이브러리를 사용하여 압축 해제하는 예제이다."),Re.forEach(a),$f=r(n),at=o(n,"PRE",{class:!0});var bI=l(at);bI.forEach(a),hf=r(n),Yt=o(n,"P",{});var HO=l(Yt);M4=e(HO,"위처럼 스탠다드 라이브러리의 인터페이스가 코드에 잘 어울릴 것 같으면, 사용하는 것이 좋다."),HO.forEach(a),gf=r(n),P=o(n,"P",{});var sn=l(P);I4=e(sn,"예제에서는 "),Zl=o(sn,"CODE",{});var AO=l(Zl);L4=e(AO,"gzip"),AO.forEach(a),H4=e(sn,"으로 압축 해제된 "),Kl=o(sn,"CODE",{});var GO=l(Kl);A4=e(GO,"io.Reader"),GO.forEach(a),G4=e(sn," 인터페이스의 인스턴스가 "),Ql=o(sn,"CODE",{});var BO=l(Ql);B4=e(BO,"gz"),BO.forEach(a),x4=e(sn,`에 할당되고,
그 `),Yl=o(sn,"CODE",{});var xO=l(Yl);N4=e(xO,"gz"),xO.forEach(a),F4=e(sn,"가 다시 한번 "),$l=o(sn,"CODE",{});var NO=l($l);W4=e(NO,"process()"),NO.forEach(a),U4=e(sn,"함수에서 "),hl=o(sn,"CODE",{});var FO=l(hl);j4=e(FO,"io.Reader"),FO.forEach(a),z4=e(sn,"의 인스턴스가 된다."),sn.forEach(a),n1=r(n),Y=o(n,"P",{});var ps=l(Y);q4=e(ps,`어느 타입의 메소드들이 특정 인터페이스를 충족시키고도 남는 경우,
즉 인터페이스에 명시된 것 외의 메소드들이 존재한다고 해도 그 타입은 인터페이스를 충족시킨다.
이 때문에 한 타입이 두 개 이상의 인터페이스를 동시에 충족시킬 수 있다. 이 때 명시된 것 외의 메소드들은 무시한다.
이를테면 `),gl=o(ps,"CODE",{});var WO=l(gl);V4=e(WO,"io.File"),WO.forEach(a),J4=e(ps," 타입은 "),nc=o(ps,"CODE",{});var UO=l(nc);X4=e(UO,"io.Reader"),UO.forEach(a),Z4=e(ps,"와 "),sc=o(ps,"CODE",{});var jO=l(sc);K4=e(jO,"io.Writer"),jO.forEach(a),Q4=e(ps,`를 동시에 충족시킨다.
즉, `),ac=o(ps,"CODE",{});var zO=l(ac);Y4=e(zO,"io.File"),zO.forEach(a),$4=e(ps," 한 가지 타입으로 읽고 쓰기가 동시에, 각각 지원되는 것이다."),ps.forEach(a),s1=r(n),a1=o(n,"BR",{}),t1=o(n,"BR",{}),e1=r(n),Qs=o(n,"H3",{id:!0});var nC=l(Qs);Ys=o(nC,"A",{"aria-hidden":!0,tabindex:!0,href:!0});var qO=l(Ys);tc=o(qO,"SPAN",{class:!0}),l(tc).forEach(a),qO.forEach(a),h4=e(nC,"Embedding and Interfaces"),nC.forEach(a),p1=r(n),ln=o(n,"P",{});var ws=l(ln);ec=o(ws,"CODE",{});var VO=l(ec);g4=e(VO,"struct"),VO.forEach(a),ny=e(ws,` 타입을 Embedding하는 것처럼, 인터페이스도 인터페이스 안에 Embedding할 수 있다.
스탠다드 라이브러리의 `),pc=o(ws,"CODE",{});var JO=l(pc);sy=e(JO,"io.ReadCloser"),JO.forEach(a),ay=e(ws,"도 "),oc=o(ws,"CODE",{});var XO=l(oc);ty=e(XO,"io.Reader"),XO.forEach(a),ey=e(ws,"와 "),lc=o(ws,"CODE",{});var ZO=l(lc);py=e(ZO,"io.Closer"),ZO.forEach(a),oy=e(ws,`가 임베딩된 것이다.
아래의 예제와 유사하다.`),ws.forEach(a),o1=r(n),tt=o(n,"PRE",{class:!0});var wI=l(tt);wI.forEach(a),l1=r(n),c1=o(n,"BR",{}),u1=o(n,"BR",{}),i1=r(n),$s=o(n,"H3",{id:!0});var sC=l($s);hs=o(sC,"A",{"aria-hidden":!0,tabindex:!0,href:!0});var KO=l(hs);cc=o(KO,"SPAN",{class:!0}),l(cc).forEach(a),KO.forEach(a),ly=e(sC,"Accept Interfaces, Return Structs"),sC.forEach(a),r1=r(n),gs=o(n,"P",{});var v2=l(gs);cy=e(v2,"Go의 빡고수들이 버릇처럼 읊는 말이 "),uc=o(v2,"STRONG",{});var QO=l(uc);uy=e(QO,"Accept Interfaces, Return Structs"),QO.forEach(a),iy=e(v2,`라고 한다.
이는 함수에 의해 호출되는 로직은 반드시 인터페이스를 통해 호출되어야 하며,
함수의 결과값은 반드시 concrete type(struct)이어야 한다는 것이다.
함수의 파라미터로 인터페이스를 받으면 어떤 기능을 사용할 것인지 명시적으로 선언하면서도, flexible함을 동시에 챙길 수 있다.`),v2.forEach(a),k1=r(n),$t=o(n,"P",{});var YO=l($t);ry=e(YO,`만약 API가 (암묵적이어야 할) 인터페이스를 리턴한다면, 디커플링이라는 인터페이스의 장점을 잃는다.
만약 그렇게 된다면 서드 파티 모듈의 인터페이스에 코드가 종속되는 결과를 낳게 된다.
대개 서드 파티 인터페이스에 대한 클라이언트의 의존성을 줄이고자 하기 마련이다.
이를 위해 또다른 인터페이스를 작성한 뒤, 타입 변환을 하는데(의존성 주입, Dependency Injection),
이는 어플리케이션의 기능을 제약할 수도 있기에 좋은 방법은 아니다.`),YO.forEach(a),f1=r(n),ht=o(n,"P",{});var $O=l(ht);ky=e($O,`인터페이스를 리턴하지 말아야 하는 또 다른 이유는 버전에 관련된 것이다.
Concrete Type을 리턴하는 경우에는 기존 코드에 새로운 메소드나 필드가 별 문제 없이 추가될 수 있다.
반면 인터페이스의 경우에는 새로운 메소드를 추가하려면 기존에 존재하는 모든 메소드들의 구현을 업데이트해야 한다.
따라서 API를 롤백해야 하는 경우에도, major version number를 증가시켜야 한다.`),$O.forEach(a),d1=r(n),gt=o(n,"P",{});var hO=l(gt);fy=e(hO,`인터페이스가 정해져 있고 파라미터에 따라서 다른 인스턴스가 나오는 factory function을 짜는 것보다는,
타입들을 분리하여 concrete type이 반환되는 각각의 함수를 작성하는 것이 좋다.`),hO.forEach(a),E1=r(n),Fn=o(n,"P",{});var Te=l(Fn);dy=e(Te,`웬만하면 인터페이스를 반환하지 않는 것이 좋긴 한데, 가끔 어쩔 수 없이 하는 경우가 있다. 대표적인 예시가 바로 에러이다.
Go에서는 `),ic=o(Te,"CODE",{});var gO=l(ic);Ey=e(gO,"error"),gO.forEach(a),my=e(Te,` 인터페이스를 반환하도록 선언되는 경우가 많다.
이는 인터페이스가 Go에서 유일하게 사용할 수 있는 추상 유형이며. `),rc=o(Te,"CODE",{});var nR=l(rc);vy=e(nR,"error"),nR.forEach(a),_y=e(Te,` 인터페이스의 다른 구현을 사용해야 하는 경우가 많기 때문이다.
따라서 가능한 모든 옵션을 처리하기 위해 인터페이스를 사용해야 한다.`),Te.forEach(a),m1=r(n),ne=o(n,"P",{});var sR=l(ne);yy=e(sR,`다만 이러한 패턴의 잠재적인 문제점이 존재한다.
concrete type을 반환하는 경우 Heap 할당이 줄어들기에 가비지 콜렉터의 워크로드가 줄어든다.
반면 인터페이스를 파라미터로 사용하는 함수의 경우, 각 인터페이스마다 Heap 할당되므로, 가비지 콜렉터가 힘들어한다.
결국은 더 좋은 성능과 더 좋은 추상화 사이에 trade-off가 존재하는 셈이다.`),sR.forEach(a),v1=r(n),se=o(n,"P",{});var aR=l(se);by=e(aR,`그렇기 때문에 되도록이면 코드를 예쁘게, 고치기 편하게 작성하는 것이 좋다.
그래야 인터페이스로 인한 잠재적인 성능 문제가 발생하여도, 이를 concrete type으로 변경하는 등의 작업을 하기가 쉬워진다.`),aR.forEach(a),_1=r(n),y1=o(n,"BR",{}),b1=o(n,"BR",{}),w1=r(n),na=o(n,"H3",{id:!0});var aC=l(na);sa=o(aC,"A",{"aria-hidden":!0,tabindex:!0,href:!0});var tR=l(sa);kc=o(tR,"SPAN",{class:!0}),l(kc).forEach(a),tR.forEach(a),wy=e(aC,"Interfaces and nil"),aC.forEach(a),C1=r(n),Wn=o(n,"P",{});var Se=l(Wn);Cy=e(Se,"많이 봐왔듯, "),fc=o(Se,"CODE",{});var eR=l(fc);Dy=e(eR,"nil"),eR.forEach(a),Py=e(Se,`은 포인터의 Zero value이다.
마찬가지로 `),dc=o(Se,"CODE",{});var pR=l(dc);Oy=e(pR,"nil"),pR.forEach(a),Ry=e(Se,"은 인터페이스의 Zero value이긴 하지만, Concrete Type들에 비해 간단하지만은 않다."),Se.forEach(a),D1=r(n),et=o(n,"PRE",{class:!0});var CI=l(et);CI.forEach(a),P1=r(n),pt=o(n,"PRE",{class:!0});var DI=l(pt);DI.forEach(a),O1=r(n),Un=o(n,"P",{});var Me=l(Un);Ty=e(Me,`Go의 인터페이스는 내부적으로 두 쌍의 포인터로 구성되며, 각각 타입, 값을 가리킨다.
만약 타입을 가리키는 포인터가 `),Ec=o(Me,"CODE",{});var oR=l(Ec);Sy=e(oR,"nil"),oR.forEach(a),My=e(Me,"이 아니라면, 인터페이스는 "),mc=o(Me,"CODE",{});var lR=l(mc);Iy=e(lR,"nil"),lR.forEach(a),Ly=e(Me,"이 아닌 것이다. 출력 결과의 세 번째 라인이 저 모양인 것이 이 때문."),Me.forEach(a),R1=r(n),O=o(n,"P",{});var an=l(O);Hy=e(an,"인터페이스에 할당된 concrete type에 따라 호출되는 메소드가 달라지듯, 인터페이스에서 "),vc=o(an,"CODE",{});var cR=l(vc);Ay=e(cR,"nil"),cR.forEach(a),Gy=e(an,`은 메소드를 호출할 수 있는지 여부를 나타낸다.
만약 인터페이스가 `),_c=o(an,"CODE",{});var uR=l(_c);By=e(uR,"nil"),uR.forEach(a),xy=e(an,"임에도 메소드를 호출하였다면, "),yc=o(an,"EM",{});var iR=l(yc);Ny=e(iR,"panic"),iR.forEach(a),Fy=e(an,`이 발생한다.
만약 인터페이스가 `),bc=o(an,"CODE",{});var rR=l(bc);Wy=e(rR,"nil"),rR.forEach(a),Uy=e(an,`이 아닌데 메소드를 호출하였다면, 메소드를 호출하려고 시도할 것이다.
(다만 위 예제와 같은 경우 인터페이스에 연결된 값이 `),wc=o(an,"CODE",{});var kR=l(wc);jy=e(kR,"nil"),kR.forEach(a),zy=e(an,"이기 때문에, 곧바로 "),Cc=o(an,"EM",{});var fR=l(Cc);qy=e(fR,"panic"),fR.forEach(a),Vy=e(an,"이 발생할 것이다.)"),an.forEach(a),T1=r(n),$=o(n,"P",{});var os=l($);Jy=e(os,"인터페이스 인스턴스의 타입을 나타내는 포인터가 "),Dc=o(os,"CODE",{});var dR=l(Dc);Xy=e(dR,"nil"),dR.forEach(a),Zy=e(os,"이 아니라면, 이는 "),Pc=o(os,"CODE",{});var ER=l(Pc);Ky=e(ER,"nil"),ER.forEach(a),Qy=e(os,`이 아닌 것이다.
그렇다고 해서 이 인터페이스의 값이 `),Oc=o(os,"CODE",{});var mR=l(Oc);Yy=e(mR,"nil"),mR.forEach(a),$y=e(os,"인지는 확실하게 알 수 없기 때문에, 나중에 나올 "),Rc=o(os,"EM",{});var vR=l(Rc);hy=e(vR,"Reflection"),vR.forEach(a),gy=e(os,"을 사용해야 한다."),os.forEach(a),S1=r(n),M1=o(n,"BR",{}),I1=o(n,"BR",{}),L1=r(n),aa=o(n,"H3",{id:!0});var tC=l(aa);ta=o(tC,"A",{"aria-hidden":!0,tabindex:!0,href:!0});var _R=l(ta);Tc=o(_R,"SPAN",{class:!0}),l(Tc).forEach(a),_R.forEach(a),n6=e(tC,"The Empty Interface Says Nothing"),tC.forEach(a),H1=r(n),ea=o(n,"P",{});var _2=l(ea);s6=e(_2,`정적 타입 언어에서도 아무 타입이나 다 집어넣을 수 있는 변수가 필요할 때가 있다.
그러한 경우, Go에서는 `),Sc=o(_2,"CODE",{});var yR=l(Sc);a6=e(yR,"interface{}"),yR.forEach(a),t6=e(_2,"를 사용할 수 있다."),_2.forEach(a),A1=r(n),ot=o(n,"PRE",{class:!0});var PI=l(ot);PI.forEach(a),G1=r(n),jn=o(n,"P",{});var Ie=l(jn);e6=e(Ie,`비어 있는 인터페이스는 말 그대로 아무 값이나 다 저장할 수 있다.
인터페이스가 비어 있다는 말은 0개 이상의 메소드가 있는 타입들을 가리킬 수 있다는 뜻이며,
그래서 메소드가 없는 `),Mc=o(Ie,"CODE",{});var bR=l(Mc);p6=e(bR,"int"),bR.forEach(a),o6=e(Ie,", "),Ic=o(Ie,"CODE",{});var wR=l(Ic);l6=e(wR,"string"),wR.forEach(a),c6=e(Ie," 등의 Primitive Type들도 저장이 가능해진다."),Ie.forEach(a),B1=r(n),x1=o(n,"BR",{}),N1=r(n),ae=o(n,"P",{});var CR=l(ae);u6=e(CR,"비어 있는 인터페이스가 사용되는 예 중 하나는, JSON처럼 외부 소스에서 읽어온 불분명한 스키마의 placeholder로 사용하는 것이다."),CR.forEach(a),F1=r(n),lt=o(n,"PRE",{class:!0});var OI=l(lt);OI.forEach(a),W1=r(n),pa=o(n,"P",{});var y2=l(pa);i6=e(y2,"위 코드를 실행하면 JSON 데이터가 "),Lc=o(y2,"CODE",{});var DR=l(Lc);r6=e(DR,"data"),DR.forEach(a),k6=e(y2," 변수에 저장된다."),y2.forEach(a),U1=r(n),j1=o(n,"BR",{}),z1=r(n),yn=o(n,"P",{});var La=l(yn);f6=e(La,`또 다른 경우에는, 유저가 만든 자료구조에서 다양한 타입의 값을 저장하기 위해 사용된다.
Go의 `),Hc=o(La,"CODE",{});var PR=l(Hc);d6=e(PR,"slice"),PR.forEach(a),E6=e(La,", "),Ac=o(La,"CODE",{});var OR=l(Ac);m6=e(OR,"map"),OR.forEach(a),v6=e(La," 등 타입들은 한 가지 타입밖에 저장하지 못하는데 비해, "),Gc=o(La,"CODE",{});var RR=l(Gc);_6=e(RR,"interface{}"),RR.forEach(a),y6=e(La,"는 여러 타입을 가리킬 수 있기 때문."),La.forEach(a),q1=r(n),ct=o(n,"PRE",{class:!0});var RI=l(ct);RI.forEach(a),V1=r(n),te=o(n,"P",{});var TR=l(te);b6=e(TR,"위 코드는 러프한 예시니까 실제로 사용하지는 말자."),TR.forEach(a),J1=r(n),bn=o(n,"P",{});var Ha=l(bn);w6=e(Ha,"또 다른 사용예로는 함수의 파라미터로 "),Bc=o(Ha,"CODE",{});var SR=l(Bc);C6=e(SR,"interface{}"),SR.forEach(a),D6=e(Ha,"를 받는 경우인데, "),xc=o(Ha,"EM",{});var MR=l(xc);P6=e(MR,"reflection"),MR.forEach(a),O6=e(Ha,`을 하기 위해 사용한다고 하는 것 같다.
`),Nc=o(Ha,"EM",{});var IR=l(Nc);R6=e(IR,"reflection"),IR.forEach(a),T6=e(Ha,"은 나중에 나온다!"),Ha.forEach(a),X1=r(n),Z1=o(n,"BR",{}),K1=r(n),H=o(n,"P",{});var Dn=l(H);S6=e(Dn,"근데 "),Fc=o(Dn,"CODE",{});var LR=l(Fc);M6=e(LR,"interface{}"),LR.forEach(a),I6=e(Dn,`를 되도록이면 사용하지 않는 게 좋다.
Go는 기본적으로 정적 타입 언어로 디자인된 언어인 만큼, `),Wc=o(Dn,"CODE",{});var HR=l(Wc);L6=e(HR,"interface{}"),HR.forEach(a),H6=e(Dn,`로 여러 타입들을 쑤시고 다니는 건 좋지 않다.
`),Uc=o(Dn,"CODE",{});var AR=l(Uc);A6=e(AR,"interface{}"),AR.forEach(a),G6=e(Dn,`를 사용하여 값들을 저장해야 할 상황에서, 값을 다시 읽어오려면 어떻게 해야 할까?
그럴 때 바로 아래에서 설명할 `),jc=o(Dn,"EM",{});var GR=l(jc);B6=e(GR,"Type Assertions"),GR.forEach(a),x6=e(Dn," 및 "),zc=o(Dn,"EM",{});var BR=l(zc);N6=e(BR,"Type Switches"),BR.forEach(a),F6=e(Dn,"를 사용해 보자."),Dn.forEach(a),Q1=r(n),Y1=o(n,"BR",{}),$1=o(n,"BR",{}),h1=r(n),oa=o(n,"H3",{id:!0});var eC=l(oa);la=o(eC,"A",{"aria-hidden":!0,tabindex:!0,href:!0});var xR=l(la);qc=o(xR,"SPAN",{class:!0}),l(qc).forEach(a),xR.forEach(a),W6=e(eC,"Type Assertions and Type Switches"),eC.forEach(a),g1=r(n),ee=o(n,"P",{});var NR=l(ee);U6=e(NR,`Go에는 어떤 변수의 인터페이스가 가리키는 타입이 특정한 Concrete Type인지,
혹은 Concrete Type이 또 다른 인터페이스를 구현하는지 확인할 수 있는 두 가지 방법이 있다.`),NR.forEach(a),nd=r(n),ca=o(n,"P",{});var b2=l(ca);j6=e(b2,"한 가지가 바로 "),Vc=o(b2,"STRONG",{});var FR=l(Vc);z6=e(FR,"Type Assertion"),FR.forEach(a),q6=e(b2,`이다.
이는 어떤 인터페이스를 구현하는 Concrete Type에 이름을 붙이거나,
또는 이 인터페이스를 구현하고 있는 Concrete Type이 구현하는 또 다른 인터페이스에 이름을 붙인다.`),b2.forEach(a),sd=r(n),ut=o(n,"PRE",{class:!0});var TI=l(ut);TI.forEach(a),ad=r(n),A=o(n,"P",{});var Pn=l(A);V6=e(Pn,"이렇게 "),Jc=o(Pn,"EM",{});var WR=l(Jc);J6=e(WR,"Type Assertion"),WR.forEach(a),X6=e(Pn,"을 사용하여 "),Xc=o(Pn,"CODE",{});var UR=l(Xc);Z6=e(UR,"i"),UR.forEach(a),K6=e(Pn,"가 가리키고 있는 타입을 "),Zc=o(Pn,"CODE",{});var jR=l(Zc);Q6=e(jR,"MyInt"),jR.forEach(a),Y6=e(Pn,`로 한정할 수 있다.
위 예제에서 변수 `),Kc=o(Pn,"CODE",{});var zR=l(Kc);$6=e(zR,"i2"),zR.forEach(a),h6=e(Pn,"의 타입은 "),Qc=o(Pn,"CODE",{});var qR=l(Qc);g6=e(qR,"MyInt"),qR.forEach(a),n7=e(Pn,"가 된다."),Pn.forEach(a),td=r(n),ed=o(n,"BR",{}),pd=r(n),zn=o(n,"P",{});var Le=l(zn);s7=e(Le,"만약 잘못된 타입으로 "),Yc=o(Le,"EM",{});var VR=l(Yc);a7=e(VR,"Type Assertion"),VR.forEach(a),t7=e(Le,"을 하면 "),$c=o(Le,"EM",{});var JR=l($c);e7=e(JR,"panic"),JR.forEach(a),p7=e(Le,"이 발생한다."),Le.forEach(a),od=r(n),it=o(n,"PRE",{class:!0});var SI=l(it);SI.forEach(a),ld=r(n),cd=o(n,"BR",{}),ud=r(n),cn=o(n,"P",{});var Cs=l(cn);hc=o(Cs,"CODE",{});var XR=l(hc);o7=e(XR,"int"),XR.forEach(a),l7=e(Cs,"와 "),gc=o(Cs,"CODE",{});var ZR=l(gc);c7=e(ZR,"MyInt"),ZR.forEach(a),u7=e(Cs,"는 본질적으론 같은 타입이지만, Go는 타입에 엄격하기 때문에 "),nu=o(Cs,"EM",{});var KR=l(nu);i7=e(KR,"Type Assertion"),KR.forEach(a),r7=e(Cs,`을 사용할 때 Concrete Type끼리 일치시켜주어야 한다.
따라서 아래와 같은 예제는 `),su=o(Cs,"EM",{});var QR=l(su);k7=e(QR,"panic"),QR.forEach(a),f7=e(Cs,"이 발생한다."),Cs.forEach(a),id=r(n),rt=o(n,"PRE",{class:!0});var MI=l(rt);MI.forEach(a),rd=r(n),kd=o(n,"BR",{}),fd=r(n),Es=o(n,"P",{});var ar=l(Es);au=o(ar,"CODE",{});var YR=l(au);d7=e(YR,"map"),YR.forEach(a),E7=e(ar,"을 사용할 때 보았던 "),tu=o(ar,"EM",{});var $R=l(tu);m7=e($R,"comma ok idiom"),$R.forEach(a),v7=e(ar,"을 사용하여 panic을 회피할 수 있다."),ar.forEach(a),dd=r(n),kt=o(n,"PRE",{class:!0});var II=l(kt);II.forEach(a),Ed=r(n),w=o(n,"P",{});var z=l(w);eu=o(z,"CODE",{});var hR=l(eu);_7=e(hR,"map"),hR.forEach(a),y7=e(z,`에서 봤던 패턴과 유사하다.
`),pu=o(z,"EM",{});var gR=l(pu);b7=e(gR,"Type Assertion"),gR.forEach(a),w7=e(z,"에 성공하면 변수 "),ou=o(z,"CODE",{});var nT=l(ou);C7=e(nT,"ok"),nT.forEach(a),D7=e(z,"는 "),lu=o(z,"CODE",{});var sT=l(lu);P7=e(sT,"true"),sT.forEach(a),O7=e(z,"가 되며, 나머지 변수는 인터페이스가 가리키는 값으로 초기화된다."),R7=o(z,"BR",{}),T7=e(z,`
반면 실패하면 `),cu=o(z,"CODE",{});var aT=l(cu);S7=e(aT,"ok"),aT.forEach(a),M7=e(z,"는 "),uu=o(z,"CODE",{});var tT=l(uu);I7=e(tT,"false"),tT.forEach(a),L7=e(z,"가 되며, 나머지 변수는 해당 타입의 Zero value로 초기화된다."),z.forEach(a),md=r(n),qn=o(n,"P",{});var He=l(qn);H7=e(He,"그렇게 얻은 "),iu=o(He,"CODE",{});var eT=l(iu);A7=e(eT,"ok"),eT.forEach(a),G7=e(He," 변수값을 통해 이를 "),ru=o(He,"CODE",{});var pT=l(ru);B7=e(pT,"if"),pT.forEach(a),x7=e(He,`문으로 처리할 수는 있지만
Go에서는 에러 핸들링을 통해 처리하는 것을 더 지향한다는 것 같다. 에러 핸들링은 다음 챕터에서 나온다!`),He.forEach(a),vd=r(n),ua=o(n,"P",{});var w2=l(ua);N7=e(w2,"어찌 됐든, 인터페이스가 가리키고 있는 데이터의 타입이 확실하다고 생각해도 되도록이면 "),ku=o(w2,"EM",{});var oT=l(ku);F7=e(oT,"comma ok idiom"),oT.forEach(a),W7=e(w2,`를 쓰는 것이 좋다.
다른 사람이나 미래의 내가 언제 이 코드를 다시 사용할 지도 모르는 일이며, 코드를 조금 수정했는데 런타임 에러가 날 수도 있으니 말이다.`),w2.forEach(a),_d=r(n),yd=o(n,"BR",{}),bd=o(n,"BR",{}),wd=r(n),ia=o(n,"P",{});var C2=l(ia);U7=e(C2,"어느 인터페이스의 타입에 여러 개의 후보군이 있다면, "),fu=o(C2,"EM",{});var lT=l(fu);j7=e(lT,"Type Switch"),lT.forEach(a),z7=e(C2,"를 써보도록 하자."),C2.forEach(a),Cd=r(n),ft=o(n,"PRE",{class:!0});var LI=l(ft);LI.forEach(a),Dd=r(n),dt=o(n,"PRE",{class:!0});var HI=l(dt);HI.forEach(a),Pd=r(n),Vn=o(n,"P",{});var Ae=l(Vn);q7=e(Ae,"기본적으로 형태는 boolean 표현식이 사용되지 않는 일반적인 "),du=o(Ae,"CODE",{});var cT=l(du);V7=e(cT,"switch"),cT.forEach(a),J7=e(Ae,`문의 형태와 유사하다.
다만 switch문 이후에 `),Eu=o(Ae,"CODE",{});var uT=l(Eu);X7=e(uT,"i.(type)"),uT.forEach(a),Z7=e(Ae,`로, 인터페이스의 타입을 나타내어 주면 된다.
이렇게 각 case문에 타입을 할당함으로써, 인터페이스의 타입에 따라 처리할 수 있다.`),Ae.forEach(a),Od=r(n),_=o(n,"P",{});var x=l(_);K7=e(x,`실행 결과를 보면 대충 알 수 있겠지만, 3번째 줄의 경우 주의해야 할 것 같다.
변수 `),mu=o(x,"CODE",{});var iT=l(mu);Q7=e(iT,"c"),iT.forEach(a),Y7=e(x,"는 값이 "),vu=o(x,"CODE",{});var rT=l(vu);$7=e(rT,"nil"),rT.forEach(a),h7=e(x,"인 것이지, 타입은 "),_u=o(x,"CODE",{});var kT=l(_u);g7=e(kT,"nil"),kT.forEach(a),n8=e(x,"이 아니라 "),yu=o(x,"CODE",{});var fT=l(yu);s8=e(fT,"*string"),fT.forEach(a),a8=e(x,`이다.
실제로 `),bu=o(x,"CODE",{});var dT=l(bu);t8=e(dT,"switch"),dT.forEach(a),e8=e(x,"문에서 "),wu=o(x,"CODE",{});var ET=l(wu);p8=e(ET,"case nil"),ET.forEach(a),o8=e(x,"에 걸리는 경우는, 변수 "),Cu=o(x,"CODE",{});var mT=l(Cu);l8=e(mT,"f"),mT.forEach(a),c8=e(x,"처럼 인터페이스가 가리키는 대상이 아무 것도 없을 때이다."),x.forEach(a),Rd=r(n),ra=o(n,"P",{});var D2=l(ra);u8=e(D2,"인터페이스가 가리키는 타입에 대해 전혀 모를 경우, "),Du=o(D2,"EM",{});var vT=l(Du);i8=e(vT,"reflection"),vT.forEach(a),r8=e(D2,`을 사용하면 된다고 한다.
나중에 나온다. 나중에…`),D2.forEach(a),Td=r(n),un=o(n,"P",{});var Ds=l(un);Pu=o(Ds,"EM",{});var _T=l(Pu);k8=e(_T,"Type Assertion"),_T.forEach(a),f8=e(Ds,"과 "),Ou=o(Ds,"EM",{});var yT=l(Ou);d8=e(yT,"Type Switch"),yT.forEach(a),E8=e(Ds,`가 꽤나 유용한 기술처럼 보이는데, 자주 사용하면 안된다고 한다.
웬만하면 함수의 파라미터나 리턴값은 특정한 몇 가지의 타입으로만 지정하는 것이 좋으며, 나머지 다른 타입들은 가능은 하더라도 안되게 해야 한다.
그렇지 않으면 우리가 짜는 함수가 어떤 타입들을 지원하는지에 대해 정확히 명시하지 못할 수 있다.
대충 `),Ru=o(Ds,"CODE",{});var bT=l(Ru);m8=e(bT,"interface{}"),bT.forEach(a),v8=e(Ds,"를 사용하는 걸 지양하라는 말과 일맥상통하는 것 같다. "),Tu=o(Ds,"CODE",{});var wT=l(Tu);_8=e(wT,"interface{}"),wT.forEach(a),y8=e(Ds,"를 안 쓰면 특정한 타입을 명시할 수밖에 없을 테니 말이다."),Ds.forEach(a),Sd=r(n),Md=o(n,"BR",{}),Id=r(n),ms=o(n,"P",{});var tr=l(ms);Su=o(tr,"EM",{});var CT=l(Su);b8=e(CT,"Type Assertion"),CT.forEach(a),w8=e(tr,"과 "),Mu=o(tr,"EM",{});var DT=l(Mu);C8=e(DT,"Type Switch"),DT.forEach(a),D8=e(tr,"가 유용하게 사용되는 예제에 대해 알아보자."),tr.forEach(a),Ld=r(n),G=o(n,"P",{});var On=l(G);P8=e(On,`가장 일반적인 경우, 한 인터페이스가 가리키고 있는 concrete type을 보기 위해 사용되는데,
이 concrete type은 다른 인터페이스에서도 가리킬 수 있는 경우이다.
이를테면 `),Iu=o(On,"CODE",{});var PT=l(Iu);O8=e(PT,"io"),PT.forEach(a),R8=e(On," 라이브러리의 "),Lu=o(On,"CODE",{});var OT=l(Lu);T8=e(OT,"io.File"),OT.forEach(a),S8=e(On," 등 여러 타입들은 "),Hu=o(On,"CODE",{});var RT=l(Hu);M8=e(RT,"io.Reader"),RT.forEach(a),I8=e(On,"와 "),Au=o(On,"CODE",{});var TT=l(Au);L8=e(TT,"io.Writer"),TT.forEach(a),H8=e(On,` 두 가지 인터페이스를 모두 만족시킨다.
그 때 `),Gu=o(On,"CODE",{});var ST=l(Gu);A8=e(ST,"io.Reader"),ST.forEach(a),G8=e(On,"가 가리키고 있는 타입이 어떤 타입인지 확인하기 위해 사용할 수 있을 것이다."),On.forEach(a),Hd=r(n),m=o(n,"P",{});var M=l(m);Bu=o(M,"CODE",{});var MT=l(Bu);B8=e(MT,"io.Copy()"),MT.forEach(a),x8=e(M," 함수는 "),xu=o(M,"CODE",{});var IT=l(xu);N8=e(IT,"io.Reader"),IT.forEach(a),F8=e(M,"와 "),Nu=o(M,"CODE",{});var LT=l(Nu);W8=e(LT,"io.Writer"),LT.forEach(a),U8=e(M," 인터페이스들을 파라미터로 받아, "),Fu=o(M,"CODE",{});var HT=l(Fu);j8=e(HT,"io.copyBuffer()"),HT.forEach(a),z8=e(M,`함수를 실행한다.
다만 이때 `),Wu=o(M,"CODE",{});var AT=l(Wu);q8=e(AT,"io.Reader"),AT.forEach(a),V8=e(M,"의 파라미터가 "),Uu=o(M,"CODE",{});var GT=l(Uu);J8=e(GT,"io.ReaderFrom"),GT.forEach(a),X8=e(M,"에서도 사용할 수 있거나, "),ju=o(M,"CODE",{});var BT=l(ju);Z8=e(BT,"io.Writer"),BT.forEach(a),K8=e(M,"의 파라미터가 "),zu=o(M,"CODE",{});var xT=l(zu);Q8=e(xT,"io.WriterTo"),xT.forEach(a),Y8=e(M,`에서도 사용할 수 있다면,
함수 내용 대부분이 생략될 수 있다.`),M.forEach(a),Ad=r(n),Et=o(n,"PRE",{class:!0});var AI=l(Et);AI.forEach(a),Gd=r(n),Bd=o(n,"BR",{}),xd=r(n),Jn=o(n,"P",{});var Ge=l(Jn);$8=e(Ge,`인터페이스는 API를 업그레이드할때도 사용된다고 한다.
챕터 12에서 `),qu=o(Ge,"EM",{});var NT=l(qu);h8=e(NT,"context"),NT.forEach(a),g8=e(Ge,"에 대해 알아볼 텐데, "),Vu=o(Ge,"EM",{});var FT=l(Vu);n9=e(FT,"context"),FT.forEach(a),s9=e(Ge,`란 취소를 관리하는 표준적인 방법을 제시하는 파라미터이다.
Go 버전 1.7부터 생긴 기능인지라, 이전 버전의 데이터베이스 드라이버 등에서는 지원하지 않는다.`),Ge.forEach(a),Nd=r(n),R=o(n,"P",{});var tn=l(R);a9=e(tn,"Go 1.8부터는 "),Ju=o(tn,"CODE",{});var WT=l(Ju);t9=e(WT,"database/sql/driver"),WT.forEach(a),e9=e(tn,` 패키지에 기존에 존재하는 인터페이스에 대한 새로운 컨텍스트 인식 유사체가 정의되었다.
이를테면 `),Xu=o(tn,"CODE",{});var UT=l(Xu);p9=e(UT,"StmtExecContext"),UT.forEach(a),o9=e(tn," 인터페이스에는 "),Zu=o(tn,"CODE",{});var jT=l(Zu);l9=e(jT,"ExecContext"),jT.forEach(a),c9=e(tn,`라는 메소드가 있다.
스탠다드 라이브러리 데이터베이스 코드에 `),Ku=o(tn,"CODE",{});var zT=l(Ku);u9=e(zT,"Stmt"),zT.forEach(a),i9=e(tn,` 인터페이스의 타입이 통과될 경우,
이 타입이 `),Qu=o(tn,"CODE",{});var qT=l(Qu);r9=e(qT,"StmtExecContext"),qT.forEach(a),k9=e(tn,"에도 사용할 수 있는지 확인한다. 만약 그렇다면 "),Yu=o(tn,"CODE",{});var VT=l(Yu);f9=e(VT,"ExecContext"),VT.forEach(a),d9=e(tn,`를 호출한다.
만약 그렇지 않다면, fallback code를 실행한다.`),tn.forEach(a),Fd=r(n),mt=o(n,"PRE",{class:!0});var GI=l(mt);GI.forEach(a),Wd=r(n),Ud=o(n,"BR",{}),jd=r(n),Xn=o(n,"P",{});var Be=l(Xn);E9=e(Be,`이런 optional interface 기능에는 한 가지 단점이 존재한다.
한 인터페이스로 여러 가지 타입을 사용하여 계층적 구조를 만드는 decorator 패턴을 사용하기 위해 인터페이스가 많이들 사용된다.
이 때, 어느 optional interface가 이 타입들 중 한 가지라도 사용할 수 있다면, `),$u=o(Be,"EM",{});var JT=l($u);m9=e(JT,"Type Assertion"),JT.forEach(a),v9=e(Be,"과 "),hu=o(Be,"EM",{});var XT=l(hu);_9=e(XT,"Type Switch"),XT.forEach(a),y9=e(Be,"으로 이를 감지할 수 없다."),Be.forEach(a),zd=r(n),T=o(n,"P",{});var en=l(T);b9=e(en,"그 예로 "),gu=o(en,"CODE",{});var ZT=l(gu);w9=e(ZT,"bufio"),ZT.forEach(a),C9=e(en,`라는 표준 라이브러리는 buffered reader를 제공한다.
이 때 `),ni=o(en,"CODE",{});var KT=l(ni);D9=e(KT,"bufio.NewReader()"),KT.forEach(a),P9=e(en," 함수에 "),si=o(en,"CODE",{});var QT=l(si);O9=e(QT,"io.Reader"),QT.forEach(a),R9=e(en,"를 지원하는 타입을 파라미터로 통과시키면, "),ai=o(en,"CODE",{});var YT=l(ai);T9=e(YT,"*bufio.Reader"),YT.forEach(a),S9=e(en,`를 리턴받는다.
만약 파라미터로 넘겨진 `),ti=o(en,"CODE",{});var $T=l(ti);M9=e($T,"io.Reader"),$T.forEach(a),I9=e(en,"의 타입이 "),ei=o(en,"CODE",{});var hT=l(ei);L9=e(hT,"io.ReaderFrom"),hT.forEach(a),H9=e(en,"도 지원하는 경우, 이를 buffered reader로 감싸게 되면 최적화가 되지 않는다."),en.forEach(a),qd=r(n),h=o(n,"P",{});var ls=l(h);A9=e(ls,`에러 핸들링 할때도 본 현상인데, 에러는 다른 에러를 감싸는 것을 통해 추가적인 정보를 포함할 수 있다.
`),pi=o(ls,"EM",{});var gT=l(pi);G9=e(gT,"Type Assertion"),gT.forEach(a),B9=e(ls,"과 "),oi=o(ls,"EM",{});var nS=l(oi);x9=e(nS,"Type Switch"),nS.forEach(a),N9=e(ls,`로는 감싸진 에러를 확인할 수 없기 때문에,
제대로 핸들링하기 위해 감싸진 에러에 접근하려면 `),li=o(ls,"CODE",{});var sS=l(li);F9=e(sS,"errors.Is()"),sS.forEach(a),W9=e(ls,"나 "),ci=o(ls,"CODE",{});var aS=l(ci);U9=e(aS,"errors.As()"),aS.forEach(a),j9=e(ls,"같은 함수를 사용해야 한다."),ls.forEach(a),Vd=r(n),Jd=o(n,"BR",{}),Xd=r(n),vt=o(n,"P",{});var pC=l(vt);ui=o(pC,"EM",{});var tS=l(ui);z9=e(tS,"Type Switch"),tS.forEach(a),q9=e(pC,`는 인터페이스를 지원하는 타입들이 여러 개 있고, 각 타입마다 다르게 처리해줘야 하는 경우 유용하다.
그중 가장 유용한 경우는, 유효한 타입이 딱 한 개만 존재하는 경우이다.`),pC.forEach(a),Zd=r(n),g=o(n,"P",{});var cs=l(g);V9=e(cs,"웬만하면 "),ii=o(cs,"CODE",{});var eS=l(ii);J9=e(eS,"switch"),eS.forEach(a),X9=e(cs,"문에 "),ri=o(cs,"CODE",{});var pS=l(ri);Z9=e(pS,"default"),pS.forEach(a),K9=e(cs,`를 반드시 넣어주는 게 좋다.
인터페이스를 지원하는 타입을 추가했는데 `),ki=o(cs,"CODE",{});var oS=l(ki);Q9=e(oS,"switch"),oS.forEach(a),Y9=e(cs,"문을 업데이트하는 것을 까먹은 경우 "),fi=o(cs,"CODE",{});var lS=l(fi);$9=e(lS,"default"),lS.forEach(a),h9=e(cs," 블록에 걸리므로, 문제를 추적하기 쉬워질 것이다."),cs.forEach(a),Kd=r(n),Qd=o(n,"BR",{}),Yd=o(n,"BR",{}),$d=r(n),ka=o(n,"H3",{id:!0});var oC=l(ka);fa=o(oC,"A",{"aria-hidden":!0,tabindex:!0,href:!0});var cS=l(fa);di=o(cS,"SPAN",{class:!0}),l(di).forEach(a),cS.forEach(a),g9=e(oC,"Function Types Are a Bridge to Interfaces"),oC.forEach(a),hd=r(n),pe=o(n,"P",{});var uS=l(pe);nb=e(uS,"Go에서는 함수를 비롯하여 유저가 정의한 타입이라면 어떠한 타입이든 메소드를 추가할 수 있으며, 이는 굉장히 유용하다."),uS.forEach(a),gd=r(n),oe=o(n,"P",{});var iS=l(oe);sb=e(iS,"가장 일반적인 사례는 HTTP 요청을 처리하는 HTTP 핸들러이다. 이는 아래와 같이 인터페이스로 정의되어 있다."),iS.forEach(a),nE=r(n),_t=o(n,"PRE",{class:!0});var BI=l(_t);BI.forEach(a),sE=r(n),F=o(n,"P",{});var Mn=l(F);Ei=o(Mn,"CODE",{});var rS=l(Ei);ab=e(rS,"http.ResponseWriter"),rS.forEach(a),tb=e(Mn,", "),mi=o(Mn,"CODE",{});var kS=l(mi);eb=e(kS,"*http.Request"),kS.forEach(a),pb=e(Mn,"를 파라미터로 받는 함수들은 "),vi=o(Mn,"CODE",{});var fS=l(vi);ob=e(fS,"HandlerFunc"),fS.forEach(a),lb=e(Mn,`로 타입 변환을 할 수 있다.
그러면 `),_i=o(Mn,"CODE",{});var dS=l(_i);cb=e(dS,"ServeHTTP()"),dS.forEach(a),ub=e(Mn,"를 호출할 수 있게 되며, "),yi=o(Mn,"CODE",{});var ES=l(yi);ib=e(ES,"http.Handler"),ES.forEach(a),rb=e(Mn," 인터페이스를 사용할 수 있게 된다."),Mn.forEach(a),aE=r(n),yt=o(n,"PRE",{class:!0});var xI=l(yt);xI.forEach(a),tE=r(n),da=o(n,"P",{});var P2=l(da);kb=e(P2,"이러한 방식을 통해 "),bi=o(P2,"CODE",{});var mS=l(bi);fb=e(mS,"http.Handler"),mS.forEach(a),db=e(P2,"의 인터페이스를 충족시키기만 하면 함수, 메소드, Closure를 HTTP 핸들러로 사용할 수 있다."),P2.forEach(a),eE=r(n),pE=o(n,"BR",{}),oE=r(n),le=o(n,"P",{});var vS=l(le);Eb=e(vS,`Go에서 함수는 가장 중요한 개념인 만큼, 또 다른 함수의 파라미터로 전달된다.
한편으로, Go에서는 작은 인터페이스를 권장하며, 메소드가 하나 뿐인 인터페이스는 함수의 파라미터로 전달되는 함수를 대체할 수 있다.
그렇다면 이런 질문이 생길 수 있다. 파라미터인 함수의 타입을 언제 명시해줘야 하며, 언제 인터페이스를 써야 할까?`),vS.forEach(a),lE=r(n),Zn=o(n,"P",{});var xe=l(Zn);mb=e(xe,`만약 함수가 다른 함수들이나, 파라미터가 아닌 state에 의존한다면,
인터페이스 파라미터를 사용하고 인터페이스에 대한 bridge로써 함수 타입을 정의하는 것이 좋다고 한다.
이를테면 이는 `),wi=o(xe,"CODE",{});var _S=l(wi);vb=e(_S,"http"),_S.forEach(a),_b=e(xe,` 패키지에서 사용하는 방식이다. http 핸들러는 설정해주어야 하는 연쇄적인 함수 호출의 진입점일 가능성이 높다.
반면 함수가 `),Ci=o(xe,"CODE",{});var yS=l(Ci);yb=e(yS,"sort.Slice()"),yS.forEach(a),bb=e(xe,"처럼 간단한 함수일 경우, 인터페이스보단 그냥 함수를 넘기는 게 좋다고 한다."),xe.forEach(a),cE=r(n),uE=o(n,"BR",{}),iE=o(n,"BR",{}),rE=r(n),Ea=o(n,"H3",{id:!0});var lC=l(Ea);ma=o(lC,"A",{"aria-hidden":!0,tabindex:!0,href:!0});var bS=l(ma);Di=o(bS,"SPAN",{class:!0}),l(Di).forEach(a),bS.forEach(a),wb=e(lC,"Implicit Interfaces Make Dependency Injection Easier"),lC.forEach(a),kE=r(n),bt=o(n,"P",{});var cC=l(bt);Pi=o(cC,"STRONG",{});var wS=l(Pi);Cb=e(wS,"Dependency Injection"),wS.forEach(a),Db=e(cC,`이란 코드가 수행하는 기능과 작업을 분명하게 명시해야 한다는 개념이다.
Go의 인터페이스는 디커플링을 맛깔나게 잘 해줘서 Dependency Injection이 엄청 잘 된다고 한다.
그래서 다른 언어에서 Dependency Injection를 위해 복잡한 프레임워크를 사용하는 반면,
Go는 어떠한 외부 라이브러리도 사용하지 않는다.`),cC.forEach(a),fE=r(n),ce=o(n,"P",{});var CS=l(ce);Pb=e(CS,"Dependency Injection이 어떻게 이루어지는지 보기 위해, 간단한 웹 서버 예제를 만들어보자."),CS.forEach(a),dE=r(n),wt=o(n,"PRE",{class:!0});var NI=l(wt);NI.forEach(a),EE=r(n),va=o(n,"P",{});var O2=l(va);Ob=e(O2,`간단한 로깅 함수와 저장을 위한 데이터 타입, 및 데이터 탐색 메소드를 정의하였다.
`),Oi=o(O2,"CODE",{});var DS=l(Oi);Rb=e(DS,"SimpleDataStore"),DS.forEach(a),Tb=e(O2," 인스턴스를 생성하는 factory function을 정의해보자."),O2.forEach(a),mE=r(n),Ct=o(n,"PRE",{class:!0});var FI=l(Ct);FI.forEach(a),vE=r(n),_E=o(n,"BR",{}),yE=r(n),Kn=o(n,"P",{});var Ne=l(Kn);Sb=e(Ne,`이제 유저에게 “hello” 또는 “good bye”라고 날리는 로직을 작성해 볼 것이다.
이 로직은 유저에게 접근해야 하므로 접근 대상이 되는 자료구조와, 로깅을 하는 함수에 대한 의존성이 존재한다.
하지만 우리는 `),Ri=o(Ne,"CODE",{});var PS=l(Ri);Mb=e(PS,"LogOutput()"),PS.forEach(a),Ib=e(Ne,"이나 "),Ti=o(Ne,"CODE",{});var OS=l(Ti);Lb=e(OS,"SimpleDataStore"),OS.forEach(a),Hb=e(Ne,`에 대한 직접적인 의존성을 만들고 싶지 않다.
미래에 다른 자료구조나 로깅 함수를 사용할 수도 있기 때문이다.`),Ne.forEach(a),bE=r(n),ue=o(n,"P",{});var RS=l(ue);Ab=e(RS,"바로 이러한 경우, 인터페이스가 적절한 해법이 된다."),RS.forEach(a),wE=r(n),Dt=o(n,"PRE",{class:!0});var WI=l(Dt);WI.forEach(a),CE=r(n),Tn=o(n,"P",{});var Ht=l(Tn);Si=o(Ht,"CODE",{});var TS=l(Si);Gb=e(TS,"LoggerAdapter"),TS.forEach(a),Bb=e(Ht,"를 선언해 "),Mi=o(Ht,"CODE",{});var SS=l(Mi);xb=e(SS,"LogOutput()"),SS.forEach(a),Nb=e(Ht,"함수를 "),Ii=o(Ht,"CODE",{});var MS=l(Ii);Fb=e(MS,"Logger"),MS.forEach(a),Wb=e(Ht,`에 연결해 주었다.
이제 우리의 비즈니스 로직은 인터페이스들을 사용하여 자료구조에 접근하고, 로깅을 할 수 있다.`),Ht.forEach(a),DE=r(n),ie=o(n,"P",{});var IS=l(ie);Ub=e(IS,"의존성이 정의되었으니, 비즈니스 로직을 완성해보자."),IS.forEach(a),PE=r(n),Pt=o(n,"PRE",{class:!0});var UI=l(Pt);UI.forEach(a),OE=r(n),W=o(n,"P",{});var In=l(W);Li=o(In,"CODE",{});var LS=l(Li);jb=e(LS,"Logger"),LS.forEach(a),zb=e(In,"와 "),Hi=o(In,"CODE",{});var HS=l(Hi);qb=e(HS,"DataStore"),HS.forEach(a),Vb=e(In,"를 필드로 갖는 "),Ai=o(In,"CODE",{});var AS=l(Ai);Jb=e(AS,"SimpleLogic"),AS.forEach(a),Xb=e(In,"이라는 "),Gi=o(In,"CODE",{});var GS=l(Gi);Zb=e(GS,"struct"),GS.forEach(a),Kb=e(In,`와, factory function을 정의해주었다.
이 `),Bi=o(In,"CODE",{});var BS=l(Bi);Qb=e(BS,"SimpleLogic"),BS.forEach(a),Yb=e(In,` 내의 메소드는 다른 concrete type을 레퍼런스하지 않기 때문에, 의존성이 없다.
그래서 차후 라이브러리를 교체하더라도 인터페이스는 라이브러리와 관련이 없기 때문에 문제가 발생하지 않는다.`),In.forEach(a),RE=r(n),TE=o(n,"BR",{}),SE=r(n),Qn=o(n,"P",{});var Fe=l(Qn);$b=e(Fe,"이제 "),xi=o(Fe,"CODE",{});var xS=l(xi);hb=e(xS,"/hello"),xS.forEach(a),gb=e(Fe,`라는 엔드포인트를 정의해볼 것이다. 이 엔드포인트에서는 유저의 ID가 같이 오면 인사를 할 것이다.
`),Ni=o(Fe,"EM",{});var NS=l(Ni);nw=e(NS,"Controller"),NS.forEach(a),sw=e(Fe,"에게 인사를 할 로직을 쥐어주기 위해 인터페이스를 만들어주자."),Fe.forEach(a),ME=r(n),Ot=o(n,"PRE",{class:!0});var jI=l(Ot);jI.forEach(a),IE=r(n),Yn=o(n,"P",{});var We=l(Yn);aw=e(We,"이 인터페이스는 "),Fi=o(We,"CODE",{});var FS=l(Fi);tw=e(FS,"SimpleLogic"),FS.forEach(a),ew=e(We,`을 가리킬 수 있다.
인터페이스는 클라이언트 코드에서 정의되기 때문에, 수정이 필요하다면 클라이언트 코드에서 수정하면 그만이다.
따라서 `),Wi=o(We,"CODE",{});var WS=l(Wi);pw=e(WS,"SimpleLogic"),WS.forEach(a),ow=e(We,"이 나중에 변경되거나, 혹은 새로운 로직이 추가되더라도 별다른 문제 없이 사용할 수 있다."),We.forEach(a),LE=r(n),Rt=o(n,"PRE",{class:!0});var zI=l(Rt);zI.forEach(a),HE=r(n),AE=o(n,"BR",{}),GE=r(n),_a=o(n,"P",{});var R2=l(_a);lw=e(R2,"마지막으로, "),Ui=o(R2,"CODE",{});var US=l(Ui);cw=e(US,"main"),US.forEach(a),uw=e(R2," 함수에서 모든 컴포넌트를 연결하고 서버를 열어보자."),R2.forEach(a),BE=r(n),Tt=o(n,"PRE",{class:!0});var qI=l(Tt);qI.forEach(a),xE=r(n),$n=o(n,"P",{});var Ue=l($n);iw=e(Ue,"파일을 실행하여 서버를 연 뒤, 브라우저에서 "),ji=o(Ue,"CODE",{});var jS=l(ji);rw=e(jS,"http://localhost:8080/hello?user_id=1"),jS.forEach(a),kw=e(Ue," 및 "),zi=o(Ue,"CODE",{});var zS=l(zi);fw=e(zS,"http://localhost:8080/hello?user_id=5"),zS.forEach(a),dw=e(Ue," 등으로 접속해보자."),Ue.forEach(a),NE=r(n),S=o(n,"P",{});var rn=l(S);qi=o(rn,"CODE",{});var qS=l(qi);Ew=e(qS,'http.HandleFunc("/hello", c.SayHello)'),qS.forEach(a),mw=e(rn," 라인을 잘 살펴보면, 두 번째 "),Vi=o(rn,"CODE",{});var VS=l(Vi);vw=e(VS,"http.HandleFunc()"),VS.forEach(a),_w=e(rn,"의 두 번째 파라미터로 "),Ji=o(rn,"CODE",{});var JS=l(Ji);yw=e(JS,"c.SayHello()"),JS.forEach(a),bw=e(rn,` 메소드를 보냈다.
이때 보내진 메소드는 `),Xi=o(rn,"CODE",{});var XS=l(Xi);ww=e(XS,"http.Handler"),XS.forEach(a),Cw=e(rn," 인터페이스를 충족시키는 "),Zi=o(rn,"CODE",{});var ZS=l(Zi);Dw=e(ZS,"http.HandlerFunc"),ZS.forEach(a),Pw=e(rn,` 타입으로 변환이 된다.
`),Ki=o(rn,"CODE",{});var KS=l(Ki);Ow=e(KS,"NewController"),KS.forEach(a),Rw=e(rn,"의 메소드임을 유지한 채로 말이다."),rn.forEach(a),FE=r(n),vs=o(n,"P",{});var er=l(vs);Qi=o(er,"CODE",{});var QS=l(Qi);Tw=e(QS,"main"),QS.forEach(a),Sw=e(er,` 함수는 concrete type들이 실제로 선언되는 유일한 영역이다.
어느 타입 하나를 다른 타입으로 변경하고 싶다면, `),Yi=o(er,"CODE",{});var YS=l(Yi);Mw=e(YS,"main"),YS.forEach(a),Iw=e(er,`에서만 변경해주면 된다.
이렇게 Dependency Injection을 통해 의존성을 Externalizing함으로써, 코드를 업데이트 할 때 변경해야 할 내용을 최소화할 수 있다.`),er.forEach(a),WE=r(n),re=o(n,"P",{});var $S=l(re);Lw=e($S,`Dependency Injection은 테스트를 더 쉽게 할 수 있도록 해주기도 한다.
환경이 다르더라도, 입출력이 제한된 상황에서 unit test를 하는 것은 코드를 효과적으로 재사용한다.
이를테면 위 예제에서 logger의 출력을 테스트하려고 한다면, logger의 출력을 capture하는 타입을 주입하고 인터페이스를 충족시켜주기만 하면 된다.`),$S.forEach(a),UE=r(n),jE=o(n,"BR",{}),zE=r(n),ya=o(n,"P",{});var T2=l(ya);Hw=e(T2,`개인적으로는 Dependency Injection이 일단 짜놓으면 편하긴 한데, 직접 짜기에는 너무 복잡하고 양이 많아 보였다.
그럴 때에는 구글님들이 `),St=o(T2,"A",{href:!0,rel:!0});var hS=l(St);Aw=e(hS,"Wire"),hS.forEach(a),Gw=e(T2,`라는, Dependency Injection을 도와주는 유틸리티가 있는데,
자동적으로 concrete type 선언 코드를 만들어준다고 하니 필요하다면 잘 사용해보도록 하자.`),T2.forEach(a),qE=r(n),VE=o(n,"BR",{}),JE=o(n,"BR",{}),XE=r(n),ba=o(n,"H3",{id:!0});var uC=l(ba);wa=o(uC,"A",{"aria-hidden":!0,tabindex:!0,href:!0});var gS=l(wa);$i=o(gS,"SPAN",{class:!0}),l($i).forEach(a),gS.forEach(a),Bw=e(uC,"Go Isn’t Particularly Object-Oriented"),uC.forEach(a),ZE=r(n),ke=o(n,"P",{});var nM=l(ke);xw=e(nM,`Go라는 언어를 특정 스타일로 구분짓기는 어렵다.
일단 절차지향은 아닌 듯 한데, 메소드 오버라이딩이나 상속도 없어서 객체지향이라기에도 애매하다.
함수 타입과 closure가 있지만 함수형 언어도 아니다.
만약 이러한 방법론에 맞춰서 Go 코드를 짜면, 아마 그게 이상적인 Go 코드는 아닐 것이다.`),nM.forEach(a),KE=r(n),QE=o(n,"BR",{}),YE=o(n,"BR",{}),$E=r(n),Ca=o(n,"H2",{id:!0});var iC=l(Ca);Da=o(iC,"A",{"aria-hidden":!0,tabindex:!0,href:!0});var sM=l(Da);hi=o(sM,"SPAN",{class:!0}),l(hi).forEach(a),sM.forEach(a),Nw=e(iC,"Refereces"),iC.forEach(a),hE=r(n),gE=o(n,"HR",{}),n2=r(n),fe=o(n,"CENTER",{});var aM=l(fe);_s=o(aM,"P",{});var je=l(_s);Mt=o(je,"A",{href:!0,rel:!0});var tM=l(Mt);de=o(tM,"IMG",{src:!0,alt:!0}),tM.forEach(a),Fw=r(je),Ww=o(je,"BR",{}),Uw=r(je),It=o(je,"A",{href:!0,rel:!0});var eM=l(It);jw=e(eM,"Jon Bodner, 『Learning Go』, O’Reilly Media, Inc."),eM.forEach(a),je.forEach(a),aM.forEach(a),s2=r(n),a2=o(n,"BR",{}),t2=r(n),Ee=o(n,"P",{});var pM=l(Ee);zw=e(pM,"이번 포스트는 의역이 너무 많아용"),pM.forEach(a),e2=r(n),me=o(n,"P",{});var oM=l(me);qw=e(oM,"원문 참조하시는 게 좋을듯함"),oM.forEach(a),p2=r(n),o2=o(n,"BR",{}),l2=o(n,"BR",{}),this.h()},h(){k(ze,"class","icon icon-link"),k(Os,"aria-hidden","true"),k(Os,"tabindex","-1"),k(Os,"href","#types"),k(Ps,"id","types"),k(Aa,"class","language-go"),k(Ye,"class","icon icon-link"),k(Ms,"aria-hidden","true"),k(Ms,"tabindex","-1"),k(Ms,"href","#inheritance-in-go"),k(Ss,"id","inheritance-in-go"),k(Ga,"class","language-go"),k(Ba,"class","language-go"),k(ap,"class","icon icon-link"),k(Hs,"aria-hidden","true"),k(Hs,"tabindex","-1"),k(Hs,"href","#enumeration-in-go---iota"),k(Ls,"id","enumeration-in-go---iota"),k(xa,"class","language-go"),k(Na,"class","language-bash"),k(Fa,"class","language-go"),k(Cp,"class","icon icon-link"),k(Bs,"aria-hidden","true"),k(Bs,"tabindex","-1"),k(Bs,"href","#methods"),k(Gs,"id","methods"),k(Wa,"class","language-go"),k(Rp,"class","icon icon-link"),k(Ns,"aria-hidden","true"),k(Ns,"tabindex","-1"),k(Ns,"href","#pointer-receivers"),k(xs,"id","pointer-receivers"),k(ja,"class","language-go"),k(za,"class","language-bash"),k(qa,"class","language-go"),k(Va,"class","language-bash"),k(Ja,"class","language-go"),k(mo,"class","icon icon-link"),k(Us,"aria-hidden","true"),k(Us,"tabindex","-1"),k(Us,"href","#methods-and-functions"),k(Ws,"id","methods-and-functions"),k(Xa,"class","language-go"),k(Io,"class","icon icon-link"),k(qs,"aria-hidden","true"),k(qs,"tabindex","-1"),k(qs,"href","#embedding"),k(zs,"id","embedding"),k(Za,"class","language-go"),k(Ka,"class","language-go"),k(Qa,"class","language-go"),k(Ya,"class","language-go"),k($a,"class","language-bash"),k(el,"class","icon icon-link"),k(Zs,"aria-hidden","true"),k(Zs,"tabindex","-1"),k(Zs,"href","#interface"),k(Xs,"id","interface"),k(ha,"class","language-go"),ZI(Vt,"background-color","#FFF5B1"),k(nt,"class","language-go"),k(st,"class","language-go"),k(at,"class","language-go"),k(tc,"class","icon icon-link"),k(Ys,"aria-hidden","true"),k(Ys,"tabindex","-1"),k(Ys,"href","#embedding-and-interfaces"),k(Qs,"id","embedding-and-interfaces"),k(tt,"class","language-go"),k(cc,"class","icon icon-link"),k(hs,"aria-hidden","true"),k(hs,"tabindex","-1"),k(hs,"href","#accept-interfaces-return-structs"),k($s,"id","accept-interfaces-return-structs"),k(kc,"class","icon icon-link"),k(sa,"aria-hidden","true"),k(sa,"tabindex","-1"),k(sa,"href","#interfaces-and-nil"),k(na,"id","interfaces-and-nil"),k(et,"class","language-go"),k(pt,"class","language-bash"),k(Tc,"class","icon icon-link"),k(ta,"aria-hidden","true"),k(ta,"tabindex","-1"),k(ta,"href","#the-empty-interface-says-nothing"),k(aa,"id","the-empty-interface-says-nothing"),k(ot,"class","language-go"),k(lt,"class","language-go"),k(ct,"class","language-go"),k(qc,"class","icon icon-link"),k(la,"aria-hidden","true"),k(la,"tabindex","-1"),k(la,"href","#type-assertions-and-type-switches"),k(oa,"id","type-assertions-and-type-switches"),k(ut,"class","language-go"),k(it,"class","language-go"),k(rt,"class","language-go"),k(kt,"class","language-go"),k(ft,"class","language-go"),k(dt,"class","language-bash"),k(Et,"class","language-go"),k(mt,"class","language-go"),k(di,"class","icon icon-link"),k(fa,"aria-hidden","true"),k(fa,"tabindex","-1"),k(fa,"href","#function-types-are-a-bridge-to-interfaces"),k(ka,"id","function-types-are-a-bridge-to-interfaces"),k(_t,"class","language-go"),k(yt,"class","language-go"),k(Di,"class","icon icon-link"),k(ma,"aria-hidden","true"),k(ma,"tabindex","-1"),k(ma,"href","#implicit-interfaces-make-dependency-injection-easier"),k(Ea,"id","implicit-interfaces-make-dependency-injection-easier"),k(wt,"class","language-go"),k(Ct,"class","language-go"),k(Dt,"class","language-go"),k(Pt,"class","language-go"),k(Ot,"class","language-go"),k(Rt,"class","language-go"),k(Tt,"class","language-go"),k(St,"href","https://github.com/google/wire"),k(St,"rel","nofollow"),k($i,"class","icon icon-link"),k(wa,"aria-hidden","true"),k(wa,"tabindex","-1"),k(wa,"href","#go-isnt-particularly-object-oriented"),k(ba,"id","go-isnt-particularly-object-oriented"),k(hi,"class","icon icon-link"),k(Da,"aria-hidden","true"),k(Da,"tabindex","-1"),k(Da,"href","#refereces"),k(Ca,"id","refereces"),KI(de.src,kC="https://learning.oreilly.com/covers/urn:orm:book:9781492077206/400w/")||k(de,"src",kC),k(de,"alt","Learning Go Book Cover"),k(Mt,"href","https://learning.oreilly.com/library/view/learning-go/9781492077206/"),k(Mt,"rel","nofollow"),k(It,"href","https://learning.oreilly.com/library/view/learning-go/9781492077206/"),k(It,"rel","nofollow")},m(n,c){u(n,At,c),u(n,pr,c),u(n,Gt,c),s(Gt,S2),u(n,or,c),u(n,lr,c),u(n,cr,c),u(n,ur,c),u(n,Ps,c),s(Ps,Os),s(Os,ze),s(Ps,M2),u(n,ir,c),u(n,rr,c),u(n,kr,c),u(n,Rs,c),s(Rs,I2),s(Rs,qe),s(qe,L2),s(Rs,H2),u(n,fr,c),u(n,Aa,c),Aa.innerHTML=cM,u(n,dr,c),u(n,Bt,c),s(Bt,A2),u(n,Er,c),u(n,mr,c),u(n,vr,c),u(n,kn,c),s(kn,G2),s(kn,Ve),s(Ve,B2),s(kn,x2),s(kn,Je),s(Je,N2),s(kn,F2),s(kn,Xe),s(Xe,W2),s(kn,U2),u(n,_r,c),u(n,Ln,c),s(Ln,j2),s(Ln,Ze),s(Ze,z2),s(Ln,q2),s(Ln,Ke),s(Ke,V2),s(Ln,J2),u(n,yr,c),u(n,Ts,c),s(Ts,X2),s(Ts,Qe),s(Qe,Z2),s(Ts,K2),u(n,br,c),u(n,wr,c),u(n,Cr,c),u(n,Dr,c),u(n,Ss,c),s(Ss,Ms),s(Ms,Ye),s(Ss,Q2),u(n,Pr,c),u(n,xt,c),s(xt,Y2),u(n,Or,c),u(n,Ga,c),Ga.innerHTML=uM,u(n,Rr,c),u(n,Is,c),s(Is,$2),s(Is,$e),s($e,h2),s(Is,g2),u(n,Tr,c),u(n,q,c),s(q,nm),s(q,he),s(he,sm),s(q,am),s(q,ge),s(ge,tm),s(q,em),s(q,np),s(np,pm),s(q,om),s(q,sp),s(sp,lm),s(q,cm),u(n,Sr,c),u(n,Ba,c),Ba.innerHTML=iM,u(n,Mr,c),u(n,Ir,c),u(n,Lr,c),u(n,Hr,c),u(n,Ls,c),s(Ls,Hs),s(Hs,ap),s(Ls,um),u(n,Ar,c),u(n,Hn,c),s(Hn,im),s(Hn,tp),s(tp,rm),s(Hn,km),s(Hn,ep),s(ep,fm),s(Hn,dm),u(n,Gr,c),u(n,xa,c),xa.innerHTML=rM,u(n,Br,c),u(n,Na,c),Na.innerHTML=kM,u(n,xr,c),u(n,V,c),s(V,Em),s(V,pp),s(pp,mm),s(V,vm),s(V,op),s(op,_m),s(V,ym),s(V,lp),s(lp,bm),s(V,wm),s(V,cp),s(cp,Cm),s(V,Dm),u(n,Nr,c),u(n,Fr,c),u(n,Wr,c),u(n,Fa,c),Fa.innerHTML=fM,u(n,Ur,c),u(n,us,c),s(us,up),s(up,Pm),s(us,Om),s(us,ip),s(ip,Rm),s(us,Tm),u(n,jr,c),u(n,zr,c),u(n,qr,c),u(n,D,c),s(D,Sm),s(D,rp),s(rp,Mm),s(D,Im),s(D,kp),s(kp,Lm),s(D,Hm),s(D,fp),s(fp,Am),s(D,Gm),s(D,dp),s(dp,Bm),s(D,xm),s(D,Ep),s(Ep,Nm),s(D,Fm),s(D,mp),s(mp,Wm),s(D,Um),u(n,Vr,c),u(n,J,c),s(J,jm),s(J,vp),s(vp,zm),s(J,qm),s(J,_p),s(_p,Vm),s(J,Jm),s(J,yp),s(yp,Xm),s(J,Zm),s(J,bp),s(bp,Km),s(J,Qm),u(n,Jr,c),u(n,As,c),s(As,Ym),s(As,wp),s(wp,$m),s(As,hm),u(n,Xr,c),u(n,Zr,c),u(n,Kr,c),u(n,Qr,c),u(n,Gs,c),s(Gs,Bs),s(Bs,Cp),s(Gs,gm),u(n,Yr,c),u(n,$r,c),u(n,hr,c),u(n,fn,c),s(fn,nv),s(fn,Dp),s(Dp,sv),s(fn,av),s(fn,Pp),s(Pp,tv),s(fn,ev),s(fn,Op),s(Op,pv),s(fn,ov),u(n,gr,c),u(n,Wa,c),Wa.innerHTML=dM,u(n,nk,c),u(n,Nt,c),s(Nt,lv),u(n,sk,c),u(n,Ft,c),s(Ft,cv),u(n,ak,c),u(n,tk,c),u(n,ek,c),u(n,pk,c),u(n,xs,c),s(xs,Ns),s(Ns,Rp),s(xs,uv),u(n,ok,c),u(n,dn,c),s(dn,iv),s(dn,Tp),s(Tp,rv),s(dn,kv),s(dn,Sp),s(Sp,fv),s(dn,dv),s(dn,Mp),s(Mp,Ev),s(dn,mv),u(n,lk,c),u(n,Ua,c),s(Ua,Ip),s(Ip,vv),s(Ua,_v),u(n,ck,c),u(n,An,c),s(An,is),s(is,yv),s(is,Lp),s(Lp,bv),s(is,wv),s(is,Hp),s(Hp,Cv),s(is,Dv),s(An,Pv),s(An,rs),s(rs,Ov),s(rs,Ap),s(Ap,Rv),s(rs,Tv),s(rs,Gp),s(Gp,Sv),s(rs,Mv),s(An,Iv),s(An,ks),s(ks,Lv),s(ks,Bp),s(Bp,Hv),s(ks,Av),s(ks,xp),s(xp,Gv),s(ks,Bv),u(n,uk,c),u(n,Rn,c),s(Rn,Np),s(Np,xv),s(Rn,Nv),s(Rn,Fp),s(Fp,Fv),s(Rn,Wv),s(Rn,Wp),s(Wp,Uv),s(Rn,jv),u(n,ik,c),u(n,rk,c),u(n,kk,c),u(n,ja,c),ja.innerHTML=EM,u(n,fk,c),u(n,En,c),s(En,zv),s(En,Up),s(Up,qv),s(En,Vv),s(En,jp),s(jp,Jv),s(En,Xv),s(En,zp),s(zp,Zv),s(En,Kv),u(n,dk,c),u(n,za,c),za.innerHTML=mM,u(n,Ek,c),u(n,mk,c),u(n,vk,c),u(n,Wt,c),s(Wt,Qv),u(n,_k,c),u(n,qa,c),qa.innerHTML=vM,u(n,yk,c),u(n,E,c),s(E,qp),s(qp,Yv),s(E,$v),s(E,Vp),s(Vp,hv),s(E,gv),s(E,Jp),s(Jp,n3),s(E,s3),s(E,Xp),s(Xp,a3),s(E,t3),s(E,Zp),s(Zp,e3),s(E,p3),s(E,Kp),s(Kp,o3),s(E,l3),s(E,Qp),s(Qp,c3),s(E,u3),s(E,Yp),s(Yp,i3),s(E,r3),s(E,$p),s($p,k3),s(E,f3),u(n,bk,c),u(n,Ut,c),s(Ut,d3),u(n,wk,c),u(n,Va,c),Va.innerHTML=_M,u(n,Ck,c),u(n,Dk,c),u(n,Pk,c),u(n,mn,c),s(mn,E3),s(mn,hp),s(hp,m3),s(mn,v3),s(mn,gp),s(gp,_3),s(mn,y3),s(mn,no),s(no,b3),s(mn,w3),u(n,Ok,c),u(n,Rk,c),u(n,Tk,c),u(n,Sk,c),u(n,fs,c),s(fs,so),s(so,C3),s(fs,D3),s(fs,ao),s(ao,P3),s(fs,O3),u(n,Mk,c),u(n,v,c),s(v,R3),s(v,to),s(to,T3),s(v,S3),s(v,eo),s(eo,M3),s(v,I3),s(v,po),s(po,L3),s(v,H3),s(v,oo),s(oo,A3),s(v,G3),s(v,lo),s(lo,B3),s(v,x3),s(v,co),s(co,N3),s(v,F3),s(v,uo),s(uo,W3),s(v,U3),u(n,Ik,c),u(n,Ja,c),Ja.innerHTML=yM,u(n,Lk,c),u(n,Fs,c),s(Fs,j3),s(Fs,io),s(io,z3),s(Fs,q3),u(n,Hk,c),u(n,pn,c),s(pn,ro),s(ro,V3),s(pn,J3),s(pn,ko),s(ko,X3),s(pn,Z3),s(pn,fo),s(fo,K3),s(pn,Q3),s(pn,Eo),s(Eo,Y3),s(pn,$3),u(n,Ak,c),u(n,Gk,c),u(n,Bk,c),u(n,xk,c),u(n,Ws,c),s(Ws,Us),s(Us,mo),s(Ws,h3),u(n,Nk,c),u(n,jt,c),s(jt,g3),u(n,Fk,c),u(n,Xa,c),Xa.innerHTML=bM,u(n,Wk,c),u(n,vn,c),s(vn,n5),s(vn,vo),s(vo,s5),s(vn,a5),s(vn,_o),s(_o,t5),s(vn,e5),s(vn,yo),s(yo,p5),s(vn,o5),u(n,Uk,c),u(n,N,c),s(N,bo),s(bo,l5),s(N,c5),s(N,wo),s(wo,u5),s(N,i5),s(N,Co),s(Co,r5),s(N,k5),s(N,Do),s(Do,f5),s(N,d5),s(N,Po),s(Po,E5),s(N,m5),u(n,jk,c),u(n,X,c),s(X,v5),s(X,Oo),s(Oo,_5),s(X,y5),s(X,Ro),s(Ro,b5),s(X,w5),s(X,To),s(To,C5),s(X,D5),s(X,So),s(So,P5),s(X,O5),u(n,zk,c),u(n,js,c),s(js,R5),s(js,Mo),s(Mo,T5),s(js,S5),u(n,qk,c),u(n,Vk,c),u(n,Jk,c),u(n,Xk,c),u(n,zs,c),s(zs,qs),s(qs,Io),s(zs,M5),u(n,Zk,c),u(n,Kk,c),u(n,Qk,c),u(n,Gn,c),s(Gn,I5),s(Gn,Lo),s(Lo,L5),s(Gn,H5),s(Gn,Ho),s(Ho,A5),s(Gn,G5),u(n,Yk,c),u(n,zt,c),s(zt,B5),u(n,$k,c),u(n,Za,c),Za.innerHTML=wM,u(n,hk,c),u(n,y,c),s(y,Ao),s(Ao,x5),s(y,N5),s(y,Go),s(Go,F5),s(y,W5),s(y,Bo),s(Bo,U5),s(y,j5),s(y,xo),s(xo,z5),s(y,q5),s(y,No),s(No,V5),s(y,J5),s(y,Fo),s(Fo,X5),s(y,Z5),s(y,Wo),s(Wo,K5),s(y,Q5),u(n,gk,c),u(n,nf,c),u(n,sf,c),u(n,Ka,c),Ka.innerHTML=CM,u(n,af,c),u(n,Vs,c),s(Vs,Y5),s(Vs,Uo),s(Uo,$5),s(Vs,h5),u(n,tf,c),u(n,_n,c),s(_n,g5),s(_n,jo),s(jo,n_),s(_n,s_),s(_n,zo),s(zo,a_),s(_n,t_),s(_n,qo),s(qo,e_),s(_n,p_),u(n,ef,c),u(n,pf,c),u(n,of,c),u(n,lf,c),u(n,ds,c),s(ds,Vo),s(Vo,o_),s(ds,l_),s(ds,Jo),s(Jo,c_),s(ds,u_),u(n,cf,c),u(n,uf,c),u(n,rf,c),u(n,Bn,c),s(Bn,i_),s(Bn,Xo),s(Xo,r_),s(Bn,k_),s(Bn,Zo),s(Zo,f_),s(Bn,d_),u(n,kf,c),u(n,Qa,c),Qa.innerHTML=DM,u(n,ff,c),u(n,Z,c),s(Z,E_),s(Z,Ko),s(Ko,m_),s(Z,v_),s(Z,Qo),s(Qo,__),s(Z,y_),s(Z,Yo),s(Yo,b_),s(Z,w_),s(Z,$o),s($o,C_),s(Z,D_),u(n,df,c),u(n,Ef,c),u(n,mf,c),u(n,Js,c),s(Js,P_),s(Js,ho),s(ho,O_),s(Js,R_),u(n,vf,c),u(n,Ya,c),Ya.innerHTML=PM,u(n,_f,c),u(n,$a,c),$a.innerHTML=OM,u(n,yf,c),u(n,I,c),s(I,T_),s(I,go),s(go,S_),s(I,M_),s(I,nl),s(nl,I_),s(I,L_),s(I,sl),s(sl,H_),s(I,A_),s(I,al),s(al,G_),s(I,B_),s(I,tl),s(tl,x_),s(I,N_),u(n,bf,c),u(n,wf,c),u(n,Cf,c),u(n,Df,c),u(n,Xs,c),s(Xs,Zs),s(Zs,el),s(Xs,F_),u(n,Pf,c),u(n,Of,c),u(n,Rf,c),u(n,Ks,c),s(Ks,W_),s(Ks,pl),s(pl,U_),s(Ks,j_),u(n,Tf,c),u(n,qt,c),s(qt,z_),u(n,Sf,c),u(n,ha,c),ha.innerHTML=RM,u(n,Mf,c),u(n,b,c),s(b,ol),s(ol,q_),s(b,V_),s(b,ll),s(ll,J_),s(b,X_),s(b,cl),s(cl,Z_),s(b,K_),s(b,ul),s(ul,Q_),s(b,Y_),s(b,il),s(il,$_),s(b,h_),s(b,rl),s(rl,g_),s(b,n0),s(b,kl),s(kl,s0),s(b,a0),u(n,If,c),u(n,Lf,c),u(n,Hf,c),u(n,on,c),s(on,fl),s(fl,t0),s(on,e0),s(on,dl),s(dl,p0),s(on,o0),s(on,El),s(El,l0),s(on,c0),s(on,ml),s(ml,u0),s(on,i0),u(n,Af,c),u(n,L,c),s(L,r0),s(L,Vt),s(Vt,k0),s(L,f0),s(L,vl),s(vl,d0),s(L,E0),s(L,_l),s(_l,m0),s(L,v0),s(L,yl),s(yl,_0),s(L,y0),s(L,bl),s(bl,b0),s(L,w0),u(n,Gf,c),u(n,ga,c),s(ga,wl),s(wl,C0),s(ga,D0),u(n,Bf,c),u(n,xn,c),s(xn,P0),s(xn,Cl),s(Cl,O0),s(xn,R0),s(xn,Dl),s(Dl,T0),s(xn,S0),u(n,xf,c),u(n,Jt,c),s(Jt,M0),u(n,Nf,c),u(n,Xt,c),s(Xt,I0),u(n,Ff,c),u(n,Wf,c),u(n,Uf,c),u(n,Zt,c),s(Zt,L0),u(n,jf,c),u(n,Kt,c),s(Kt,H0),u(n,zf,c),u(n,nt,c),nt.innerHTML=TM,u(n,qf,c),u(n,f,c),s(f,Pl),s(Pl,A0),s(f,G0),s(f,Ol),s(Ol,B0),s(f,x0),s(f,Rl),s(Rl,N0),s(f,F0),s(f,Tl),s(Tl,W0),s(f,U0),s(f,Sl),s(Sl,j0),s(f,z0),s(f,Ml),s(Ml,q0),s(f,V0),s(f,Il),s(Il,J0),s(f,X0),s(f,Ll),s(Ll,Z0),s(f,K0),s(f,Hl),s(Hl,Q0),s(f,Y0),s(f,Al),s(Al,$0),s(f,h0),s(f,Gl),s(Gl,g0),s(f,n4),s(f,Bl),s(Bl,s4),s(f,a4),s(f,xl),s(xl,t4),s(f,e4),u(n,Vf,c),u(n,Jf,c),u(n,Xf,c),u(n,K,c),s(K,p4),s(K,Nl),s(Nl,o4),s(K,l4),s(K,Fl),s(Fl,c4),s(K,u4),s(K,Wl),s(Wl,i4),s(K,r4),s(K,Ul),s(Ul,k4),s(K,f4),u(n,Zf,c),u(n,Qt,c),s(Qt,d4),u(n,Kf,c),u(n,st,c),st.innerHTML=SM,u(n,Qf,c),u(n,Q,c),s(Q,E4),s(Q,jl),s(jl,m4),s(Q,v4),s(Q,zl),s(zl,_4),s(Q,y4),s(Q,ql),s(ql,b4),s(Q,w4),s(Q,Vl),s(Vl,C4),s(Q,D4),u(n,Yf,c),u(n,Nn,c),s(Nn,P4),s(Nn,Jl),s(Jl,O4),s(Nn,R4),s(Nn,Xl),s(Xl,T4),s(Nn,S4),u(n,$f,c),u(n,at,c),at.innerHTML=MM,u(n,hf,c),u(n,Yt,c),s(Yt,M4),u(n,gf,c),u(n,P,c),s(P,I4),s(P,Zl),s(Zl,L4),s(P,H4),s(P,Kl),s(Kl,A4),s(P,G4),s(P,Ql),s(Ql,B4),s(P,x4),s(P,Yl),s(Yl,N4),s(P,F4),s(P,$l),s($l,W4),s(P,U4),s(P,hl),s(hl,j4),s(P,z4),u(n,n1,c),u(n,Y,c),s(Y,q4),s(Y,gl),s(gl,V4),s(Y,J4),s(Y,nc),s(nc,X4),s(Y,Z4),s(Y,sc),s(sc,K4),s(Y,Q4),s(Y,ac),s(ac,Y4),s(Y,$4),u(n,s1,c),u(n,a1,c),u(n,t1,c),u(n,e1,c),u(n,Qs,c),s(Qs,Ys),s(Ys,tc),s(Qs,h4),u(n,p1,c),u(n,ln,c),s(ln,ec),s(ec,g4),s(ln,ny),s(ln,pc),s(pc,sy),s(ln,ay),s(ln,oc),s(oc,ty),s(ln,ey),s(ln,lc),s(lc,py),s(ln,oy),u(n,o1,c),u(n,tt,c),tt.innerHTML=IM,u(n,l1,c),u(n,c1,c),u(n,u1,c),u(n,i1,c),u(n,$s,c),s($s,hs),s(hs,cc),s($s,ly),u(n,r1,c),u(n,gs,c),s(gs,cy),s(gs,uc),s(uc,uy),s(gs,iy),u(n,k1,c),u(n,$t,c),s($t,ry),u(n,f1,c),u(n,ht,c),s(ht,ky),u(n,d1,c),u(n,gt,c),s(gt,fy),u(n,E1,c),u(n,Fn,c),s(Fn,dy),s(Fn,ic),s(ic,Ey),s(Fn,my),s(Fn,rc),s(rc,vy),s(Fn,_y),u(n,m1,c),u(n,ne,c),s(ne,yy),u(n,v1,c),u(n,se,c),s(se,by),u(n,_1,c),u(n,y1,c),u(n,b1,c),u(n,w1,c),u(n,na,c),s(na,sa),s(sa,kc),s(na,wy),u(n,C1,c),u(n,Wn,c),s(Wn,Cy),s(Wn,fc),s(fc,Dy),s(Wn,Py),s(Wn,dc),s(dc,Oy),s(Wn,Ry),u(n,D1,c),u(n,et,c),et.innerHTML=LM,u(n,P1,c),u(n,pt,c),pt.innerHTML=HM,u(n,O1,c),u(n,Un,c),s(Un,Ty),s(Un,Ec),s(Ec,Sy),s(Un,My),s(Un,mc),s(mc,Iy),s(Un,Ly),u(n,R1,c),u(n,O,c),s(O,Hy),s(O,vc),s(vc,Ay),s(O,Gy),s(O,_c),s(_c,By),s(O,xy),s(O,yc),s(yc,Ny),s(O,Fy),s(O,bc),s(bc,Wy),s(O,Uy),s(O,wc),s(wc,jy),s(O,zy),s(O,Cc),s(Cc,qy),s(O,Vy),u(n,T1,c),u(n,$,c),s($,Jy),s($,Dc),s(Dc,Xy),s($,Zy),s($,Pc),s(Pc,Ky),s($,Qy),s($,Oc),s(Oc,Yy),s($,$y),s($,Rc),s(Rc,hy),s($,gy),u(n,S1,c),u(n,M1,c),u(n,I1,c),u(n,L1,c),u(n,aa,c),s(aa,ta),s(ta,Tc),s(aa,n6),u(n,H1,c),u(n,ea,c),s(ea,s6),s(ea,Sc),s(Sc,a6),s(ea,t6),u(n,A1,c),u(n,ot,c),ot.innerHTML=AM,u(n,G1,c),u(n,jn,c),s(jn,e6),s(jn,Mc),s(Mc,p6),s(jn,o6),s(jn,Ic),s(Ic,l6),s(jn,c6),u(n,B1,c),u(n,x1,c),u(n,N1,c),u(n,ae,c),s(ae,u6),u(n,F1,c),u(n,lt,c),lt.innerHTML=GM,u(n,W1,c),u(n,pa,c),s(pa,i6),s(pa,Lc),s(Lc,r6),s(pa,k6),u(n,U1,c),u(n,j1,c),u(n,z1,c),u(n,yn,c),s(yn,f6),s(yn,Hc),s(Hc,d6),s(yn,E6),s(yn,Ac),s(Ac,m6),s(yn,v6),s(yn,Gc),s(Gc,_6),s(yn,y6),u(n,q1,c),u(n,ct,c),ct.innerHTML=BM,u(n,V1,c),u(n,te,c),s(te,b6),u(n,J1,c),u(n,bn,c),s(bn,w6),s(bn,Bc),s(Bc,C6),s(bn,D6),s(bn,xc),s(xc,P6),s(bn,O6),s(bn,Nc),s(Nc,R6),s(bn,T6),u(n,X1,c),u(n,Z1,c),u(n,K1,c),u(n,H,c),s(H,S6),s(H,Fc),s(Fc,M6),s(H,I6),s(H,Wc),s(Wc,L6),s(H,H6),s(H,Uc),s(Uc,A6),s(H,G6),s(H,jc),s(jc,B6),s(H,x6),s(H,zc),s(zc,N6),s(H,F6),u(n,Q1,c),u(n,Y1,c),u(n,$1,c),u(n,h1,c),u(n,oa,c),s(oa,la),s(la,qc),s(oa,W6),u(n,g1,c),u(n,ee,c),s(ee,U6),u(n,nd,c),u(n,ca,c),s(ca,j6),s(ca,Vc),s(Vc,z6),s(ca,q6),u(n,sd,c),u(n,ut,c),ut.innerHTML=xM,u(n,ad,c),u(n,A,c),s(A,V6),s(A,Jc),s(Jc,J6),s(A,X6),s(A,Xc),s(Xc,Z6),s(A,K6),s(A,Zc),s(Zc,Q6),s(A,Y6),s(A,Kc),s(Kc,$6),s(A,h6),s(A,Qc),s(Qc,g6),s(A,n7),u(n,td,c),u(n,ed,c),u(n,pd,c),u(n,zn,c),s(zn,s7),s(zn,Yc),s(Yc,a7),s(zn,t7),s(zn,$c),s($c,e7),s(zn,p7),u(n,od,c),u(n,it,c),it.innerHTML=NM,u(n,ld,c),u(n,cd,c),u(n,ud,c),u(n,cn,c),s(cn,hc),s(hc,o7),s(cn,l7),s(cn,gc),s(gc,c7),s(cn,u7),s(cn,nu),s(nu,i7),s(cn,r7),s(cn,su),s(su,k7),s(cn,f7),u(n,id,c),u(n,rt,c),rt.innerHTML=FM,u(n,rd,c),u(n,kd,c),u(n,fd,c),u(n,Es,c),s(Es,au),s(au,d7),s(Es,E7),s(Es,tu),s(tu,m7),s(Es,v7),u(n,dd,c),u(n,kt,c),kt.innerHTML=WM,u(n,Ed,c),u(n,w,c),s(w,eu),s(eu,_7),s(w,y7),s(w,pu),s(pu,b7),s(w,w7),s(w,ou),s(ou,C7),s(w,D7),s(w,lu),s(lu,P7),s(w,O7),s(w,R7),s(w,T7),s(w,cu),s(cu,S7),s(w,M7),s(w,uu),s(uu,I7),s(w,L7),u(n,md,c),u(n,qn,c),s(qn,H7),s(qn,iu),s(iu,A7),s(qn,G7),s(qn,ru),s(ru,B7),s(qn,x7),u(n,vd,c),u(n,ua,c),s(ua,N7),s(ua,ku),s(ku,F7),s(ua,W7),u(n,_d,c),u(n,yd,c),u(n,bd,c),u(n,wd,c),u(n,ia,c),s(ia,U7),s(ia,fu),s(fu,j7),s(ia,z7),u(n,Cd,c),u(n,ft,c),ft.innerHTML=UM,u(n,Dd,c),u(n,dt,c),dt.innerHTML=jM,u(n,Pd,c),u(n,Vn,c),s(Vn,q7),s(Vn,du),s(du,V7),s(Vn,J7),s(Vn,Eu),s(Eu,X7),s(Vn,Z7),u(n,Od,c),u(n,_,c),s(_,K7),s(_,mu),s(mu,Q7),s(_,Y7),s(_,vu),s(vu,$7),s(_,h7),s(_,_u),s(_u,g7),s(_,n8),s(_,yu),s(yu,s8),s(_,a8),s(_,bu),s(bu,t8),s(_,e8),s(_,wu),s(wu,p8),s(_,o8),s(_,Cu),s(Cu,l8),s(_,c8),u(n,Rd,c),u(n,ra,c),s(ra,u8),s(ra,Du),s(Du,i8),s(ra,r8),u(n,Td,c),u(n,un,c),s(un,Pu),s(Pu,k8),s(un,f8),s(un,Ou),s(Ou,d8),s(un,E8),s(un,Ru),s(Ru,m8),s(un,v8),s(un,Tu),s(Tu,_8),s(un,y8),u(n,Sd,c),u(n,Md,c),u(n,Id,c),u(n,ms,c),s(ms,Su),s(Su,b8),s(ms,w8),s(ms,Mu),s(Mu,C8),s(ms,D8),u(n,Ld,c),u(n,G,c),s(G,P8),s(G,Iu),s(Iu,O8),s(G,R8),s(G,Lu),s(Lu,T8),s(G,S8),s(G,Hu),s(Hu,M8),s(G,I8),s(G,Au),s(Au,L8),s(G,H8),s(G,Gu),s(Gu,A8),s(G,G8),u(n,Hd,c),u(n,m,c),s(m,Bu),s(Bu,B8),s(m,x8),s(m,xu),s(xu,N8),s(m,F8),s(m,Nu),s(Nu,W8),s(m,U8),s(m,Fu),s(Fu,j8),s(m,z8),s(m,Wu),s(Wu,q8),s(m,V8),s(m,Uu),s(Uu,J8),s(m,X8),s(m,ju),s(ju,Z8),s(m,K8),s(m,zu),s(zu,Q8),s(m,Y8),u(n,Ad,c),u(n,Et,c),Et.innerHTML=zM,u(n,Gd,c),u(n,Bd,c),u(n,xd,c),u(n,Jn,c),s(Jn,$8),s(Jn,qu),s(qu,h8),s(Jn,g8),s(Jn,Vu),s(Vu,n9),s(Jn,s9),u(n,Nd,c),u(n,R,c),s(R,a9),s(R,Ju),s(Ju,t9),s(R,e9),s(R,Xu),s(Xu,p9),s(R,o9),s(R,Zu),s(Zu,l9),s(R,c9),s(R,Ku),s(Ku,u9),s(R,i9),s(R,Qu),s(Qu,r9),s(R,k9),s(R,Yu),s(Yu,f9),s(R,d9),u(n,Fd,c),u(n,mt,c),mt.innerHTML=qM,u(n,Wd,c),u(n,Ud,c),u(n,jd,c),u(n,Xn,c),s(Xn,E9),s(Xn,$u),s($u,m9),s(Xn,v9),s(Xn,hu),s(hu,_9),s(Xn,y9),u(n,zd,c),u(n,T,c),s(T,b9),s(T,gu),s(gu,w9),s(T,C9),s(T,ni),s(ni,D9),s(T,P9),s(T,si),s(si,O9),s(T,R9),s(T,ai),s(ai,T9),s(T,S9),s(T,ti),s(ti,M9),s(T,I9),s(T,ei),s(ei,L9),s(T,H9),u(n,qd,c),u(n,h,c),s(h,A9),s(h,pi),s(pi,G9),s(h,B9),s(h,oi),s(oi,x9),s(h,N9),s(h,li),s(li,F9),s(h,W9),s(h,ci),s(ci,U9),s(h,j9),u(n,Vd,c),u(n,Jd,c),u(n,Xd,c),u(n,vt,c),s(vt,ui),s(ui,z9),s(vt,q9),u(n,Zd,c),u(n,g,c),s(g,V9),s(g,ii),s(ii,J9),s(g,X9),s(g,ri),s(ri,Z9),s(g,K9),s(g,ki),s(ki,Q9),s(g,Y9),s(g,fi),s(fi,$9),s(g,h9),u(n,Kd,c),u(n,Qd,c),u(n,Yd,c),u(n,$d,c),u(n,ka,c),s(ka,fa),s(fa,di),s(ka,g9),u(n,hd,c),u(n,pe,c),s(pe,nb),u(n,gd,c),u(n,oe,c),s(oe,sb),u(n,nE,c),u(n,_t,c),_t.innerHTML=VM,u(n,sE,c),u(n,F,c),s(F,Ei),s(Ei,ab),s(F,tb),s(F,mi),s(mi,eb),s(F,pb),s(F,vi),s(vi,ob),s(F,lb),s(F,_i),s(_i,cb),s(F,ub),s(F,yi),s(yi,ib),s(F,rb),u(n,aE,c),u(n,yt,c),yt.innerHTML=JM,u(n,tE,c),u(n,da,c),s(da,kb),s(da,bi),s(bi,fb),s(da,db),u(n,eE,c),u(n,pE,c),u(n,oE,c),u(n,le,c),s(le,Eb),u(n,lE,c),u(n,Zn,c),s(Zn,mb),s(Zn,wi),s(wi,vb),s(Zn,_b),s(Zn,Ci),s(Ci,yb),s(Zn,bb),u(n,cE,c),u(n,uE,c),u(n,iE,c),u(n,rE,c),u(n,Ea,c),s(Ea,ma),s(ma,Di),s(Ea,wb),u(n,kE,c),u(n,bt,c),s(bt,Pi),s(Pi,Cb),s(bt,Db),u(n,fE,c),u(n,ce,c),s(ce,Pb),u(n,dE,c),u(n,wt,c),wt.innerHTML=XM,u(n,EE,c),u(n,va,c),s(va,Ob),s(va,Oi),s(Oi,Rb),s(va,Tb),u(n,mE,c),u(n,Ct,c),Ct.innerHTML=ZM,u(n,vE,c),u(n,_E,c),u(n,yE,c),u(n,Kn,c),s(Kn,Sb),s(Kn,Ri),s(Ri,Mb),s(Kn,Ib),s(Kn,Ti),s(Ti,Lb),s(Kn,Hb),u(n,bE,c),u(n,ue,c),s(ue,Ab),u(n,wE,c),u(n,Dt,c),Dt.innerHTML=KM,u(n,CE,c),u(n,Tn,c),s(Tn,Si),s(Si,Gb),s(Tn,Bb),s(Tn,Mi),s(Mi,xb),s(Tn,Nb),s(Tn,Ii),s(Ii,Fb),s(Tn,Wb),u(n,DE,c),u(n,ie,c),s(ie,Ub),u(n,PE,c),u(n,Pt,c),Pt.innerHTML=QM,u(n,OE,c),u(n,W,c),s(W,Li),s(Li,jb),s(W,zb),s(W,Hi),s(Hi,qb),s(W,Vb),s(W,Ai),s(Ai,Jb),s(W,Xb),s(W,Gi),s(Gi,Zb),s(W,Kb),s(W,Bi),s(Bi,Qb),s(W,Yb),u(n,RE,c),u(n,TE,c),u(n,SE,c),u(n,Qn,c),s(Qn,$b),s(Qn,xi),s(xi,hb),s(Qn,gb),s(Qn,Ni),s(Ni,nw),s(Qn,sw),u(n,ME,c),u(n,Ot,c),Ot.innerHTML=YM,u(n,IE,c),u(n,Yn,c),s(Yn,aw),s(Yn,Fi),s(Fi,tw),s(Yn,ew),s(Yn,Wi),s(Wi,pw),s(Yn,ow),u(n,LE,c),u(n,Rt,c),Rt.innerHTML=$M,u(n,HE,c),u(n,AE,c),u(n,GE,c),u(n,_a,c),s(_a,lw),s(_a,Ui),s(Ui,cw),s(_a,uw),u(n,BE,c),u(n,Tt,c),Tt.innerHTML=hM,u(n,xE,c),u(n,$n,c),s($n,iw),s($n,ji),s(ji,rw),s($n,kw),s($n,zi),s(zi,fw),s($n,dw),u(n,NE,c),u(n,S,c),s(S,qi),s(qi,Ew),s(S,mw),s(S,Vi),s(Vi,vw),s(S,_w),s(S,Ji),s(Ji,yw),s(S,bw),s(S,Xi),s(Xi,ww),s(S,Cw),s(S,Zi),s(Zi,Dw),s(S,Pw),s(S,Ki),s(Ki,Ow),s(S,Rw),u(n,FE,c),u(n,vs,c),s(vs,Qi),s(Qi,Tw),s(vs,Sw),s(vs,Yi),s(Yi,Mw),s(vs,Iw),u(n,WE,c),u(n,re,c),s(re,Lw),u(n,UE,c),u(n,jE,c),u(n,zE,c),u(n,ya,c),s(ya,Hw),s(ya,St),s(St,Aw),s(ya,Gw),u(n,qE,c),u(n,VE,c),u(n,JE,c),u(n,XE,c),u(n,ba,c),s(ba,wa),s(wa,$i),s(ba,Bw),u(n,ZE,c),u(n,ke,c),s(ke,xw),u(n,KE,c),u(n,QE,c),u(n,YE,c),u(n,$E,c),u(n,Ca,c),s(Ca,Da),s(Da,hi),s(Ca,Nw),u(n,hE,c),u(n,gE,c),u(n,n2,c),u(n,fe,c),s(fe,_s),s(_s,Mt),s(Mt,de),s(_s,Fw),s(_s,Ww),s(_s,Uw),s(_s,It),s(It,jw),u(n,s2,c),u(n,a2,c),u(n,t2,c),u(n,Ee,c),s(Ee,zw),u(n,e2,c),u(n,me,c),s(me,qw),u(n,p2,c),u(n,o2,c),u(n,l2,c)},p:rC,i:rC,o:rC,d(n){n&&a(At),n&&a(pr),n&&a(Gt),n&&a(or),n&&a(lr),n&&a(cr),n&&a(ur),n&&a(Ps),n&&a(ir),n&&a(rr),n&&a(kr),n&&a(Rs),n&&a(fr),n&&a(Aa),n&&a(dr),n&&a(Bt),n&&a(Er),n&&a(mr),n&&a(vr),n&&a(kn),n&&a(_r),n&&a(Ln),n&&a(yr),n&&a(Ts),n&&a(br),n&&a(wr),n&&a(Cr),n&&a(Dr),n&&a(Ss),n&&a(Pr),n&&a(xt),n&&a(Or),n&&a(Ga),n&&a(Rr),n&&a(Is),n&&a(Tr),n&&a(q),n&&a(Sr),n&&a(Ba),n&&a(Mr),n&&a(Ir),n&&a(Lr),n&&a(Hr),n&&a(Ls),n&&a(Ar),n&&a(Hn),n&&a(Gr),n&&a(xa),n&&a(Br),n&&a(Na),n&&a(xr),n&&a(V),n&&a(Nr),n&&a(Fr),n&&a(Wr),n&&a(Fa),n&&a(Ur),n&&a(us),n&&a(jr),n&&a(zr),n&&a(qr),n&&a(D),n&&a(Vr),n&&a(J),n&&a(Jr),n&&a(As),n&&a(Xr),n&&a(Zr),n&&a(Kr),n&&a(Qr),n&&a(Gs),n&&a(Yr),n&&a($r),n&&a(hr),n&&a(fn),n&&a(gr),n&&a(Wa),n&&a(nk),n&&a(Nt),n&&a(sk),n&&a(Ft),n&&a(ak),n&&a(tk),n&&a(ek),n&&a(pk),n&&a(xs),n&&a(ok),n&&a(dn),n&&a(lk),n&&a(Ua),n&&a(ck),n&&a(An),n&&a(uk),n&&a(Rn),n&&a(ik),n&&a(rk),n&&a(kk),n&&a(ja),n&&a(fk),n&&a(En),n&&a(dk),n&&a(za),n&&a(Ek),n&&a(mk),n&&a(vk),n&&a(Wt),n&&a(_k),n&&a(qa),n&&a(yk),n&&a(E),n&&a(bk),n&&a(Ut),n&&a(wk),n&&a(Va),n&&a(Ck),n&&a(Dk),n&&a(Pk),n&&a(mn),n&&a(Ok),n&&a(Rk),n&&a(Tk),n&&a(Sk),n&&a(fs),n&&a(Mk),n&&a(v),n&&a(Ik),n&&a(Ja),n&&a(Lk),n&&a(Fs),n&&a(Hk),n&&a(pn),n&&a(Ak),n&&a(Gk),n&&a(Bk),n&&a(xk),n&&a(Ws),n&&a(Nk),n&&a(jt),n&&a(Fk),n&&a(Xa),n&&a(Wk),n&&a(vn),n&&a(Uk),n&&a(N),n&&a(jk),n&&a(X),n&&a(zk),n&&a(js),n&&a(qk),n&&a(Vk),n&&a(Jk),n&&a(Xk),n&&a(zs),n&&a(Zk),n&&a(Kk),n&&a(Qk),n&&a(Gn),n&&a(Yk),n&&a(zt),n&&a($k),n&&a(Za),n&&a(hk),n&&a(y),n&&a(gk),n&&a(nf),n&&a(sf),n&&a(Ka),n&&a(af),n&&a(Vs),n&&a(tf),n&&a(_n),n&&a(ef),n&&a(pf),n&&a(of),n&&a(lf),n&&a(ds),n&&a(cf),n&&a(uf),n&&a(rf),n&&a(Bn),n&&a(kf),n&&a(Qa),n&&a(ff),n&&a(Z),n&&a(df),n&&a(Ef),n&&a(mf),n&&a(Js),n&&a(vf),n&&a(Ya),n&&a(_f),n&&a($a),n&&a(yf),n&&a(I),n&&a(bf),n&&a(wf),n&&a(Cf),n&&a(Df),n&&a(Xs),n&&a(Pf),n&&a(Of),n&&a(Rf),n&&a(Ks),n&&a(Tf),n&&a(qt),n&&a(Sf),n&&a(ha),n&&a(Mf),n&&a(b),n&&a(If),n&&a(Lf),n&&a(Hf),n&&a(on),n&&a(Af),n&&a(L),n&&a(Gf),n&&a(ga),n&&a(Bf),n&&a(xn),n&&a(xf),n&&a(Jt),n&&a(Nf),n&&a(Xt),n&&a(Ff),n&&a(Wf),n&&a(Uf),n&&a(Zt),n&&a(jf),n&&a(Kt),n&&a(zf),n&&a(nt),n&&a(qf),n&&a(f),n&&a(Vf),n&&a(Jf),n&&a(Xf),n&&a(K),n&&a(Zf),n&&a(Qt),n&&a(Kf),n&&a(st),n&&a(Qf),n&&a(Q),n&&a(Yf),n&&a(Nn),n&&a($f),n&&a(at),n&&a(hf),n&&a(Yt),n&&a(gf),n&&a(P),n&&a(n1),n&&a(Y),n&&a(s1),n&&a(a1),n&&a(t1),n&&a(e1),n&&a(Qs),n&&a(p1),n&&a(ln),n&&a(o1),n&&a(tt),n&&a(l1),n&&a(c1),n&&a(u1),n&&a(i1),n&&a($s),n&&a(r1),n&&a(gs),n&&a(k1),n&&a($t),n&&a(f1),n&&a(ht),n&&a(d1),n&&a(gt),n&&a(E1),n&&a(Fn),n&&a(m1),n&&a(ne),n&&a(v1),n&&a(se),n&&a(_1),n&&a(y1),n&&a(b1),n&&a(w1),n&&a(na),n&&a(C1),n&&a(Wn),n&&a(D1),n&&a(et),n&&a(P1),n&&a(pt),n&&a(O1),n&&a(Un),n&&a(R1),n&&a(O),n&&a(T1),n&&a($),n&&a(S1),n&&a(M1),n&&a(I1),n&&a(L1),n&&a(aa),n&&a(H1),n&&a(ea),n&&a(A1),n&&a(ot),n&&a(G1),n&&a(jn),n&&a(B1),n&&a(x1),n&&a(N1),n&&a(ae),n&&a(F1),n&&a(lt),n&&a(W1),n&&a(pa),n&&a(U1),n&&a(j1),n&&a(z1),n&&a(yn),n&&a(q1),n&&a(ct),n&&a(V1),n&&a(te),n&&a(J1),n&&a(bn),n&&a(X1),n&&a(Z1),n&&a(K1),n&&a(H),n&&a(Q1),n&&a(Y1),n&&a($1),n&&a(h1),n&&a(oa),n&&a(g1),n&&a(ee),n&&a(nd),n&&a(ca),n&&a(sd),n&&a(ut),n&&a(ad),n&&a(A),n&&a(td),n&&a(ed),n&&a(pd),n&&a(zn),n&&a(od),n&&a(it),n&&a(ld),n&&a(cd),n&&a(ud),n&&a(cn),n&&a(id),n&&a(rt),n&&a(rd),n&&a(kd),n&&a(fd),n&&a(Es),n&&a(dd),n&&a(kt),n&&a(Ed),n&&a(w),n&&a(md),n&&a(qn),n&&a(vd),n&&a(ua),n&&a(_d),n&&a(yd),n&&a(bd),n&&a(wd),n&&a(ia),n&&a(Cd),n&&a(ft),n&&a(Dd),n&&a(dt),n&&a(Pd),n&&a(Vn),n&&a(Od),n&&a(_),n&&a(Rd),n&&a(ra),n&&a(Td),n&&a(un),n&&a(Sd),n&&a(Md),n&&a(Id),n&&a(ms),n&&a(Ld),n&&a(G),n&&a(Hd),n&&a(m),n&&a(Ad),n&&a(Et),n&&a(Gd),n&&a(Bd),n&&a(xd),n&&a(Jn),n&&a(Nd),n&&a(R),n&&a(Fd),n&&a(mt),n&&a(Wd),n&&a(Ud),n&&a(jd),n&&a(Xn),n&&a(zd),n&&a(T),n&&a(qd),n&&a(h),n&&a(Vd),n&&a(Jd),n&&a(Xd),n&&a(vt),n&&a(Zd),n&&a(g),n&&a(Kd),n&&a(Qd),n&&a(Yd),n&&a($d),n&&a(ka),n&&a(hd),n&&a(pe),n&&a(gd),n&&a(oe),n&&a(nE),n&&a(_t),n&&a(sE),n&&a(F),n&&a(aE),n&&a(yt),n&&a(tE),n&&a(da),n&&a(eE),n&&a(pE),n&&a(oE),n&&a(le),n&&a(lE),n&&a(Zn),n&&a(cE),n&&a(uE),n&&a(iE),n&&a(rE),n&&a(Ea),n&&a(kE),n&&a(bt),n&&a(fE),n&&a(ce),n&&a(dE),n&&a(wt),n&&a(EE),n&&a(va),n&&a(mE),n&&a(Ct),n&&a(vE),n&&a(_E),n&&a(yE),n&&a(Kn),n&&a(bE),n&&a(ue),n&&a(wE),n&&a(Dt),n&&a(CE),n&&a(Tn),n&&a(DE),n&&a(ie),n&&a(PE),n&&a(Pt),n&&a(OE),n&&a(W),n&&a(RE),n&&a(TE),n&&a(SE),n&&a(Qn),n&&a(ME),n&&a(Ot),n&&a(IE),n&&a(Yn),n&&a(LE),n&&a(Rt),n&&a(HE),n&&a(AE),n&&a(GE),n&&a(_a),n&&a(BE),n&&a(Tt),n&&a(xE),n&&a($n),n&&a(NE),n&&a(S),n&&a(FE),n&&a(vs),n&&a(WE),n&&a(re),n&&a(UE),n&&a(jE),n&&a(zE),n&&a(ya),n&&a(qE),n&&a(VE),n&&a(JE),n&&a(XE),n&&a(ba),n&&a(ZE),n&&a(ke),n&&a(KE),n&&a(QE),n&&a(YE),n&&a($E),n&&a(Ca),n&&a(hE),n&&a(gE),n&&a(n2),n&&a(fe),n&&a(s2),n&&a(a2),n&&a(t2),n&&a(Ee),n&&a(e2),n&&a(me),n&&a(p2),n&&a(o2),n&&a(l2)}}}const $I={title:"타입, 메소드, 인터페이스",date:"2022-08-11T00:00:00.000Z",excerpt:"Types, Methods, Interfaces",categories:["Golang","Basic Golang"],coverImage:"/post_img/Go/Golang_basics/cover.png",coverWidth:16,coverHeight:9,indexed:!0,exposed:!0};class hI extends VI{constructor(At){super(),JI(this,At,null,QI,XI,{})}}export{hI as default,$I as metadata};
