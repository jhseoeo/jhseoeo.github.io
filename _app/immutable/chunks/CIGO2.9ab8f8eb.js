import{S as Tf,i as $f,s as Vf,k as a,q as s,a as i,y as qf,l as o,m as n,r,h as l,c,z as jf,n as f,U as zf,b as p,E as e,A as Ff,g as Kf,d as Qf,B as Zf}from"./index.d78780bf.js";import{H as Jf}from"./Highlight.1019e7a6.js";function Xf(Mn){let d;return{c(){d=s("Mutual Exclusion")},l(W){d=r(W,"Mutual Exclusion")},m(W,w){p(W,d,w)},d(W){W&&l(d)}}}function Yf(Mn){let d,W,w,Wn,wn,lo,ll,Dn,to,ao,oo,no,z,F,Tl,An,so,ro,io,K,Q,$l,Bn,co,m,Me,Vl,Hn,Nn,h,ql,Tn,$n,jl,Vn,qn,zl,jn,zn,Fl,Fn,Kn,Kl,Qn,Zn,We,Ql,Jn,Xn,Zl,Jl,Yn,gn,we,Xl,es,ls,Yl,gl,ts,uo,Z,J,et,as,po,I,lt,tt,os,ns,De,at,ss,rs,Ae,D,is,ot,cs,us,nt,ps,fs,ds,st,hs,Es,Be,rt,vs,_s,He,it,ks,Ls,tl,ct,bs,Cs,fo,X,Y,ut,ms,ho,al,ol,Is,pt,nl,xs,ft,dt,Rs,Eo,vo,_o,ko,g,ee,ht,Ss,Lo,bo,Co,le,te,Et,ys,mo,x,vt,_t,Ps,Gs,kt,Lt,Os,Us,k,bt,Ms,Ws,Ct,mt,ws,Ds,sl,wf=`<code class="language-go"><span class="token keyword">if</span> <span class="token function">len</span><span class="token punctuation">(</span>ch<span class="token punctuation">)</span> <span class="token operator">></span> <span class="token number">0</span> <span class="token punctuation">&#123;</span>
  x <span class="token operator">:=</span> <span class="token operator">&lt;-</span>ch
<span class="token punctuation">&#125;</span></code>`,As,A,It,Bs,Hs,xt,Ns,Ts,Rt,$s,Io,ae,oe,St,Vs,xo,v,rl,qs,yt,Pt,js,zs,ne,Fs,Gt,Ks,Qs,Ot,Ut,Zs,Js,il,Xs,Mt,Wt,Ys,gs,wt,er,Ro,se,re,Dt,lr,So,ie,B,tr,At,ar,or,Bt,nr,sr,rr,R,ir,Ht,cr,ur,Nt,pr,fr,Ne,cl,dr,Te,Tt,hr,Er,$t,vr,_r,ul,kr,Vt,qt,Lr,yo,ce,ue,jt,br,Po,S,$e,zt,Cr,mr,Ve,Ft,Ir,xr,Kt,Rr,Sr,L,pe,Qt,yr,Pr,Zt,Gr,Or,Ur,qe,Jt,Mr,Wr,je,wr,Xt,Dr,Ar,Br,pl,Df=`<code class="language-go"><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
  <span class="token keyword">var</span> i <span class="token builtin">int</span>
  f <span class="token operator">:=</span> <span class="token keyword">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    i<span class="token operator">++</span>
    <span class="token keyword">return</span> i
  <span class="token punctuation">&#125;</span>
  ch1 <span class="token operator">:=</span> <span class="token function">make</span><span class="token punctuation">(</span><span class="token keyword">chan</span> <span class="token builtin">int</span><span class="token punctuation">)</span>
  ch2 <span class="token operator">:=</span> <span class="token function">make</span><span class="token punctuation">(</span><span class="token keyword">chan</span> <span class="token builtin">int</span><span class="token punctuation">)</span>

  <span class="token keyword">select</span> <span class="token punctuation">&#123;</span>
  <span class="token keyword">case</span> ch1 <span class="token operator">&lt;-</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
  <span class="token keyword">case</span> ch2 <span class="token operator">&lt;-</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
  <span class="token keyword">default</span><span class="token punctuation">:</span>
  <span class="token punctuation">&#125;</span>
  fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span>
<span class="token punctuation">&#125;</span></code>`,Hr,ze,_,Yt,Nr,Tr,gt,$r,Vr,ea,qr,jr,la,zr,Fr,Kr,ta,Qr,Zr,H,fe,aa,Jr,Xr,oa,Yr,gr,ei,fl,Af=`<code class="language-go">ch1 <span class="token operator">:=</span> <span class="token function">make</span><span class="token punctuation">(</span><span class="token keyword">chan</span> <span class="token builtin">int</span><span class="token punctuation">)</span>
ch2 <span class="token operator">:=</span> <span class="token function">make</span><span class="token punctuation">(</span><span class="token keyword">chan</span> <span class="token builtin">int</span><span class="token punctuation">)</span>

<span class="token keyword">go</span> <span class="token keyword">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
  ch2 <span class="token operator">&lt;-</span> <span class="token number">1</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token keyword">go</span> <span class="token keyword">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
  fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token operator">&lt;-</span>ch1<span class="token punctuation">)</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">(</span><span class="token punctuation">)</span>

<span class="token keyword">select</span> <span class="token punctuation">&#123;</span>
<span class="token keyword">case</span> ch1<span class="token operator">&lt;-</span> <span class="token operator">&lt;-</span>ch2<span class="token punctuation">:</span>
  time<span class="token punctuation">.</span><span class="token function">Sleep</span><span class="token punctuation">(</span>time<span class="token punctuation">.</span>Second<span class="token punctuation">)</span>
<span class="token keyword">default</span><span class="token punctuation">:</span>
<span class="token punctuation">&#125;</span></code>`,li,b,C,ti,na,ai,oi,sa,ni,si,ra,ri,ii,ci,N,ui,ia,pi,fi,ca,di,hi,Ei,E,vi,ua,_i,ki,pa,Li,bi,fa,Ci,mi,da,Ii,xi,Ri,ha,Si,Go,Oo,Uo,Mo,de,he,Ea,yi,Wo,wo,Do,y,Fe,Pi,Ee,Gi,Oi,T,Ui,va,Mi,Wi,_a,wi,Di,Ai,dl,Bi,ka,La,Hi,Ao,ve,_e,ba,Ni,Bo,P,Ca,Ti,$i,hl,Vi,ma,Ia,qi,ji,El,zi,Ke,xa,Fi,Ki,Ra,Qi,Ho,No,To,$o,ke,Le,Sa,Zi,Vo,qo,jo,G,ya,Ji,Xi,Pa,Yi,gi,vl,ec,Qe,Ze,lc,Ga,tc,ac,oc,_l,Oa,nc,sc,zo,Fo,Ko,Qo,be,Ce,Ua,rc,Zo,Jo,Xo,O,Ma,ic,cc,Wa,uc,pc,wa,fc,Yo,me,Da,Aa,dc,hc,$,Ba,Ec,vc,Ha,_c,kc,kl,Lc,Na,Ta,bc,go,Ie,Je,$a,Cc,mc,V,Ll,Va,Ic,xc,Rc,bl,qa,Sc,yc,Pc,xe,ja,Gc,Oc,za,Uc,Mc,Wc,Xe,Fa,wc,Dc,Ka,Qa,Ac,en,ln,tn,an,Re,Se,Za,Bc,on,nn,sn,Cl,q,Ye,ml,_u,Hc,Nc,Tc,ge,$c,rn;return Ee=new Jf({props:{$$slots:{default:[Xf]},$$scope:{ctx:Mn}}}),{c(){d=a("p"),W=s("내용의 상당 부분이 "),w=a("a"),Wn=s("https://jhseoeo.github.io/posts/post/Go/Golang%20Basics/GO10"),wn=s("의 내용과 중복되므로, 해당 포스트를 먼저 읽고 오시는 것을 추천드립니다."),lo=i(),ll=a("p"),Dn=s("해당 포스트에서 다루지 않은 내용만 중점적으로 다루려 합니다."),to=i(),ao=a("br"),oo=a("br"),no=i(),z=a("h2"),F=a("a"),Tl=a("span"),An=s("Goroutine"),so=i(),ro=a("hr"),io=i(),K=a("h3"),Q=a("a"),$l=a("span"),Bn=s("Goroutine이 빠른 이유"),co=i(),m=a("ul"),Me=a("li"),Vl=a("p"),Hn=s("Go 런타임은 실행될 때 기본적으로 플랫폼의 프로세서(코어) 수만큼의 쓰레드를 생성함"),Nn=i(),h=a("ul"),ql=a("li"),Tn=s("이 쓰레드 풀 위에서 Goroutine이 실행됨"),$n=i(),jl=a("li"),Vn=s("만약 그 이하의 쓰레드를 생성하면 CPU utilization이 떨어짐"),qn=i(),zl=a("li"),jn=s("만약 그 이상의 쓰레드를 생성하면 Time Sharing때문에 Context Switching 오버헤드가 발생"),zn=i(),Fl=a("li"),Fn=s("만일 고루틴이 Channel, Mutex 등에 의해 block되면 해당 고루틴을 실행시키는 쓰레드는 다른 고루틴을 실행시킴"),Kn=i(),Kl=a("li"),Qn=s("만일 고루틴이 동기 I/O에 의해 block되면 해당 고루틴을 실행시키는 쓰레드 자체가 block되므로, 새로운 쓰레드를 생성하거나 기존의 쓰레드를 재사용하여 다른 고루틴을 실행시킴"),Zn=i(),We=a("li"),Ql=a("p"),Jn=s("Go Scheduler는 user space에 있기 때문에 OS Thread를 사용하는 것보다 오버헤드가 적음"),Xn=i(),Zl=a("ul"),Jl=a("li"),Yn=s("따라서 쓰레드 생성 및 관리에 대한 오버헤드가 적음"),gn=i(),we=a("li"),Xl=a("p"),es=s("Goroutine은 OS Thread보다 훨씬 적은 메모리를 사용함"),ls=i(),Yl=a("ul"),gl=a("li"),ts=s("Goroutine의 Stack 크기는 2KB 정도인 반면, OS Thread의 Stack 크기는 MB 단위임"),uo=i(),Z=a("h3"),J=a("a"),et=a("span"),as=s("Goroutine의 특징"),po=i(),I=a("ul"),lt=a("li"),tt=a("p"),os=s("OS Thread는 스케줄링 우선순위가 존재하지만, Goroutine은 존재하지 않음(Starvation이 발생하는 고루틴을 우선 선택하는 스케줄링 알고리즘이 있긴 하지만, 이를 지향하지는 않음)"),ns=i(),De=a("li"),at=a("p"),ss=s("Go 프로그램을 실행시키면 main 고루틴과 가비지 컬렉터 고루틴이 생성됨"),rs=i(),Ae=a("ul"),D=a("li"),is=s("main 고루틴은 "),ot=a("code"),cs=s("main"),us=s(" 패키지의 "),nt=a("code"),ps=s("main"),fs=s(" 함수에서 생성됨"),ds=i(),st=a("li"),hs=s("main 함수가 종료되면 모든 고루틴이 종료되고 프로그램이 종료됨"),Es=i(),Be=a("li"),rt=a("p"),vs=s("Goroutine을 일시정지 혹은 종료시키는 magic function은 없음"),_s=i(),He=a("ul"),it=a("li"),ks=s("고루틴이 중단되어야 함을 정의하는 message 또는 flag를 사용하는 것이 일반적"),Ls=i(),tl=a("li"),ct=a("code"),bs=s("panic"),Cs=s("은 고루틴을 종료시킬 수 있음. panic이 발생한 해당 고루틴이 종료됨"),fo=i(),X=a("h3"),Y=a("a"),ut=a("span"),ms=s("Closure"),ho=i(),al=a("ul"),ol=a("li"),Is=s("어떤 익명 함수가 그 함수 내부 컨텍스트에 있는 변수를 참조하면, 그 익명 함수를 클로저(Closure)라고 함"),pt=a("ul"),nl=a("li"),xs=s("클로저가 참조하는 로컬 변수는 stack에서 heap으로 옮겨짐(escape to heap)"),ft=a("ul"),dt=a("li"),Rs=s("stack에 저장되면 함수가 종료되면서 로컬 변수가 사라지기 때문"),Eo=i(),vo=a("br"),_o=a("br"),ko=i(),g=a("h2"),ee=a("a"),ht=a("span"),Ss=s("Channel"),Lo=i(),bo=a("hr"),Co=i(),le=a("h3"),te=a("a"),Et=a("span"),ys=s("Channel의 length와 capacity"),mo=i(),x=a("ul"),vt=a("li"),_t=a("p"),Ps=s("Channel은 내부적으로 FIFO 큐로 구현되어 있음"),Gs=i(),kt=a("li"),Lt=a("p"),Os=s("Channel의 capacity는 채널 버퍼의 크기를 의미함"),Us=i(),k=a("li"),bt=a("p"),Ms=s("Channel의 length는 현재 큐에 들어있는 element의 개수를 의미함"),Ws=i(),Ct=a("ul"),mt=a("li"),ws=s("아래와 같은 코드는 좋지 않음"),Ds=i(),sl=a("pre"),As=i(),A=a("ul"),It=a("li"),Bs=s("이 코드는 ch에 element가 들어있는지 확인한 후, 들어있다면 element를 읽어옴"),Hs=i(),xt=a("li"),Ns=s("이 때 length를 가져오는 것은 데이터를 읽어오는 것과는 달리 mutual exclusive하지 않음"),Ts=i(),Rt=a("li"),$s=s("따라서 데이터를 읽어오려고 할 때 채널의 값을 다른 고루틴이 이미 읽어버리는 race condition이 발생할 수도 있음"),Io=i(),ae=a("h3"),oe=a("a"),St=a("span"),Vs=s("Channel의 close"),xo=i(),v=a("ul"),rl=a("li"),qs=s("원래 채널은 1:1 통신만 가능함."),yt=a("ul"),Pt=a("li"),js=s("채널에서 데이터를 읽는 고루틴이 여러 개이고 데이터를 쓰는 고루틴이 하나라면, 쓰기 고루틴이 데이터를 쓸 때 무작위로 읽기 고루틴 중 하나에게 데이터를 전송함"),zs=i(),ne=a("li"),Fs=s("하지만 채널을 "),Gt=a("code"),Ks=s("close"),Qs=s("하면 해당 채널을 receive하는 모든 고루틴이 이를 감지할 수 있음"),Ot=a("ul"),Ut=a("li"),Zs=s("일종의 일회성 Broadcast인 셈"),Js=i(),il=a("li"),Xs=s("닫힌 채널로부터 데이터를 읽어오면 해당 타입의 zero value를 읽어옴"),Mt=a("ul"),Wt=a("li"),Ys=s("comma ok idiom을 사용하면 닫힌 채널인지 확인할 수 있음"),gs=i(),wt=a("li"),er=s("닫힌 채널에 데이터를 쓰려고 하면 panic이 발생함"),Ro=i(),se=a("h3"),re=a("a"),Dt=a("span"),lr=s("메모리 공유"),So=i(),ie=a("ul"),B=a("li"),tr=s("채널을 통해 전송한 데이터가 "),At=a("code"),ar=s("int"),or=s(", "),Bt=a("code"),nr=s("float"),sr=s(" 등의 primitive type이라면, 해당 데이터는 복사되어 전송됨"),rr=i(),R=a("li"),ir=s("채널을 통해 전송한 데이터가 "),Ht=a("code"),cr=s("slice"),ur=s(", "),Nt=a("code"),pr=s("map"),fr=s(" 등의 reference type이라면, 해당 데이터의 포인터 주소가 전송됨"),Ne=a("ul"),cl=a("li"),dr=s("이 때 이 데이터의 ownership은 전송된 고루틴에게 넘어가지 않고 메모리는 공유됨."),Te=a("ul"),Tt=a("li"),hr=s("결과적으로 shared memory를 사용하는 것과 같은 상태가 됨"),Er=i(),$t=a("li"),vr=s("이 상태는 data race임."),_r=i(),ul=a("li"),kr=s("보통 채널을 통해 reference type의 데이터를 전송하고 나면 그 데이터를 사용하지 않는 것이 좋음."),Vt=a("ul"),qt=a("li"),Lr=s("deep copy를 통해 복사본을 만들어 사용하거나, Mutex를 사용할 수도 있음"),yo=i(),ce=a("h3"),ue=a("a"),jt=a("span"),br=s("Non-blocking Channel"),Po=i(),S=a("ul"),$e=a("li"),zt=a("p"),Cr=s("원래 채널은 blocking 성질을 가지고 있음"),mr=i(),Ve=a("ul"),Ft=a("li"),Ir=s("채널에 데이터를 쓰려고 하면 채널에 데이터가 들어올 때까지 기다림"),xr=i(),Kt=a("li"),Rr=s("채널에서 데이터를 읽으려고 하면 채널에 데이터가 들어올 때까지 기다림"),Sr=i(),L=a("li"),pe=a("p"),Qt=a("code"),yr=s("select"),Pr=s("문에 "),Zt=a("code"),Gr=s("default"),Or=s(" 케이스가 있으면 non-blocking 채널이 됨."),Ur=i(),qe=a("ul"),Jt=a("li"),Mr=s("이 때 주의할 점은 채널에 대한 send, receive 연산의 우선순위가 가장 높지는 않다는 것임"),Wr=i(),je=a("li"),wr=s("예를 들면 아래 코드의 출력 결과는 "),Xt=a("code"),Dr=s("2"),Ar=s("임."),Br=i(),pl=a("pre"),Hr=i(),ze=a("ul"),_=a("li"),Yt=a("code"),Nr=s("default"),Tr=s(" 케이스로 넘어가기 이전 "),gt=a("code"),$r=s("ch1"),Vr=s(", "),ea=a("code"),qr=s("ch2"),jr=s(" 케이스에서 채널 blocking 여부를 확인하는데, 그 이전에 "),la=a("code"),zr=s("f()"),Fr=s("가 한 번씩 호출되기 때문"),Kr=i(),ta=a("li"),Qr=s("함수를 stateless하게 짜는 버릇을 들이자."),Zr=i(),H=a("li"),fe=a("p"),aa=a("code"),Jr=s("select"),Xr=s("문의 "),oa=a("code"),Yr=s("case"),gr=s(" 옆에 채널 연산자가 여러 개 붙어버리면 의도한 대로 동작 안할 수도 있음"),ei=i(),fl=a("pre"),li=i(),b=a("ul"),C=a("li"),ti=s("위 코드는 "),na=a("code"),ai=s("ch1"),oi=s("에 "),sa=a("code"),ni=s("ch2"),si=s("의 값을 전송하고, "),ra=a("code"),ri=s("ch1"),ii=s("에서 값을 읽어와서 출력함"),ci=i(),N=a("li"),ui=s("이 때 "),ia=a("code"),pi=s("<-ch2"),fi=s("가 먼저 실행되는데, "),ca=a("code"),di=s("ch2"),hi=s("에 값이 없을 때 읽어오려 하면 채널이 blocking됨"),Ei=i(),E=a("li"),vi=s("하지만 "),ua=a("code"),_i=s("default"),ki=s(" 케이스로 넘어가지 않음. "),pa=a("code"),Li=s("ch1<-"),bi=s("가 blocking될 때 "),fa=a("code"),Ci=s("default"),mi=s("로 넘어가고, "),da=a("code"),Ii=s("<-ch2"),xi=s("는 그냥 blocking됨"),Ri=i(),ha=a("li"),Si=s("그러니까 이렇게 짜지 말자;;"),Go=i(),Oo=a("br"),Uo=a("br"),Mo=i(),de=a("h2"),he=a("a"),Ea=a("span"),yi=s("Mutex"),Wo=i(),wo=a("hr"),Do=i(),y=a("ul"),Fe=a("li"),Pi=s("Mutex는 "),qf(Ee.$$.fragment),Gi=s("의 약자로, critical section에 대한 여러 고루틴의 동시 접근을 막기 위해 사용됨."),Oi=i(),T=a("li"),Ui=s("기본적으로 선언과 동시에 사용할 수 있으며, "),va=a("code"),Mi=s("lock"),Wi=s(" 및 "),_a=a("code"),wi=s("unlock"),Di=s(" 메소드를 지원함"),Ai=i(),dl=a("li"),Bi=s("Mutex 자체는 shared object여야 함. 단, Mutex가 복사되어선 안됨."),ka=a("ul"),La=a("li"),Hi=s("Mutex가 복사되면 복사된 Mutex들이 각자의 lock을 가지게 되므로, 동시 접근을 막을 수 없음"),Ao=i(),ve=a("h3"),_e=a("a"),ba=a("span"),Ni=s("RWMutex"),Bo=i(),P=a("ul"),Ca=a("li"),Ti=s("데이터의 Reader는 여러 명이어도 상관 없지만, Writer는 한 명 뿐이어야 함"),$i=i(),hl=a("li"),Vi=s("RWMutex.RLock() 메소드를 통해 Reader가 lock을 획득하고, RWMutex.RUnlock() 메소드를 통해 lock을 해제함"),ma=a("ul"),Ia=a("li"),qi=s("RWMutex.RLock()을 호출하는 여러 Reader 고루틴은 동시에 Critical Section에 접근할 수 있음"),ji=i(),El=a("li"),zi=s("RWMutex.Lock() 메소드를 통해 Writer가 lock을 획득하고, RWMutex.Unlock() 메소드를 통해 lock을 해제함"),Ke=a("ul"),xa=a("li"),Fi=s("RWMutex.Lock()을 호출하는 Writer 고루틴은 Critical Section에 접근할 수 있음"),Ki=i(),Ra=a("li"),Qi=s("이 때 RWMutex.RLock()을 호출하는 Reader 고루틴은 Critical Section에 접근할 수 없음"),Ho=i(),No=a("br"),To=a("br"),$o=i(),ke=a("h2"),Le=a("a"),Sa=a("span"),Zi=s("WaitGroup"),Vo=i(),qo=a("hr"),jo=i(),G=a("ul"),ya=a("li"),Ji=s("WaitGroup은 지정된 개수의 고루틴이 모두 종료될 때까지 기다리는 기능을 제공함"),Xi=i(),Pa=a("li"),Yi=s("주로 여러 서비스를 호출하여 그 결과를 모아서 처리해야 할 때 유용하게 사용할 수 있음"),gi=i(),vl=a("li"),ec=s("WaitGroup과 Channel을 동시에 사용하는 경우 올바른 순서로 사용해야 함"),Qe=a("ul"),Ze=a("li"),lc=s("만약 채널에서 데이터를 읽어오기 전에 "),Ga=a("code"),tc=s("Wg.Wait()"),ac=s("를 호출하면, Deadlock이 발생할 수 있음"),oc=i(),_l=a("li"),Oa=a("code"),nc=s("Wg.Wait()"),sc=s(" 이후 채널을 닫는 로직 또는 채널로부터 데이터를 읽어오는 로직을 별도의 고루틴으로 분리하는 것이 좋은 방법이 될 수 있음"),zo=i(),Fo=a("br"),Ko=a("br"),Qo=i(),be=a("h2"),Ce=a("a"),Ua=a("span"),rc=s("Conditional Variable"),Zo=i(),Jo=a("hr"),Xo=i(),O=a("ul"),Ma=a("li"),ic=s("Conditional Variable은 조건이 발생할 때까지 여러 고루틴이 기다리고, 조건이 발생하면 다른 고루틴에 이를 알리는 기능을 제공함"),cc=i(),Wa=a("li"),uc=s("Go에서 Conditional Variable은 대부분 Channel로 대체될 수 있음"),pc=i(),wa=a("li"),fc=s("하지만 Shared Memory 시스템에서 Producer-Consumer 문제 등, 여러 문제를 해결할 때 유용할 수 있음"),Yo=i(),me=a("blockquote"),Da=a("p"),Aa=a("strong"),dc=s("Producer-Consumer 문제"),hc=i(),$=a("ul"),Ba=a("li"),Ec=s("Producer-Consumer 문제는 데이터를 생산하는 Producer와, 데이터를 소비하는 Consumer에 대한 문제임"),vc=i(),Ha=a("li"),_c=s("1개 이상의 Producer와 Consumer가 존재할 수 있음"),kc=i(),kl=a("li"),Lc=s("일반적으로 Producer가 데이터를 쓰고 Consumer가 데이터를 읽어오는 대기열(Queue)를 사용함"),Na=a("ul"),Ta=a("li"),bc=s("Go에서는 이 대기열을 Channel로 구현할 수 있지만, Shared Memory 시스템에서는 Conditional Variable을 사용함"),go=i(),Ie=a("ul"),Je=a("li"),$a=a("p"),Cc=s("세개의 주요 오퍼레이션이 존재함"),mc=i(),V=a("ul"),Ll=a("li"),Va=a("code"),Ic=s("Wait()"),xc=s(": 조건이 발생할 때까지 기다림"),Rc=i(),bl=a("li"),qa=a("code"),Sc=s("Signal()"),yc=s(": 조건이 발생했음을 알림"),Pc=i(),xe=a("li"),ja=a("code"),Gc=s("Broadcast()"),Oc=s(": 조건이 발생했음을 알림. "),za=a("code"),Uc=s("Signal()"),Mc=s("과 달리 모든 고루틴에게 알림"),Wc=i(),Xe=a("li"),Fa=a("p"),wc=s("Conditional Variable은 Mutex와 함께 사용됨"),Dc=i(),Ka=a("ul"),Qa=a("li"),Ac=s("Conditional Variable은 Critical Section 안에서만 수정할 수 있음"),en=i(),ln=a("br"),tn=a("br"),an=i(),Re=a("h2"),Se=a("a"),Za=a("span"),Bc=s("References"),on=i(),nn=a("hr"),sn=i(),Cl=a("center"),q=a("p"),Ye=a("a"),ml=a("img"),Hc=i(),Nc=a("br"),Tc=i(),ge=a("a"),$c=s("Burak Serdar, 『Effective Concurrency in Go』, Packt Publishing"),this.h()},l(t){d=o(t,"P",{});var u=n(d);W=r(u,"내용의 상당 부분이 "),w=o(u,"A",{href:!0,rel:!0});var Ja=n(w);Wn=r(Ja,"https://jhseoeo.github.io/posts/post/Go/Golang%20Basics/GO10"),Ja.forEach(l),wn=r(u,"의 내용과 중복되므로, 해당 포스트를 먼저 읽고 오시는 것을 추천드립니다."),u.forEach(l),lo=c(t),ll=o(t,"P",{});var ku=n(ll);Dn=r(ku,"해당 포스트에서 다루지 않은 내용만 중점적으로 다루려 합니다."),ku.forEach(l),to=c(t),ao=o(t,"BR",{}),oo=o(t,"BR",{}),no=c(t),z=o(t,"H2",{id:!0});var Vc=n(z);F=o(Vc,"A",{"aria-hidden":!0,tabindex:!0,href:!0});var Lu=n(F);Tl=o(Lu,"SPAN",{class:!0}),n(Tl).forEach(l),Lu.forEach(l),An=r(Vc,"Goroutine"),Vc.forEach(l),so=c(t),ro=o(t,"HR",{}),io=c(t),K=o(t,"H3",{id:!0});var qc=n(K);Q=o(qc,"A",{"aria-hidden":!0,tabindex:!0,href:!0});var bu=n(Q);$l=o(bu,"SPAN",{class:!0}),n($l).forEach(l),bu.forEach(l),Bn=r(qc,"Goroutine이 빠른 이유"),qc.forEach(l),co=c(t),m=o(t,"UL",{});var Il=n(m);Me=o(Il,"LI",{});var cn=n(Me);Vl=o(cn,"P",{});var Cu=n(Vl);Hn=r(Cu,"Go 런타임은 실행될 때 기본적으로 플랫폼의 프로세서(코어) 수만큼의 쓰레드를 생성함"),Cu.forEach(l),Nn=c(cn),h=o(cn,"UL",{});var U=n(h);ql=o(U,"LI",{});var mu=n(ql);Tn=r(mu,"이 쓰레드 풀 위에서 Goroutine이 실행됨"),mu.forEach(l),$n=c(U),jl=o(U,"LI",{});var Iu=n(jl);Vn=r(Iu,"만약 그 이하의 쓰레드를 생성하면 CPU utilization이 떨어짐"),Iu.forEach(l),qn=c(U),zl=o(U,"LI",{});var xu=n(zl);jn=r(xu,"만약 그 이상의 쓰레드를 생성하면 Time Sharing때문에 Context Switching 오버헤드가 발생"),xu.forEach(l),zn=c(U),Fl=o(U,"LI",{});var Ru=n(Fl);Fn=r(Ru,"만일 고루틴이 Channel, Mutex 등에 의해 block되면 해당 고루틴을 실행시키는 쓰레드는 다른 고루틴을 실행시킴"),Ru.forEach(l),Kn=c(U),Kl=o(U,"LI",{});var Su=n(Kl);Qn=r(Su,"만일 고루틴이 동기 I/O에 의해 block되면 해당 고루틴을 실행시키는 쓰레드 자체가 block되므로, 새로운 쓰레드를 생성하거나 기존의 쓰레드를 재사용하여 다른 고루틴을 실행시킴"),Su.forEach(l),U.forEach(l),cn.forEach(l),Zn=c(Il),We=o(Il,"LI",{});var un=n(We);Ql=o(un,"P",{});var yu=n(Ql);Jn=r(yu,"Go Scheduler는 user space에 있기 때문에 OS Thread를 사용하는 것보다 오버헤드가 적음"),yu.forEach(l),Xn=c(un),Zl=o(un,"UL",{});var Pu=n(Zl);Jl=o(Pu,"LI",{});var Gu=n(Jl);Yn=r(Gu,"따라서 쓰레드 생성 및 관리에 대한 오버헤드가 적음"),Gu.forEach(l),Pu.forEach(l),un.forEach(l),gn=c(Il),we=o(Il,"LI",{});var pn=n(we);Xl=o(pn,"P",{});var Ou=n(Xl);es=r(Ou,"Goroutine은 OS Thread보다 훨씬 적은 메모리를 사용함"),Ou.forEach(l),ls=c(pn),Yl=o(pn,"UL",{});var Uu=n(Yl);gl=o(Uu,"LI",{});var Mu=n(gl);ts=r(Mu,"Goroutine의 Stack 크기는 2KB 정도인 반면, OS Thread의 Stack 크기는 MB 단위임"),Mu.forEach(l),Uu.forEach(l),pn.forEach(l),Il.forEach(l),uo=c(t),Z=o(t,"H3",{id:!0});var jc=n(Z);J=o(jc,"A",{"aria-hidden":!0,tabindex:!0,href:!0});var Wu=n(J);et=o(Wu,"SPAN",{class:!0}),n(et).forEach(l),Wu.forEach(l),as=r(jc,"Goroutine의 특징"),jc.forEach(l),po=c(t),I=o(t,"UL",{});var xl=n(I);lt=o(xl,"LI",{});var wu=n(lt);tt=o(wu,"P",{});var Du=n(tt);os=r(Du,"OS Thread는 스케줄링 우선순위가 존재하지만, Goroutine은 존재하지 않음(Starvation이 발생하는 고루틴을 우선 선택하는 스케줄링 알고리즘이 있긴 하지만, 이를 지향하지는 않음)"),Du.forEach(l),wu.forEach(l),ns=c(xl),De=o(xl,"LI",{});var fn=n(De);at=o(fn,"P",{});var Au=n(at);ss=r(Au,"Go 프로그램을 실행시키면 main 고루틴과 가비지 컬렉터 고루틴이 생성됨"),Au.forEach(l),rs=c(fn),Ae=o(fn,"UL",{});var dn=n(Ae);D=o(dn,"LI",{});var Rl=n(D);is=r(Rl,"main 고루틴은 "),ot=o(Rl,"CODE",{});var Bu=n(ot);cs=r(Bu,"main"),Bu.forEach(l),us=r(Rl," 패키지의 "),nt=o(Rl,"CODE",{});var Hu=n(nt);ps=r(Hu,"main"),Hu.forEach(l),fs=r(Rl," 함수에서 생성됨"),Rl.forEach(l),ds=c(dn),st=o(dn,"LI",{});var Nu=n(st);hs=r(Nu,"main 함수가 종료되면 모든 고루틴이 종료되고 프로그램이 종료됨"),Nu.forEach(l),dn.forEach(l),fn.forEach(l),Es=c(xl),Be=o(xl,"LI",{});var hn=n(Be);rt=o(hn,"P",{});var Tu=n(rt);vs=r(Tu,"Goroutine을 일시정지 혹은 종료시키는 magic function은 없음"),Tu.forEach(l),_s=c(hn),He=o(hn,"UL",{});var En=n(He);it=o(En,"LI",{});var $u=n(it);ks=r($u,"고루틴이 중단되어야 함을 정의하는 message 또는 flag를 사용하는 것이 일반적"),$u.forEach(l),Ls=c(En),tl=o(En,"LI",{});var zc=n(tl);ct=o(zc,"CODE",{});var Vu=n(ct);bs=r(Vu,"panic"),Vu.forEach(l),Cs=r(zc,"은 고루틴을 종료시킬 수 있음. panic이 발생한 해당 고루틴이 종료됨"),zc.forEach(l),En.forEach(l),hn.forEach(l),xl.forEach(l),fo=c(t),X=o(t,"H3",{id:!0});var Fc=n(X);Y=o(Fc,"A",{"aria-hidden":!0,tabindex:!0,href:!0});var qu=n(Y);ut=o(qu,"SPAN",{class:!0}),n(ut).forEach(l),qu.forEach(l),ms=r(Fc,"Closure"),Fc.forEach(l),ho=c(t),al=o(t,"UL",{});var ju=n(al);ol=o(ju,"LI",{});var Kc=n(ol);Is=r(Kc,"어떤 익명 함수가 그 함수 내부 컨텍스트에 있는 변수를 참조하면, 그 익명 함수를 클로저(Closure)라고 함"),pt=o(Kc,"UL",{});var zu=n(pt);nl=o(zu,"LI",{});var Qc=n(nl);xs=r(Qc,"클로저가 참조하는 로컬 변수는 stack에서 heap으로 옮겨짐(escape to heap)"),ft=o(Qc,"UL",{});var Fu=n(ft);dt=o(Fu,"LI",{});var Ku=n(dt);Rs=r(Ku,"stack에 저장되면 함수가 종료되면서 로컬 변수가 사라지기 때문"),Ku.forEach(l),Fu.forEach(l),Qc.forEach(l),zu.forEach(l),Kc.forEach(l),ju.forEach(l),Eo=c(t),vo=o(t,"BR",{}),_o=o(t,"BR",{}),ko=c(t),g=o(t,"H2",{id:!0});var Zc=n(g);ee=o(Zc,"A",{"aria-hidden":!0,tabindex:!0,href:!0});var Qu=n(ee);ht=o(Qu,"SPAN",{class:!0}),n(ht).forEach(l),Qu.forEach(l),Ss=r(Zc,"Channel"),Zc.forEach(l),Lo=c(t),bo=o(t,"HR",{}),Co=c(t),le=o(t,"H3",{id:!0});var Jc=n(le);te=o(Jc,"A",{"aria-hidden":!0,tabindex:!0,href:!0});var Zu=n(te);Et=o(Zu,"SPAN",{class:!0}),n(Et).forEach(l),Zu.forEach(l),ys=r(Jc,"Channel의 length와 capacity"),Jc.forEach(l),mo=c(t),x=o(t,"UL",{});var Sl=n(x);vt=o(Sl,"LI",{});var Ju=n(vt);_t=o(Ju,"P",{});var Xu=n(_t);Ps=r(Xu,"Channel은 내부적으로 FIFO 큐로 구현되어 있음"),Xu.forEach(l),Ju.forEach(l),Gs=c(Sl),kt=o(Sl,"LI",{});var Yu=n(kt);Lt=o(Yu,"P",{});var gu=n(Lt);Os=r(gu,"Channel의 capacity는 채널 버퍼의 크기를 의미함"),gu.forEach(l),Yu.forEach(l),Us=c(Sl),k=o(Sl,"LI",{});var ye=n(k);bt=o(ye,"P",{});var ep=n(bt);Ms=r(ep,"Channel의 length는 현재 큐에 들어있는 element의 개수를 의미함"),ep.forEach(l),Ws=c(ye),Ct=o(ye,"UL",{});var lp=n(Ct);mt=o(lp,"LI",{});var tp=n(mt);ws=r(tp,"아래와 같은 코드는 좋지 않음"),tp.forEach(l),lp.forEach(l),Ds=c(ye),sl=o(ye,"PRE",{class:!0});var Bf=n(sl);Bf.forEach(l),As=c(ye),A=o(ye,"UL",{});var yl=n(A);It=o(yl,"LI",{});var ap=n(It);Bs=r(ap,"이 코드는 ch에 element가 들어있는지 확인한 후, 들어있다면 element를 읽어옴"),ap.forEach(l),Hs=c(yl),xt=o(yl,"LI",{});var op=n(xt);Ns=r(op,"이 때 length를 가져오는 것은 데이터를 읽어오는 것과는 달리 mutual exclusive하지 않음"),op.forEach(l),Ts=c(yl),Rt=o(yl,"LI",{});var np=n(Rt);$s=r(np,"따라서 데이터를 읽어오려고 할 때 채널의 값을 다른 고루틴이 이미 읽어버리는 race condition이 발생할 수도 있음"),np.forEach(l),yl.forEach(l),ye.forEach(l),Sl.forEach(l),Io=c(t),ae=o(t,"H3",{id:!0});var Xc=n(ae);oe=o(Xc,"A",{"aria-hidden":!0,tabindex:!0,href:!0});var sp=n(oe);St=o(sp,"SPAN",{class:!0}),n(St).forEach(l),sp.forEach(l),Vs=r(Xc,"Channel의 close"),Xc.forEach(l),xo=c(t),v=o(t,"UL",{});var Pe=n(v);rl=o(Pe,"LI",{});var Yc=n(rl);qs=r(Yc,"원래 채널은 1:1 통신만 가능함."),yt=o(Yc,"UL",{});var rp=n(yt);Pt=o(rp,"LI",{});var ip=n(Pt);js=r(ip,"채널에서 데이터를 읽는 고루틴이 여러 개이고 데이터를 쓰는 고루틴이 하나라면, 쓰기 고루틴이 데이터를 쓸 때 무작위로 읽기 고루틴 중 하나에게 데이터를 전송함"),ip.forEach(l),rp.forEach(l),Yc.forEach(l),zs=c(Pe),ne=o(Pe,"LI",{});var Xa=n(ne);Fs=r(Xa,"하지만 채널을 "),Gt=o(Xa,"CODE",{});var cp=n(Gt);Ks=r(cp,"close"),cp.forEach(l),Qs=r(Xa,"하면 해당 채널을 receive하는 모든 고루틴이 이를 감지할 수 있음"),Ot=o(Xa,"UL",{});var up=n(Ot);Ut=o(up,"LI",{});var pp=n(Ut);Zs=r(pp,"일종의 일회성 Broadcast인 셈"),pp.forEach(l),up.forEach(l),Xa.forEach(l),Js=c(Pe),il=o(Pe,"LI",{});var gc=n(il);Xs=r(gc,"닫힌 채널로부터 데이터를 읽어오면 해당 타입의 zero value를 읽어옴"),Mt=o(gc,"UL",{});var fp=n(Mt);Wt=o(fp,"LI",{});var dp=n(Wt);Ys=r(dp,"comma ok idiom을 사용하면 닫힌 채널인지 확인할 수 있음"),dp.forEach(l),fp.forEach(l),gc.forEach(l),gs=c(Pe),wt=o(Pe,"LI",{});var hp=n(wt);er=r(hp,"닫힌 채널에 데이터를 쓰려고 하면 panic이 발생함"),hp.forEach(l),Pe.forEach(l),Ro=c(t),se=o(t,"H3",{id:!0});var eu=n(se);re=o(eu,"A",{"aria-hidden":!0,tabindex:!0,href:!0});var Ep=n(re);Dt=o(Ep,"SPAN",{class:!0}),n(Dt).forEach(l),Ep.forEach(l),lr=r(eu,"메모리 공유"),eu.forEach(l),So=c(t),ie=o(t,"UL",{});var vn=n(ie);B=o(vn,"LI",{});var Pl=n(B);tr=r(Pl,"채널을 통해 전송한 데이터가 "),At=o(Pl,"CODE",{});var vp=n(At);ar=r(vp,"int"),vp.forEach(l),or=r(Pl,", "),Bt=o(Pl,"CODE",{});var _p=n(Bt);nr=r(_p,"float"),_p.forEach(l),sr=r(Pl," 등의 primitive type이라면, 해당 데이터는 복사되어 전송됨"),Pl.forEach(l),rr=c(vn),R=o(vn,"LI",{});var el=n(R);ir=r(el,"채널을 통해 전송한 데이터가 "),Ht=o(el,"CODE",{});var kp=n(Ht);cr=r(kp,"slice"),kp.forEach(l),ur=r(el,", "),Nt=o(el,"CODE",{});var Lp=n(Nt);pr=r(Lp,"map"),Lp.forEach(l),fr=r(el," 등의 reference type이라면, 해당 데이터의 포인터 주소가 전송됨"),Ne=o(el,"UL",{});var _n=n(Ne);cl=o(_n,"LI",{});var lu=n(cl);dr=r(lu,"이 때 이 데이터의 ownership은 전송된 고루틴에게 넘어가지 않고 메모리는 공유됨."),Te=o(lu,"UL",{});var kn=n(Te);Tt=o(kn,"LI",{});var bp=n(Tt);hr=r(bp,"결과적으로 shared memory를 사용하는 것과 같은 상태가 됨"),bp.forEach(l),Er=c(kn),$t=o(kn,"LI",{});var Cp=n($t);vr=r(Cp,"이 상태는 data race임."),Cp.forEach(l),kn.forEach(l),lu.forEach(l),_r=c(_n),ul=o(_n,"LI",{});var tu=n(ul);kr=r(tu,"보통 채널을 통해 reference type의 데이터를 전송하고 나면 그 데이터를 사용하지 않는 것이 좋음."),Vt=o(tu,"UL",{});var mp=n(Vt);qt=o(mp,"LI",{});var Ip=n(qt);Lr=r(Ip,"deep copy를 통해 복사본을 만들어 사용하거나, Mutex를 사용할 수도 있음"),Ip.forEach(l),mp.forEach(l),tu.forEach(l),_n.forEach(l),el.forEach(l),vn.forEach(l),yo=c(t),ce=o(t,"H3",{id:!0});var au=n(ce);ue=o(au,"A",{"aria-hidden":!0,tabindex:!0,href:!0});var xp=n(ue);jt=o(xp,"SPAN",{class:!0}),n(jt).forEach(l),xp.forEach(l),br=r(au,"Non-blocking Channel"),au.forEach(l),Po=c(t),S=o(t,"UL",{});var Gl=n(S);$e=o(Gl,"LI",{});var Ln=n($e);zt=o(Ln,"P",{});var Rp=n(zt);Cr=r(Rp,"원래 채널은 blocking 성질을 가지고 있음"),Rp.forEach(l),mr=c(Ln),Ve=o(Ln,"UL",{});var bn=n(Ve);Ft=o(bn,"LI",{});var Sp=n(Ft);Ir=r(Sp,"채널에 데이터를 쓰려고 하면 채널에 데이터가 들어올 때까지 기다림"),Sp.forEach(l),xr=c(bn),Kt=o(bn,"LI",{});var yp=n(Kt);Rr=r(yp,"채널에서 데이터를 읽으려고 하면 채널에 데이터가 들어올 때까지 기다림"),yp.forEach(l),bn.forEach(l),Ln.forEach(l),Sr=c(Gl),L=o(Gl,"LI",{});var Ge=n(L);pe=o(Ge,"P",{});var Ya=n(pe);Qt=o(Ya,"CODE",{});var Pp=n(Qt);yr=r(Pp,"select"),Pp.forEach(l),Pr=r(Ya,"문에 "),Zt=o(Ya,"CODE",{});var Gp=n(Zt);Gr=r(Gp,"default"),Gp.forEach(l),Or=r(Ya," 케이스가 있으면 non-blocking 채널이 됨."),Ya.forEach(l),Ur=c(Ge),qe=o(Ge,"UL",{});var Cn=n(qe);Jt=o(Cn,"LI",{});var Op=n(Jt);Mr=r(Op,"이 때 주의할 점은 채널에 대한 send, receive 연산의 우선순위가 가장 높지는 않다는 것임"),Op.forEach(l),Wr=c(Cn),je=o(Cn,"LI",{});var mn=n(je);wr=r(mn,"예를 들면 아래 코드의 출력 결과는 "),Xt=o(mn,"CODE",{});var Up=n(Xt);Dr=r(Up,"2"),Up.forEach(l),Ar=r(mn,"임."),mn.forEach(l),Cn.forEach(l),Br=c(Ge),pl=o(Ge,"PRE",{class:!0});var Hf=n(pl);Hf.forEach(l),Hr=c(Ge),ze=o(Ge,"UL",{});var In=n(ze);_=o(In,"LI",{});var j=n(_);Yt=o(j,"CODE",{});var Mp=n(Yt);Nr=r(Mp,"default"),Mp.forEach(l),Tr=r(j," 케이스로 넘어가기 이전 "),gt=o(j,"CODE",{});var Wp=n(gt);$r=r(Wp,"ch1"),Wp.forEach(l),Vr=r(j,", "),ea=o(j,"CODE",{});var wp=n(ea);qr=r(wp,"ch2"),wp.forEach(l),jr=r(j," 케이스에서 채널 blocking 여부를 확인하는데, 그 이전에 "),la=o(j,"CODE",{});var Dp=n(la);zr=r(Dp,"f()"),Dp.forEach(l),Fr=r(j,"가 한 번씩 호출되기 때문"),j.forEach(l),Kr=c(In),ta=o(In,"LI",{});var Ap=n(ta);Qr=r(Ap,"함수를 stateless하게 짜는 버릇을 들이자."),Ap.forEach(l),In.forEach(l),Ge.forEach(l),Zr=c(Gl),H=o(Gl,"LI",{});var Ol=n(H);fe=o(Ol,"P",{});var ga=n(fe);aa=o(ga,"CODE",{});var Bp=n(aa);Jr=r(Bp,"select"),Bp.forEach(l),Xr=r(ga,"문의 "),oa=o(ga,"CODE",{});var Hp=n(oa);Yr=r(Hp,"case"),Hp.forEach(l),gr=r(ga," 옆에 채널 연산자가 여러 개 붙어버리면 의도한 대로 동작 안할 수도 있음"),ga.forEach(l),ei=c(Ol),fl=o(Ol,"PRE",{class:!0});var Nf=n(fl);Nf.forEach(l),li=c(Ol),b=o(Ol,"UL",{});var Oe=n(b);C=o(Oe,"LI",{});var Ue=n(C);ti=r(Ue,"위 코드는 "),na=o(Ue,"CODE",{});var Np=n(na);ai=r(Np,"ch1"),Np.forEach(l),oi=r(Ue,"에 "),sa=o(Ue,"CODE",{});var Tp=n(sa);ni=r(Tp,"ch2"),Tp.forEach(l),si=r(Ue,"의 값을 전송하고, "),ra=o(Ue,"CODE",{});var $p=n(ra);ri=r($p,"ch1"),$p.forEach(l),ii=r(Ue,"에서 값을 읽어와서 출력함"),Ue.forEach(l),ci=c(Oe),N=o(Oe,"LI",{});var Ul=n(N);ui=r(Ul,"이 때 "),ia=o(Ul,"CODE",{});var Vp=n(ia);pi=r(Vp,"<-ch2"),Vp.forEach(l),fi=r(Ul,"가 먼저 실행되는데, "),ca=o(Ul,"CODE",{});var qp=n(ca);di=r(qp,"ch2"),qp.forEach(l),hi=r(Ul,"에 값이 없을 때 읽어오려 하면 채널이 blocking됨"),Ul.forEach(l),Ei=c(Oe),E=o(Oe,"LI",{});var M=n(E);vi=r(M,"하지만 "),ua=o(M,"CODE",{});var jp=n(ua);_i=r(jp,"default"),jp.forEach(l),ki=r(M," 케이스로 넘어가지 않음. "),pa=o(M,"CODE",{});var zp=n(pa);Li=r(zp,"ch1<-"),zp.forEach(l),bi=r(M,"가 blocking될 때 "),fa=o(M,"CODE",{});var Fp=n(fa);Ci=r(Fp,"default"),Fp.forEach(l),mi=r(M,"로 넘어가고, "),da=o(M,"CODE",{});var Kp=n(da);Ii=r(Kp,"<-ch2"),Kp.forEach(l),xi=r(M,"는 그냥 blocking됨"),M.forEach(l),Ri=c(Oe),ha=o(Oe,"LI",{});var Qp=n(ha);Si=r(Qp,"그러니까 이렇게 짜지 말자;;"),Qp.forEach(l),Oe.forEach(l),Ol.forEach(l),Gl.forEach(l),Go=c(t),Oo=o(t,"BR",{}),Uo=o(t,"BR",{}),Mo=c(t),de=o(t,"H2",{id:!0});var ou=n(de);he=o(ou,"A",{"aria-hidden":!0,tabindex:!0,href:!0});var Zp=n(he);Ea=o(Zp,"SPAN",{class:!0}),n(Ea).forEach(l),Zp.forEach(l),yi=r(ou,"Mutex"),ou.forEach(l),Wo=c(t),wo=o(t,"HR",{}),Do=c(t),y=o(t,"UL",{});var Ml=n(y);Fe=o(Ml,"LI",{});var xn=n(Fe);Pi=r(xn,"Mutex는 "),jf(Ee.$$.fragment,xn),Gi=r(xn,"의 약자로, critical section에 대한 여러 고루틴의 동시 접근을 막기 위해 사용됨."),xn.forEach(l),Oi=c(Ml),T=o(Ml,"LI",{});var Wl=n(T);Ui=r(Wl,"기본적으로 선언과 동시에 사용할 수 있으며, "),va=o(Wl,"CODE",{});var Jp=n(va);Mi=r(Jp,"lock"),Jp.forEach(l),Wi=r(Wl," 및 "),_a=o(Wl,"CODE",{});var Xp=n(_a);wi=r(Xp,"unlock"),Xp.forEach(l),Di=r(Wl," 메소드를 지원함"),Wl.forEach(l),Ai=c(Ml),dl=o(Ml,"LI",{});var nu=n(dl);Bi=r(nu,"Mutex 자체는 shared object여야 함. 단, Mutex가 복사되어선 안됨."),ka=o(nu,"UL",{});var Yp=n(ka);La=o(Yp,"LI",{});var gp=n(La);Hi=r(gp,"Mutex가 복사되면 복사된 Mutex들이 각자의 lock을 가지게 되므로, 동시 접근을 막을 수 없음"),gp.forEach(l),Yp.forEach(l),nu.forEach(l),Ml.forEach(l),Ao=c(t),ve=o(t,"H3",{id:!0});var su=n(ve);_e=o(su,"A",{"aria-hidden":!0,tabindex:!0,href:!0});var ef=n(_e);ba=o(ef,"SPAN",{class:!0}),n(ba).forEach(l),ef.forEach(l),Ni=r(su,"RWMutex"),su.forEach(l),Bo=c(t),P=o(t,"UL",{});var wl=n(P);Ca=o(wl,"LI",{});var lf=n(Ca);Ti=r(lf,"데이터의 Reader는 여러 명이어도 상관 없지만, Writer는 한 명 뿐이어야 함"),lf.forEach(l),$i=c(wl),hl=o(wl,"LI",{});var ru=n(hl);Vi=r(ru,"RWMutex.RLock() 메소드를 통해 Reader가 lock을 획득하고, RWMutex.RUnlock() 메소드를 통해 lock을 해제함"),ma=o(ru,"UL",{});var tf=n(ma);Ia=o(tf,"LI",{});var af=n(Ia);qi=r(af,"RWMutex.RLock()을 호출하는 여러 Reader 고루틴은 동시에 Critical Section에 접근할 수 있음"),af.forEach(l),tf.forEach(l),ru.forEach(l),ji=c(wl),El=o(wl,"LI",{});var iu=n(El);zi=r(iu,"RWMutex.Lock() 메소드를 통해 Writer가 lock을 획득하고, RWMutex.Unlock() 메소드를 통해 lock을 해제함"),Ke=o(iu,"UL",{});var Rn=n(Ke);xa=o(Rn,"LI",{});var of=n(xa);Fi=r(of,"RWMutex.Lock()을 호출하는 Writer 고루틴은 Critical Section에 접근할 수 있음"),of.forEach(l),Ki=c(Rn),Ra=o(Rn,"LI",{});var nf=n(Ra);Qi=r(nf,"이 때 RWMutex.RLock()을 호출하는 Reader 고루틴은 Critical Section에 접근할 수 없음"),nf.forEach(l),Rn.forEach(l),iu.forEach(l),wl.forEach(l),Ho=c(t),No=o(t,"BR",{}),To=o(t,"BR",{}),$o=c(t),ke=o(t,"H2",{id:!0});var cu=n(ke);Le=o(cu,"A",{"aria-hidden":!0,tabindex:!0,href:!0});var sf=n(Le);Sa=o(sf,"SPAN",{class:!0}),n(Sa).forEach(l),sf.forEach(l),Zi=r(cu,"WaitGroup"),cu.forEach(l),Vo=c(t),qo=o(t,"HR",{}),jo=c(t),G=o(t,"UL",{});var Dl=n(G);ya=o(Dl,"LI",{});var rf=n(ya);Ji=r(rf,"WaitGroup은 지정된 개수의 고루틴이 모두 종료될 때까지 기다리는 기능을 제공함"),rf.forEach(l),Xi=c(Dl),Pa=o(Dl,"LI",{});var cf=n(Pa);Yi=r(cf,"주로 여러 서비스를 호출하여 그 결과를 모아서 처리해야 할 때 유용하게 사용할 수 있음"),cf.forEach(l),gi=c(Dl),vl=o(Dl,"LI",{});var uu=n(vl);ec=r(uu,"WaitGroup과 Channel을 동시에 사용하는 경우 올바른 순서로 사용해야 함"),Qe=o(uu,"UL",{});var Sn=n(Qe);Ze=o(Sn,"LI",{});var yn=n(Ze);lc=r(yn,"만약 채널에서 데이터를 읽어오기 전에 "),Ga=o(yn,"CODE",{});var uf=n(Ga);tc=r(uf,"Wg.Wait()"),uf.forEach(l),ac=r(yn,"를 호출하면, Deadlock이 발생할 수 있음"),yn.forEach(l),oc=c(Sn),_l=o(Sn,"LI",{});var pu=n(_l);Oa=o(pu,"CODE",{});var pf=n(Oa);nc=r(pf,"Wg.Wait()"),pf.forEach(l),sc=r(pu," 이후 채널을 닫는 로직 또는 채널로부터 데이터를 읽어오는 로직을 별도의 고루틴으로 분리하는 것이 좋은 방법이 될 수 있음"),pu.forEach(l),Sn.forEach(l),uu.forEach(l),Dl.forEach(l),zo=c(t),Fo=o(t,"BR",{}),Ko=o(t,"BR",{}),Qo=c(t),be=o(t,"H2",{id:!0});var fu=n(be);Ce=o(fu,"A",{"aria-hidden":!0,tabindex:!0,href:!0});var ff=n(Ce);Ua=o(ff,"SPAN",{class:!0}),n(Ua).forEach(l),ff.forEach(l),rc=r(fu,"Conditional Variable"),fu.forEach(l),Zo=c(t),Jo=o(t,"HR",{}),Xo=c(t),O=o(t,"UL",{});var Al=n(O);Ma=o(Al,"LI",{});var df=n(Ma);ic=r(df,"Conditional Variable은 조건이 발생할 때까지 여러 고루틴이 기다리고, 조건이 발생하면 다른 고루틴에 이를 알리는 기능을 제공함"),df.forEach(l),cc=c(Al),Wa=o(Al,"LI",{});var hf=n(Wa);uc=r(hf,"Go에서 Conditional Variable은 대부분 Channel로 대체될 수 있음"),hf.forEach(l),pc=c(Al),wa=o(Al,"LI",{});var Ef=n(wa);fc=r(Ef,"하지만 Shared Memory 시스템에서 Producer-Consumer 문제 등, 여러 문제를 해결할 때 유용할 수 있음"),Ef.forEach(l),Al.forEach(l),Yo=c(t),me=o(t,"BLOCKQUOTE",{});var Pn=n(me);Da=o(Pn,"P",{});var vf=n(Da);Aa=o(vf,"STRONG",{});var _f=n(Aa);dc=r(_f,"Producer-Consumer 문제"),_f.forEach(l),vf.forEach(l),hc=c(Pn),$=o(Pn,"UL",{});var Bl=n($);Ba=o(Bl,"LI",{});var kf=n(Ba);Ec=r(kf,"Producer-Consumer 문제는 데이터를 생산하는 Producer와, 데이터를 소비하는 Consumer에 대한 문제임"),kf.forEach(l),vc=c(Bl),Ha=o(Bl,"LI",{});var Lf=n(Ha);_c=r(Lf,"1개 이상의 Producer와 Consumer가 존재할 수 있음"),Lf.forEach(l),kc=c(Bl),kl=o(Bl,"LI",{});var du=n(kl);Lc=r(du,"일반적으로 Producer가 데이터를 쓰고 Consumer가 데이터를 읽어오는 대기열(Queue)를 사용함"),Na=o(du,"UL",{});var bf=n(Na);Ta=o(bf,"LI",{});var Cf=n(Ta);bc=r(Cf,"Go에서는 이 대기열을 Channel로 구현할 수 있지만, Shared Memory 시스템에서는 Conditional Variable을 사용함"),Cf.forEach(l),bf.forEach(l),du.forEach(l),Bl.forEach(l),Pn.forEach(l),go=c(t),Ie=o(t,"UL",{});var Gn=n(Ie);Je=o(Gn,"LI",{});var On=n(Je);$a=o(On,"P",{});var mf=n($a);Cc=r(mf,"세개의 주요 오퍼레이션이 존재함"),mf.forEach(l),mc=c(On),V=o(On,"UL",{});var Hl=n(V);Ll=o(Hl,"LI",{});var hu=n(Ll);Va=o(hu,"CODE",{});var If=n(Va);Ic=r(If,"Wait()"),If.forEach(l),xc=r(hu,": 조건이 발생할 때까지 기다림"),hu.forEach(l),Rc=c(Hl),bl=o(Hl,"LI",{});var Eu=n(bl);qa=o(Eu,"CODE",{});var xf=n(qa);Sc=r(xf,"Signal()"),xf.forEach(l),yc=r(Eu,": 조건이 발생했음을 알림"),Eu.forEach(l),Pc=c(Hl),xe=o(Hl,"LI",{});var eo=n(xe);ja=o(eo,"CODE",{});var Rf=n(ja);Gc=r(Rf,"Broadcast()"),Rf.forEach(l),Oc=r(eo,": 조건이 발생했음을 알림. "),za=o(eo,"CODE",{});var Sf=n(za);Uc=r(Sf,"Signal()"),Sf.forEach(l),Mc=r(eo,"과 달리 모든 고루틴에게 알림"),eo.forEach(l),Hl.forEach(l),On.forEach(l),Wc=c(Gn),Xe=o(Gn,"LI",{});var Un=n(Xe);Fa=o(Un,"P",{});var yf=n(Fa);wc=r(yf,"Conditional Variable은 Mutex와 함께 사용됨"),yf.forEach(l),Dc=c(Un),Ka=o(Un,"UL",{});var Pf=n(Ka);Qa=o(Pf,"LI",{});var Gf=n(Qa);Ac=r(Gf,"Conditional Variable은 Critical Section 안에서만 수정할 수 있음"),Gf.forEach(l),Pf.forEach(l),Un.forEach(l),Gn.forEach(l),en=c(t),ln=o(t,"BR",{}),tn=o(t,"BR",{}),an=c(t),Re=o(t,"H2",{id:!0});var vu=n(Re);Se=o(vu,"A",{"aria-hidden":!0,tabindex:!0,href:!0});var Of=n(Se);Za=o(Of,"SPAN",{class:!0}),n(Za).forEach(l),Of.forEach(l),Bc=r(vu,"References"),vu.forEach(l),on=c(t),nn=o(t,"HR",{}),sn=c(t),Cl=o(t,"CENTER",{});var Uf=n(Cl);q=o(Uf,"P",{});var Nl=n(q);Ye=o(Nl,"A",{href:!0,rel:!0});var Mf=n(Ye);ml=o(Mf,"IMG",{src:!0,alt:!0}),Mf.forEach(l),Hc=c(Nl),Nc=o(Nl,"BR",{}),Tc=c(Nl),ge=o(Nl,"A",{href:!0,rel:!0});var Wf=n(ge);$c=r(Wf,"Burak Serdar, 『Effective Concurrency in Go』, Packt Publishing"),Wf.forEach(l),Nl.forEach(l),Uf.forEach(l),this.h()},h(){f(w,"href","https://jhseoeo.github.io/posts/post/Go/Golang%20Basics/GO10"),f(w,"rel","nofollow"),f(Tl,"class","icon icon-link"),f(F,"aria-hidden","true"),f(F,"tabindex","-1"),f(F,"href","#goroutine"),f(z,"id","goroutine"),f($l,"class","icon icon-link"),f(Q,"aria-hidden","true"),f(Q,"tabindex","-1"),f(Q,"href","#goroutine이-빠른-이유"),f(K,"id","goroutine이-빠른-이유"),f(et,"class","icon icon-link"),f(J,"aria-hidden","true"),f(J,"tabindex","-1"),f(J,"href","#goroutine의-특징"),f(Z,"id","goroutine의-특징"),f(ut,"class","icon icon-link"),f(Y,"aria-hidden","true"),f(Y,"tabindex","-1"),f(Y,"href","#closure"),f(X,"id","closure"),f(ht,"class","icon icon-link"),f(ee,"aria-hidden","true"),f(ee,"tabindex","-1"),f(ee,"href","#channel"),f(g,"id","channel"),f(Et,"class","icon icon-link"),f(te,"aria-hidden","true"),f(te,"tabindex","-1"),f(te,"href","#channel의-length와-capacity"),f(le,"id","channel의-length와-capacity"),f(sl,"class","language-go"),f(St,"class","icon icon-link"),f(oe,"aria-hidden","true"),f(oe,"tabindex","-1"),f(oe,"href","#channel의-close"),f(ae,"id","channel의-close"),f(Dt,"class","icon icon-link"),f(re,"aria-hidden","true"),f(re,"tabindex","-1"),f(re,"href","#메모리-공유"),f(se,"id","메모리-공유"),f(jt,"class","icon icon-link"),f(ue,"aria-hidden","true"),f(ue,"tabindex","-1"),f(ue,"href","#non-blocking-channel"),f(ce,"id","non-blocking-channel"),f(pl,"class","language-go"),f(fl,"class","language-go"),f(Ea,"class","icon icon-link"),f(he,"aria-hidden","true"),f(he,"tabindex","-1"),f(he,"href","#mutex"),f(de,"id","mutex"),f(ba,"class","icon icon-link"),f(_e,"aria-hidden","true"),f(_e,"tabindex","-1"),f(_e,"href","#rwmutex"),f(ve,"id","rwmutex"),f(Sa,"class","icon icon-link"),f(Le,"aria-hidden","true"),f(Le,"tabindex","-1"),f(Le,"href","#waitgroup"),f(ke,"id","waitgroup"),f(Ua,"class","icon icon-link"),f(Ce,"aria-hidden","true"),f(Ce,"tabindex","-1"),f(Ce,"href","#conditional-variable"),f(be,"id","conditional-variable"),f(Za,"class","icon icon-link"),f(Se,"aria-hidden","true"),f(Se,"tabindex","-1"),f(Se,"href","#references"),f(Re,"id","references"),zf(ml.src,_u="https://learning.oreilly.com/covers/urn:orm:book:9781804619070/400w/")||f(ml,"src",_u),f(ml,"alt","Effective Concurrency in Go"),f(Ye,"href","https://learning.oreilly.com/library/view/effective-concurrency-in/9781804619070/"),f(Ye,"rel","nofollow"),f(ge,"href","https://learning.oreilly.com/library/view/effective-concurrency-in/9781804619070/"),f(ge,"rel","nofollow")},m(t,u){p(t,d,u),e(d,W),e(d,w),e(w,Wn),e(d,wn),p(t,lo,u),p(t,ll,u),e(ll,Dn),p(t,to,u),p(t,ao,u),p(t,oo,u),p(t,no,u),p(t,z,u),e(z,F),e(F,Tl),e(z,An),p(t,so,u),p(t,ro,u),p(t,io,u),p(t,K,u),e(K,Q),e(Q,$l),e(K,Bn),p(t,co,u),p(t,m,u),e(m,Me),e(Me,Vl),e(Vl,Hn),e(Me,Nn),e(Me,h),e(h,ql),e(ql,Tn),e(h,$n),e(h,jl),e(jl,Vn),e(h,qn),e(h,zl),e(zl,jn),e(h,zn),e(h,Fl),e(Fl,Fn),e(h,Kn),e(h,Kl),e(Kl,Qn),e(m,Zn),e(m,We),e(We,Ql),e(Ql,Jn),e(We,Xn),e(We,Zl),e(Zl,Jl),e(Jl,Yn),e(m,gn),e(m,we),e(we,Xl),e(Xl,es),e(we,ls),e(we,Yl),e(Yl,gl),e(gl,ts),p(t,uo,u),p(t,Z,u),e(Z,J),e(J,et),e(Z,as),p(t,po,u),p(t,I,u),e(I,lt),e(lt,tt),e(tt,os),e(I,ns),e(I,De),e(De,at),e(at,ss),e(De,rs),e(De,Ae),e(Ae,D),e(D,is),e(D,ot),e(ot,cs),e(D,us),e(D,nt),e(nt,ps),e(D,fs),e(Ae,ds),e(Ae,st),e(st,hs),e(I,Es),e(I,Be),e(Be,rt),e(rt,vs),e(Be,_s),e(Be,He),e(He,it),e(it,ks),e(He,Ls),e(He,tl),e(tl,ct),e(ct,bs),e(tl,Cs),p(t,fo,u),p(t,X,u),e(X,Y),e(Y,ut),e(X,ms),p(t,ho,u),p(t,al,u),e(al,ol),e(ol,Is),e(ol,pt),e(pt,nl),e(nl,xs),e(nl,ft),e(ft,dt),e(dt,Rs),p(t,Eo,u),p(t,vo,u),p(t,_o,u),p(t,ko,u),p(t,g,u),e(g,ee),e(ee,ht),e(g,Ss),p(t,Lo,u),p(t,bo,u),p(t,Co,u),p(t,le,u),e(le,te),e(te,Et),e(le,ys),p(t,mo,u),p(t,x,u),e(x,vt),e(vt,_t),e(_t,Ps),e(x,Gs),e(x,kt),e(kt,Lt),e(Lt,Os),e(x,Us),e(x,k),e(k,bt),e(bt,Ms),e(k,Ws),e(k,Ct),e(Ct,mt),e(mt,ws),e(k,Ds),e(k,sl),sl.innerHTML=wf,e(k,As),e(k,A),e(A,It),e(It,Bs),e(A,Hs),e(A,xt),e(xt,Ns),e(A,Ts),e(A,Rt),e(Rt,$s),p(t,Io,u),p(t,ae,u),e(ae,oe),e(oe,St),e(ae,Vs),p(t,xo,u),p(t,v,u),e(v,rl),e(rl,qs),e(rl,yt),e(yt,Pt),e(Pt,js),e(v,zs),e(v,ne),e(ne,Fs),e(ne,Gt),e(Gt,Ks),e(ne,Qs),e(ne,Ot),e(Ot,Ut),e(Ut,Zs),e(v,Js),e(v,il),e(il,Xs),e(il,Mt),e(Mt,Wt),e(Wt,Ys),e(v,gs),e(v,wt),e(wt,er),p(t,Ro,u),p(t,se,u),e(se,re),e(re,Dt),e(se,lr),p(t,So,u),p(t,ie,u),e(ie,B),e(B,tr),e(B,At),e(At,ar),e(B,or),e(B,Bt),e(Bt,nr),e(B,sr),e(ie,rr),e(ie,R),e(R,ir),e(R,Ht),e(Ht,cr),e(R,ur),e(R,Nt),e(Nt,pr),e(R,fr),e(R,Ne),e(Ne,cl),e(cl,dr),e(cl,Te),e(Te,Tt),e(Tt,hr),e(Te,Er),e(Te,$t),e($t,vr),e(Ne,_r),e(Ne,ul),e(ul,kr),e(ul,Vt),e(Vt,qt),e(qt,Lr),p(t,yo,u),p(t,ce,u),e(ce,ue),e(ue,jt),e(ce,br),p(t,Po,u),p(t,S,u),e(S,$e),e($e,zt),e(zt,Cr),e($e,mr),e($e,Ve),e(Ve,Ft),e(Ft,Ir),e(Ve,xr),e(Ve,Kt),e(Kt,Rr),e(S,Sr),e(S,L),e(L,pe),e(pe,Qt),e(Qt,yr),e(pe,Pr),e(pe,Zt),e(Zt,Gr),e(pe,Or),e(L,Ur),e(L,qe),e(qe,Jt),e(Jt,Mr),e(qe,Wr),e(qe,je),e(je,wr),e(je,Xt),e(Xt,Dr),e(je,Ar),e(L,Br),e(L,pl),pl.innerHTML=Df,e(L,Hr),e(L,ze),e(ze,_),e(_,Yt),e(Yt,Nr),e(_,Tr),e(_,gt),e(gt,$r),e(_,Vr),e(_,ea),e(ea,qr),e(_,jr),e(_,la),e(la,zr),e(_,Fr),e(ze,Kr),e(ze,ta),e(ta,Qr),e(S,Zr),e(S,H),e(H,fe),e(fe,aa),e(aa,Jr),e(fe,Xr),e(fe,oa),e(oa,Yr),e(fe,gr),e(H,ei),e(H,fl),fl.innerHTML=Af,e(H,li),e(H,b),e(b,C),e(C,ti),e(C,na),e(na,ai),e(C,oi),e(C,sa),e(sa,ni),e(C,si),e(C,ra),e(ra,ri),e(C,ii),e(b,ci),e(b,N),e(N,ui),e(N,ia),e(ia,pi),e(N,fi),e(N,ca),e(ca,di),e(N,hi),e(b,Ei),e(b,E),e(E,vi),e(E,ua),e(ua,_i),e(E,ki),e(E,pa),e(pa,Li),e(E,bi),e(E,fa),e(fa,Ci),e(E,mi),e(E,da),e(da,Ii),e(E,xi),e(b,Ri),e(b,ha),e(ha,Si),p(t,Go,u),p(t,Oo,u),p(t,Uo,u),p(t,Mo,u),p(t,de,u),e(de,he),e(he,Ea),e(de,yi),p(t,Wo,u),p(t,wo,u),p(t,Do,u),p(t,y,u),e(y,Fe),e(Fe,Pi),Ff(Ee,Fe,null),e(Fe,Gi),e(y,Oi),e(y,T),e(T,Ui),e(T,va),e(va,Mi),e(T,Wi),e(T,_a),e(_a,wi),e(T,Di),e(y,Ai),e(y,dl),e(dl,Bi),e(dl,ka),e(ka,La),e(La,Hi),p(t,Ao,u),p(t,ve,u),e(ve,_e),e(_e,ba),e(ve,Ni),p(t,Bo,u),p(t,P,u),e(P,Ca),e(Ca,Ti),e(P,$i),e(P,hl),e(hl,Vi),e(hl,ma),e(ma,Ia),e(Ia,qi),e(P,ji),e(P,El),e(El,zi),e(El,Ke),e(Ke,xa),e(xa,Fi),e(Ke,Ki),e(Ke,Ra),e(Ra,Qi),p(t,Ho,u),p(t,No,u),p(t,To,u),p(t,$o,u),p(t,ke,u),e(ke,Le),e(Le,Sa),e(ke,Zi),p(t,Vo,u),p(t,qo,u),p(t,jo,u),p(t,G,u),e(G,ya),e(ya,Ji),e(G,Xi),e(G,Pa),e(Pa,Yi),e(G,gi),e(G,vl),e(vl,ec),e(vl,Qe),e(Qe,Ze),e(Ze,lc),e(Ze,Ga),e(Ga,tc),e(Ze,ac),e(Qe,oc),e(Qe,_l),e(_l,Oa),e(Oa,nc),e(_l,sc),p(t,zo,u),p(t,Fo,u),p(t,Ko,u),p(t,Qo,u),p(t,be,u),e(be,Ce),e(Ce,Ua),e(be,rc),p(t,Zo,u),p(t,Jo,u),p(t,Xo,u),p(t,O,u),e(O,Ma),e(Ma,ic),e(O,cc),e(O,Wa),e(Wa,uc),e(O,pc),e(O,wa),e(wa,fc),p(t,Yo,u),p(t,me,u),e(me,Da),e(Da,Aa),e(Aa,dc),e(me,hc),e(me,$),e($,Ba),e(Ba,Ec),e($,vc),e($,Ha),e(Ha,_c),e($,kc),e($,kl),e(kl,Lc),e(kl,Na),e(Na,Ta),e(Ta,bc),p(t,go,u),p(t,Ie,u),e(Ie,Je),e(Je,$a),e($a,Cc),e(Je,mc),e(Je,V),e(V,Ll),e(Ll,Va),e(Va,Ic),e(Ll,xc),e(V,Rc),e(V,bl),e(bl,qa),e(qa,Sc),e(bl,yc),e(V,Pc),e(V,xe),e(xe,ja),e(ja,Gc),e(xe,Oc),e(xe,za),e(za,Uc),e(xe,Mc),e(Ie,Wc),e(Ie,Xe),e(Xe,Fa),e(Fa,wc),e(Xe,Dc),e(Xe,Ka),e(Ka,Qa),e(Qa,Ac),p(t,en,u),p(t,ln,u),p(t,tn,u),p(t,an,u),p(t,Re,u),e(Re,Se),e(Se,Za),e(Re,Bc),p(t,on,u),p(t,nn,u),p(t,sn,u),p(t,Cl,u),e(Cl,q),e(q,Ye),e(Ye,ml),e(q,Hc),e(q,Nc),e(q,Tc),e(q,ge),e(ge,$c),rn=!0},p(t,[u]){const Ja={};u&1&&(Ja.$$scope={dirty:u,ctx:t}),Ee.$set(Ja)},i(t){rn||(Kf(Ee.$$.fragment,t),rn=!0)},o(t){Qf(Ee.$$.fragment,t),rn=!1},d(t){t&&l(d),t&&l(lo),t&&l(ll),t&&l(to),t&&l(ao),t&&l(oo),t&&l(no),t&&l(z),t&&l(so),t&&l(ro),t&&l(io),t&&l(K),t&&l(co),t&&l(m),t&&l(uo),t&&l(Z),t&&l(po),t&&l(I),t&&l(fo),t&&l(X),t&&l(ho),t&&l(al),t&&l(Eo),t&&l(vo),t&&l(_o),t&&l(ko),t&&l(g),t&&l(Lo),t&&l(bo),t&&l(Co),t&&l(le),t&&l(mo),t&&l(x),t&&l(Io),t&&l(ae),t&&l(xo),t&&l(v),t&&l(Ro),t&&l(se),t&&l(So),t&&l(ie),t&&l(yo),t&&l(ce),t&&l(Po),t&&l(S),t&&l(Go),t&&l(Oo),t&&l(Uo),t&&l(Mo),t&&l(de),t&&l(Wo),t&&l(wo),t&&l(Do),t&&l(y),Zf(Ee),t&&l(Ao),t&&l(ve),t&&l(Bo),t&&l(P),t&&l(Ho),t&&l(No),t&&l(To),t&&l($o),t&&l(ke),t&&l(Vo),t&&l(qo),t&&l(jo),t&&l(G),t&&l(zo),t&&l(Fo),t&&l(Ko),t&&l(Qo),t&&l(be),t&&l(Zo),t&&l(Jo),t&&l(Xo),t&&l(O),t&&l(Yo),t&&l(me),t&&l(go),t&&l(Ie),t&&l(en),t&&l(ln),t&&l(tn),t&&l(an),t&&l(Re),t&&l(on),t&&l(nn),t&&l(sn),t&&l(Cl)}}}const ld={title:"Go의 동시성 지원",date:"2023-08-25T00:00:00.000Z",excerpt:"Go에서 동시성을 지원하는 방법들",categories:["Golang","Concurrency in Go"],coverImage:"/post_img/Go/Concurrency in Go/cover.png",coverWidth:16,coverHeight:9,indexed:!1,exposed:!0};class td extends Tf{constructor(d){super(),$f(this,d,null,Yf,Vf,{})}}export{td as default,ld as metadata};
