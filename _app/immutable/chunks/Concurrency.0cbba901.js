import{S as od,i as sd,s as fd,k as r,q as o,a as c,y as et,l as i,m as a,r as s,h as t,c as u,z as lt,n as h,b as n,E as e,A as tt,g as rt,d as it,B as at}from"./index.d78780bf.js";import{H as wi}from"./Highlight.1019e7a6.js";import{I as nd}from"./Image.605b14b5.js";function cd(b){let v;return{c(){v=o("작성되는 방식")},l(d){v=s(d,"작성되는 방식")},m(d,_){n(d,v,_)},d(d){d&&t(v)}}}function ud(b){let v;return{c(){v=o("실행되는 방식")},l(d){v=s(d,"실행되는 방식")},m(d,_){n(d,v,_)},d(d){d&&t(v)}}}function hd(b){let v;return{c(){v=o("Context Switching")},l(d){v=s(d,"Context Switching")},m(d,_){n(d,v,_)},d(d){d&&t(v)}}}function dd(b){let v;return{c(){v=o("Total Order")},l(d){v=s(d,"Total Order")},m(d,_){n(d,v,_)},d(d){d&&t(v)}}}function vd(b){let v;return{c(){v=o("Partial Order")},l(d){v=s(d,"Partial Order")},m(d,_){n(d,v,_)},d(d){d&&t(v)}}}function Ed(b){let v,d,_,Ro,Wi,Pl,ot,No,Xi,Ki,Qi,ji,K,Q,st,Mo,zi,Zi,Fi,j,z,ft,Bo,Ji,Z,nt,p,Ho,ct,Go,To,Oo,ut,Do,qo,wo,Wo,Xo,ht,H,Ko,dt,Qo,jo,zo,Zo,Vi,F,J,vt,Fo,Yi,bl,I,Jo,Et,Vo,Yo,go,_t,es,ls,ts,gi,V,Y,pt,rs,ea,A,is,g,as,ee,os,la,ta,ra,ia,le,te,mt,ss,aa,oa,sa,y,Lt,fs,ns,St,cs,us,Pt,hs,fa,re,ie,bt,ds,na,m,It,vs,Es,Il,_s,G,el,ps,ae,ms,Ls,kt,Ss,Ps,$t,bs,Is,kl,Ct,ks,$s,Cs,oe,xt,xs,As,At,ys,Us,ca,$l,yt,Rs,ua,Cl,xl,Ns,k,T,Ms,Ut,Bs,Hs,Rt,Gs,Ts,Os,se,Nt,Ds,qs,Mt,ws,Ws,Xs,fe,Bt,Ks,Qs,Ht,js,zs,Zs,O,Gt,Fs,Js,Tt,Vs,Ys,Ot,ll,gs,Dt,ef,lf,ha,ne,ce,qt,tf,da,Al,rf,va,U,yl,af,tl,wt,of,sf,Wt,ff,nf,Xt,cf,uf,Ul,hf,Kt,Qt,df,Ea,Rl,vf,_a,ue,he,jt,Ef,pa,R,zt,_f,pf,Nl,mf,Zt,rl,Lf,de,Sf,Pf,Ml,bf,Ft,il,If,ve,kf,ma,Ee,_e,Jt,$f,La,pe,al,Vt,Cf,xf,$,Yt,Af,yf,gt,Uf,Rf,er,Nf,Mf,lr,Bf,Hf,ol,tr,Gf,Tf,D,rr,Of,Df,ir,qf,wf,ar,Wf,Sa,Pa,ba,Ia,me,Le,or,Xf,ka,$a,Ca,Se,Pe,sr,Kf,xa,L,sl,fr,Qf,jf,fl,nr,zf,Zf,cr,Ff,Jf,nl,ur,Vf,Yf,cl,hr,gf,en,dr,ln,tn,vr,Er,rn,an,ul,_r,on,sn,hl,pr,fn,nn,Bl,cn,q,mr,un,hn,Lr,dn,vn,Sr,En,Aa,be,Ie,Pr,_n,ya,N,br,Ir,pn,mn,kr,$r,Ln,Sn,Cr,xr,Pn,Ua,ke,$e,Ar,bn,Ra,Ce,dl,yr,In,kn,Ur,Rr,$n,Cn,Nr,Mr,xn,Na,xe,Ae,Br,An,Ma,S,Hr,Gr,yn,Un,Tr,Or,Rn,Nn,Dr,qr,Mn,Bn,vl,wr,Hn,Gn,w,Wr,Tn,On,Xr,Dn,qn,Kr,wn,Ba,Ha,Ga,Ta,ye,Ue,Qr,Wn,Oa,Da,qa,Re,Ne,jr,Xn,wa,E,zr,Zr,Kn,Qn,Fr,Jr,jn,zn,Vr,Yr,Zn,Fn,gr,ei,Jn,Vn,El,Hl,li,Yn,gn,ec,W,ti,lc,tc,ri,rc,ic,ii,ac,Wa,Me,Be,ai,oc,Xa,He,oi,sc,fc,Ge,nc,si,cc,uc,_l,pl,hc,fi,dc,vc,Ec,Gl,_c,ni,ci,pc,Ka,Te,Oe,ui,mc,Qa,M,hi,di,Lc,Sc,ml,vi,Pc,bc,C,Ei,Ic,kc,_i,$c,Cc,pi,xc,Ac,mi,yc,Uc,Li,Si,Rc,ja,Tl,Pi,Nc,za,De,qe,bi,Mc,Za,we,Ii,Bc,Hc,ki,Gc,Fa,Ol,$i,Tc,Ja,We,Xe,Ci,Oc,Va,P,xi,Dc,qc,Ai,wc,Wc,yi,Xc,Kc,Ui,Qc,Ya,ga,eo,lo,Ke,Qe,Ri,jc,to,ro,io,x,Ni,zc,Zc,Ll,Fc,Jc,Vc,ao;return g=new wi({props:{$$slots:{default:[cd]},$$scope:{ctx:b}}}),ee=new wi({props:{$$slots:{default:[ud]},$$scope:{ctx:b}}}),ae=new wi({props:{$$slots:{default:[hd]},$$scope:{ctx:b}}}),de=new wi({props:{$$slots:{default:[dd]},$$scope:{ctx:b}}}),ve=new wi({props:{$$slots:{default:[vd]},$$scope:{ctx:b}}}),Ll=new nd({props:{alt:"Effective Concurrency in Go",src:"https://learning.oreilly.com/covers/urn:orm:book:9781804619070/400w/"}}),{c(){v=r("p"),d=r("strong"),_=o("Effective Concurrency in Go"),Ro=o("를 읽던 중, 동시성 관련해서 좋은 내용들이 많이 나와서 한 번 개념을 정리해보았읍니다."),Wi=c(),Pl=r("ul"),ot=r("li"),No=o("본 포스트 안에서 쓰레드와 고루틴을 혼용해서 사용했는데, 얼추 비슷한 애들이라고 생각하시면 됩니다."),Xi=c(),Ki=r("br"),Qi=r("br"),ji=c(),K=r("h2"),Q=r("a"),st=r("span"),Mo=o("동시성(Concurrency) vs 병렬성(Parallelism)"),zi=c(),Zi=r("hr"),Fi=c(),j=r("h3"),z=r("a"),ft=r("span"),Bo=o("동시성(Concurrency)"),Ji=c(),Z=r("ul"),nt=r("li"),p=r("p"),Ho=o("여러 작업을 동시에 수행하는 것"),ct=r("strong"),Go=o("처럼 보이는 것"),To=r("br"),Oo=o(`
실제로는 여러 작업을 `),ut=r("strong"),Do=o("동시에 수행하는 것이 아니라, 짧은 시간 간격으로 번갈아가며 수행하는 것"),qo=o("이다."),wo=r("br"),Wo=o(`
싱글 코어에서도 동시성을 구현할 수 있음.`),Xo=c(),ht=r("li"),H=r("p"),Ko=o("엄밀한 정의는, "),dt=r("strong"),Qo=o("결과에 영향을 주지 않고, 프로그램의 서로 다른 부분이 partial order 또는 순서에 관계없이 실행될 수 있는 것"),jo=o("을 의미함."),zo=r("br"),Zo=o(`
프로그램이 A,B,C로 구성되어 있을 때, A,C,B 또는 B,C,A 등로 실행되어도 결과에 영향을 주지 않는다면, 이 프로그램은 동시성을 가지고 있다고 할 수 있음.`),Vi=c(),F=r("h3"),J=r("a"),vt=r("span"),Fo=o("병렬성(Parallelism)"),Yi=c(),bl=r("ul"),I=r("li"),Jo=o("여러 작업을 "),Et=r("strong"),Vo=o("동시에 수행하는 것"),Yo=r("br"),go=o(`
실제로 여러 작업이 `),_t=r("strong"),es=o("동시에 수행됨"),ls=r("br"),ts=o(`
멀티 코어, 즉 서로 다른 CPU 코어에서 돌아가는 프로세스나 쓰레드가 이에 해당함.`),gi=c(),V=r("h3"),Y=r("a"),pt=r("span"),rs=o("동시성과 병렬성의 차이"),ea=c(),A=r("p"),is=o("동시성은 프로그램이 "),et(g.$$.fragment),as=o("에 관련된 것이고, 병렬성은 프로그램이 "),et(ee.$$.fragment),os=o("에 관련된 것이다."),la=c(),ta=r("br"),ra=r("br"),ia=c(),le=r("h2"),te=r("a"),mt=r("span"),ss=o("동시성 프로그래밍"),aa=c(),oa=r("hr"),sa=c(),y=r("ul"),Lt=r("li"),fs=o("문제를 실행 단위로 나누어 time sharing 또는 병렬적으로 실행될 수 있게끔 하는 것"),ns=c(),St=r("li"),cs=o("이들은 서로 병렬적으로 또는 인터리빙(interleaving)되어 실행될 수 있으며, 메시지를 통해 통신할 수 있음."),us=c(),Pt=r("li"),hs=o("따라서 동시성 프로그래밍은 객체지향이나 함수형 프로그래밍처럼, 프로그램을 작성하는 방식이라고도 할 수 있음."),fa=c(),re=r("h3"),ie=r("a"),bt=r("span"),ds=o("Time Sharing과 Context Switching"),na=c(),m=r("ul"),It=r("li"),vs=o("컴퓨팅 리소스(주로 CPU)를 여러 프로그램이 공유하는 것."),Es=c(),Il=r("li"),_s=o("어떤 프로세스가 여러 쓰레드로 구성되어 있다 할 때, 한 쓰레드가 일정한 time quantum 동안 CPU를 사용하고, 그 다음 쓰레드가 CPU를 사용하는 방식으로 진행됨."),G=r("ul"),el=r("li"),ps=o("이를 "),et(ae.$$.fragment),ms=o("이라고 함."),Ls=c(),kt=r("li"),Ss=o("쓰레드의 실행 컨텍스트에는 해당 쓰레드의 state(레지스터 값, 프로그램 카운터, Stack Pointer 등)가 저장되어 있음."),Ps=c(),$t=r("li"),bs=o("Context Switching이 발생하면, 현재 쓰레드의 state가 저장되고, 다음 쓰레드의 state가 복원됨."),Is=c(),kl=r("li"),Ct=r("strong"),ks=o("Preemptive Thread Scheduling"),$s=o("에서는 쓰레드가 실행되는 도중 Context Switching이 발생할 수 있음."),Cs=c(),oe=r("li"),xt=r("strong"),xs=o("Non-Preemptive Thread Scheduling"),As=o("("),At=r("strong"),ys=o("Cooperative Threading"),Us=o(")에서는 쓰레드가 실행을 마칠 때까지 Context Switching이 발생하지 않음."),ca=c(),$l=r("blockquote"),yt=r("p"),Rs=o("정보) Go 언어에서는 1.14 이전까지는 Non-Preemptive Thread Scheduling을 사용하였으나, 1.14부터 Preemptive Thread Scheduling을 사용하도록 변경되었다."),ua=c(),Cl=r("ul"),xl=r("li"),Ns=o("쓰레드의 상태와 스케줄링"),k=r("ul"),T=r("li"),Ms=o("쓰레드가 실행되면 "),Ut=r("em"),Bs=o("Ready"),Hs=o(" state로 들어가고, CPU를 사용할 수 있을 때 "),Rt=r("em"),Gs=o("Running"),Ts=o(" state로 들어감."),Os=c(),se=r("li"),Nt=r("em"),Ds=o("Running"),qs=o(" state의 쓰레드는 time quantum이 끝나면 다시 "),Mt=r("em"),ws=o("Ready"),Ws=o(" state로 돌아감."),Xs=c(),fe=r("li"),Bt=r("em"),Ks=o("Running"),Qs=o(" state의 쓰레드가 I/O 작업 등으로 인한 인터럽트가 발생하거나, lock을 획득하지 못하면 "),Ht=r("em"),js=o("Blocked"),zs=o(" state로 들어감."),Zs=c(),O=r("li"),Gt=r("em"),Fs=o("Blocked"),Js=o(" state의 쓰레드는 I/O 작업이 끝나거나, lock을 획득하면 다시 "),Tt=r("em"),Vs=o("Ready"),Ys=o(" state로 돌아가게 되고, 스케줄러에 의해 선택되기를 기다림."),Ot=r("ul"),ll=r("li"),gs=o("이 때 "),Dt=r("em"),ef=o("Ready"),lf=o(" state의 쓰레드가 바로 실행되리라는 보장은 없음."),ha=c(),ne=r("h3"),ce=r("a"),qt=r("span"),tf=o("동시성 프로그래밍은 왜 어려운가?"),da=c(),Al=r("p"),rf=o("상태 관리의 어려움 때문임"),va=c(),U=r("ul"),yl=r("li"),af=o("각각의 Sequantial Program은 상태(state)를 가지고 있음."),tl=r("ul"),wt=r("li"),of=o("state는 Sequantial Program의 실행 위치와 메모리에 저장된 값을 의미함"),sf=c(),Wt=r("li"),ff=o("프로그램의 현재 state에 따라 다음 state를 예측할 수 있음"),nf=c(),Xt=r("li"),cf=o("그런데 동시에 여러 프로그램이 실행되면 각각의 Sequantial Program이 가지고 있는 state가 서로 영향을 미칠 수 있음."),uf=c(),Ul=r("li"),hf=o("Sequantial Program이 많아질수록, 가능한 state의 수가 많아질수록 전체 프로그램이 가질 수 있는 state의 경우의 수가 기하급수적으로 증가함"),Kt=r("ul"),Qt=r("li"),df=o("n개의 state가 있는 Sequantial Program이 m개 실행되면 n^m개의 state가 존재함"),Ea=c(),Rl=r("p"),vf=o("따라서, 일반적인 state 분석으로 동시성 프로그램의 행동을 예측하기 어려움."),_a=c(),ue=r("h3"),he=r("a"),jt=r("span"),Ef=o("Happened-Before 관계"),pa=c(),R=r("ul"),zt=r("li"),_f=o("두 개의 서로 같지 않은 정수가 있다면, 이들의 대소 관계를 알 수 있음."),pf=c(),Nl=r("li"),mf=o("마찬가지로 한 Sequantial Program에서 발생한 서로 다른 두 이벤트가 있다면, 한 이벤트는 반드시 다른 이벤트보다 먼저 발생했을 것임."),Zt=r("ul"),rl=r("li"),Lf=o("이를 "),et(de.$$.fragment),Sf=o("라고 함."),Pf=c(),Ml=r("li"),bf=o("서로 다른 프로세스에서 발생한 이벤트에 순서를 정하는 것은 불가능하지만, Message Passing 등을 통해 이벤트의 순서를 일부 정의할 수 있음."),Ft=r("ul"),il=r("li"),If=o("이를 "),et(ve.$$.fragment),kf=o("라고 함."),ma=c(),Ee=r("h3"),_e=r("a"),Jt=r("span"),$f=o("Dining Philosopher Problem"),La=c(),pe=r("ul"),al=r("li"),Vt=r("p"),Cf=o("문제 정의"),xf=c(),$=r("ul"),Yt=r("li"),Af=o("철학자들이 원형 테이블에 앉아있음."),yf=c(),gt=r("li"),Uf=o("테이블 위에는 포크가 5개 놓여있음."),Rf=c(),er=r("li"),Nf=o("철학자들은 생각을 하다가 배가 고파지면 양 옆의 포크를 집어들어 먹기 시작함."),Mf=c(),lr=r("li"),Bf=o("식사를 마치면 포크를 내려놓고 다시 생각을 하기 시작함."),Hf=c(),ol=r("li"),tr=r("p"),Gf=o("Deadlock 발생 가능성"),Tf=c(),D=r("ul"),rr=r("li"),Of=o("모든 철학자가 자신의 왼쪽 포크만을 집어든 상태라면, 모든 철학자는 다음 포크를 집어들기 위해 오른쪽 철학자가 포크를 내려놓기를 기다려야 함."),Df=c(),ir=r("li"),qf=o("이 상태에서는 모든 철학자가 포크를 내려놓기를 기다리는 상태로 무한 대기 상태에 빠짐."),wf=c(),ar=r("li"),Wf=o("한 철학자가 자신의 포크를 내려놓지 않는 이상, 다른 철학자들은 포크를 집어들 수 없음."),Sa=c(),Pa=r("br"),ba=r("br"),Ia=c(),me=r("h2"),Le=r("a"),or=r("span"),Xf=o("Shared Memory와 Message Passing"),ka=c(),$a=r("hr"),Ca=c(),Se=r("h3"),Pe=r("a"),sr=r("span"),Kf=o("관련 Computer Architecture 지식"),xa=c(),L=r("ul"),sl=r("li"),fr=r("p"),Qf=o("UMA(Uniform Memory Access)"),jf=c(),fl=r("ul"),nr=r("li"),zf=o("메모리에 접근할 때 모든 프로세서가 동일한 권한을 가지고 있음."),Zf=c(),cr=r("li"),Ff=o("동일한 메모리 액세스 버스가 공유되기 때문에 처리량이 감소할 수 있음."),Jf=c(),nl=r("li"),ur=r("p"),Vf=o("NUMA(Non-Uniform Memory Access)"),Yf=c(),cl=r("ul"),hr=r("li"),gf=o("프로세서는 메모리의 특정 영역에 대해서만 접근 권한을 가짐"),en=c(),dr=r("li"),ln=o("OS가 프로세서에서 필요한 메모리를 해당 영역에 할당함으로써 전용 메모리 액세스 버스를 사용할 수 있기 때문에 처리량이 증가할 수 있음."),tn=c(),vr=r("li"),Er=r("p"),rn=o("대부분의 프로세서는 캐시 메모리를 사용하며, 캐시 일관성(Cache Coherence) 프로토콜을 사용하여 캐시 메모리의 일관성을 유지함."),an=c(),ul=r("li"),_r=r("p"),on=o("현대 프로세서는 메모리 read 및 write가 완료될 때까지 기다리지 않음. 파이프라이닝(Pipelining)을 통해 다음 명령어를 동시에 실행함."),sn=c(),hl=r("ul"),pr=r("li"),fn=o("이 때 파이프라이닝의 최적화를 위해서 컴파일러가 명령어의 순서를 바꿀 수 있음."),nn=c(),Bl=r("li"),cn=o("그래서 한 쓰레드에서 읽은 메모리의 값이 다른 쓰레드에서 쓰인(write) 값이라고 확신할 수 없음."),q=r("ul"),mr=r("li"),un=o("따라서 컴파일러 및 프로세서가 모든 변경사항을 메모리에 커밋(commit)하는 방법이 필요함."),hn=c(),Lr=r("li"),dn=o("메모리 배리어(Memory Barrier)는 가장 저수준의 메모리 일관성 프로토콜로, 프로세서와 컴파일러에 특정 순서 제약을 강제함. 메모리 배리어 이전에 실행되는 모든 작업은 반드시 메모리 배리어 이후에 실행되는 명령어보다 먼저 완료되어야 함."),vn=c(),Sr=r("li"),En=o("Go의 채널, Atomic 연산, 뮤텍스, condition variable 등은 모두 메모리 배리어를 사용함."),Aa=c(),be=r("h3"),Ie=r("a"),Pr=r("span"),_n=o("Shared Memory"),ya=c(),N=r("ul"),br=r("li"),Ir=r("p"),pn=o("단일 프로그램 내에서 Shared memory란 일반적으로 여러 쓰레드가 공유하는 변수 등의 메모리 공간을 의미함."),mn=c(),kr=r("li"),$r=r("p"),Ln=o(`Shared Memory를 통해 통신하는 경우 버그가 발생할 수 있는 가능성이 높아짐.
이 때 동시성으로 인해 발생하는 버그는 사실상 무작위적으로 발생하기에, 버그를 재현 및 디버깅하기가 어려움.`),Sn=c(),Cr=r("li"),xr=r("p"),Pn=o("lock을 통해 Happened-Before 관계를 정의함"),Ua=c(),ke=r("h3"),$e=r("a"),Ar=r("span"),bn=o("Message Passing"),Ra=c(),Ce=r("ul"),dl=r("li"),yr=r("p"),In=o("UNIX나 LINUX의 철학은 프로세스가 서로 독립적이어야 하며, 메시지를 송수신하는 방식으로 통신해야 한다는 것임."),kn=c(),Ur=r("ul"),Rr=r("li"),$n=o("프로세스는 한 종류의 일을 잘 하도록 설계되며, 이러한 프로세스들이 모여 시스템을 구성함."),Cn=c(),Nr=r("li"),Mr=r("p"),xn=o("메시지를 통홰 Happened-Before 관계를 정의함. (메시지 패싱을 통해 두 쓰레드는 작업의 선후 관계를 정의할 수 있음)"),Na=c(),xe=r("h3"),Ae=r("a"),Br=r("span"),An=o("Hybrid Approach"),Ma=c(),S=r("ul"),Hr=r("li"),Gr=r("p"),yn=o("Shared Memory와 Message Passing을 혼용하는 방식"),Un=c(),Tr=r("li"),Or=r("p"),Rn=o("보통 Shared Memory는 빠르고 활용성이 좋지만 data race가 발생할 수 있는 위협이 있음. 이러한 경우 Message Passing을 사용함."),Nn=c(),Dr=r("li"),qr=r("p"),Mn=o("하지만 의도치 않게 메모리를 공유되는 경우가 발생할 수 있음."),Bn=c(),vl=r("li"),wr=r("p"),Hn=o("Golang에서의 접근 방식"),Gn=c(),w=r("ul"),Wr=r("li"),Tn=o("어떤 고루틴이 데이터 객체를 채널로 전달하면, 해당 데이터 객체의 소유권을 잃음."),On=c(),Xr=r("li"),Dn=o("해당 채널에서 데이터 객체를 꺼낸 고루틴이 소유권을 가짐."),qn=c(),Kr=r("li"),wn=o("채널로 데이터 객체를 전달한 고루틴은, mutual exclusion을 충족시키지 않는 한 해당 데이터 객체에 다시 접근할 수 없음."),Ba=c(),Ha=r("br"),Ga=r("br"),Ta=c(),ye=r("h2"),Ue=r("a"),Qr=r("span"),Wn=o("Atomicity, Race, Deadlock, Starvation"),Oa=c(),Da=r("hr"),qa=c(),Re=r("h3"),Ne=r("a"),jr=r("span"),Xn=o("Race Condition"),wa=c(),E=r("ul"),zr=r("li"),Zr=r("p"),Kn=o("동시성 프로그램의 실행 순서 및 타이밍에 따라 실행 결과가 달라지는 것."),Qn=c(),Fr=r("li"),Jr=r("p"),jn=o("각 쓰레드가 인터리빙되어 실행되기 때문에 발생함."),zn=c(),Vr=r("li"),Yr=r("p"),Zn=o("이상적이지 않은 결과가 발생할 수 있음."),Fn=c(),gr=r("li"),ei=r("p"),Jn=o("실질적으로 재현이 어려움."),Vn=c(),El=r("li"),Hl=r("p"),li=r("strong"),Yn=o("Data race"),gn=o("는 다음과 같은 항목에 해당하는 Race Condition의 특수한 케이스임."),ec=c(),W=r("ul"),ti=r("li"),lc=o("두 개 이상의 쓰레드가 동일한 메모리에 접근함"),tc=c(),ri=r("li"),rc=o("한 개 이상의 쓰레드가 메모라에 쓰기 연산을 수행함"),ic=c(),ii=r("li"),ac=o("두 쓰레드의 작업 순서를 보장하기 위한 동기화 및 lock이 없음"),Wa=c(),Me=r("h3"),Be=r("a"),ai=r("span"),oc=o("Atomicity"),Xa=c(),He=r("ul"),oi=r("li"),sc=o("어떤 작업 및 그 하위 작업이 실행될 때 모두 완료되거나, 아니면 전혀 실행되지 않는 것을 의미함."),fc=c(),Ge=r("li"),nc=o("프로그램의 특정 영역에 반드시 한 쓰레드만 접근할 수 있게 하는 "),si=r("strong"),cc=o("Critical Section"),uc=o("을 사용하여 구현할 수 있음."),_l=r("ul"),pl=r("li"),hc=o("Mutual Exclusion(Mutex)를 통해 "),fi=r("strong"),dc=o("Critical Section"),vc=o("을 설정함."),Ec=c(),Gl=r("li"),_c=o("여러 shared object와 상호작용해야 하는 경우, Mutex의 사용이 복잡해짐."),ni=r("ul"),ci=r("li"),pc=o("상황에 따라 Deadlock이 발생할 수도 있음."),Ka=c(),Te=r("h3"),Oe=r("a"),ui=r("span"),mc=o("Deadlock"),Qa=c(),M=r("ul"),hi=r("li"),di=r("p"),Lc=o("두 개 이상의 쓰레드가 서로의 작업이 끝나기를 기다리는 상황"),Sc=c(),ml=r("li"),vi=r("p"),Pc=o("Deadlock이 발생하려면 Coffman 조건이 충족되어야 함."),bc=c(),C=r("ul"),Ei=r("li"),Ic=o("Mutual Exclusion: 한 쓰레드가 Critical Section에 들어가면, 다른 쓰레드는 해당 Critical Section에 들어갈 수 없음."),kc=c(),_i=r("li"),$c=o("Hold and Wait: 쓰레드는 어떤 자원을 점유한 상태에서, 다른 쓰레드가 점유한 자원을 기다림."),Cc=c(),pi=r("li"),xc=o("No Preemption: 쓰레드는 점유한 자원을 다른 쓰레드가 강제로 빼앗을 수 없음."),Ac=c(),mi=r("li"),yc=o("Circular Wait: 쓰레드 간에 자원을 순환적으로 기다림."),Uc=c(),Li=r("li"),Si=r("p"),Rc=o("Deadlock을 예방하기 위해 shared resoruce에 대한 일관된 lock 순서를 정의할 수 있으나, 모든 Deadlock을 예방할 수는 없음."),ja=c(),Tl=r("blockquote"),Pi=r("p"),Nc=o(`정보) Go에서는 모든 Goroutine이 Block된 상태이면 Deadlock이 발생했다고 판단하고, panic을 발생시킴.
그래서 모든 Goroutine이 아닌 일부 Goroutine에서만 Deadlock이 발생했다면 이를 감지하지 못함.`),za=c(),De=r("h3"),qe=r("a"),bi=r("span"),Mc=o("Starvation"),Za=c(),we=r("ul"),Ii=r("li"),Bc=o("일부 쓰레드가 Critical Section에 들어가기 위해 계속해서 기다리지만, 다른 쓰레드가 먼저 Critical Section에 들어감으로 인해 Critical Section에 지속적으로 접근하지 못하는 상황"),Hc=c(),ki=r("li"),Gc=o("DoS(Denial of Service) 공격의 기본 원리임."),Fa=c(),Ol=r("blockquote"),$i=r("p"),Tc=o("정보) Go 런타임은 특정 Goroutine이 Starvation 상태에 빠지는 것을 감지하지는 못한다."),Ja=c(),We=r("h3"),Xe=r("a"),Ci=r("span"),Oc=o("Livelock"),Va=c(),P=r("ul"),xi=r("li"),Dc=o("Deadlock처럼 보이지만, 쓰레드가 lock을 획득하려고 시도하는 연산을 계속 반복하기 때문에 실제로는 차단된 쓰레드가 없는 상황"),qc=c(),Ai=r("li"),wc=o("쓰레드가 작동하더라도 실제로는 유의미한 작업을 수행하지 못하기 때문에, Starvation과 유사함."),Wc=c(),yi=r("li"),Xc=o("Livelock은 몇번 반복하다 보면 해결될 수 있기 때문에 확인하기 어려움."),Kc=c(),Ui=r("li"),Qc=o("lock을 획득하기 위해 재시도 및 무작위적인 대기 시간을 추가하는 방법으로 해결할 수 있음."),Ya=c(),ga=r("br"),eo=r("br"),lo=c(),Ke=r("h2"),Qe=r("a"),Ri=r("span"),jc=o("References"),to=c(),ro=r("hr"),io=c(),x=r("center"),Ni=r("p"),zc=o("["),Zc=c(),et(Ll.$$.fragment),Fc=o(`
](https://learning.oreilly.com/library/view/effective-concurrency-in/9781804619070/)`),Jc=r("br"),Vc=o(`
[Burak Serdar, 『Effective Concurrency in Go』, Packt Publishing](https://learning.oreilly.com/library/view/effective-concurrency-in/9781804619070/)`),this.h()},l(l){v=i(l,"P",{});var f=a(v);d=i(f,"STRONG",{});var Mi=a(d);_=s(Mi,"Effective Concurrency in Go"),Mi.forEach(t),Ro=s(f,"를 읽던 중, 동시성 관련해서 좋은 내용들이 많이 나와서 한 번 개념을 정리해보았읍니다."),f.forEach(t),Wi=u(l),Pl=i(l,"UL",{});var Bi=a(Pl);ot=i(Bi,"LI",{});var Hi=a(ot);No=s(Hi,"본 포스트 안에서 쓰레드와 고루틴을 혼용해서 사용했는데, 얼추 비슷한 애들이라고 생각하시면 됩니다."),Hi.forEach(t),Bi.forEach(t),Xi=u(l),Ki=i(l,"BR",{}),Qi=i(l,"BR",{}),ji=u(l),K=i(l,"H2",{id:!0});var Dl=a(K);Q=i(Dl,"A",{"aria-hidden":!0,tabindex:!0,href:!0});var Gi=a(Q);st=i(Gi,"SPAN",{class:!0}),a(st).forEach(t),Gi.forEach(t),Mo=s(Dl,"동시성(Concurrency) vs 병렬성(Parallelism)"),Dl.forEach(t),zi=u(l),Zi=i(l,"HR",{}),Fi=u(l),j=i(l,"H3",{id:!0});var Yc=a(j);z=i(Yc,"A",{"aria-hidden":!0,tabindex:!0,href:!0});var Au=a(z);ft=i(Au,"SPAN",{class:!0}),a(ft).forEach(t),Au.forEach(t),Bo=s(Yc,"동시성(Concurrency)"),Yc.forEach(t),Ji=u(l),Z=i(l,"UL",{});var oo=a(Z);nt=i(oo,"LI",{});var yu=a(nt);p=i(yu,"P",{});var X=a(p);Ho=s(X,"여러 작업을 동시에 수행하는 것"),ct=i(X,"STRONG",{});var Uu=a(ct);Go=s(Uu,"처럼 보이는 것"),Uu.forEach(t),To=i(X,"BR",{}),Oo=s(X,`
실제로는 여러 작업을 `),ut=i(X,"STRONG",{});var Ru=a(ut);Do=s(Ru,"동시에 수행하는 것이 아니라, 짧은 시간 간격으로 번갈아가며 수행하는 것"),Ru.forEach(t),qo=s(X,"이다."),wo=i(X,"BR",{}),Wo=s(X,`
싱글 코어에서도 동시성을 구현할 수 있음.`),X.forEach(t),yu.forEach(t),Xo=u(oo),ht=i(oo,"LI",{});var Nu=a(ht);H=i(Nu,"P",{});var ql=a(H);Ko=s(ql,"엄밀한 정의는, "),dt=i(ql,"STRONG",{});var Mu=a(dt);Qo=s(Mu,"결과에 영향을 주지 않고, 프로그램의 서로 다른 부분이 partial order 또는 순서에 관계없이 실행될 수 있는 것"),Mu.forEach(t),jo=s(ql,"을 의미함."),zo=i(ql,"BR",{}),Zo=s(ql,`
프로그램이 A,B,C로 구성되어 있을 때, A,C,B 또는 B,C,A 등로 실행되어도 결과에 영향을 주지 않는다면, 이 프로그램은 동시성을 가지고 있다고 할 수 있음.`),ql.forEach(t),Nu.forEach(t),oo.forEach(t),Vi=u(l),F=i(l,"H3",{id:!0});var gc=a(F);J=i(gc,"A",{"aria-hidden":!0,tabindex:!0,href:!0});var Bu=a(J);vt=i(Bu,"SPAN",{class:!0}),a(vt).forEach(t),Bu.forEach(t),Fo=s(gc,"병렬성(Parallelism)"),gc.forEach(t),Yi=u(l),bl=i(l,"UL",{});var Hu=a(bl);I=i(Hu,"LI",{});var je=a(I);Jo=s(je,"여러 작업을 "),Et=i(je,"STRONG",{});var Gu=a(Et);Vo=s(Gu,"동시에 수행하는 것"),Gu.forEach(t),Yo=i(je,"BR",{}),go=s(je,`
실제로 여러 작업이 `),_t=i(je,"STRONG",{});var Tu=a(_t);es=s(Tu,"동시에 수행됨"),Tu.forEach(t),ls=i(je,"BR",{}),ts=s(je,`
멀티 코어, 즉 서로 다른 CPU 코어에서 돌아가는 프로세스나 쓰레드가 이에 해당함.`),je.forEach(t),Hu.forEach(t),gi=u(l),V=i(l,"H3",{id:!0});var eu=a(V);Y=i(eu,"A",{"aria-hidden":!0,tabindex:!0,href:!0});var Ou=a(Y);pt=i(Ou,"SPAN",{class:!0}),a(pt).forEach(t),Ou.forEach(t),rs=s(eu,"동시성과 병렬성의 차이"),eu.forEach(t),ea=u(l),A=i(l,"P",{});var wl=a(A);is=s(wl,"동시성은 프로그램이 "),lt(g.$$.fragment,wl),as=s(wl,"에 관련된 것이고, 병렬성은 프로그램이 "),lt(ee.$$.fragment,wl),os=s(wl,"에 관련된 것이다."),wl.forEach(t),la=u(l),ta=i(l,"BR",{}),ra=i(l,"BR",{}),ia=u(l),le=i(l,"H2",{id:!0});var lu=a(le);te=i(lu,"A",{"aria-hidden":!0,tabindex:!0,href:!0});var Du=a(te);mt=i(Du,"SPAN",{class:!0}),a(mt).forEach(t),Du.forEach(t),ss=s(lu,"동시성 프로그래밍"),lu.forEach(t),aa=u(l),oa=i(l,"HR",{}),sa=u(l),y=i(l,"UL",{});var Wl=a(y);Lt=i(Wl,"LI",{});var qu=a(Lt);fs=s(qu,"문제를 실행 단위로 나누어 time sharing 또는 병렬적으로 실행될 수 있게끔 하는 것"),qu.forEach(t),ns=u(Wl),St=i(Wl,"LI",{});var wu=a(St);cs=s(wu,"이들은 서로 병렬적으로 또는 인터리빙(interleaving)되어 실행될 수 있으며, 메시지를 통해 통신할 수 있음."),wu.forEach(t),us=u(Wl),Pt=i(Wl,"LI",{});var Wu=a(Pt);hs=s(Wu,"따라서 동시성 프로그래밍은 객체지향이나 함수형 프로그래밍처럼, 프로그램을 작성하는 방식이라고도 할 수 있음."),Wu.forEach(t),Wl.forEach(t),fa=u(l),re=i(l,"H3",{id:!0});var tu=a(re);ie=i(tu,"A",{"aria-hidden":!0,tabindex:!0,href:!0});var Xu=a(ie);bt=i(Xu,"SPAN",{class:!0}),a(bt).forEach(t),Xu.forEach(t),ds=s(tu,"Time Sharing과 Context Switching"),tu.forEach(t),na=u(l),m=i(l,"UL",{});var ze=a(m);It=i(ze,"LI",{});var Ku=a(It);vs=s(Ku,"컴퓨팅 리소스(주로 CPU)를 여러 프로그램이 공유하는 것."),Ku.forEach(t),Es=u(ze),Il=i(ze,"LI",{});var ru=a(Il);_s=s(ru,"어떤 프로세스가 여러 쓰레드로 구성되어 있다 할 때, 한 쓰레드가 일정한 time quantum 동안 CPU를 사용하고, 그 다음 쓰레드가 CPU를 사용하는 방식으로 진행됨."),G=i(ru,"UL",{});var Xl=a(G);el=i(Xl,"LI",{});var so=a(el);ps=s(so,"이를 "),lt(ae.$$.fragment,so),ms=s(so,"이라고 함."),so.forEach(t),Ls=u(Xl),kt=i(Xl,"LI",{});var Qu=a(kt);Ss=s(Qu,"쓰레드의 실행 컨텍스트에는 해당 쓰레드의 state(레지스터 값, 프로그램 카운터, Stack Pointer 등)가 저장되어 있음."),Qu.forEach(t),Ps=u(Xl),$t=i(Xl,"LI",{});var ju=a($t);bs=s(ju,"Context Switching이 발생하면, 현재 쓰레드의 state가 저장되고, 다음 쓰레드의 state가 복원됨."),ju.forEach(t),Xl.forEach(t),ru.forEach(t),Is=u(ze),kl=i(ze,"LI",{});var iu=a(kl);Ct=i(iu,"STRONG",{});var zu=a(Ct);ks=s(zu,"Preemptive Thread Scheduling"),zu.forEach(t),$s=s(iu,"에서는 쓰레드가 실행되는 도중 Context Switching이 발생할 수 있음."),iu.forEach(t),Cs=u(ze),oe=i(ze,"LI",{});var Ti=a(oe);xt=i(Ti,"STRONG",{});var Zu=a(xt);xs=s(Zu,"Non-Preemptive Thread Scheduling"),Zu.forEach(t),As=s(Ti,"("),At=i(Ti,"STRONG",{});var Fu=a(At);ys=s(Fu,"Cooperative Threading"),Fu.forEach(t),Us=s(Ti,")에서는 쓰레드가 실행을 마칠 때까지 Context Switching이 발생하지 않음."),Ti.forEach(t),ze.forEach(t),ca=u(l),$l=i(l,"BLOCKQUOTE",{});var Ju=a($l);yt=i(Ju,"P",{});var Vu=a(yt);Rs=s(Vu,"정보) Go 언어에서는 1.14 이전까지는 Non-Preemptive Thread Scheduling을 사용하였으나, 1.14부터 Preemptive Thread Scheduling을 사용하도록 변경되었다."),Vu.forEach(t),Ju.forEach(t),ua=u(l),Cl=i(l,"UL",{});var Yu=a(Cl);xl=i(Yu,"LI",{});var au=a(xl);Ns=s(au,"쓰레드의 상태와 스케줄링"),k=i(au,"UL",{});var Ze=a(k);T=i(Ze,"LI",{});var Kl=a(T);Ms=s(Kl,"쓰레드가 실행되면 "),Ut=i(Kl,"EM",{});var gu=a(Ut);Bs=s(gu,"Ready"),gu.forEach(t),Hs=s(Kl," state로 들어가고, CPU를 사용할 수 있을 때 "),Rt=i(Kl,"EM",{});var e1=a(Rt);Gs=s(e1,"Running"),e1.forEach(t),Ts=s(Kl," state로 들어감."),Kl.forEach(t),Os=u(Ze),se=i(Ze,"LI",{});var Oi=a(se);Nt=i(Oi,"EM",{});var l1=a(Nt);Ds=s(l1,"Running"),l1.forEach(t),qs=s(Oi," state의 쓰레드는 time quantum이 끝나면 다시 "),Mt=i(Oi,"EM",{});var t1=a(Mt);ws=s(t1,"Ready"),t1.forEach(t),Ws=s(Oi," state로 돌아감."),Oi.forEach(t),Xs=u(Ze),fe=i(Ze,"LI",{});var Di=a(fe);Bt=i(Di,"EM",{});var r1=a(Bt);Ks=s(r1,"Running"),r1.forEach(t),Qs=s(Di," state의 쓰레드가 I/O 작업 등으로 인한 인터럽트가 발생하거나, lock을 획득하지 못하면 "),Ht=i(Di,"EM",{});var i1=a(Ht);js=s(i1,"Blocked"),i1.forEach(t),zs=s(Di," state로 들어감."),Di.forEach(t),Zs=u(Ze),O=i(Ze,"LI",{});var Ql=a(O);Gt=i(Ql,"EM",{});var a1=a(Gt);Fs=s(a1,"Blocked"),a1.forEach(t),Js=s(Ql," state의 쓰레드는 I/O 작업이 끝나거나, lock을 획득하면 다시 "),Tt=i(Ql,"EM",{});var o1=a(Tt);Vs=s(o1,"Ready"),o1.forEach(t),Ys=s(Ql," state로 돌아가게 되고, 스케줄러에 의해 선택되기를 기다림."),Ot=i(Ql,"UL",{});var s1=a(Ot);ll=i(s1,"LI",{});var fo=a(ll);gs=s(fo,"이 때 "),Dt=i(fo,"EM",{});var f1=a(Dt);ef=s(f1,"Ready"),f1.forEach(t),lf=s(fo," state의 쓰레드가 바로 실행되리라는 보장은 없음."),fo.forEach(t),s1.forEach(t),Ql.forEach(t),Ze.forEach(t),au.forEach(t),Yu.forEach(t),ha=u(l),ne=i(l,"H3",{id:!0});var ou=a(ne);ce=i(ou,"A",{"aria-hidden":!0,tabindex:!0,href:!0});var n1=a(ce);qt=i(n1,"SPAN",{class:!0}),a(qt).forEach(t),n1.forEach(t),tf=s(ou,"동시성 프로그래밍은 왜 어려운가?"),ou.forEach(t),da=u(l),Al=i(l,"P",{});var c1=a(Al);rf=s(c1,"상태 관리의 어려움 때문임"),c1.forEach(t),va=u(l),U=i(l,"UL",{});var jl=a(U);yl=i(jl,"LI",{});var su=a(yl);af=s(su,"각각의 Sequantial Program은 상태(state)를 가지고 있음."),tl=i(su,"UL",{});var no=a(tl);wt=i(no,"LI",{});var u1=a(wt);of=s(u1,"state는 Sequantial Program의 실행 위치와 메모리에 저장된 값을 의미함"),u1.forEach(t),sf=u(no),Wt=i(no,"LI",{});var h1=a(Wt);ff=s(h1,"프로그램의 현재 state에 따라 다음 state를 예측할 수 있음"),h1.forEach(t),no.forEach(t),su.forEach(t),nf=u(jl),Xt=i(jl,"LI",{});var d1=a(Xt);cf=s(d1,"그런데 동시에 여러 프로그램이 실행되면 각각의 Sequantial Program이 가지고 있는 state가 서로 영향을 미칠 수 있음."),d1.forEach(t),uf=u(jl),Ul=i(jl,"LI",{});var fu=a(Ul);hf=s(fu,"Sequantial Program이 많아질수록, 가능한 state의 수가 많아질수록 전체 프로그램이 가질 수 있는 state의 경우의 수가 기하급수적으로 증가함"),Kt=i(fu,"UL",{});var v1=a(Kt);Qt=i(v1,"LI",{});var E1=a(Qt);df=s(E1,"n개의 state가 있는 Sequantial Program이 m개 실행되면 n^m개의 state가 존재함"),E1.forEach(t),v1.forEach(t),fu.forEach(t),jl.forEach(t),Ea=u(l),Rl=i(l,"P",{});var _1=a(Rl);vf=s(_1,"따라서, 일반적인 state 분석으로 동시성 프로그램의 행동을 예측하기 어려움."),_1.forEach(t),_a=u(l),ue=i(l,"H3",{id:!0});var nu=a(ue);he=i(nu,"A",{"aria-hidden":!0,tabindex:!0,href:!0});var p1=a(he);jt=i(p1,"SPAN",{class:!0}),a(jt).forEach(t),p1.forEach(t),Ef=s(nu,"Happened-Before 관계"),nu.forEach(t),pa=u(l),R=i(l,"UL",{});var zl=a(R);zt=i(zl,"LI",{});var m1=a(zt);_f=s(m1,"두 개의 서로 같지 않은 정수가 있다면, 이들의 대소 관계를 알 수 있음."),m1.forEach(t),pf=u(zl),Nl=i(zl,"LI",{});var cu=a(Nl);mf=s(cu,"마찬가지로 한 Sequantial Program에서 발생한 서로 다른 두 이벤트가 있다면, 한 이벤트는 반드시 다른 이벤트보다 먼저 발생했을 것임."),Zt=i(cu,"UL",{});var L1=a(Zt);rl=i(L1,"LI",{});var co=a(rl);Lf=s(co,"이를 "),lt(de.$$.fragment,co),Sf=s(co,"라고 함."),co.forEach(t),L1.forEach(t),cu.forEach(t),Pf=u(zl),Ml=i(zl,"LI",{});var uu=a(Ml);bf=s(uu,"서로 다른 프로세스에서 발생한 이벤트에 순서를 정하는 것은 불가능하지만, Message Passing 등을 통해 이벤트의 순서를 일부 정의할 수 있음."),Ft=i(uu,"UL",{});var S1=a(Ft);il=i(S1,"LI",{});var uo=a(il);If=s(uo,"이를 "),lt(ve.$$.fragment,uo),kf=s(uo,"라고 함."),uo.forEach(t),S1.forEach(t),uu.forEach(t),zl.forEach(t),ma=u(l),Ee=i(l,"H3",{id:!0});var hu=a(Ee);_e=i(hu,"A",{"aria-hidden":!0,tabindex:!0,href:!0});var P1=a(_e);Jt=i(P1,"SPAN",{class:!0}),a(Jt).forEach(t),P1.forEach(t),$f=s(hu,"Dining Philosopher Problem"),hu.forEach(t),La=u(l),pe=i(l,"UL",{});var ho=a(pe);al=i(ho,"LI",{});var vo=a(al);Vt=i(vo,"P",{});var b1=a(Vt);Cf=s(b1,"문제 정의"),b1.forEach(t),xf=u(vo),$=i(vo,"UL",{});var Fe=a($);Yt=i(Fe,"LI",{});var I1=a(Yt);Af=s(I1,"철학자들이 원형 테이블에 앉아있음."),I1.forEach(t),yf=u(Fe),gt=i(Fe,"LI",{});var k1=a(gt);Uf=s(k1,"테이블 위에는 포크가 5개 놓여있음."),k1.forEach(t),Rf=u(Fe),er=i(Fe,"LI",{});var $1=a(er);Nf=s($1,"철학자들은 생각을 하다가 배가 고파지면 양 옆의 포크를 집어들어 먹기 시작함."),$1.forEach(t),Mf=u(Fe),lr=i(Fe,"LI",{});var C1=a(lr);Bf=s(C1,"식사를 마치면 포크를 내려놓고 다시 생각을 하기 시작함."),C1.forEach(t),Fe.forEach(t),vo.forEach(t),Hf=u(ho),ol=i(ho,"LI",{});var Eo=a(ol);tr=i(Eo,"P",{});var x1=a(tr);Gf=s(x1,"Deadlock 발생 가능성"),x1.forEach(t),Tf=u(Eo),D=i(Eo,"UL",{});var Zl=a(D);rr=i(Zl,"LI",{});var A1=a(rr);Of=s(A1,"모든 철학자가 자신의 왼쪽 포크만을 집어든 상태라면, 모든 철학자는 다음 포크를 집어들기 위해 오른쪽 철학자가 포크를 내려놓기를 기다려야 함."),A1.forEach(t),Df=u(Zl),ir=i(Zl,"LI",{});var y1=a(ir);qf=s(y1,"이 상태에서는 모든 철학자가 포크를 내려놓기를 기다리는 상태로 무한 대기 상태에 빠짐."),y1.forEach(t),wf=u(Zl),ar=i(Zl,"LI",{});var U1=a(ar);Wf=s(U1,"한 철학자가 자신의 포크를 내려놓지 않는 이상, 다른 철학자들은 포크를 집어들 수 없음."),U1.forEach(t),Zl.forEach(t),Eo.forEach(t),ho.forEach(t),Sa=u(l),Pa=i(l,"BR",{}),ba=i(l,"BR",{}),Ia=u(l),me=i(l,"H2",{id:!0});var du=a(me);Le=i(du,"A",{"aria-hidden":!0,tabindex:!0,href:!0});var R1=a(Le);or=i(R1,"SPAN",{class:!0}),a(or).forEach(t),R1.forEach(t),Xf=s(du,"Shared Memory와 Message Passing"),du.forEach(t),ka=u(l),$a=i(l,"HR",{}),Ca=u(l),Se=i(l,"H3",{id:!0});var vu=a(Se);Pe=i(vu,"A",{"aria-hidden":!0,tabindex:!0,href:!0});var N1=a(Pe);sr=i(N1,"SPAN",{class:!0}),a(sr).forEach(t),N1.forEach(t),Kf=s(vu,"관련 Computer Architecture 지식"),vu.forEach(t),xa=u(l),L=i(l,"UL",{});var Je=a(L);sl=i(Je,"LI",{});var _o=a(sl);fr=i(_o,"P",{});var M1=a(fr);Qf=s(M1,"UMA(Uniform Memory Access)"),M1.forEach(t),jf=u(_o),fl=i(_o,"UL",{});var po=a(fl);nr=i(po,"LI",{});var B1=a(nr);zf=s(B1,"메모리에 접근할 때 모든 프로세서가 동일한 권한을 가지고 있음."),B1.forEach(t),Zf=u(po),cr=i(po,"LI",{});var H1=a(cr);Ff=s(H1,"동일한 메모리 액세스 버스가 공유되기 때문에 처리량이 감소할 수 있음."),H1.forEach(t),po.forEach(t),_o.forEach(t),Jf=u(Je),nl=i(Je,"LI",{});var mo=a(nl);ur=i(mo,"P",{});var G1=a(ur);Vf=s(G1,"NUMA(Non-Uniform Memory Access)"),G1.forEach(t),Yf=u(mo),cl=i(mo,"UL",{});var Lo=a(cl);hr=i(Lo,"LI",{});var T1=a(hr);gf=s(T1,"프로세서는 메모리의 특정 영역에 대해서만 접근 권한을 가짐"),T1.forEach(t),en=u(Lo),dr=i(Lo,"LI",{});var O1=a(dr);ln=s(O1,"OS가 프로세서에서 필요한 메모리를 해당 영역에 할당함으로써 전용 메모리 액세스 버스를 사용할 수 있기 때문에 처리량이 증가할 수 있음."),O1.forEach(t),Lo.forEach(t),mo.forEach(t),tn=u(Je),vr=i(Je,"LI",{});var D1=a(vr);Er=i(D1,"P",{});var q1=a(Er);rn=s(q1,"대부분의 프로세서는 캐시 메모리를 사용하며, 캐시 일관성(Cache Coherence) 프로토콜을 사용하여 캐시 메모리의 일관성을 유지함."),q1.forEach(t),D1.forEach(t),an=u(Je),ul=i(Je,"LI",{});var So=a(ul);_r=i(So,"P",{});var w1=a(_r);on=s(w1,"현대 프로세서는 메모리 read 및 write가 완료될 때까지 기다리지 않음. 파이프라이닝(Pipelining)을 통해 다음 명령어를 동시에 실행함."),w1.forEach(t),sn=u(So),hl=i(So,"UL",{});var Po=a(hl);pr=i(Po,"LI",{});var W1=a(pr);fn=s(W1,"이 때 파이프라이닝의 최적화를 위해서 컴파일러가 명령어의 순서를 바꿀 수 있음."),W1.forEach(t),nn=u(Po),Bl=i(Po,"LI",{});var Eu=a(Bl);cn=s(Eu,"그래서 한 쓰레드에서 읽은 메모리의 값이 다른 쓰레드에서 쓰인(write) 값이라고 확신할 수 없음."),q=i(Eu,"UL",{});var Fl=a(q);mr=i(Fl,"LI",{});var X1=a(mr);un=s(X1,"따라서 컴파일러 및 프로세서가 모든 변경사항을 메모리에 커밋(commit)하는 방법이 필요함."),X1.forEach(t),hn=u(Fl),Lr=i(Fl,"LI",{});var K1=a(Lr);dn=s(K1,"메모리 배리어(Memory Barrier)는 가장 저수준의 메모리 일관성 프로토콜로, 프로세서와 컴파일러에 특정 순서 제약을 강제함. 메모리 배리어 이전에 실행되는 모든 작업은 반드시 메모리 배리어 이후에 실행되는 명령어보다 먼저 완료되어야 함."),K1.forEach(t),vn=u(Fl),Sr=i(Fl,"LI",{});var Q1=a(Sr);En=s(Q1,"Go의 채널, Atomic 연산, 뮤텍스, condition variable 등은 모두 메모리 배리어를 사용함."),Q1.forEach(t),Fl.forEach(t),Eu.forEach(t),Po.forEach(t),So.forEach(t),Je.forEach(t),Aa=u(l),be=i(l,"H3",{id:!0});var _u=a(be);Ie=i(_u,"A",{"aria-hidden":!0,tabindex:!0,href:!0});var j1=a(Ie);Pr=i(j1,"SPAN",{class:!0}),a(Pr).forEach(t),j1.forEach(t),_n=s(_u,"Shared Memory"),_u.forEach(t),ya=u(l),N=i(l,"UL",{});var Jl=a(N);br=i(Jl,"LI",{});var z1=a(br);Ir=i(z1,"P",{});var Z1=a(Ir);pn=s(Z1,"단일 프로그램 내에서 Shared memory란 일반적으로 여러 쓰레드가 공유하는 변수 등의 메모리 공간을 의미함."),Z1.forEach(t),z1.forEach(t),mn=u(Jl),kr=i(Jl,"LI",{});var F1=a(kr);$r=i(F1,"P",{});var J1=a($r);Ln=s(J1,`Shared Memory를 통해 통신하는 경우 버그가 발생할 수 있는 가능성이 높아짐.
이 때 동시성으로 인해 발생하는 버그는 사실상 무작위적으로 발생하기에, 버그를 재현 및 디버깅하기가 어려움.`),J1.forEach(t),F1.forEach(t),Sn=u(Jl),Cr=i(Jl,"LI",{});var V1=a(Cr);xr=i(V1,"P",{});var Y1=a(xr);Pn=s(Y1,"lock을 통해 Happened-Before 관계를 정의함"),Y1.forEach(t),V1.forEach(t),Jl.forEach(t),Ua=u(l),ke=i(l,"H3",{id:!0});var pu=a(ke);$e=i(pu,"A",{"aria-hidden":!0,tabindex:!0,href:!0});var g1=a($e);Ar=i(g1,"SPAN",{class:!0}),a(Ar).forEach(t),g1.forEach(t),bn=s(pu,"Message Passing"),pu.forEach(t),Ra=u(l),Ce=i(l,"UL",{});var bo=a(Ce);dl=i(bo,"LI",{});var Io=a(dl);yr=i(Io,"P",{});var eh=a(yr);In=s(eh,"UNIX나 LINUX의 철학은 프로세스가 서로 독립적이어야 하며, 메시지를 송수신하는 방식으로 통신해야 한다는 것임."),eh.forEach(t),kn=u(Io),Ur=i(Io,"UL",{});var lh=a(Ur);Rr=i(lh,"LI",{});var th=a(Rr);$n=s(th,"프로세스는 한 종류의 일을 잘 하도록 설계되며, 이러한 프로세스들이 모여 시스템을 구성함."),th.forEach(t),lh.forEach(t),Io.forEach(t),Cn=u(bo),Nr=i(bo,"LI",{});var rh=a(Nr);Mr=i(rh,"P",{});var ih=a(Mr);xn=s(ih,"메시지를 통홰 Happened-Before 관계를 정의함. (메시지 패싱을 통해 두 쓰레드는 작업의 선후 관계를 정의할 수 있음)"),ih.forEach(t),rh.forEach(t),bo.forEach(t),Na=u(l),xe=i(l,"H3",{id:!0});var mu=a(xe);Ae=i(mu,"A",{"aria-hidden":!0,tabindex:!0,href:!0});var ah=a(Ae);Br=i(ah,"SPAN",{class:!0}),a(Br).forEach(t),ah.forEach(t),An=s(mu,"Hybrid Approach"),mu.forEach(t),Ma=u(l),S=i(l,"UL",{});var Ve=a(S);Hr=i(Ve,"LI",{});var oh=a(Hr);Gr=i(oh,"P",{});var sh=a(Gr);yn=s(sh,"Shared Memory와 Message Passing을 혼용하는 방식"),sh.forEach(t),oh.forEach(t),Un=u(Ve),Tr=i(Ve,"LI",{});var fh=a(Tr);Or=i(fh,"P",{});var nh=a(Or);Rn=s(nh,"보통 Shared Memory는 빠르고 활용성이 좋지만 data race가 발생할 수 있는 위협이 있음. 이러한 경우 Message Passing을 사용함."),nh.forEach(t),fh.forEach(t),Nn=u(Ve),Dr=i(Ve,"LI",{});var ch=a(Dr);qr=i(ch,"P",{});var uh=a(qr);Mn=s(uh,"하지만 의도치 않게 메모리를 공유되는 경우가 발생할 수 있음."),uh.forEach(t),ch.forEach(t),Bn=u(Ve),vl=i(Ve,"LI",{});var ko=a(vl);wr=i(ko,"P",{});var hh=a(wr);Hn=s(hh,"Golang에서의 접근 방식"),hh.forEach(t),Gn=u(ko),w=i(ko,"UL",{});var Vl=a(w);Wr=i(Vl,"LI",{});var dh=a(Wr);Tn=s(dh,"어떤 고루틴이 데이터 객체를 채널로 전달하면, 해당 데이터 객체의 소유권을 잃음."),dh.forEach(t),On=u(Vl),Xr=i(Vl,"LI",{});var vh=a(Xr);Dn=s(vh,"해당 채널에서 데이터 객체를 꺼낸 고루틴이 소유권을 가짐."),vh.forEach(t),qn=u(Vl),Kr=i(Vl,"LI",{});var Eh=a(Kr);wn=s(Eh,"채널로 데이터 객체를 전달한 고루틴은, mutual exclusion을 충족시키지 않는 한 해당 데이터 객체에 다시 접근할 수 없음."),Eh.forEach(t),Vl.forEach(t),ko.forEach(t),Ve.forEach(t),Ba=u(l),Ha=i(l,"BR",{}),Ga=i(l,"BR",{}),Ta=u(l),ye=i(l,"H2",{id:!0});var Lu=a(ye);Ue=i(Lu,"A",{"aria-hidden":!0,tabindex:!0,href:!0});var _h=a(Ue);Qr=i(_h,"SPAN",{class:!0}),a(Qr).forEach(t),_h.forEach(t),Wn=s(Lu,"Atomicity, Race, Deadlock, Starvation"),Lu.forEach(t),Oa=u(l),Da=i(l,"HR",{}),qa=u(l),Re=i(l,"H3",{id:!0});var Su=a(Re);Ne=i(Su,"A",{"aria-hidden":!0,tabindex:!0,href:!0});var ph=a(Ne);jr=i(ph,"SPAN",{class:!0}),a(jr).forEach(t),ph.forEach(t),Xn=s(Su,"Race Condition"),Su.forEach(t),wa=u(l),E=i(l,"UL",{});var B=a(E);zr=i(B,"LI",{});var mh=a(zr);Zr=i(mh,"P",{});var Lh=a(Zr);Kn=s(Lh,"동시성 프로그램의 실행 순서 및 타이밍에 따라 실행 결과가 달라지는 것."),Lh.forEach(t),mh.forEach(t),Qn=u(B),Fr=i(B,"LI",{});var Sh=a(Fr);Jr=i(Sh,"P",{});var Ph=a(Jr);jn=s(Ph,"각 쓰레드가 인터리빙되어 실행되기 때문에 발생함."),Ph.forEach(t),Sh.forEach(t),zn=u(B),Vr=i(B,"LI",{});var bh=a(Vr);Yr=i(bh,"P",{});var Ih=a(Yr);Zn=s(Ih,"이상적이지 않은 결과가 발생할 수 있음."),Ih.forEach(t),bh.forEach(t),Fn=u(B),gr=i(B,"LI",{});var kh=a(gr);ei=i(kh,"P",{});var $h=a(ei);Jn=s($h,"실질적으로 재현이 어려움."),$h.forEach(t),kh.forEach(t),Vn=u(B),El=i(B,"LI",{});var $o=a(El);Hl=i($o,"P",{});var Pu=a(Hl);li=i(Pu,"STRONG",{});var Ch=a(li);Yn=s(Ch,"Data race"),Ch.forEach(t),gn=s(Pu,"는 다음과 같은 항목에 해당하는 Race Condition의 특수한 케이스임."),Pu.forEach(t),ec=u($o),W=i($o,"UL",{});var Yl=a(W);ti=i(Yl,"LI",{});var xh=a(ti);lc=s(xh,"두 개 이상의 쓰레드가 동일한 메모리에 접근함"),xh.forEach(t),tc=u(Yl),ri=i(Yl,"LI",{});var Ah=a(ri);rc=s(Ah,"한 개 이상의 쓰레드가 메모라에 쓰기 연산을 수행함"),Ah.forEach(t),ic=u(Yl),ii=i(Yl,"LI",{});var yh=a(ii);ac=s(yh,"두 쓰레드의 작업 순서를 보장하기 위한 동기화 및 lock이 없음"),yh.forEach(t),Yl.forEach(t),$o.forEach(t),B.forEach(t),Wa=u(l),Me=i(l,"H3",{id:!0});var bu=a(Me);Be=i(bu,"A",{"aria-hidden":!0,tabindex:!0,href:!0});var Uh=a(Be);ai=i(Uh,"SPAN",{class:!0}),a(ai).forEach(t),Uh.forEach(t),oc=s(bu,"Atomicity"),bu.forEach(t),Xa=u(l),He=i(l,"UL",{});var Co=a(He);oi=i(Co,"LI",{});var Rh=a(oi);sc=s(Rh,"어떤 작업 및 그 하위 작업이 실행될 때 모두 완료되거나, 아니면 전혀 실행되지 않는 것을 의미함."),Rh.forEach(t),fc=u(Co),Ge=i(Co,"LI",{});var qi=a(Ge);nc=s(qi,"프로그램의 특정 영역에 반드시 한 쓰레드만 접근할 수 있게 하는 "),si=i(qi,"STRONG",{});var Nh=a(si);cc=s(Nh,"Critical Section"),Nh.forEach(t),uc=s(qi,"을 사용하여 구현할 수 있음."),_l=i(qi,"UL",{});var xo=a(_l);pl=i(xo,"LI",{});var Ao=a(pl);hc=s(Ao,"Mutual Exclusion(Mutex)를 통해 "),fi=i(Ao,"STRONG",{});var Mh=a(fi);dc=s(Mh,"Critical Section"),Mh.forEach(t),vc=s(Ao,"을 설정함."),Ao.forEach(t),Ec=u(xo),Gl=i(xo,"LI",{});var Iu=a(Gl);_c=s(Iu,"여러 shared object와 상호작용해야 하는 경우, Mutex의 사용이 복잡해짐."),ni=i(Iu,"UL",{});var Bh=a(ni);ci=i(Bh,"LI",{});var Hh=a(ci);pc=s(Hh,"상황에 따라 Deadlock이 발생할 수도 있음."),Hh.forEach(t),Bh.forEach(t),Iu.forEach(t),xo.forEach(t),qi.forEach(t),Co.forEach(t),Ka=u(l),Te=i(l,"H3",{id:!0});var ku=a(Te);Oe=i(ku,"A",{"aria-hidden":!0,tabindex:!0,href:!0});var Gh=a(Oe);ui=i(Gh,"SPAN",{class:!0}),a(ui).forEach(t),Gh.forEach(t),mc=s(ku,"Deadlock"),ku.forEach(t),Qa=u(l),M=i(l,"UL",{});var gl=a(M);hi=i(gl,"LI",{});var Th=a(hi);di=i(Th,"P",{});var Oh=a(di);Lc=s(Oh,"두 개 이상의 쓰레드가 서로의 작업이 끝나기를 기다리는 상황"),Oh.forEach(t),Th.forEach(t),Sc=u(gl),ml=i(gl,"LI",{});var yo=a(ml);vi=i(yo,"P",{});var Dh=a(vi);Pc=s(Dh,"Deadlock이 발생하려면 Coffman 조건이 충족되어야 함."),Dh.forEach(t),bc=u(yo),C=i(yo,"UL",{});var Ye=a(C);Ei=i(Ye,"LI",{});var qh=a(Ei);Ic=s(qh,"Mutual Exclusion: 한 쓰레드가 Critical Section에 들어가면, 다른 쓰레드는 해당 Critical Section에 들어갈 수 없음."),qh.forEach(t),kc=u(Ye),_i=i(Ye,"LI",{});var wh=a(_i);$c=s(wh,"Hold and Wait: 쓰레드는 어떤 자원을 점유한 상태에서, 다른 쓰레드가 점유한 자원을 기다림."),wh.forEach(t),Cc=u(Ye),pi=i(Ye,"LI",{});var Wh=a(pi);xc=s(Wh,"No Preemption: 쓰레드는 점유한 자원을 다른 쓰레드가 강제로 빼앗을 수 없음."),Wh.forEach(t),Ac=u(Ye),mi=i(Ye,"LI",{});var Xh=a(mi);yc=s(Xh,"Circular Wait: 쓰레드 간에 자원을 순환적으로 기다림."),Xh.forEach(t),Ye.forEach(t),yo.forEach(t),Uc=u(gl),Li=i(gl,"LI",{});var Kh=a(Li);Si=i(Kh,"P",{});var Qh=a(Si);Rc=s(Qh,"Deadlock을 예방하기 위해 shared resoruce에 대한 일관된 lock 순서를 정의할 수 있으나, 모든 Deadlock을 예방할 수는 없음."),Qh.forEach(t),Kh.forEach(t),gl.forEach(t),ja=u(l),Tl=i(l,"BLOCKQUOTE",{});var jh=a(Tl);Pi=i(jh,"P",{});var zh=a(Pi);Nc=s(zh,`정보) Go에서는 모든 Goroutine이 Block된 상태이면 Deadlock이 발생했다고 판단하고, panic을 발생시킴.
그래서 모든 Goroutine이 아닌 일부 Goroutine에서만 Deadlock이 발생했다면 이를 감지하지 못함.`),zh.forEach(t),jh.forEach(t),za=u(l),De=i(l,"H3",{id:!0});var $u=a(De);qe=i($u,"A",{"aria-hidden":!0,tabindex:!0,href:!0});var Zh=a(qe);bi=i(Zh,"SPAN",{class:!0}),a(bi).forEach(t),Zh.forEach(t),Mc=s($u,"Starvation"),$u.forEach(t),Za=u(l),we=i(l,"UL",{});var Uo=a(we);Ii=i(Uo,"LI",{});var Fh=a(Ii);Bc=s(Fh,"일부 쓰레드가 Critical Section에 들어가기 위해 계속해서 기다리지만, 다른 쓰레드가 먼저 Critical Section에 들어감으로 인해 Critical Section에 지속적으로 접근하지 못하는 상황"),Fh.forEach(t),Hc=u(Uo),ki=i(Uo,"LI",{});var Jh=a(ki);Gc=s(Jh,"DoS(Denial of Service) 공격의 기본 원리임."),Jh.forEach(t),Uo.forEach(t),Fa=u(l),Ol=i(l,"BLOCKQUOTE",{});var Vh=a(Ol);$i=i(Vh,"P",{});var Yh=a($i);Tc=s(Yh,"정보) Go 런타임은 특정 Goroutine이 Starvation 상태에 빠지는 것을 감지하지는 못한다."),Yh.forEach(t),Vh.forEach(t),Ja=u(l),We=i(l,"H3",{id:!0});var Cu=a(We);Xe=i(Cu,"A",{"aria-hidden":!0,tabindex:!0,href:!0});var gh=a(Xe);Ci=i(gh,"SPAN",{class:!0}),a(Ci).forEach(t),gh.forEach(t),Oc=s(Cu,"Livelock"),Cu.forEach(t),Va=u(l),P=i(l,"UL",{});var ge=a(P);xi=i(ge,"LI",{});var ed=a(xi);Dc=s(ed,"Deadlock처럼 보이지만, 쓰레드가 lock을 획득하려고 시도하는 연산을 계속 반복하기 때문에 실제로는 차단된 쓰레드가 없는 상황"),ed.forEach(t),qc=u(ge),Ai=i(ge,"LI",{});var ld=a(Ai);wc=s(ld,"쓰레드가 작동하더라도 실제로는 유의미한 작업을 수행하지 못하기 때문에, Starvation과 유사함."),ld.forEach(t),Wc=u(ge),yi=i(ge,"LI",{});var td=a(yi);Xc=s(td,"Livelock은 몇번 반복하다 보면 해결될 수 있기 때문에 확인하기 어려움."),td.forEach(t),Kc=u(ge),Ui=i(ge,"LI",{});var rd=a(Ui);Qc=s(rd,"lock을 획득하기 위해 재시도 및 무작위적인 대기 시간을 추가하는 방법으로 해결할 수 있음."),rd.forEach(t),ge.forEach(t),Ya=u(l),ga=i(l,"BR",{}),eo=i(l,"BR",{}),lo=u(l),Ke=i(l,"H2",{id:!0});var xu=a(Ke);Qe=i(xu,"A",{"aria-hidden":!0,tabindex:!0,href:!0});var id=a(Qe);Ri=i(id,"SPAN",{class:!0}),a(Ri).forEach(t),id.forEach(t),jc=s(xu,"References"),xu.forEach(t),to=u(l),ro=i(l,"HR",{}),io=u(l),x=i(l,"CENTER",{});var Sl=a(x);Ni=i(Sl,"P",{});var ad=a(Ni);zc=s(ad,"["),ad.forEach(t),Zc=u(Sl),lt(Ll.$$.fragment,Sl),Fc=s(Sl,`
](https://learning.oreilly.com/library/view/effective-concurrency-in/9781804619070/)`),Jc=i(Sl,"BR",{}),Vc=s(Sl,`
[Burak Serdar, 『Effective Concurrency in Go』, Packt Publishing](https://learning.oreilly.com/library/view/effective-concurrency-in/9781804619070/)`),Sl.forEach(t),this.h()},h(){h(st,"class","icon icon-link"),h(Q,"aria-hidden","true"),h(Q,"tabindex","-1"),h(Q,"href","#동시성concurrency-vs-병렬성parallelism"),h(K,"id","동시성concurrency-vs-병렬성parallelism"),h(ft,"class","icon icon-link"),h(z,"aria-hidden","true"),h(z,"tabindex","-1"),h(z,"href","#동시성concurrency"),h(j,"id","동시성concurrency"),h(vt,"class","icon icon-link"),h(J,"aria-hidden","true"),h(J,"tabindex","-1"),h(J,"href","#병렬성parallelism"),h(F,"id","병렬성parallelism"),h(pt,"class","icon icon-link"),h(Y,"aria-hidden","true"),h(Y,"tabindex","-1"),h(Y,"href","#동시성과-병렬성의-차이"),h(V,"id","동시성과-병렬성의-차이"),h(mt,"class","icon icon-link"),h(te,"aria-hidden","true"),h(te,"tabindex","-1"),h(te,"href","#동시성-프로그래밍"),h(le,"id","동시성-프로그래밍"),h(bt,"class","icon icon-link"),h(ie,"aria-hidden","true"),h(ie,"tabindex","-1"),h(ie,"href","#time-sharing과-context-switching"),h(re,"id","time-sharing과-context-switching"),h(qt,"class","icon icon-link"),h(ce,"aria-hidden","true"),h(ce,"tabindex","-1"),h(ce,"href","#동시성-프로그래밍은-왜-어려운가"),h(ne,"id","동시성-프로그래밍은-왜-어려운가"),h(jt,"class","icon icon-link"),h(he,"aria-hidden","true"),h(he,"tabindex","-1"),h(he,"href","#happened-before-관계"),h(ue,"id","happened-before-관계"),h(Jt,"class","icon icon-link"),h(_e,"aria-hidden","true"),h(_e,"tabindex","-1"),h(_e,"href","#dining-philosopher-problem"),h(Ee,"id","dining-philosopher-problem"),h(or,"class","icon icon-link"),h(Le,"aria-hidden","true"),h(Le,"tabindex","-1"),h(Le,"href","#shared-memory와-message-passing"),h(me,"id","shared-memory와-message-passing"),h(sr,"class","icon icon-link"),h(Pe,"aria-hidden","true"),h(Pe,"tabindex","-1"),h(Pe,"href","#관련-computer-architecture-지식"),h(Se,"id","관련-computer-architecture-지식"),h(Pr,"class","icon icon-link"),h(Ie,"aria-hidden","true"),h(Ie,"tabindex","-1"),h(Ie,"href","#shared-memory"),h(be,"id","shared-memory"),h(Ar,"class","icon icon-link"),h($e,"aria-hidden","true"),h($e,"tabindex","-1"),h($e,"href","#message-passing"),h(ke,"id","message-passing"),h(Br,"class","icon icon-link"),h(Ae,"aria-hidden","true"),h(Ae,"tabindex","-1"),h(Ae,"href","#hybrid-approach"),h(xe,"id","hybrid-approach"),h(Qr,"class","icon icon-link"),h(Ue,"aria-hidden","true"),h(Ue,"tabindex","-1"),h(Ue,"href","#atomicity-race-deadlock-starvation"),h(ye,"id","atomicity-race-deadlock-starvation"),h(jr,"class","icon icon-link"),h(Ne,"aria-hidden","true"),h(Ne,"tabindex","-1"),h(Ne,"href","#race-condition"),h(Re,"id","race-condition"),h(ai,"class","icon icon-link"),h(Be,"aria-hidden","true"),h(Be,"tabindex","-1"),h(Be,"href","#atomicity"),h(Me,"id","atomicity"),h(ui,"class","icon icon-link"),h(Oe,"aria-hidden","true"),h(Oe,"tabindex","-1"),h(Oe,"href","#deadlock"),h(Te,"id","deadlock"),h(bi,"class","icon icon-link"),h(qe,"aria-hidden","true"),h(qe,"tabindex","-1"),h(qe,"href","#starvation"),h(De,"id","starvation"),h(Ci,"class","icon icon-link"),h(Xe,"aria-hidden","true"),h(Xe,"tabindex","-1"),h(Xe,"href","#livelock"),h(We,"id","livelock"),h(Ri,"class","icon icon-link"),h(Qe,"aria-hidden","true"),h(Qe,"tabindex","-1"),h(Qe,"href","#references"),h(Ke,"id","references")},m(l,f){n(l,v,f),e(v,d),e(d,_),e(v,Ro),n(l,Wi,f),n(l,Pl,f),e(Pl,ot),e(ot,No),n(l,Xi,f),n(l,Ki,f),n(l,Qi,f),n(l,ji,f),n(l,K,f),e(K,Q),e(Q,st),e(K,Mo),n(l,zi,f),n(l,Zi,f),n(l,Fi,f),n(l,j,f),e(j,z),e(z,ft),e(j,Bo),n(l,Ji,f),n(l,Z,f),e(Z,nt),e(nt,p),e(p,Ho),e(p,ct),e(ct,Go),e(p,To),e(p,Oo),e(p,ut),e(ut,Do),e(p,qo),e(p,wo),e(p,Wo),e(Z,Xo),e(Z,ht),e(ht,H),e(H,Ko),e(H,dt),e(dt,Qo),e(H,jo),e(H,zo),e(H,Zo),n(l,Vi,f),n(l,F,f),e(F,J),e(J,vt),e(F,Fo),n(l,Yi,f),n(l,bl,f),e(bl,I),e(I,Jo),e(I,Et),e(Et,Vo),e(I,Yo),e(I,go),e(I,_t),e(_t,es),e(I,ls),e(I,ts),n(l,gi,f),n(l,V,f),e(V,Y),e(Y,pt),e(V,rs),n(l,ea,f),n(l,A,f),e(A,is),tt(g,A,null),e(A,as),tt(ee,A,null),e(A,os),n(l,la,f),n(l,ta,f),n(l,ra,f),n(l,ia,f),n(l,le,f),e(le,te),e(te,mt),e(le,ss),n(l,aa,f),n(l,oa,f),n(l,sa,f),n(l,y,f),e(y,Lt),e(Lt,fs),e(y,ns),e(y,St),e(St,cs),e(y,us),e(y,Pt),e(Pt,hs),n(l,fa,f),n(l,re,f),e(re,ie),e(ie,bt),e(re,ds),n(l,na,f),n(l,m,f),e(m,It),e(It,vs),e(m,Es),e(m,Il),e(Il,_s),e(Il,G),e(G,el),e(el,ps),tt(ae,el,null),e(el,ms),e(G,Ls),e(G,kt),e(kt,Ss),e(G,Ps),e(G,$t),e($t,bs),e(m,Is),e(m,kl),e(kl,Ct),e(Ct,ks),e(kl,$s),e(m,Cs),e(m,oe),e(oe,xt),e(xt,xs),e(oe,As),e(oe,At),e(At,ys),e(oe,Us),n(l,ca,f),n(l,$l,f),e($l,yt),e(yt,Rs),n(l,ua,f),n(l,Cl,f),e(Cl,xl),e(xl,Ns),e(xl,k),e(k,T),e(T,Ms),e(T,Ut),e(Ut,Bs),e(T,Hs),e(T,Rt),e(Rt,Gs),e(T,Ts),e(k,Os),e(k,se),e(se,Nt),e(Nt,Ds),e(se,qs),e(se,Mt),e(Mt,ws),e(se,Ws),e(k,Xs),e(k,fe),e(fe,Bt),e(Bt,Ks),e(fe,Qs),e(fe,Ht),e(Ht,js),e(fe,zs),e(k,Zs),e(k,O),e(O,Gt),e(Gt,Fs),e(O,Js),e(O,Tt),e(Tt,Vs),e(O,Ys),e(O,Ot),e(Ot,ll),e(ll,gs),e(ll,Dt),e(Dt,ef),e(ll,lf),n(l,ha,f),n(l,ne,f),e(ne,ce),e(ce,qt),e(ne,tf),n(l,da,f),n(l,Al,f),e(Al,rf),n(l,va,f),n(l,U,f),e(U,yl),e(yl,af),e(yl,tl),e(tl,wt),e(wt,of),e(tl,sf),e(tl,Wt),e(Wt,ff),e(U,nf),e(U,Xt),e(Xt,cf),e(U,uf),e(U,Ul),e(Ul,hf),e(Ul,Kt),e(Kt,Qt),e(Qt,df),n(l,Ea,f),n(l,Rl,f),e(Rl,vf),n(l,_a,f),n(l,ue,f),e(ue,he),e(he,jt),e(ue,Ef),n(l,pa,f),n(l,R,f),e(R,zt),e(zt,_f),e(R,pf),e(R,Nl),e(Nl,mf),e(Nl,Zt),e(Zt,rl),e(rl,Lf),tt(de,rl,null),e(rl,Sf),e(R,Pf),e(R,Ml),e(Ml,bf),e(Ml,Ft),e(Ft,il),e(il,If),tt(ve,il,null),e(il,kf),n(l,ma,f),n(l,Ee,f),e(Ee,_e),e(_e,Jt),e(Ee,$f),n(l,La,f),n(l,pe,f),e(pe,al),e(al,Vt),e(Vt,Cf),e(al,xf),e(al,$),e($,Yt),e(Yt,Af),e($,yf),e($,gt),e(gt,Uf),e($,Rf),e($,er),e(er,Nf),e($,Mf),e($,lr),e(lr,Bf),e(pe,Hf),e(pe,ol),e(ol,tr),e(tr,Gf),e(ol,Tf),e(ol,D),e(D,rr),e(rr,Of),e(D,Df),e(D,ir),e(ir,qf),e(D,wf),e(D,ar),e(ar,Wf),n(l,Sa,f),n(l,Pa,f),n(l,ba,f),n(l,Ia,f),n(l,me,f),e(me,Le),e(Le,or),e(me,Xf),n(l,ka,f),n(l,$a,f),n(l,Ca,f),n(l,Se,f),e(Se,Pe),e(Pe,sr),e(Se,Kf),n(l,xa,f),n(l,L,f),e(L,sl),e(sl,fr),e(fr,Qf),e(sl,jf),e(sl,fl),e(fl,nr),e(nr,zf),e(fl,Zf),e(fl,cr),e(cr,Ff),e(L,Jf),e(L,nl),e(nl,ur),e(ur,Vf),e(nl,Yf),e(nl,cl),e(cl,hr),e(hr,gf),e(cl,en),e(cl,dr),e(dr,ln),e(L,tn),e(L,vr),e(vr,Er),e(Er,rn),e(L,an),e(L,ul),e(ul,_r),e(_r,on),e(ul,sn),e(ul,hl),e(hl,pr),e(pr,fn),e(hl,nn),e(hl,Bl),e(Bl,cn),e(Bl,q),e(q,mr),e(mr,un),e(q,hn),e(q,Lr),e(Lr,dn),e(q,vn),e(q,Sr),e(Sr,En),n(l,Aa,f),n(l,be,f),e(be,Ie),e(Ie,Pr),e(be,_n),n(l,ya,f),n(l,N,f),e(N,br),e(br,Ir),e(Ir,pn),e(N,mn),e(N,kr),e(kr,$r),e($r,Ln),e(N,Sn),e(N,Cr),e(Cr,xr),e(xr,Pn),n(l,Ua,f),n(l,ke,f),e(ke,$e),e($e,Ar),e(ke,bn),n(l,Ra,f),n(l,Ce,f),e(Ce,dl),e(dl,yr),e(yr,In),e(dl,kn),e(dl,Ur),e(Ur,Rr),e(Rr,$n),e(Ce,Cn),e(Ce,Nr),e(Nr,Mr),e(Mr,xn),n(l,Na,f),n(l,xe,f),e(xe,Ae),e(Ae,Br),e(xe,An),n(l,Ma,f),n(l,S,f),e(S,Hr),e(Hr,Gr),e(Gr,yn),e(S,Un),e(S,Tr),e(Tr,Or),e(Or,Rn),e(S,Nn),e(S,Dr),e(Dr,qr),e(qr,Mn),e(S,Bn),e(S,vl),e(vl,wr),e(wr,Hn),e(vl,Gn),e(vl,w),e(w,Wr),e(Wr,Tn),e(w,On),e(w,Xr),e(Xr,Dn),e(w,qn),e(w,Kr),e(Kr,wn),n(l,Ba,f),n(l,Ha,f),n(l,Ga,f),n(l,Ta,f),n(l,ye,f),e(ye,Ue),e(Ue,Qr),e(ye,Wn),n(l,Oa,f),n(l,Da,f),n(l,qa,f),n(l,Re,f),e(Re,Ne),e(Ne,jr),e(Re,Xn),n(l,wa,f),n(l,E,f),e(E,zr),e(zr,Zr),e(Zr,Kn),e(E,Qn),e(E,Fr),e(Fr,Jr),e(Jr,jn),e(E,zn),e(E,Vr),e(Vr,Yr),e(Yr,Zn),e(E,Fn),e(E,gr),e(gr,ei),e(ei,Jn),e(E,Vn),e(E,El),e(El,Hl),e(Hl,li),e(li,Yn),e(Hl,gn),e(El,ec),e(El,W),e(W,ti),e(ti,lc),e(W,tc),e(W,ri),e(ri,rc),e(W,ic),e(W,ii),e(ii,ac),n(l,Wa,f),n(l,Me,f),e(Me,Be),e(Be,ai),e(Me,oc),n(l,Xa,f),n(l,He,f),e(He,oi),e(oi,sc),e(He,fc),e(He,Ge),e(Ge,nc),e(Ge,si),e(si,cc),e(Ge,uc),e(Ge,_l),e(_l,pl),e(pl,hc),e(pl,fi),e(fi,dc),e(pl,vc),e(_l,Ec),e(_l,Gl),e(Gl,_c),e(Gl,ni),e(ni,ci),e(ci,pc),n(l,Ka,f),n(l,Te,f),e(Te,Oe),e(Oe,ui),e(Te,mc),n(l,Qa,f),n(l,M,f),e(M,hi),e(hi,di),e(di,Lc),e(M,Sc),e(M,ml),e(ml,vi),e(vi,Pc),e(ml,bc),e(ml,C),e(C,Ei),e(Ei,Ic),e(C,kc),e(C,_i),e(_i,$c),e(C,Cc),e(C,pi),e(pi,xc),e(C,Ac),e(C,mi),e(mi,yc),e(M,Uc),e(M,Li),e(Li,Si),e(Si,Rc),n(l,ja,f),n(l,Tl,f),e(Tl,Pi),e(Pi,Nc),n(l,za,f),n(l,De,f),e(De,qe),e(qe,bi),e(De,Mc),n(l,Za,f),n(l,we,f),e(we,Ii),e(Ii,Bc),e(we,Hc),e(we,ki),e(ki,Gc),n(l,Fa,f),n(l,Ol,f),e(Ol,$i),e($i,Tc),n(l,Ja,f),n(l,We,f),e(We,Xe),e(Xe,Ci),e(We,Oc),n(l,Va,f),n(l,P,f),e(P,xi),e(xi,Dc),e(P,qc),e(P,Ai),e(Ai,wc),e(P,Wc),e(P,yi),e(yi,Xc),e(P,Kc),e(P,Ui),e(Ui,Qc),n(l,Ya,f),n(l,ga,f),n(l,eo,f),n(l,lo,f),n(l,Ke,f),e(Ke,Qe),e(Qe,Ri),e(Ke,jc),n(l,to,f),n(l,ro,f),n(l,io,f),n(l,x,f),e(x,Ni),e(Ni,zc),e(x,Zc),tt(Ll,x,null),e(x,Fc),e(x,Jc),e(x,Vc),ao=!0},p(l,[f]){const Mi={};f&1&&(Mi.$$scope={dirty:f,ctx:l}),g.$set(Mi);const Bi={};f&1&&(Bi.$$scope={dirty:f,ctx:l}),ee.$set(Bi);const Hi={};f&1&&(Hi.$$scope={dirty:f,ctx:l}),ae.$set(Hi);const Dl={};f&1&&(Dl.$$scope={dirty:f,ctx:l}),de.$set(Dl);const Gi={};f&1&&(Gi.$$scope={dirty:f,ctx:l}),ve.$set(Gi)},i(l){ao||(rt(g.$$.fragment,l),rt(ee.$$.fragment,l),rt(ae.$$.fragment,l),rt(de.$$.fragment,l),rt(ve.$$.fragment,l),rt(Ll.$$.fragment,l),ao=!0)},o(l){it(g.$$.fragment,l),it(ee.$$.fragment,l),it(ae.$$.fragment,l),it(de.$$.fragment,l),it(ve.$$.fragment,l),it(Ll.$$.fragment,l),ao=!1},d(l){l&&t(v),l&&t(Wi),l&&t(Pl),l&&t(Xi),l&&t(Ki),l&&t(Qi),l&&t(ji),l&&t(K),l&&t(zi),l&&t(Zi),l&&t(Fi),l&&t(j),l&&t(Ji),l&&t(Z),l&&t(Vi),l&&t(F),l&&t(Yi),l&&t(bl),l&&t(gi),l&&t(V),l&&t(ea),l&&t(A),at(g),at(ee),l&&t(la),l&&t(ta),l&&t(ra),l&&t(ia),l&&t(le),l&&t(aa),l&&t(oa),l&&t(sa),l&&t(y),l&&t(fa),l&&t(re),l&&t(na),l&&t(m),at(ae),l&&t(ca),l&&t($l),l&&t(ua),l&&t(Cl),l&&t(ha),l&&t(ne),l&&t(da),l&&t(Al),l&&t(va),l&&t(U),l&&t(Ea),l&&t(Rl),l&&t(_a),l&&t(ue),l&&t(pa),l&&t(R),at(de),at(ve),l&&t(ma),l&&t(Ee),l&&t(La),l&&t(pe),l&&t(Sa),l&&t(Pa),l&&t(ba),l&&t(Ia),l&&t(me),l&&t(ka),l&&t($a),l&&t(Ca),l&&t(Se),l&&t(xa),l&&t(L),l&&t(Aa),l&&t(be),l&&t(ya),l&&t(N),l&&t(Ua),l&&t(ke),l&&t(Ra),l&&t(Ce),l&&t(Na),l&&t(xe),l&&t(Ma),l&&t(S),l&&t(Ba),l&&t(Ha),l&&t(Ga),l&&t(Ta),l&&t(ye),l&&t(Oa),l&&t(Da),l&&t(qa),l&&t(Re),l&&t(wa),l&&t(E),l&&t(Wa),l&&t(Me),l&&t(Xa),l&&t(He),l&&t(Ka),l&&t(Te),l&&t(Qa),l&&t(M),l&&t(ja),l&&t(Tl),l&&t(za),l&&t(De),l&&t(Za),l&&t(we),l&&t(Fa),l&&t(Ol),l&&t(Ja),l&&t(We),l&&t(Va),l&&t(P),l&&t(Ya),l&&t(ga),l&&t(eo),l&&t(lo),l&&t(Ke),l&&t(to),l&&t(ro),l&&t(io),l&&t(x),at(Ll)}}}const Ld={title:"동시성 관련 개념 정리",date:"2023-08-18T00:00:00.000Z",excerpt:"Concepts about concurrency",categories:["Computer Science","OS","Golang"],coverImage:"/post_img/Computer Science/OS/Concurrency/cover.png",coverWidth:16,coverHeight:9,indexed:!0,exposed:!0};class Sd extends od{constructor(v){super(),sd(this,v,null,Ed,fd,{})}}export{Sd as default,Ld as metadata};
