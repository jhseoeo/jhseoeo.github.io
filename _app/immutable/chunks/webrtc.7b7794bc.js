import{S as oE,i as sE,s as uE,k as i,q as s,a as f,y as Yi,l as r,m as a,r as u,h as t,c as o,z as gi,n,b as E,E as l,A as lr,M as vE,g as er,d as tr,B as ir}from"./index.d78780bf.js";import{I as rr}from"./Image.605b14b5.js";function EE(fE){let M,tf,ar,fr,or,sr,F,G,We,rf,ur,vr,Er,q,Q,$e,af,nr,_,we,ke,ff,of,xl,Wl,sf,De,uf,vf,Ef,ye,He,nf,_f,Be,Oe,df,cf,Me,Fe,Pf,pf,Ge,qe,If,hf,$l,Qe,bf,Lf,w,ae,je,Tf,Cf,Nf,fe,ze,Uf,Sf,Rf,oe,Ze,mf,Af,_r,dr,cr,j,z,Je,xf,Pr,d,wl,Ke,Wf,$f,kl,Ve,wf,kf,Xe,Df,yf,Dl,Ye,Hf,Bf,ge,lt,Of,Mf,yl,et,Ff,Gf,tt,it,qf,Qf,Hl,rt,jf,zf,k,at,Zf,Jf,ft,Kf,Vf,se,Xf,Bl,ot,Yf,gf,st,lo,eo,Ol,ut,to,io,Ml,vt,ro,ao,Et,fo,pr,Ir,hr,Z,J,nt,oo,br,U,Fl,_t,so,uo,D,dt,vo,Eo,ue,no,ct,Pt,_o,co,ve,Po,pt,It,po,Io,Gl,ht,ho,bo,bt,Lt,Lo,To,ql,Tt,Co,No,y,Ct,Uo,So,Nt,Ro,mo,Ut,Ao,Lr,Tr,Cr,K,V,St,xo,Nr,Ql,Ur,S,Rt,Wo,$o,mt,wo,ko,At,Do,Sr,Ee,yo,Rr,mr,Ar,xr,X,Y,xt,Ho,Wr,$r,wr,g,ll,Wt,Bo,kr,jl,Dr,I,$t,Oo,Mo,wt,Fo,Go,kt,qo,Qo,ne,jo,Dt,yt,zo,yr,Hr,Br,Or,el,tl,Ht,Zo,Mr,Fr,Gr,il,rl,Bt,Jo,qr,c,Ot,Mt,Ko,Vo,Ft,Gt,Xo,Yo,qt,zl,go,Qt,ls,es,ts,Zl,jt,is,rs,H,zt,as,fs,Zt,os,ss,Jt,us,vs,Jl,Kt,Es,ns,Vt,_e,_s,B,Xt,ds,cs,Yt,Ps,ps,gt,Is,Qr,jr,zr,al,fl,li,hs,Zr,h,ei,bs,Ls,Kl,Ts,ti,Cs,Ns,Us,ii,Ss,Rs,ri,ms,Jr,Kr,Vr,ol,sl,ai,As,Xr,ul,de,xs,fi,oi,Ws,$s,ce,ws,si,ui,ks,Yr,gr,la,ea,vl,El,vi,Ds,ta,ia,ra,nl,_l,Ei,ys,aa,Vl,fa,R,ni,Hs,Bs,Pe,Os,_i,di,Ms,Fs,pe,Gs,O,ci,qs,Qs,Pi,js,zs,pi,Zs,oa,sa,ua,dl,cl,Ii,Js,va,b,hi,Ks,Vs,bi,Xs,Ys,Ie,gs,Li,he,Xl,l1,e1,t1,Ti,i1,Ea,na,_a,Pl,pl,Ci,r1,da,P,Ni,a1,f1,Ui,o1,s1,Si,u1,v1,Ri,E1,n1,mi,_1,ca,Pa,pa,Il,hl,Ai,d1,Ia,Yl,ha,m,gl,xi,c1,P1,C,Wi,p1,I1,$i,h1,b1,wi,L1,T1,ki,C1,N1,le,Di,U1,S1,p,yi,R1,m1,Hi,A1,x1,Bi,W1,$1,Oi,w1,k1,Mi,D1,y1,ee,Fi,H1,B1,N,Gi,O1,M1,qi,F1,G1,Qi,q1,Q1,ji,j1,ba,La,Ta,bl,Ll,zi,z1,Ca,te,Na,L,Zi,Z1,J1,Ji,K1,V1,Ki,X1,Y1,Vi,g1,Ua,Sa,Ra,ma,Tl,Cl,Xi,l2,Aa,ie,e2,re,t2,xa,Wa,$a,wa;return Ql=new rr({props:{alt:"webrtc signaling architecture",src:"/post_img/Networking/WebRTC/2023-01-16-22-07-55.png"}}),jl=new rr({props:{alt:"js sdp example",src:"/post_img/Networking/WebRTC/2023-01-29-22-15-14.PNG"}}),Vl=new rr({props:{alt:"port forwarding",src:"/post_img/Networking/WebRTC/2023-01-17-00-20-14.png"}}),Yl=new rr({props:{alt:"data flow diagram of each realy server",src:"/post_img/Networking/WebRTC/2023-01-29-23-58-14.png"}}),te=new rr({props:{alt:"webrtc signaling process",src:"/post_img/Networking/WebRTC/2023-01-30-01-11-14.png"}}),{c(){M=i("p"),tf=s("교내 프로젝트, 교과목, 스터디를 통해 정리한 WebRTC 관련 내용을 기록해보았습니다"),ar=f(),fr=i("br"),or=i("br"),sr=f(),F=i("h2"),G=i("a"),We=i("span"),rf=s("WebRTC"),ur=f(),vr=i("hr"),Er=f(),q=i("h3"),Q=i("a"),$e=i("span"),af=s("WebRTC란?"),nr=f(),_=i("ul"),we=i("li"),ke=i("p"),ff=s("Web Real-Time Communication의 약자"),of=f(),xl=i("li"),Wl=i("p"),sf=s("별도의 소프트웨어나 플러그인 없이 ("),De=i("strong"),uf=s("웹 브라우저 만으로도"),vf=s(") 오디오 및 비디오 데이터를 주고받을 수 있음"),Ef=f(),ye=i("ul"),He=i("li"),nf=s("화상 통화, 실시간 회의 등 구현 가능"),_f=f(),Be=i("li"),Oe=i("p"),df=s("웹 브라우저 뿐 아니라 IOS, Android Native App 위에서도 동작함"),cf=f(),Me=i("li"),Fe=i("p"),Pf=s("구글이 표준화를 주도하고 있어, Chrome 호환성이 제일 좋음"),pf=f(),Ge=i("li"),qe=i("p"),If=s("UDP, 피어-to-피어로 통신함"),hf=f(),$l=i("li"),Qe=i("p"),bf=s("브라우저 API 제공"),Lf=f(),w=i("ul"),ae=i("li"),je=i("code"),Tf=s("RTC피어Connection()"),Cf=s(" : signal 처리, 코덱 처리, p2p 통신, 보안, bandwidth 관리 등, 다양한 역할을 하는 WebRTC 통신 주요 class"),Nf=f(),fe=i("li"),ze=i("code"),Uf=s("getUserMedia()"),Sf=s(" : 카메라나 마이크 등 장치에 접근하여 유저 데이터를 capture"),Rf=f(),oe=i("li"),Ze=i("code"),mf=s("RTCDataChannel()"),Af=s(" : 오디오, 비디오 외의 비정형 데이터를 주고받기 위함. WebSocket과 거의 유사한 api"),_r=f(),dr=i("br"),cr=f(),j=i("h3"),z=i("a"),Je=i("span"),xf=s("WebRTC 장점"),Pr=f(),d=i("ol"),wl=i("li"),Ke=i("p"),Wf=s("UDP를 사용하여 지연시간이 매우 짧다"),$f=f(),kl=i("ul"),Ve=i("li"),wf=s("카메라로 찍은 화면이 상대에게 도달하기까지 걸리는 시간이 500ms 이하"),kf=f(),Xe=i("li"),Df=s("다른 HTTP Live Stream 기술들의 경우, 주로 영상을 사람들에게 뿌리는(1:N) 용도라서 지연 시간이 존재"),yf=f(),Dl=i("li"),Ye=i("p"),Hf=s("Platform and Device Independent"),Bf=f(),ge=i("ul"),lt=i("li"),Of=s("웹브라우저 위에서 돌아가도록 설계되었기 때문에, 브라우저만 돌아가면 OS, 장치가 무엇이든 상관없음"),Mf=f(),yl=i("li"),et=i("p"),Ff=s("Open-source 및 표준화되어있음"),Gf=f(),tt=i("ul"),it=i("li"),qf=s("언어별로 표준 문서가 존재하며, 표준대로 진행하면 모두 연결 가능함"),Qf=f(),Hl=i("li"),rt=i("p"),jf=s("네트워크 성능에 따라 품질 조정"),zf=f(),k=i("ul"),at=i("li"),Zf=s("네트워크 성능에 따라 전송받는 (영상)데이터의 품질(화질)이 달라질 수 있음"),Jf=f(),ft=i("li"),Kf=s("하지만 한 순간에는 특정 해상도의 영상 하나만 받을 수 있음"),Vf=f(),se=i("li"),Xf=s("Simulcasting"),Bl=i("ul"),ot=i("li"),Yf=s("동시의 여러 해상도의 영상을 보냄"),gf=f(),st=i("li"),lo=s("bandwidth를 낭비하지만, 수신 장치가 알아서 적합한 품질의 영상 선택"),eo=f(),Ol=i("li"),ut=i("p"),to=s("P2P의 장점"),io=f(),Ml=i("ul"),vt=i("li"),ro=s("주요 데이터가 서버를 경유하지 않기 때문에, 서버 입장에선 부담이 적음"),ao=f(),Et=i("li"),fo=s("유저 입장에선 내 데이터를 서버가 볼 수 없기 때문에, 안심하고 이용 가능"),pr=f(),Ir=i("br"),hr=f(),Z=i("h3"),J=i("a"),nt=i("span"),oo=s("WebRTC 단점"),br=f(),U=i("ol"),Fl=i("li"),_t=i("p"),so=s("Scalability"),uo=f(),D=i("ul"),dt=i("li"),vo=s("하나의 세션에 참가하는 통신 대상이 일정 이상 늘어나기 어려움"),Eo=f(),ue=i("li"),no=s("통신하는 대상의 수가 제한됨"),ct=i("ul"),Pt=i("li"),_o=s("권고에 따르면 최대 50개 (WebRTC expert Tsahi LeventLevi recommends staying shy of any more than 50 concurrent 피어 connections.)"),co=f(),ve=i("li"),Po=s("몇 천 명의 유저가 통신하는 경우, live streaming server를 두어 데이터를 분산시킴"),pt=i("ul"),It=i("li"),po=s("SFU, MCU 등이 대표적"),Io=f(),Gl=i("li"),ht=i("p"),ho=s("Broadcast Quality"),bo=f(),bt=i("ul"),Lt=i("li"),Lo=s("WebRTC 자체에 퀄리티 문제는 없지만, Broadcast를 함으로써 발생하는 영상 품질의 하락 문제"),To=f(),ql=i("li"),Tt=i("p"),Co=s("그래도 서버가 필요함"),No=f(),y=i("ul"),Ct=i("li"),Uo=s("두 피어끼리의 connection 생성 및 해제 -> Signaling Server"),So=f(),Nt=i("li"),Ro=s("피어간 통신이 가능한지 여부 또는 Public IP를 확인해야 하는 경우 -> STUN 서버"),mo=f(),Ut=i("li"),Ao=s("다양한 네트워크 상의 이슈(방화벽, 공유기나 라우터의 보안 정책 등) 때문에 피어간 직접 통신이 되지 않을 경우 -> TURN 서버를 통해 데이터를 Relay"),Lr=f(),Tr=i("br"),Cr=f(),K=i("h3"),V=i("a"),St=i("span"),xo=s("WebRTC 동작 흐름"),Nr=f(),Yi(Ql.$$.fragment),Ur=f(),S=i("ol"),Rt=i("li"),Wo=s("Signaling Server : 기기 사이에서 커넥션을 생성 및 해제해주고, 통신할 대상을 찾아줌"),$o=f(),mt=i("li"),wo=s("STUN Server : 요청자의 Public IP를 확인"),ko=f(),At=i("li"),Do=s("TURN Server : P2P로 데이터를 직접 전송할 수 없다면, 데이터를 Relay"),Sr=f(),Ee=i("p"),yo=s("자세한 내용은 아래에서 다룰 예정"),Rr=f(),mr=i("br"),Ar=i("br"),xr=f(),X=i("h2"),Y=i("a"),xt=i("span"),Ho=s("SDP"),Wr=f(),$r=i("hr"),wr=f(),g=i("h3"),ll=i("a"),Wt=i("span"),Bo=s("SDP란?"),kr=f(),Yi(jl.$$.fragment),Dr=f(),I=i("ul"),$t=i("li"),Oo=s("Session Description Protocol의 약자 (실질적으로는 프로토콜이 아니긴 함)"),Mo=f(),wt=i("li"),Fo=s("해상도, 형식, 코덱, 암호화 등, 컨텐츠에 대한 메타데이터 정보"),Go=f(),kt=i("li"),qo=s("누구와 어떻게 대화할지에 대한 정보를 포함함"),Qo=f(),ne=i("li"),jo=s("SIP(Session Initiation Protocol)를 통해 SDP를 전송"),Dt=i("ul"),yt=i("li"),zo=s("SIP는 WebRTC 이전에도 존재하던 사용자/참가자 그룹 간의 연결 설정 프로토콜이며, WebRTC는 SIP를 사용하여 Session 설정"),yr=f(),Hr=i("br"),Br=i("br"),Or=f(),el=i("h2"),tl=i("a"),Ht=i("span"),Zo=s("ICE"),Mr=f(),Fr=i("hr"),Gr=f(),il=i("h3"),rl=i("a"),Bt=i("span"),Jo=s("ICE란?"),qr=f(),c=i("ul"),Ot=i("li"),Mt=i("p"),Ko=s("Interactive Connectivity Establishment"),Vo=f(),Ft=i("li"),Gt=i("p"),Xo=s("브라우저가 피어를 통한 연결이 가능하게 해주는 프레임워크"),Yo=f(),qt=i("li"),zl=i("p"),go=s("두 피어간 "),Qt=i("strong"),ls=s("최적의 경로"),es=s("를 찾아줌 (NAT Traversal)"),ts=f(),Zl=i("li"),jt=i("p"),is=s("피어끼리 연결이 쉽지 않은 이유"),rs=f(),H=i("ul"),zt=i("li"),as=s("방화벽에 걸리는 경우"),fs=f(),Zt=i("li"),os=s("장치에 Public IP가 없는 경우"),ss=f(),Jt=i("li"),us=s("라우터의 보안 정책이 피어간 직접 연결을 막는 경우"),vs=f(),Jl=i("li"),Kt=i("p"),Es=s("ICE는 STUN서버와 TURN서버를 사용하여 이러한 작업 수행"),ns=f(),Vt=i("ul"),_e=i("li"),_s=s("일반적으로, STUN, TURN 서버까지 거치고 나면 다음과 같은 주소를 얻음"),B=i("ul"),Xt=i("li"),ds=s("Private IP, Port"),cs=f(),Yt=i("li"),Ps=s("Public IP, Port (through STUN)"),ps=f(),gt=i("li"),Is=s("TURN 서버의 IP, Port(through TURN)"),Qr=f(),jr=i("br"),zr=f(),al=i("h3"),fl=i("a"),li=i("span"),hs=s("ICE Candidates"),Zr=f(),h=i("ul"),ei=i("li"),bs=s("WebRTC 피어 연결을 시작하면, 일반적으로 여러개의 candiate들이 각 피어에 의해 만들어짐"),Ls=f(),Kl=i("li"),Ts=s("구분자("),ti=i("code"),Cs=s("foundation"),Ns=s("), IP, 포트, 우선순위, 프로토콜 등으로 구성"),Us=f(),ii=i("li"),Ss=s("UDP가 기본이지만 UDP가 안되면 TCP도 허용함"),Rs=f(),ri=i("li"),ms=s("각 피어가 수집한 ICE Candidates로 패킷을 보내 본 뒤, 가장 latency가 낮고 안정적인 ICE Candidates를 사용"),Jr=f(),Kr=i("br"),Vr=f(),ol=i("h3"),sl=i("a"),ai=i("span"),As=s("Trickle ICE"),Xr=f(),ul=i("ul"),de=i("li"),xs=s("일반적으로 피어는 ICE Candidates를 수집하여 목록을 완성한 후 한꺼번에 교환함"),fi=i("ul"),oi=i("li"),Ws=s("이 방식은 네트워크 지연 등 이유로 ICE Candidates를 수집하는 데 오래 걸릴 수 있음"),$s=f(),ce=i("li"),ws=s("비효율적인 ICE Candidates 교환 작업을 비동기 처리"),si=i("ul"),ui=i("li"),ks=s("ICE Candidates를 찾은 즉시 피어에게 전송"),Yr=f(),gr=i("br"),la=i("br"),ea=f(),vl=i("h2"),El=i("a"),vi=i("span"),Ds=s("Signaling"),ta=f(),ia=i("hr"),ra=f(),nl=i("h3"),_l=i("a"),Ei=i("span"),ys=s("NAT?"),aa=f(),Yi(Vl.$$.fragment),fa=f(),R=i("ul"),ni=i("li"),Hs=s("Network Address Translation"),Bs=f(),Pe=i("li"),Os=s("일반적인 사용자의 네트워크 환경에서는 대부분 공유기를 두기 때문에 Private IP, Public IP가 각각 존재함"),_i=i("ul"),di=i("li"),Ms=s("(일반적인 경우) 한 대의 공유기에 여러 대의 장치가 연결되고, 따라서 한 개의 Public IP와 여러 개의 Private IP가 존재함"),Fs=f(),pe=i("li"),Gs=s("이 때 NAT는 Public IP를 특정 Private IP로 매핑시킴"),O=i("ul"),ci=i("li"),qs=s("다만 연결된 장치 개수만큼 여러 대의 Private IP가 Public IP에 매핑될 필요가 있기에, PAT도 함께 적용"),Qs=f(),Pi=i("li"),js=s("NAT + PAT(포트포워딩이라고도 함)는 Public IP:특정 포트를, 특정 Private IP:특정 포트로 매핑시킴"),zs=f(),pi=i("li"),Zs=s("위 그림에서 Public IP:80으로 요청을 보내면, 192.168.0.37을 가진 장치가 80번 포트로 요청을 받을 것"),oa=f(),sa=i("br"),ua=f(),dl=i("h3"),cl=i("a"),Ii=i("span"),Js=s("STUN"),va=f(),b=i("ul"),hi=i("li"),Ks=s("Session Traversal Utilities for NAT"),Vs=f(),bi=i("li"),Xs=s("기본적으로, NAT 환경에서 사용자 장치는 자신의 Public IP를 알 수 없음"),Ys=f(),Ie=i("li"),gs=s("STUN 서버는 사용자의 Public IP를 알려주는 역할"),Li=i("ul"),he=i("li"),Xl=i("a"),l1=s("https://ipip.kr"),e1=s("에 접속하면 Public IP를 알 수 있음. 이와 유사한 역할"),t1=f(),Ti=i("li"),i1=s("STUN을 통해 사용자가 P2P UDP 통신을 위해 사용할 수 있는 IP주소와 포트번호를 찾아냄"),Ea=f(),na=i("br"),_a=f(),Pl=i("h3"),pl=i("a"),Ci=i("span"),r1=s("TURN"),da=f(),P=i("ul"),Ni=i("li"),a1=s("Traversal Using Relays around NAT"),f1=f(),Ui=i("li"),o1=s("상대 Peer에게 보낼 정보를 TURN 서버에 전달하고, TURN이 상대 Peer에게 전달해줌"),s1=f(),Si=i("li"),u1=s("Symmetric NAT 등, Router의 NAT으로 생기는 제약 조건 등을 우회함"),v1=f(),Ri=i("li"),E1=s("오버헤드가 발생하지만 대안이 없는 경우 사용"),n1=f(),mi=i("li"),_1=s("SFU, MCU도 TURN 서버의 일종이라고 볼 수 있음"),ca=f(),Pa=i("br"),pa=f(),Il=i("h3"),hl=i("a"),Ai=i("span"),d1=s("P2P vs SFU vs MCU"),Ia=f(),Yi(Yl.$$.fragment),ha=f(),m=i("ul"),gl=i("li"),xi=i("p"),c1=s("P2P"),P1=f(),C=i("ul"),Wi=i("li"),p1=s("각 사용자는 (전체 사용자-1) 만큼의 업로드/다운로드 연결을 가짐"),I1=f(),$i=i("li"),h1=s("서버의 부담이 덜하며 지연시간이 가장 짧음"),b1=f(),wi=i("li"),L1=s("통신에 참여하는 사용자가 많아질수록 클라이언트의 워크로드가 급격히 증가함"),T1=f(),ki=i("li"),C1=s("1:1 통신 및 소규모의 1:N, N:N 통신에 적합"),N1=f(),le=i("li"),Di=i("p"),U1=s("SFU"),S1=f(),p=i("ul"),yi=i("li"),R1=s("각 사용자는 한 개의 중앙 서버와의 업로드 연결, 그리고 (전체 사용자-1) 만큼의 다운로드 연결을 가짐"),m1=f(),Hi=i("li"),A1=s("지연 시간이 P2P보다는 길지만 MCU보다는 빠름"),x1=f(),Bi=i("li"),W1=s("데이터가 서버를 거치기 때문에 서버 부담이 존재"),$1=f(),Oi=i("li"),w1=s("클라이언트의 워크로드를 줄일 수 있지만, 대규모의 N:N 통신에서는 여전히 부하가 심함"),k1=f(),Mi=i("li"),D1=s("1:N 및 대규모가 아닌 N:N 통신에 적합"),y1=f(),ee=i("li"),Fi=i("p"),H1=s("MCU"),B1=f(),N=i("ul"),Gi=i("li"),O1=s("각 사용자는 한 개의 중앙 서버와의 업로드/다운로드 연결을 가짐"),M1=f(),qi=i("li"),F1=s("클라이언트 부담 최소화"),G1=f(),Qi=i("li"),q1=s("데이터가 서버를 거쳐, 각 클라이언트들에게 데이터를 처리하여 분배해야 하기 때문에 서버 부담이 매우 크며 지연 시간이 길어짐"),Q1=f(),ji=i("li"),j1=s("대규모 N:N 통신에 적합"),ba=f(),La=i("br"),Ta=f(),bl=i("h3"),Ll=i("a"),zi=i("span"),z1=s("Signaling Server"),Ca=f(),Yi(te.$$.fragment),Na=f(),L=i("ul"),Zi=i("li"),Z1=s("기기 사이에서 연결 생성 및 해제"),J1=f(),Ji=i("li"),K1=s("통신할 대상을 찾아주는 역할"),V1=f(),Ki=i("li"),X1=s("SDP나 ICE Candidates 등 연결 생성을 위한 데이터가 각 피어에게 전달됨"),Y1=f(),Vi=i("li"),g1=s("Websocket, HTTPS 등 서로 다른 통신 프로토콜로 설계 가능"),Ua=f(),Sa=i("br"),Ra=i("br"),ma=f(),Tl=i("h2"),Cl=i("a"),Xi=i("span"),l2=s("출처"),Aa=f(),ie=i("p"),e2=s("WebRTC : "),re=i("a"),t2=s("https://wormwlrm.github.io/2021/01/24/Introducing-WebRTC.html"),xa=f(),Wa=i("br"),$a=i("br"),this.h()},l(e){M=r(e,"P",{});var v=a(M);tf=u(v,"교내 프로젝트, 교과목, 스터디를 통해 정리한 WebRTC 관련 내용을 기록해보았습니다"),v.forEach(t),ar=o(e),fr=r(e,"BR",{}),or=r(e,"BR",{}),sr=o(e),F=r(e,"H2",{id:!0});var i2=a(F);G=r(i2,"A",{"aria-hidden":!0,tabindex:!0,href:!0});var y2=a(G);We=r(y2,"SPAN",{class:!0}),a(We).forEach(t),y2.forEach(t),rf=u(i2,"WebRTC"),i2.forEach(t),ur=o(e),vr=r(e,"HR",{}),Er=o(e),q=r(e,"H3",{id:!0});var r2=a(q);Q=r(r2,"A",{"aria-hidden":!0,tabindex:!0,href:!0});var H2=a(Q);$e=r(H2,"SPAN",{class:!0}),a($e).forEach(t),H2.forEach(t),af=u(r2,"WebRTC란?"),r2.forEach(t),nr=o(e),_=r(e,"UL",{});var T=a(_);we=r(T,"LI",{});var B2=a(we);ke=r(B2,"P",{});var O2=a(ke);ff=u(O2,"Web Real-Time Communication의 약자"),O2.forEach(t),B2.forEach(t),of=o(T),xl=r(T,"LI",{});var ka=a(xl);Wl=r(ka,"P",{});var Da=a(Wl);sf=u(Da,"별도의 소프트웨어나 플러그인 없이 ("),De=r(Da,"STRONG",{});var M2=a(De);uf=u(M2,"웹 브라우저 만으로도"),M2.forEach(t),vf=u(Da,") 오디오 및 비디오 데이터를 주고받을 수 있음"),Da.forEach(t),Ef=o(ka),ye=r(ka,"UL",{});var F2=a(ye);He=r(F2,"LI",{});var G2=a(He);nf=u(G2,"화상 통화, 실시간 회의 등 구현 가능"),G2.forEach(t),F2.forEach(t),ka.forEach(t),_f=o(T),Be=r(T,"LI",{});var q2=a(Be);Oe=r(q2,"P",{});var Q2=a(Oe);df=u(Q2,"웹 브라우저 뿐 아니라 IOS, Android Native App 위에서도 동작함"),Q2.forEach(t),q2.forEach(t),cf=o(T),Me=r(T,"LI",{});var j2=a(Me);Fe=r(j2,"P",{});var z2=a(Fe);Pf=u(z2,"구글이 표준화를 주도하고 있어, Chrome 호환성이 제일 좋음"),z2.forEach(t),j2.forEach(t),pf=o(T),Ge=r(T,"LI",{});var Z2=a(Ge);qe=r(Z2,"P",{});var J2=a(qe);If=u(J2,"UDP, 피어-to-피어로 통신함"),J2.forEach(t),Z2.forEach(t),hf=o(T),$l=r(T,"LI",{});var ya=a($l);Qe=r(ya,"P",{});var K2=a(Qe);bf=u(K2,"브라우저 API 제공"),K2.forEach(t),Lf=o(ya),w=r(ya,"UL",{});var be=a(w);ae=r(be,"LI",{});var a2=a(ae);je=r(a2,"CODE",{});var V2=a(je);Tf=u(V2,"RTC피어Connection()"),V2.forEach(t),Cf=u(a2," : signal 처리, 코덱 처리, p2p 통신, 보안, bandwidth 관리 등, 다양한 역할을 하는 WebRTC 통신 주요 class"),a2.forEach(t),Nf=o(be),fe=r(be,"LI",{});var f2=a(fe);ze=r(f2,"CODE",{});var X2=a(ze);Uf=u(X2,"getUserMedia()"),X2.forEach(t),Sf=u(f2," : 카메라나 마이크 등 장치에 접근하여 유저 데이터를 capture"),f2.forEach(t),Rf=o(be),oe=r(be,"LI",{});var o2=a(oe);Ze=r(o2,"CODE",{});var Y2=a(Ze);mf=u(Y2,"RTCDataChannel()"),Y2.forEach(t),Af=u(o2," : 오디오, 비디오 외의 비정형 데이터를 주고받기 위함. WebSocket과 거의 유사한 api"),o2.forEach(t),be.forEach(t),ya.forEach(t),T.forEach(t),_r=o(e),dr=r(e,"BR",{}),cr=o(e),j=r(e,"H3",{id:!0});var s2=a(j);z=r(s2,"A",{"aria-hidden":!0,tabindex:!0,href:!0});var g2=a(z);Je=r(g2,"SPAN",{class:!0}),a(Je).forEach(t),g2.forEach(t),xf=u(s2,"WebRTC 장점"),s2.forEach(t),Pr=o(e),d=r(e,"OL",{});var A=a(d);wl=r(A,"LI",{});var Ha=a(wl);Ke=r(Ha,"P",{});var lu=a(Ke);Wf=u(lu,"UDP를 사용하여 지연시간이 매우 짧다"),lu.forEach(t),$f=o(Ha),kl=r(Ha,"UL",{});var Ba=a(kl);Ve=r(Ba,"LI",{});var eu=a(Ve);wf=u(eu,"카메라로 찍은 화면이 상대에게 도달하기까지 걸리는 시간이 500ms 이하"),eu.forEach(t),kf=o(Ba),Xe=r(Ba,"LI",{});var tu=a(Xe);Df=u(tu,"다른 HTTP Live Stream 기술들의 경우, 주로 영상을 사람들에게 뿌리는(1:N) 용도라서 지연 시간이 존재"),tu.forEach(t),Ba.forEach(t),Ha.forEach(t),yf=o(A),Dl=r(A,"LI",{});var Oa=a(Dl);Ye=r(Oa,"P",{});var iu=a(Ye);Hf=u(iu,"Platform and Device Independent"),iu.forEach(t),Bf=o(Oa),ge=r(Oa,"UL",{});var ru=a(ge);lt=r(ru,"LI",{});var au=a(lt);Of=u(au,"웹브라우저 위에서 돌아가도록 설계되었기 때문에, 브라우저만 돌아가면 OS, 장치가 무엇이든 상관없음"),au.forEach(t),ru.forEach(t),Oa.forEach(t),Mf=o(A),yl=r(A,"LI",{});var Ma=a(yl);et=r(Ma,"P",{});var fu=a(et);Ff=u(fu,"Open-source 및 표준화되어있음"),fu.forEach(t),Gf=o(Ma),tt=r(Ma,"UL",{});var ou=a(tt);it=r(ou,"LI",{});var su=a(it);qf=u(su,"언어별로 표준 문서가 존재하며, 표준대로 진행하면 모두 연결 가능함"),su.forEach(t),ou.forEach(t),Ma.forEach(t),Qf=o(A),Hl=r(A,"LI",{});var Fa=a(Hl);rt=r(Fa,"P",{});var uu=a(rt);jf=u(uu,"네트워크 성능에 따라 품질 조정"),uu.forEach(t),zf=o(Fa),k=r(Fa,"UL",{});var Le=a(k);at=r(Le,"LI",{});var vu=a(at);Zf=u(vu,"네트워크 성능에 따라 전송받는 (영상)데이터의 품질(화질)이 달라질 수 있음"),vu.forEach(t),Jf=o(Le),ft=r(Le,"LI",{});var Eu=a(ft);Kf=u(Eu,"하지만 한 순간에는 특정 해상도의 영상 하나만 받을 수 있음"),Eu.forEach(t),Vf=o(Le),se=r(Le,"LI",{});var u2=a(se);Xf=u(u2,"Simulcasting"),Bl=r(u2,"UL",{});var Ga=a(Bl);ot=r(Ga,"LI",{});var nu=a(ot);Yf=u(nu,"동시의 여러 해상도의 영상을 보냄"),nu.forEach(t),gf=o(Ga),st=r(Ga,"LI",{});var _u=a(st);lo=u(_u,"bandwidth를 낭비하지만, 수신 장치가 알아서 적합한 품질의 영상 선택"),_u.forEach(t),Ga.forEach(t),u2.forEach(t),Le.forEach(t),Fa.forEach(t),eo=o(A),Ol=r(A,"LI",{});var qa=a(Ol);ut=r(qa,"P",{});var du=a(ut);to=u(du,"P2P의 장점"),du.forEach(t),io=o(qa),Ml=r(qa,"UL",{});var Qa=a(Ml);vt=r(Qa,"LI",{});var cu=a(vt);ro=u(cu,"주요 데이터가 서버를 경유하지 않기 때문에, 서버 입장에선 부담이 적음"),cu.forEach(t),ao=o(Qa),Et=r(Qa,"LI",{});var Pu=a(Et);fo=u(Pu,"유저 입장에선 내 데이터를 서버가 볼 수 없기 때문에, 안심하고 이용 가능"),Pu.forEach(t),Qa.forEach(t),qa.forEach(t),A.forEach(t),pr=o(e),Ir=r(e,"BR",{}),hr=o(e),Z=r(e,"H3",{id:!0});var v2=a(Z);J=r(v2,"A",{"aria-hidden":!0,tabindex:!0,href:!0});var pu=a(J);nt=r(pu,"SPAN",{class:!0}),a(nt).forEach(t),pu.forEach(t),oo=u(v2,"WebRTC 단점"),v2.forEach(t),br=o(e),U=r(e,"OL",{});var Te=a(U);Fl=r(Te,"LI",{});var ja=a(Fl);_t=r(ja,"P",{});var Iu=a(_t);so=u(Iu,"Scalability"),Iu.forEach(t),uo=o(ja),D=r(ja,"UL",{});var Ce=a(D);dt=r(Ce,"LI",{});var hu=a(dt);vo=u(hu,"하나의 세션에 참가하는 통신 대상이 일정 이상 늘어나기 어려움"),hu.forEach(t),Eo=o(Ce),ue=r(Ce,"LI",{});var E2=a(ue);no=u(E2,"통신하는 대상의 수가 제한됨"),ct=r(E2,"UL",{});var bu=a(ct);Pt=r(bu,"LI",{});var Lu=a(Pt);_o=u(Lu,"권고에 따르면 최대 50개 (WebRTC expert Tsahi LeventLevi recommends staying shy of any more than 50 concurrent 피어 connections.)"),Lu.forEach(t),bu.forEach(t),E2.forEach(t),co=o(Ce),ve=r(Ce,"LI",{});var n2=a(ve);Po=u(n2,"몇 천 명의 유저가 통신하는 경우, live streaming server를 두어 데이터를 분산시킴"),pt=r(n2,"UL",{});var Tu=a(pt);It=r(Tu,"LI",{});var Cu=a(It);po=u(Cu,"SFU, MCU 등이 대표적"),Cu.forEach(t),Tu.forEach(t),n2.forEach(t),Ce.forEach(t),ja.forEach(t),Io=o(Te),Gl=r(Te,"LI",{});var za=a(Gl);ht=r(za,"P",{});var Nu=a(ht);ho=u(Nu,"Broadcast Quality"),Nu.forEach(t),bo=o(za),bt=r(za,"UL",{});var Uu=a(bt);Lt=r(Uu,"LI",{});var Su=a(Lt);Lo=u(Su,"WebRTC 자체에 퀄리티 문제는 없지만, Broadcast를 함으로써 발생하는 영상 품질의 하락 문제"),Su.forEach(t),Uu.forEach(t),za.forEach(t),To=o(Te),ql=r(Te,"LI",{});var Za=a(ql);Tt=r(Za,"P",{});var Ru=a(Tt);Co=u(Ru,"그래도 서버가 필요함"),Ru.forEach(t),No=o(Za),y=r(Za,"UL",{});var Ne=a(y);Ct=r(Ne,"LI",{});var mu=a(Ct);Uo=u(mu,"두 피어끼리의 connection 생성 및 해제 -> Signaling Server"),mu.forEach(t),So=o(Ne),Nt=r(Ne,"LI",{});var Au=a(Nt);Ro=u(Au,"피어간 통신이 가능한지 여부 또는 Public IP를 확인해야 하는 경우 -> STUN 서버"),Au.forEach(t),mo=o(Ne),Ut=r(Ne,"LI",{});var xu=a(Ut);Ao=u(xu,"다양한 네트워크 상의 이슈(방화벽, 공유기나 라우터의 보안 정책 등) 때문에 피어간 직접 통신이 되지 않을 경우 -> TURN 서버를 통해 데이터를 Relay"),xu.forEach(t),Ne.forEach(t),Za.forEach(t),Te.forEach(t),Lr=o(e),Tr=r(e,"BR",{}),Cr=o(e),K=r(e,"H3",{id:!0});var _2=a(K);V=r(_2,"A",{"aria-hidden":!0,tabindex:!0,href:!0});var Wu=a(V);St=r(Wu,"SPAN",{class:!0}),a(St).forEach(t),Wu.forEach(t),xo=u(_2,"WebRTC 동작 흐름"),_2.forEach(t),Nr=o(e),gi(Ql.$$.fragment,e),Ur=o(e),S=r(e,"OL",{});var Ue=a(S);Rt=r(Ue,"LI",{});var $u=a(Rt);Wo=u($u,"Signaling Server : 기기 사이에서 커넥션을 생성 및 해제해주고, 통신할 대상을 찾아줌"),$u.forEach(t),$o=o(Ue),mt=r(Ue,"LI",{});var wu=a(mt);wo=u(wu,"STUN Server : 요청자의 Public IP를 확인"),wu.forEach(t),ko=o(Ue),At=r(Ue,"LI",{});var ku=a(At);Do=u(ku,"TURN Server : P2P로 데이터를 직접 전송할 수 없다면, 데이터를 Relay"),ku.forEach(t),Ue.forEach(t),Sr=o(e),Ee=r(e,"P",{});var Du=a(Ee);yo=u(Du,"자세한 내용은 아래에서 다룰 예정"),Du.forEach(t),Rr=o(e),mr=r(e,"BR",{}),Ar=r(e,"BR",{}),xr=o(e),X=r(e,"H2",{id:!0});var d2=a(X);Y=r(d2,"A",{"aria-hidden":!0,tabindex:!0,href:!0});var yu=a(Y);xt=r(yu,"SPAN",{class:!0}),a(xt).forEach(t),yu.forEach(t),Ho=u(d2,"SDP"),d2.forEach(t),Wr=o(e),$r=r(e,"HR",{}),wr=o(e),g=r(e,"H3",{id:!0});var c2=a(g);ll=r(c2,"A",{"aria-hidden":!0,tabindex:!0,href:!0});var Hu=a(ll);Wt=r(Hu,"SPAN",{class:!0}),a(Wt).forEach(t),Hu.forEach(t),Bo=u(c2,"SDP란?"),c2.forEach(t),kr=o(e),gi(jl.$$.fragment,e),Dr=o(e),I=r(e,"UL",{});var Nl=a(I);$t=r(Nl,"LI",{});var Bu=a($t);Oo=u(Bu,"Session Description Protocol의 약자 (실질적으로는 프로토콜이 아니긴 함)"),Bu.forEach(t),Mo=o(Nl),wt=r(Nl,"LI",{});var Ou=a(wt);Fo=u(Ou,"해상도, 형식, 코덱, 암호화 등, 컨텐츠에 대한 메타데이터 정보"),Ou.forEach(t),Go=o(Nl),kt=r(Nl,"LI",{});var Mu=a(kt);qo=u(Mu,"누구와 어떻게 대화할지에 대한 정보를 포함함"),Mu.forEach(t),Qo=o(Nl),ne=r(Nl,"LI",{});var P2=a(ne);jo=u(P2,"SIP(Session Initiation Protocol)를 통해 SDP를 전송"),Dt=r(P2,"UL",{});var Fu=a(Dt);yt=r(Fu,"LI",{});var Gu=a(yt);zo=u(Gu,"SIP는 WebRTC 이전에도 존재하던 사용자/참가자 그룹 간의 연결 설정 프로토콜이며, WebRTC는 SIP를 사용하여 Session 설정"),Gu.forEach(t),Fu.forEach(t),P2.forEach(t),Nl.forEach(t),yr=o(e),Hr=r(e,"BR",{}),Br=r(e,"BR",{}),Or=o(e),el=r(e,"H2",{id:!0});var p2=a(el);tl=r(p2,"A",{"aria-hidden":!0,tabindex:!0,href:!0});var qu=a(tl);Ht=r(qu,"SPAN",{class:!0}),a(Ht).forEach(t),qu.forEach(t),Zo=u(p2,"ICE"),p2.forEach(t),Mr=o(e),Fr=r(e,"HR",{}),Gr=o(e),il=r(e,"H3",{id:!0});var I2=a(il);rl=r(I2,"A",{"aria-hidden":!0,tabindex:!0,href:!0});var Qu=a(rl);Bt=r(Qu,"SPAN",{class:!0}),a(Bt).forEach(t),Qu.forEach(t),Jo=u(I2,"ICE란?"),I2.forEach(t),qr=o(e),c=r(e,"UL",{});var x=a(c);Ot=r(x,"LI",{});var ju=a(Ot);Mt=r(ju,"P",{});var zu=a(Mt);Ko=u(zu,"Interactive Connectivity Establishment"),zu.forEach(t),ju.forEach(t),Vo=o(x),Ft=r(x,"LI",{});var Zu=a(Ft);Gt=r(Zu,"P",{});var Ju=a(Gt);Xo=u(Ju,"브라우저가 피어를 통한 연결이 가능하게 해주는 프레임워크"),Ju.forEach(t),Zu.forEach(t),Yo=o(x),qt=r(x,"LI",{});var Ku=a(qt);zl=r(Ku,"P",{});var Ja=a(zl);go=u(Ja,"두 피어간 "),Qt=r(Ja,"STRONG",{});var Vu=a(Qt);ls=u(Vu,"최적의 경로"),Vu.forEach(t),es=u(Ja,"를 찾아줌 (NAT Traversal)"),Ja.forEach(t),Ku.forEach(t),ts=o(x),Zl=r(x,"LI",{});var Ka=a(Zl);jt=r(Ka,"P",{});var Xu=a(jt);is=u(Xu,"피어끼리 연결이 쉽지 않은 이유"),Xu.forEach(t),rs=o(Ka),H=r(Ka,"UL",{});var Se=a(H);zt=r(Se,"LI",{});var Yu=a(zt);as=u(Yu,"방화벽에 걸리는 경우"),Yu.forEach(t),fs=o(Se),Zt=r(Se,"LI",{});var gu=a(Zt);os=u(gu,"장치에 Public IP가 없는 경우"),gu.forEach(t),ss=o(Se),Jt=r(Se,"LI",{});var lv=a(Jt);us=u(lv,"라우터의 보안 정책이 피어간 직접 연결을 막는 경우"),lv.forEach(t),Se.forEach(t),Ka.forEach(t),vs=o(x),Jl=r(x,"LI",{});var Va=a(Jl);Kt=r(Va,"P",{});var ev=a(Kt);Es=u(ev,"ICE는 STUN서버와 TURN서버를 사용하여 이러한 작업 수행"),ev.forEach(t),ns=o(Va),Vt=r(Va,"UL",{});var tv=a(Vt);_e=r(tv,"LI",{});var h2=a(_e);_s=u(h2,"일반적으로, STUN, TURN 서버까지 거치고 나면 다음과 같은 주소를 얻음"),B=r(h2,"UL",{});var Re=a(B);Xt=r(Re,"LI",{});var iv=a(Xt);ds=u(iv,"Private IP, Port"),iv.forEach(t),cs=o(Re),Yt=r(Re,"LI",{});var rv=a(Yt);Ps=u(rv,"Public IP, Port (through STUN)"),rv.forEach(t),ps=o(Re),gt=r(Re,"LI",{});var av=a(gt);Is=u(av,"TURN 서버의 IP, Port(through TURN)"),av.forEach(t),Re.forEach(t),h2.forEach(t),tv.forEach(t),Va.forEach(t),x.forEach(t),Qr=o(e),jr=r(e,"BR",{}),zr=o(e),al=r(e,"H3",{id:!0});var b2=a(al);fl=r(b2,"A",{"aria-hidden":!0,tabindex:!0,href:!0});var fv=a(fl);li=r(fv,"SPAN",{class:!0}),a(li).forEach(t),fv.forEach(t),hs=u(b2,"ICE Candidates"),b2.forEach(t),Zr=o(e),h=r(e,"UL",{});var Ul=a(h);ei=r(Ul,"LI",{});var ov=a(ei);bs=u(ov,"WebRTC 피어 연결을 시작하면, 일반적으로 여러개의 candiate들이 각 피어에 의해 만들어짐"),ov.forEach(t),Ls=o(Ul),Kl=r(Ul,"LI",{});var Xa=a(Kl);Ts=u(Xa,"구분자("),ti=r(Xa,"CODE",{});var sv=a(ti);Cs=u(sv,"foundation"),sv.forEach(t),Ns=u(Xa,"), IP, 포트, 우선순위, 프로토콜 등으로 구성"),Xa.forEach(t),Us=o(Ul),ii=r(Ul,"LI",{});var uv=a(ii);Ss=u(uv,"UDP가 기본이지만 UDP가 안되면 TCP도 허용함"),uv.forEach(t),Rs=o(Ul),ri=r(Ul,"LI",{});var vv=a(ri);ms=u(vv,"각 피어가 수집한 ICE Candidates로 패킷을 보내 본 뒤, 가장 latency가 낮고 안정적인 ICE Candidates를 사용"),vv.forEach(t),Ul.forEach(t),Jr=o(e),Kr=r(e,"BR",{}),Vr=o(e),ol=r(e,"H3",{id:!0});var L2=a(ol);sl=r(L2,"A",{"aria-hidden":!0,tabindex:!0,href:!0});var Ev=a(sl);ai=r(Ev,"SPAN",{class:!0}),a(ai).forEach(t),Ev.forEach(t),As=u(L2,"Trickle ICE"),L2.forEach(t),Xr=o(e),ul=r(e,"UL",{});var Ya=a(ul);de=r(Ya,"LI",{});var T2=a(de);xs=u(T2,"일반적으로 피어는 ICE Candidates를 수집하여 목록을 완성한 후 한꺼번에 교환함"),fi=r(T2,"UL",{});var nv=a(fi);oi=r(nv,"LI",{});var _v=a(oi);Ws=u(_v,"이 방식은 네트워크 지연 등 이유로 ICE Candidates를 수집하는 데 오래 걸릴 수 있음"),_v.forEach(t),nv.forEach(t),T2.forEach(t),$s=o(Ya),ce=r(Ya,"LI",{});var C2=a(ce);ws=u(C2,"비효율적인 ICE Candidates 교환 작업을 비동기 처리"),si=r(C2,"UL",{});var dv=a(si);ui=r(dv,"LI",{});var cv=a(ui);ks=u(cv,"ICE Candidates를 찾은 즉시 피어에게 전송"),cv.forEach(t),dv.forEach(t),C2.forEach(t),Ya.forEach(t),Yr=o(e),gr=r(e,"BR",{}),la=r(e,"BR",{}),ea=o(e),vl=r(e,"H2",{id:!0});var N2=a(vl);El=r(N2,"A",{"aria-hidden":!0,tabindex:!0,href:!0});var Pv=a(El);vi=r(Pv,"SPAN",{class:!0}),a(vi).forEach(t),Pv.forEach(t),Ds=u(N2,"Signaling"),N2.forEach(t),ta=o(e),ia=r(e,"HR",{}),ra=o(e),nl=r(e,"H3",{id:!0});var U2=a(nl);_l=r(U2,"A",{"aria-hidden":!0,tabindex:!0,href:!0});var pv=a(_l);Ei=r(pv,"SPAN",{class:!0}),a(Ei).forEach(t),pv.forEach(t),ys=u(U2,"NAT?"),U2.forEach(t),aa=o(e),gi(Vl.$$.fragment,e),fa=o(e),R=r(e,"UL",{});var me=a(R);ni=r(me,"LI",{});var Iv=a(ni);Hs=u(Iv,"Network Address Translation"),Iv.forEach(t),Bs=o(me),Pe=r(me,"LI",{});var S2=a(Pe);Os=u(S2,"일반적인 사용자의 네트워크 환경에서는 대부분 공유기를 두기 때문에 Private IP, Public IP가 각각 존재함"),_i=r(S2,"UL",{});var hv=a(_i);di=r(hv,"LI",{});var bv=a(di);Ms=u(bv,"(일반적인 경우) 한 대의 공유기에 여러 대의 장치가 연결되고, 따라서 한 개의 Public IP와 여러 개의 Private IP가 존재함"),bv.forEach(t),hv.forEach(t),S2.forEach(t),Fs=o(me),pe=r(me,"LI",{});var R2=a(pe);Gs=u(R2,"이 때 NAT는 Public IP를 특정 Private IP로 매핑시킴"),O=r(R2,"UL",{});var Ae=a(O);ci=r(Ae,"LI",{});var Lv=a(ci);qs=u(Lv,"다만 연결된 장치 개수만큼 여러 대의 Private IP가 Public IP에 매핑될 필요가 있기에, PAT도 함께 적용"),Lv.forEach(t),Qs=o(Ae),Pi=r(Ae,"LI",{});var Tv=a(Pi);js=u(Tv,"NAT + PAT(포트포워딩이라고도 함)는 Public IP:특정 포트를, 특정 Private IP:특정 포트로 매핑시킴"),Tv.forEach(t),zs=o(Ae),pi=r(Ae,"LI",{});var Cv=a(pi);Zs=u(Cv,"위 그림에서 Public IP:80으로 요청을 보내면, 192.168.0.37을 가진 장치가 80번 포트로 요청을 받을 것"),Cv.forEach(t),Ae.forEach(t),R2.forEach(t),me.forEach(t),oa=o(e),sa=r(e,"BR",{}),ua=o(e),dl=r(e,"H3",{id:!0});var m2=a(dl);cl=r(m2,"A",{"aria-hidden":!0,tabindex:!0,href:!0});var Nv=a(cl);Ii=r(Nv,"SPAN",{class:!0}),a(Ii).forEach(t),Nv.forEach(t),Js=u(m2,"STUN"),m2.forEach(t),va=o(e),b=r(e,"UL",{});var Sl=a(b);hi=r(Sl,"LI",{});var Uv=a(hi);Ks=u(Uv,"Session Traversal Utilities for NAT"),Uv.forEach(t),Vs=o(Sl),bi=r(Sl,"LI",{});var Sv=a(bi);Xs=u(Sv,"기본적으로, NAT 환경에서 사용자 장치는 자신의 Public IP를 알 수 없음"),Sv.forEach(t),Ys=o(Sl),Ie=r(Sl,"LI",{});var A2=a(Ie);gs=u(A2,"STUN 서버는 사용자의 Public IP를 알려주는 역할"),Li=r(A2,"UL",{});var Rv=a(Li);he=r(Rv,"LI",{});var x2=a(he);Xl=r(x2,"A",{href:!0,rel:!0});var mv=a(Xl);l1=u(mv,"https://ipip.kr"),mv.forEach(t),e1=u(x2,"에 접속하면 Public IP를 알 수 있음. 이와 유사한 역할"),x2.forEach(t),Rv.forEach(t),A2.forEach(t),t1=o(Sl),Ti=r(Sl,"LI",{});var Av=a(Ti);i1=u(Av,"STUN을 통해 사용자가 P2P UDP 통신을 위해 사용할 수 있는 IP주소와 포트번호를 찾아냄"),Av.forEach(t),Sl.forEach(t),Ea=o(e),na=r(e,"BR",{}),_a=o(e),Pl=r(e,"H3",{id:!0});var W2=a(Pl);pl=r(W2,"A",{"aria-hidden":!0,tabindex:!0,href:!0});var xv=a(pl);Ci=r(xv,"SPAN",{class:!0}),a(Ci).forEach(t),xv.forEach(t),r1=u(W2,"TURN"),W2.forEach(t),da=o(e),P=r(e,"UL",{});var W=a(P);Ni=r(W,"LI",{});var Wv=a(Ni);a1=u(Wv,"Traversal Using Relays around NAT"),Wv.forEach(t),f1=o(W),Ui=r(W,"LI",{});var $v=a(Ui);o1=u($v,"상대 Peer에게 보낼 정보를 TURN 서버에 전달하고, TURN이 상대 Peer에게 전달해줌"),$v.forEach(t),s1=o(W),Si=r(W,"LI",{});var wv=a(Si);u1=u(wv,"Symmetric NAT 등, Router의 NAT으로 생기는 제약 조건 등을 우회함"),wv.forEach(t),v1=o(W),Ri=r(W,"LI",{});var kv=a(Ri);E1=u(kv,"오버헤드가 발생하지만 대안이 없는 경우 사용"),kv.forEach(t),n1=o(W),mi=r(W,"LI",{});var Dv=a(mi);_1=u(Dv,"SFU, MCU도 TURN 서버의 일종이라고 볼 수 있음"),Dv.forEach(t),W.forEach(t),ca=o(e),Pa=r(e,"BR",{}),pa=o(e),Il=r(e,"H3",{id:!0});var $2=a(Il);hl=r($2,"A",{"aria-hidden":!0,tabindex:!0,href:!0});var yv=a(hl);Ai=r(yv,"SPAN",{class:!0}),a(Ai).forEach(t),yv.forEach(t),d1=u($2,"P2P vs SFU vs MCU"),$2.forEach(t),Ia=o(e),gi(Yl.$$.fragment,e),ha=o(e),m=r(e,"UL",{});var xe=a(m);gl=r(xe,"LI",{});var ga=a(gl);xi=r(ga,"P",{});var Hv=a(xi);c1=u(Hv,"P2P"),Hv.forEach(t),P1=o(ga),C=r(ga,"UL",{});var Rl=a(C);Wi=r(Rl,"LI",{});var Bv=a(Wi);p1=u(Bv,"각 사용자는 (전체 사용자-1) 만큼의 업로드/다운로드 연결을 가짐"),Bv.forEach(t),I1=o(Rl),$i=r(Rl,"LI",{});var Ov=a($i);h1=u(Ov,"서버의 부담이 덜하며 지연시간이 가장 짧음"),Ov.forEach(t),b1=o(Rl),wi=r(Rl,"LI",{});var Mv=a(wi);L1=u(Mv,"통신에 참여하는 사용자가 많아질수록 클라이언트의 워크로드가 급격히 증가함"),Mv.forEach(t),T1=o(Rl),ki=r(Rl,"LI",{});var Fv=a(ki);C1=u(Fv,"1:1 통신 및 소규모의 1:N, N:N 통신에 적합"),Fv.forEach(t),Rl.forEach(t),ga.forEach(t),N1=o(xe),le=r(xe,"LI",{});var lf=a(le);Di=r(lf,"P",{});var Gv=a(Di);U1=u(Gv,"SFU"),Gv.forEach(t),S1=o(lf),p=r(lf,"UL",{});var $=a(p);yi=r($,"LI",{});var qv=a(yi);R1=u(qv,"각 사용자는 한 개의 중앙 서버와의 업로드 연결, 그리고 (전체 사용자-1) 만큼의 다운로드 연결을 가짐"),qv.forEach(t),m1=o($),Hi=r($,"LI",{});var Qv=a(Hi);A1=u(Qv,"지연 시간이 P2P보다는 길지만 MCU보다는 빠름"),Qv.forEach(t),x1=o($),Bi=r($,"LI",{});var jv=a(Bi);W1=u(jv,"데이터가 서버를 거치기 때문에 서버 부담이 존재"),jv.forEach(t),$1=o($),Oi=r($,"LI",{});var zv=a(Oi);w1=u(zv,"클라이언트의 워크로드를 줄일 수 있지만, 대규모의 N:N 통신에서는 여전히 부하가 심함"),zv.forEach(t),k1=o($),Mi=r($,"LI",{});var Zv=a(Mi);D1=u(Zv,"1:N 및 대규모가 아닌 N:N 통신에 적합"),Zv.forEach(t),$.forEach(t),lf.forEach(t),y1=o(xe),ee=r(xe,"LI",{});var ef=a(ee);Fi=r(ef,"P",{});var Jv=a(Fi);H1=u(Jv,"MCU"),Jv.forEach(t),B1=o(ef),N=r(ef,"UL",{});var ml=a(N);Gi=r(ml,"LI",{});var Kv=a(Gi);O1=u(Kv,"각 사용자는 한 개의 중앙 서버와의 업로드/다운로드 연결을 가짐"),Kv.forEach(t),M1=o(ml),qi=r(ml,"LI",{});var Vv=a(qi);F1=u(Vv,"클라이언트 부담 최소화"),Vv.forEach(t),G1=o(ml),Qi=r(ml,"LI",{});var Xv=a(Qi);q1=u(Xv,"데이터가 서버를 거쳐, 각 클라이언트들에게 데이터를 처리하여 분배해야 하기 때문에 서버 부담이 매우 크며 지연 시간이 길어짐"),Xv.forEach(t),Q1=o(ml),ji=r(ml,"LI",{});var Yv=a(ji);j1=u(Yv,"대규모 N:N 통신에 적합"),Yv.forEach(t),ml.forEach(t),ef.forEach(t),xe.forEach(t),ba=o(e),La=r(e,"BR",{}),Ta=o(e),bl=r(e,"H3",{id:!0});var w2=a(bl);Ll=r(w2,"A",{"aria-hidden":!0,tabindex:!0,href:!0});var gv=a(Ll);zi=r(gv,"SPAN",{class:!0}),a(zi).forEach(t),gv.forEach(t),z1=u(w2,"Signaling Server"),w2.forEach(t),Ca=o(e),gi(te.$$.fragment,e),Na=o(e),L=r(e,"UL",{});var Al=a(L);Zi=r(Al,"LI",{});var lE=a(Zi);Z1=u(lE,"기기 사이에서 연결 생성 및 해제"),lE.forEach(t),J1=o(Al),Ji=r(Al,"LI",{});var eE=a(Ji);K1=u(eE,"통신할 대상을 찾아주는 역할"),eE.forEach(t),V1=o(Al),Ki=r(Al,"LI",{});var tE=a(Ki);X1=u(tE,"SDP나 ICE Candidates 등 연결 생성을 위한 데이터가 각 피어에게 전달됨"),tE.forEach(t),Y1=o(Al),Vi=r(Al,"LI",{});var iE=a(Vi);g1=u(iE,"Websocket, HTTPS 등 서로 다른 통신 프로토콜로 설계 가능"),iE.forEach(t),Al.forEach(t),Ua=o(e),Sa=r(e,"BR",{}),Ra=r(e,"BR",{}),ma=o(e),Tl=r(e,"H2",{id:!0});var k2=a(Tl);Cl=r(k2,"A",{"aria-hidden":!0,tabindex:!0,href:!0});var rE=a(Cl);Xi=r(rE,"SPAN",{class:!0}),a(Xi).forEach(t),rE.forEach(t),l2=u(k2,"출처"),k2.forEach(t),Aa=o(e),ie=r(e,"P",{});var D2=a(ie);e2=u(D2,"WebRTC : "),re=r(D2,"A",{href:!0,rel:!0});var aE=a(re);t2=u(aE,"https://wormwlrm.github.io/2021/01/24/Introducing-WebRTC.html"),aE.forEach(t),D2.forEach(t),xa=o(e),Wa=r(e,"BR",{}),$a=r(e,"BR",{}),this.h()},h(){n(We,"class","icon icon-link"),n(G,"aria-hidden","true"),n(G,"tabindex","-1"),n(G,"href","#webrtc"),n(F,"id","webrtc"),n($e,"class","icon icon-link"),n(Q,"aria-hidden","true"),n(Q,"tabindex","-1"),n(Q,"href","#webrtc란"),n(q,"id","webrtc란"),n(Je,"class","icon icon-link"),n(z,"aria-hidden","true"),n(z,"tabindex","-1"),n(z,"href","#webrtc-장점"),n(j,"id","webrtc-장점"),n(nt,"class","icon icon-link"),n(J,"aria-hidden","true"),n(J,"tabindex","-1"),n(J,"href","#webrtc-단점"),n(Z,"id","webrtc-단점"),n(St,"class","icon icon-link"),n(V,"aria-hidden","true"),n(V,"tabindex","-1"),n(V,"href","#webrtc-동작-흐름"),n(K,"id","webrtc-동작-흐름"),n(xt,"class","icon icon-link"),n(Y,"aria-hidden","true"),n(Y,"tabindex","-1"),n(Y,"href","#sdp"),n(X,"id","sdp"),n(Wt,"class","icon icon-link"),n(ll,"aria-hidden","true"),n(ll,"tabindex","-1"),n(ll,"href","#sdp란"),n(g,"id","sdp란"),n(Ht,"class","icon icon-link"),n(tl,"aria-hidden","true"),n(tl,"tabindex","-1"),n(tl,"href","#ice"),n(el,"id","ice"),n(Bt,"class","icon icon-link"),n(rl,"aria-hidden","true"),n(rl,"tabindex","-1"),n(rl,"href","#ice란"),n(il,"id","ice란"),n(li,"class","icon icon-link"),n(fl,"aria-hidden","true"),n(fl,"tabindex","-1"),n(fl,"href","#ice-candidates"),n(al,"id","ice-candidates"),n(ai,"class","icon icon-link"),n(sl,"aria-hidden","true"),n(sl,"tabindex","-1"),n(sl,"href","#trickle-ice"),n(ol,"id","trickle-ice"),n(vi,"class","icon icon-link"),n(El,"aria-hidden","true"),n(El,"tabindex","-1"),n(El,"href","#signaling"),n(vl,"id","signaling"),n(Ei,"class","icon icon-link"),n(_l,"aria-hidden","true"),n(_l,"tabindex","-1"),n(_l,"href","#nat"),n(nl,"id","nat"),n(Ii,"class","icon icon-link"),n(cl,"aria-hidden","true"),n(cl,"tabindex","-1"),n(cl,"href","#stun"),n(dl,"id","stun"),n(Xl,"href","https://ipip.kr"),n(Xl,"rel","nofollow"),n(Ci,"class","icon icon-link"),n(pl,"aria-hidden","true"),n(pl,"tabindex","-1"),n(pl,"href","#turn"),n(Pl,"id","turn"),n(Ai,"class","icon icon-link"),n(hl,"aria-hidden","true"),n(hl,"tabindex","-1"),n(hl,"href","#p2p-vs-sfu-vs-mcu"),n(Il,"id","p2p-vs-sfu-vs-mcu"),n(zi,"class","icon icon-link"),n(Ll,"aria-hidden","true"),n(Ll,"tabindex","-1"),n(Ll,"href","#signaling-server"),n(bl,"id","signaling-server"),n(Xi,"class","icon icon-link"),n(Cl,"aria-hidden","true"),n(Cl,"tabindex","-1"),n(Cl,"href","#출처"),n(Tl,"id","출처"),n(re,"href","https://wormwlrm.github.io/2021/01/24/Introducing-WebRTC.html"),n(re,"rel","nofollow")},m(e,v){E(e,M,v),l(M,tf),E(e,ar,v),E(e,fr,v),E(e,or,v),E(e,sr,v),E(e,F,v),l(F,G),l(G,We),l(F,rf),E(e,ur,v),E(e,vr,v),E(e,Er,v),E(e,q,v),l(q,Q),l(Q,$e),l(q,af),E(e,nr,v),E(e,_,v),l(_,we),l(we,ke),l(ke,ff),l(_,of),l(_,xl),l(xl,Wl),l(Wl,sf),l(Wl,De),l(De,uf),l(Wl,vf),l(xl,Ef),l(xl,ye),l(ye,He),l(He,nf),l(_,_f),l(_,Be),l(Be,Oe),l(Oe,df),l(_,cf),l(_,Me),l(Me,Fe),l(Fe,Pf),l(_,pf),l(_,Ge),l(Ge,qe),l(qe,If),l(_,hf),l(_,$l),l($l,Qe),l(Qe,bf),l($l,Lf),l($l,w),l(w,ae),l(ae,je),l(je,Tf),l(ae,Cf),l(w,Nf),l(w,fe),l(fe,ze),l(ze,Uf),l(fe,Sf),l(w,Rf),l(w,oe),l(oe,Ze),l(Ze,mf),l(oe,Af),E(e,_r,v),E(e,dr,v),E(e,cr,v),E(e,j,v),l(j,z),l(z,Je),l(j,xf),E(e,Pr,v),E(e,d,v),l(d,wl),l(wl,Ke),l(Ke,Wf),l(wl,$f),l(wl,kl),l(kl,Ve),l(Ve,wf),l(kl,kf),l(kl,Xe),l(Xe,Df),l(d,yf),l(d,Dl),l(Dl,Ye),l(Ye,Hf),l(Dl,Bf),l(Dl,ge),l(ge,lt),l(lt,Of),l(d,Mf),l(d,yl),l(yl,et),l(et,Ff),l(yl,Gf),l(yl,tt),l(tt,it),l(it,qf),l(d,Qf),l(d,Hl),l(Hl,rt),l(rt,jf),l(Hl,zf),l(Hl,k),l(k,at),l(at,Zf),l(k,Jf),l(k,ft),l(ft,Kf),l(k,Vf),l(k,se),l(se,Xf),l(se,Bl),l(Bl,ot),l(ot,Yf),l(Bl,gf),l(Bl,st),l(st,lo),l(d,eo),l(d,Ol),l(Ol,ut),l(ut,to),l(Ol,io),l(Ol,Ml),l(Ml,vt),l(vt,ro),l(Ml,ao),l(Ml,Et),l(Et,fo),E(e,pr,v),E(e,Ir,v),E(e,hr,v),E(e,Z,v),l(Z,J),l(J,nt),l(Z,oo),E(e,br,v),E(e,U,v),l(U,Fl),l(Fl,_t),l(_t,so),l(Fl,uo),l(Fl,D),l(D,dt),l(dt,vo),l(D,Eo),l(D,ue),l(ue,no),l(ue,ct),l(ct,Pt),l(Pt,_o),l(D,co),l(D,ve),l(ve,Po),l(ve,pt),l(pt,It),l(It,po),l(U,Io),l(U,Gl),l(Gl,ht),l(ht,ho),l(Gl,bo),l(Gl,bt),l(bt,Lt),l(Lt,Lo),l(U,To),l(U,ql),l(ql,Tt),l(Tt,Co),l(ql,No),l(ql,y),l(y,Ct),l(Ct,Uo),l(y,So),l(y,Nt),l(Nt,Ro),l(y,mo),l(y,Ut),l(Ut,Ao),E(e,Lr,v),E(e,Tr,v),E(e,Cr,v),E(e,K,v),l(K,V),l(V,St),l(K,xo),E(e,Nr,v),lr(Ql,e,v),E(e,Ur,v),E(e,S,v),l(S,Rt),l(Rt,Wo),l(S,$o),l(S,mt),l(mt,wo),l(S,ko),l(S,At),l(At,Do),E(e,Sr,v),E(e,Ee,v),l(Ee,yo),E(e,Rr,v),E(e,mr,v),E(e,Ar,v),E(e,xr,v),E(e,X,v),l(X,Y),l(Y,xt),l(X,Ho),E(e,Wr,v),E(e,$r,v),E(e,wr,v),E(e,g,v),l(g,ll),l(ll,Wt),l(g,Bo),E(e,kr,v),lr(jl,e,v),E(e,Dr,v),E(e,I,v),l(I,$t),l($t,Oo),l(I,Mo),l(I,wt),l(wt,Fo),l(I,Go),l(I,kt),l(kt,qo),l(I,Qo),l(I,ne),l(ne,jo),l(ne,Dt),l(Dt,yt),l(yt,zo),E(e,yr,v),E(e,Hr,v),E(e,Br,v),E(e,Or,v),E(e,el,v),l(el,tl),l(tl,Ht),l(el,Zo),E(e,Mr,v),E(e,Fr,v),E(e,Gr,v),E(e,il,v),l(il,rl),l(rl,Bt),l(il,Jo),E(e,qr,v),E(e,c,v),l(c,Ot),l(Ot,Mt),l(Mt,Ko),l(c,Vo),l(c,Ft),l(Ft,Gt),l(Gt,Xo),l(c,Yo),l(c,qt),l(qt,zl),l(zl,go),l(zl,Qt),l(Qt,ls),l(zl,es),l(c,ts),l(c,Zl),l(Zl,jt),l(jt,is),l(Zl,rs),l(Zl,H),l(H,zt),l(zt,as),l(H,fs),l(H,Zt),l(Zt,os),l(H,ss),l(H,Jt),l(Jt,us),l(c,vs),l(c,Jl),l(Jl,Kt),l(Kt,Es),l(Jl,ns),l(Jl,Vt),l(Vt,_e),l(_e,_s),l(_e,B),l(B,Xt),l(Xt,ds),l(B,cs),l(B,Yt),l(Yt,Ps),l(B,ps),l(B,gt),l(gt,Is),E(e,Qr,v),E(e,jr,v),E(e,zr,v),E(e,al,v),l(al,fl),l(fl,li),l(al,hs),E(e,Zr,v),E(e,h,v),l(h,ei),l(ei,bs),l(h,Ls),l(h,Kl),l(Kl,Ts),l(Kl,ti),l(ti,Cs),l(Kl,Ns),l(h,Us),l(h,ii),l(ii,Ss),l(h,Rs),l(h,ri),l(ri,ms),E(e,Jr,v),E(e,Kr,v),E(e,Vr,v),E(e,ol,v),l(ol,sl),l(sl,ai),l(ol,As),E(e,Xr,v),E(e,ul,v),l(ul,de),l(de,xs),l(de,fi),l(fi,oi),l(oi,Ws),l(ul,$s),l(ul,ce),l(ce,ws),l(ce,si),l(si,ui),l(ui,ks),E(e,Yr,v),E(e,gr,v),E(e,la,v),E(e,ea,v),E(e,vl,v),l(vl,El),l(El,vi),l(vl,Ds),E(e,ta,v),E(e,ia,v),E(e,ra,v),E(e,nl,v),l(nl,_l),l(_l,Ei),l(nl,ys),E(e,aa,v),lr(Vl,e,v),E(e,fa,v),E(e,R,v),l(R,ni),l(ni,Hs),l(R,Bs),l(R,Pe),l(Pe,Os),l(Pe,_i),l(_i,di),l(di,Ms),l(R,Fs),l(R,pe),l(pe,Gs),l(pe,O),l(O,ci),l(ci,qs),l(O,Qs),l(O,Pi),l(Pi,js),l(O,zs),l(O,pi),l(pi,Zs),E(e,oa,v),E(e,sa,v),E(e,ua,v),E(e,dl,v),l(dl,cl),l(cl,Ii),l(dl,Js),E(e,va,v),E(e,b,v),l(b,hi),l(hi,Ks),l(b,Vs),l(b,bi),l(bi,Xs),l(b,Ys),l(b,Ie),l(Ie,gs),l(Ie,Li),l(Li,he),l(he,Xl),l(Xl,l1),l(he,e1),l(b,t1),l(b,Ti),l(Ti,i1),E(e,Ea,v),E(e,na,v),E(e,_a,v),E(e,Pl,v),l(Pl,pl),l(pl,Ci),l(Pl,r1),E(e,da,v),E(e,P,v),l(P,Ni),l(Ni,a1),l(P,f1),l(P,Ui),l(Ui,o1),l(P,s1),l(P,Si),l(Si,u1),l(P,v1),l(P,Ri),l(Ri,E1),l(P,n1),l(P,mi),l(mi,_1),E(e,ca,v),E(e,Pa,v),E(e,pa,v),E(e,Il,v),l(Il,hl),l(hl,Ai),l(Il,d1),E(e,Ia,v),lr(Yl,e,v),E(e,ha,v),E(e,m,v),l(m,gl),l(gl,xi),l(xi,c1),l(gl,P1),l(gl,C),l(C,Wi),l(Wi,p1),l(C,I1),l(C,$i),l($i,h1),l(C,b1),l(C,wi),l(wi,L1),l(C,T1),l(C,ki),l(ki,C1),l(m,N1),l(m,le),l(le,Di),l(Di,U1),l(le,S1),l(le,p),l(p,yi),l(yi,R1),l(p,m1),l(p,Hi),l(Hi,A1),l(p,x1),l(p,Bi),l(Bi,W1),l(p,$1),l(p,Oi),l(Oi,w1),l(p,k1),l(p,Mi),l(Mi,D1),l(m,y1),l(m,ee),l(ee,Fi),l(Fi,H1),l(ee,B1),l(ee,N),l(N,Gi),l(Gi,O1),l(N,M1),l(N,qi),l(qi,F1),l(N,G1),l(N,Qi),l(Qi,q1),l(N,Q1),l(N,ji),l(ji,j1),E(e,ba,v),E(e,La,v),E(e,Ta,v),E(e,bl,v),l(bl,Ll),l(Ll,zi),l(bl,z1),E(e,Ca,v),lr(te,e,v),E(e,Na,v),E(e,L,v),l(L,Zi),l(Zi,Z1),l(L,J1),l(L,Ji),l(Ji,K1),l(L,V1),l(L,Ki),l(Ki,X1),l(L,Y1),l(L,Vi),l(Vi,g1),E(e,Ua,v),E(e,Sa,v),E(e,Ra,v),E(e,ma,v),E(e,Tl,v),l(Tl,Cl),l(Cl,Xi),l(Tl,l2),E(e,Aa,v),E(e,ie,v),l(ie,e2),l(ie,re),l(re,t2),E(e,xa,v),E(e,Wa,v),E(e,$a,v),wa=!0},p:vE,i(e){wa||(er(Ql.$$.fragment,e),er(jl.$$.fragment,e),er(Vl.$$.fragment,e),er(Yl.$$.fragment,e),er(te.$$.fragment,e),wa=!0)},o(e){tr(Ql.$$.fragment,e),tr(jl.$$.fragment,e),tr(Vl.$$.fragment,e),tr(Yl.$$.fragment,e),tr(te.$$.fragment,e),wa=!1},d(e){e&&t(M),e&&t(ar),e&&t(fr),e&&t(or),e&&t(sr),e&&t(F),e&&t(ur),e&&t(vr),e&&t(Er),e&&t(q),e&&t(nr),e&&t(_),e&&t(_r),e&&t(dr),e&&t(cr),e&&t(j),e&&t(Pr),e&&t(d),e&&t(pr),e&&t(Ir),e&&t(hr),e&&t(Z),e&&t(br),e&&t(U),e&&t(Lr),e&&t(Tr),e&&t(Cr),e&&t(K),e&&t(Nr),ir(Ql,e),e&&t(Ur),e&&t(S),e&&t(Sr),e&&t(Ee),e&&t(Rr),e&&t(mr),e&&t(Ar),e&&t(xr),e&&t(X),e&&t(Wr),e&&t($r),e&&t(wr),e&&t(g),e&&t(kr),ir(jl,e),e&&t(Dr),e&&t(I),e&&t(yr),e&&t(Hr),e&&t(Br),e&&t(Or),e&&t(el),e&&t(Mr),e&&t(Fr),e&&t(Gr),e&&t(il),e&&t(qr),e&&t(c),e&&t(Qr),e&&t(jr),e&&t(zr),e&&t(al),e&&t(Zr),e&&t(h),e&&t(Jr),e&&t(Kr),e&&t(Vr),e&&t(ol),e&&t(Xr),e&&t(ul),e&&t(Yr),e&&t(gr),e&&t(la),e&&t(ea),e&&t(vl),e&&t(ta),e&&t(ia),e&&t(ra),e&&t(nl),e&&t(aa),ir(Vl,e),e&&t(fa),e&&t(R),e&&t(oa),e&&t(sa),e&&t(ua),e&&t(dl),e&&t(va),e&&t(b),e&&t(Ea),e&&t(na),e&&t(_a),e&&t(Pl),e&&t(da),e&&t(P),e&&t(ca),e&&t(Pa),e&&t(pa),e&&t(Il),e&&t(Ia),ir(Yl,e),e&&t(ha),e&&t(m),e&&t(ba),e&&t(La),e&&t(Ta),e&&t(bl),e&&t(Ca),ir(te,e),e&&t(Na),e&&t(L),e&&t(Ua),e&&t(Sa),e&&t(Ra),e&&t(ma),e&&t(Tl),e&&t(Aa),e&&t(ie),e&&t(xa),e&&t(Wa),e&&t($a)}}}const dE={title:"WebRTC에 관하여 정리해보았다",date:"2023-01-22T00:00:00.000Z",excerpt:"교내 프로젝트, 교과목, 스터디를 하며 정리한 WebRTC 관련 내용을 기록해보았습니다",categories:["WebRTC"],coverImage:"/post_img/Networking/WebRTC/cover.png",coverWidth:16,coverHeight:9,indexed:!0,exposed:!0};class cE extends oE{constructor(M){super(),sE(this,M,null,EE,uE,{})}}export{cE as default,dE as metadata};
