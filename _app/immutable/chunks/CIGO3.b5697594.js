import{S as Po,i as Wo,s as Ho,k as l,q as n,a as s,y as ko,l as r,m as a,r as i,h as t,c as d,z as wo,n as R,b as f,E as e,A as Mo,g as Xo,d as Yo,B as No}from"./index.5621e629.js";import{H as Uo}from"./Highlight.2decd09b.js";function To(Ne){let h;return{c(){h=n("메모리 모델")},l(B){h=i(B,"메모리 모델")},m(B,k){f(B,h,k)},d(B){B&&t(h)}}}function go(Ne){let h,B,k,w,Ue,ye,y,Te,L,ge,Le,M,Ze,qe,X,je,Ge,ze,xe,Ie,q,G,g,Fe,De,$e,Ae,z,x,Z,Je,Pe,m,$,j,F,Ke,Qe,S,E,Ve,J,et,tt,K,ot,lt,Q,rt,at,nt,V,it,ct,ee,st,dt,A,te,oe,ft,pt,C,P,le,ht,ut,W,re,Et,_t,ae,vt,mt,ne,_,Rt,ie,Bt,St,ce,Ct,Ot,se,bt,yt,Lt,de,fe,qt,Gt,H,pe,he,zt,xt,O,ue,It,Dt,u,Ee,$t,At,_e,Pt,Wt,ve,Ht,kt,me,wt,Mt,Xt,p,Re,Yt,Nt,Be,Ut,Tt,Se,gt,Zt,Ce,jt,Ft,Oe,Jt,Kt,We;return L=new Uo({props:{$$slots:{default:[To]},$$scope:{ctx:Ne}}}),{c(){h=l("p"),B=n(`어떤 언어든 그 언어를 딥하게 파고 제대로 이해하기 위해서는 그 언어의 메모리 모델을 이해하는 것이 중요하다고 생각한다.
그만큼 Go를 열심히 공부하는 입장으로서 Go의 메모리 모델을 이해하는 것은 필수적이다.`),k=s(),w=l("p"),Ue=n(`단일 프로세서의 성능 향상에 한계가 오면서 멀티 코어 프로세서가 등장하게 되었고, 대부분의 성능 향상은 멀티 코어 프로세서에서 동작하는 것이 대전제가 되었다.
한편 현대 컴파일러 또한 극한의 최적화를 위해 코드를 재배치하는 일이 비일비재하다.
이는 sequantial program에서는 문제가 되지 않지만, concurrent program에서는 문제가 될 수 있다.`),ye=s(),y=l("p"),Te=n("이러한 문제를 해결하기 위해서 "),ko(L.$$.fragment),ge=n(`이 정의된다.
메모리 모델은 컴파일러 빌더가 보장해야 하고, 프로그래머가 기대할 수 있는 것들을 정의한다.
즉, 메모리 모델은 하드웨어에 대한 컴파일러 빌더의 동작이 정의된 것이라고 볼 수 있다.`),Le=s(),M=l("p"),Ze=n(`여러 고루틴에서 동시에 엑세스되는 데이터를 수정하는 프로그램은 이러한 액세스를 직렬화해야 함을 언급하며 Go의 메모리 모델 문서가 시작되는데, 이는 쉬운 일이 아니다.
동시성 프로그램의 모든 가능성을 고려하는 것은 불가능하기 때문이다.
대신 메모리 모델에 대한 인사이트를 가지고 있다면 동시성 프로그램의 문제를 해결하는 데 도움이 될 수 있다.`),qe=s(),X=l("p"),je=n(`물론 메모리 모델과 너무 가깝게 작성된 코드를 짜는 것은 좋지 않지만, 알고 하지 않는 것과 모르고 하지 않는 것은 차이가 있다.
Go의 메모리 모델에 대해 본격적으로 알아보자.`),Ge=s(),ze=l("br"),xe=l("br"),Ie=s(),q=l("h2"),G=l("a"),g=l("span"),Fe=n("Happened-Before Relationship"),De=s(),$e=l("hr"),Ae=s(),z=l("h3"),x=l("a"),Z=l("span"),Je=n("메모리 연산 순서 정의 모델"),Pe=s(),m=l("ul"),$=l("li"),j=l("p"),F=l("strong"),Ke=n("Sequenced-Before Relationship"),Qe=s(),S=l("ul"),E=l("li"),Ve=n("만약 "),J=l("code"),et=n("A is sequenced before B"),tt=n("라면, "),K=l("code"),ot=n("A"),lt=n("가 "),Q=l("code"),rt=n("B"),at=n("보다 먼저 실행되었음을 의미함"),nt=s(),V=l("li"),it=n("하지만 Sequenced-Before Relationship은 동시성을 고려하지 않음"),ct=s(),ee=l("li"),st=n("메모리 read 연산이 변수에 쓰여진 마지막 값을 읽는 한, 컴파일러에 의해 instruction reordering이 발생할 수 있음"),dt=s(),A=l("li"),te=l("p"),oe=l("strong"),ft=n("Synchronized-Before Relationship"),pt=s(),C=l("ul"),P=l("li"),le=l("p"),ht=n("일반적인 메모리 연산 외에도 동기화 메모리 작업(Synchronizing Memory Operation)이 존재함"),ut=s(),W=l("ul"),re=l("li"),Et=n("Syncrhonizing Read Operation: Mutex lock, Channel receive, atomic read, atomic compare-and-swap"),_t=s(),ae=l("li"),vt=n("Synchrornizing Write Operation: Mutex unlock, Channel send, Channel close, atomic write, atomic compare-and-swap"),mt=s(),ne=l("li"),_=l("p"),Rt=n("만약 "),ie=l("code"),Bt=n("A is synchronized before B"),St=n("라면, 동기화 연산 "),ce=l("code"),Ct=n("A"),Ot=n("가 동기화 연산 "),se=l("code"),bt=n("B"),yt=n("보다 먼저 실행되었음을 의미함"),Lt=s(),de=l("li"),fe=l("p"),qt=n("Sequenced-Before Relationship이 단일 고루틴에서의 일반적인 메모리 연산 순서를 정의한다면, Synchronized-Before Relationship은 여러 고루틴에서의 메모리 연산 순서를 정의할 수 있음"),Gt=s(),H=l("li"),pe=l("p"),he=l("strong"),zt=n("Happened-Before Relationship"),xt=s(),O=l("ul"),ue=l("li"),It=n("Sequenced-Before Relationship와 Synchronized-Before Relationship의 조합"),Dt=s(),u=l("li"),Ee=l("code"),$t=n("W"),At=n("가 메모리 쓰기 작업이고 "),_e=l("code"),Pt=n("R"),Wt=n("이 메모리 읽기 작업일 때, 만약 "),ve=l("code"),Ht=n("W synchronized before R"),kt=n("이면, "),me=l("code"),wt=n("W happened before R"),Mt=n("임"),Xt=s(),p=l("li"),Re=l("code"),Yt=n("X"),Nt=n("가 메모리 쓰기 작업이고 "),Be=l("code"),Ut=n("Y"),Tt=n("이 메모리 읽기 작업일 때, 만약 "),Se=l("code"),gt=n("X sequenced before W"),Zt=n("이고 "),Ce=l("code"),jt=n("Y is sequenced after R"),Ft=n("이면, "),Oe=l("code"),Jt=n("X happened before Y"),Kt=n("임"),this.h()},l(o){h=r(o,"P",{});var c=a(h);B=i(c,`어떤 언어든 그 언어를 딥하게 파고 제대로 이해하기 위해서는 그 언어의 메모리 모델을 이해하는 것이 중요하다고 생각한다.
그만큼 Go를 열심히 공부하는 입장으로서 Go의 메모리 모델을 이해하는 것은 필수적이다.`),c.forEach(t),k=d(o),w=r(o,"P",{});var be=a(w);Ue=i(be,`단일 프로세서의 성능 향상에 한계가 오면서 멀티 코어 프로세서가 등장하게 되었고, 대부분의 성능 향상은 멀티 코어 프로세서에서 동작하는 것이 대전제가 되었다.
한편 현대 컴파일러 또한 극한의 최적화를 위해 코드를 재배치하는 일이 비일비재하다.
이는 sequantial program에서는 문제가 되지 않지만, concurrent program에서는 문제가 될 수 있다.`),be.forEach(t),ye=d(o),y=r(o,"P",{});var He=a(y);Te=i(He,"이러한 문제를 해결하기 위해서 "),wo(L.$$.fragment,He),ge=i(He,`이 정의된다.
메모리 모델은 컴파일러 빌더가 보장해야 하고, 프로그래머가 기대할 수 있는 것들을 정의한다.
즉, 메모리 모델은 하드웨어에 대한 컴파일러 빌더의 동작이 정의된 것이라고 볼 수 있다.`),He.forEach(t),Le=d(o),M=r(o,"P",{});var eo=a(M);Ze=i(eo,`여러 고루틴에서 동시에 엑세스되는 데이터를 수정하는 프로그램은 이러한 액세스를 직렬화해야 함을 언급하며 Go의 메모리 모델 문서가 시작되는데, 이는 쉬운 일이 아니다.
동시성 프로그램의 모든 가능성을 고려하는 것은 불가능하기 때문이다.
대신 메모리 모델에 대한 인사이트를 가지고 있다면 동시성 프로그램의 문제를 해결하는 데 도움이 될 수 있다.`),eo.forEach(t),qe=d(o),X=r(o,"P",{});var to=a(X);je=i(to,`물론 메모리 모델과 너무 가깝게 작성된 코드를 짜는 것은 좋지 않지만, 알고 하지 않는 것과 모르고 하지 않는 것은 차이가 있다.
Go의 메모리 모델에 대해 본격적으로 알아보자.`),to.forEach(t),Ge=d(o),ze=r(o,"BR",{}),xe=r(o,"BR",{}),Ie=d(o),q=r(o,"H2",{id:!0});var Qt=a(q);G=r(Qt,"A",{"aria-hidden":!0,tabindex:!0,href:!0});var oo=a(G);g=r(oo,"SPAN",{class:!0}),a(g).forEach(t),oo.forEach(t),Fe=i(Qt,"Happened-Before Relationship"),Qt.forEach(t),De=d(o),$e=r(o,"HR",{}),Ae=d(o),z=r(o,"H3",{id:!0});var Vt=a(z);x=r(Vt,"A",{"aria-hidden":!0,tabindex:!0,href:!0});var lo=a(x);Z=r(lo,"SPAN",{class:!0}),a(Z).forEach(t),lo.forEach(t),Je=i(Vt,"메모리 연산 순서 정의 모델"),Vt.forEach(t),Pe=d(o),m=r(o,"UL",{});var Y=a(m);$=r(Y,"LI",{});var ke=a($);j=r(ke,"P",{});var ro=a(j);F=r(ro,"STRONG",{});var ao=a(F);Ke=i(ao,"Sequenced-Before Relationship"),ao.forEach(t),ro.forEach(t),Qe=d(ke),S=r(ke,"UL",{});var N=a(S);E=r(N,"LI",{});var I=a(E);Ve=i(I,"만약 "),J=r(I,"CODE",{});var no=a(J);et=i(no,"A is sequenced before B"),no.forEach(t),tt=i(I,"라면, "),K=r(I,"CODE",{});var io=a(K);ot=i(io,"A"),io.forEach(t),lt=i(I,"가 "),Q=r(I,"CODE",{});var co=a(Q);rt=i(co,"B"),co.forEach(t),at=i(I,"보다 먼저 실행되었음을 의미함"),I.forEach(t),nt=d(N),V=r(N,"LI",{});var so=a(V);it=i(so,"하지만 Sequenced-Before Relationship은 동시성을 고려하지 않음"),so.forEach(t),ct=d(N),ee=r(N,"LI",{});var fo=a(ee);st=i(fo,"메모리 read 연산이 변수에 쓰여진 마지막 값을 읽는 한, 컴파일러에 의해 instruction reordering이 발생할 수 있음"),fo.forEach(t),N.forEach(t),ke.forEach(t),dt=d(Y),A=r(Y,"LI",{});var we=a(A);te=r(we,"P",{});var po=a(te);oe=r(po,"STRONG",{});var ho=a(oe);ft=i(ho,"Synchronized-Before Relationship"),ho.forEach(t),po.forEach(t),pt=d(we),C=r(we,"UL",{});var U=a(C);P=r(U,"LI",{});var Me=a(P);le=r(Me,"P",{});var uo=a(le);ht=i(uo,"일반적인 메모리 연산 외에도 동기화 메모리 작업(Synchronizing Memory Operation)이 존재함"),uo.forEach(t),ut=d(Me),W=r(Me,"UL",{});var Xe=a(W);re=r(Xe,"LI",{});var Eo=a(re);Et=i(Eo,"Syncrhonizing Read Operation: Mutex lock, Channel receive, atomic read, atomic compare-and-swap"),Eo.forEach(t),_t=d(Xe),ae=r(Xe,"LI",{});var _o=a(ae);vt=i(_o,"Synchrornizing Write Operation: Mutex unlock, Channel send, Channel close, atomic write, atomic compare-and-swap"),_o.forEach(t),Xe.forEach(t),Me.forEach(t),mt=d(U),ne=r(U,"LI",{});var vo=a(ne);_=r(vo,"P",{});var D=a(_);Rt=i(D,"만약 "),ie=r(D,"CODE",{});var mo=a(ie);Bt=i(mo,"A is synchronized before B"),mo.forEach(t),St=i(D,"라면, 동기화 연산 "),ce=r(D,"CODE",{});var Ro=a(ce);Ct=i(Ro,"A"),Ro.forEach(t),Ot=i(D,"가 동기화 연산 "),se=r(D,"CODE",{});var Bo=a(se);bt=i(Bo,"B"),Bo.forEach(t),yt=i(D,"보다 먼저 실행되었음을 의미함"),D.forEach(t),vo.forEach(t),Lt=d(U),de=r(U,"LI",{});var So=a(de);fe=r(So,"P",{});var Co=a(fe);qt=i(Co,"Sequenced-Before Relationship이 단일 고루틴에서의 일반적인 메모리 연산 순서를 정의한다면, Synchronized-Before Relationship은 여러 고루틴에서의 메모리 연산 순서를 정의할 수 있음"),Co.forEach(t),So.forEach(t),U.forEach(t),we.forEach(t),Gt=d(Y),H=r(Y,"LI",{});var Ye=a(H);pe=r(Ye,"P",{});var Oo=a(pe);he=r(Oo,"STRONG",{});var bo=a(he);zt=i(bo,"Happened-Before Relationship"),bo.forEach(t),Oo.forEach(t),xt=d(Ye),O=r(Ye,"UL",{});var T=a(O);ue=r(T,"LI",{});var yo=a(ue);It=i(yo,"Sequenced-Before Relationship와 Synchronized-Before Relationship의 조합"),yo.forEach(t),Dt=d(T),u=r(T,"LI",{});var b=a(u);Ee=r(b,"CODE",{});var Lo=a(Ee);$t=i(Lo,"W"),Lo.forEach(t),At=i(b,"가 메모리 쓰기 작업이고 "),_e=r(b,"CODE",{});var qo=a(_e);Pt=i(qo,"R"),qo.forEach(t),Wt=i(b,"이 메모리 읽기 작업일 때, 만약 "),ve=r(b,"CODE",{});var Go=a(ve);Ht=i(Go,"W synchronized before R"),Go.forEach(t),kt=i(b,"이면, "),me=r(b,"CODE",{});var zo=a(me);wt=i(zo,"W happened before R"),zo.forEach(t),Mt=i(b,"임"),b.forEach(t),Xt=d(T),p=r(T,"LI",{});var v=a(p);Re=r(v,"CODE",{});var xo=a(Re);Yt=i(xo,"X"),xo.forEach(t),Nt=i(v,"가 메모리 쓰기 작업이고 "),Be=r(v,"CODE",{});var Io=a(Be);Ut=i(Io,"Y"),Io.forEach(t),Tt=i(v,"이 메모리 읽기 작업일 때, 만약 "),Se=r(v,"CODE",{});var Do=a(Se);gt=i(Do,"X sequenced before W"),Do.forEach(t),Zt=i(v,"이고 "),Ce=r(v,"CODE",{});var $o=a(Ce);jt=i($o,"Y is sequenced after R"),$o.forEach(t),Ft=i(v,"이면, "),Oe=r(v,"CODE",{});var Ao=a(Oe);Jt=i(Ao,"X happened before Y"),Ao.forEach(t),Kt=i(v,"임"),v.forEach(t),T.forEach(t),Ye.forEach(t),Y.forEach(t),this.h()},h(){R(g,"class","icon icon-link"),R(G,"aria-hidden","true"),R(G,"tabindex","-1"),R(G,"href","#happened-before-relationship"),R(q,"id","happened-before-relationship"),R(Z,"class","icon icon-link"),R(x,"aria-hidden","true"),R(x,"tabindex","-1"),R(x,"href","#메모리-연산-순서-정의-모델"),R(z,"id","메모리-연산-순서-정의-모델")},m(o,c){f(o,h,c),e(h,B),f(o,k,c),f(o,w,c),e(w,Ue),f(o,ye,c),f(o,y,c),e(y,Te),Mo(L,y,null),e(y,ge),f(o,Le,c),f(o,M,c),e(M,Ze),f(o,qe,c),f(o,X,c),e(X,je),f(o,Ge,c),f(o,ze,c),f(o,xe,c),f(o,Ie,c),f(o,q,c),e(q,G),e(G,g),e(q,Fe),f(o,De,c),f(o,$e,c),f(o,Ae,c),f(o,z,c),e(z,x),e(x,Z),e(z,Je),f(o,Pe,c),f(o,m,c),e(m,$),e($,j),e(j,F),e(F,Ke),e($,Qe),e($,S),e(S,E),e(E,Ve),e(E,J),e(J,et),e(E,tt),e(E,K),e(K,ot),e(E,lt),e(E,Q),e(Q,rt),e(E,at),e(S,nt),e(S,V),e(V,it),e(S,ct),e(S,ee),e(ee,st),e(m,dt),e(m,A),e(A,te),e(te,oe),e(oe,ft),e(A,pt),e(A,C),e(C,P),e(P,le),e(le,ht),e(P,ut),e(P,W),e(W,re),e(re,Et),e(W,_t),e(W,ae),e(ae,vt),e(C,mt),e(C,ne),e(ne,_),e(_,Rt),e(_,ie),e(ie,Bt),e(_,St),e(_,ce),e(ce,Ct),e(_,Ot),e(_,se),e(se,bt),e(_,yt),e(C,Lt),e(C,de),e(de,fe),e(fe,qt),e(m,Gt),e(m,H),e(H,pe),e(pe,he),e(he,zt),e(H,xt),e(H,O),e(O,ue),e(ue,It),e(O,Dt),e(O,u),e(u,Ee),e(Ee,$t),e(u,At),e(u,_e),e(_e,Pt),e(u,Wt),e(u,ve),e(ve,Ht),e(u,kt),e(u,me),e(me,wt),e(u,Mt),e(O,Xt),e(O,p),e(p,Re),e(Re,Yt),e(p,Nt),e(p,Be),e(Be,Ut),e(p,Tt),e(p,Se),e(Se,gt),e(p,Zt),e(p,Ce),e(Ce,jt),e(p,Ft),e(p,Oe),e(Oe,Jt),e(p,Kt),We=!0},p(o,[c]){const be={};c&1&&(be.$$scope={dirty:c,ctx:o}),L.$set(be)},i(o){We||(Xo(L.$$.fragment,o),We=!0)},o(o){Yo(L.$$.fragment,o),We=!1},d(o){o&&t(h),o&&t(k),o&&t(w),o&&t(ye),o&&t(y),No(L),o&&t(Le),o&&t(M),o&&t(qe),o&&t(X),o&&t(Ge),o&&t(ze),o&&t(xe),o&&t(Ie),o&&t(q),o&&t(De),o&&t($e),o&&t(Ae),o&&t(z),o&&t(Pe),o&&t(m)}}}const Fo={title:"Go의 메모리 모델",date:"2023-08-31T00:00:00.000Z",excerpt:"Go의 메모리 모델",categories:["Golang","Concurrency in Go"],coverImage:"/post_img/Go/Concurrency in Go/cover.png",coverWidth:16,coverHeight:9,indexed:!1,exposed:!1};class Jo extends Po{constructor(h){super(),Wo(this,h,null,go,Ho,{})}}export{Jo as default,Fo as metadata};
