import{S as cd,i as ud,s as hd,k as r,q as o,a as c,y as Oi,l as i,m as a,r as s,h as l,c as u,z as Ti,n as h,U as dd,b as n,E as e,A as qi,g as Di,d as wi,B as Wi}from"./index.5621e629.js";import{H as Xi}from"./Highlight.2decd09b.js";function vd(I){let v;return{c(){v=o("작성되는 방식")},l(d){v=s(d,"작성되는 방식")},m(d,_){n(d,v,_)},d(d){d&&l(v)}}}function Ed(I){let v;return{c(){v=o("실행되는 방식")},l(d){v=s(d,"실행되는 방식")},m(d,_){n(d,v,_)},d(d){d&&l(v)}}}function _d(I){let v;return{c(){v=o("Context Switching")},l(d){v=s(d,"Context Switching")},m(d,_){n(d,v,_)},d(d){d&&l(v)}}}function pd(I){let v;return{c(){v=o("Total Order")},l(d){v=s(d,"Total Order")},m(d,_){n(d,v,_)},d(d){d&&l(v)}}}function md(I){let v;return{c(){v=o("Partial Order")},l(d){v=s(d,"Partial Order")},m(d,_){n(d,v,_)},d(d){d&&l(v)}}}function Ld(I){let v,d,_,No,Ki,Pl,rt,Bo,Qi,ji,Ji,zi,K,Q,it,Ho,Zi,Fi,Vi,j,J,at,Go,Yi,z,ot,p,Oo,st,To,qo,Do,ft,wo,Wo,Xo,Ko,Qo,nt,B,jo,ct,Jo,zo,Zo,Fo,gi,Z,F,ut,Vo,ea,Il,b,Yo,ht,go,es,ls,dt,ts,rs,is,la,V,Y,vt,as,ta,A,os,g,ss,ee,fs,ra,ia,aa,oa,le,te,Et,ns,sa,fa,na,x,_t,cs,us,pt,hs,ds,mt,vs,ca,re,ie,Lt,Es,ua,m,St,_s,ps,bl,ms,H,el,Ls,ae,Ss,Ps,Pt,Is,bs,It,ks,$s,kl,bt,Cs,As,xs,oe,kt,Us,ys,$t,Rs,Ms,ha,$l,Ct,Ns,da,Cl,Al,Bs,k,G,Hs,At,Gs,Os,xt,Ts,qs,Ds,se,Ut,ws,Ws,yt,Xs,Ks,Qs,fe,Rt,js,Js,Mt,zs,Zs,Fs,O,Nt,Vs,Ys,Bt,gs,ef,Ht,ll,lf,Gt,tf,rf,va,ne,ce,Ot,af,Ea,xl,of,_a,U,Ul,sf,tl,Tt,ff,nf,qt,cf,uf,Dt,hf,df,yl,vf,wt,Wt,Ef,pa,Rl,_f,ma,ue,he,Xt,pf,La,y,Kt,mf,Lf,Ml,Sf,Qt,rl,Pf,de,If,bf,Nl,kf,jt,il,$f,ve,Cf,Sa,Ee,_e,Jt,Af,Pa,pe,al,zt,xf,Uf,$,Zt,yf,Rf,Ft,Mf,Nf,Vt,Bf,Hf,Yt,Gf,Of,ol,gt,Tf,qf,T,er,Df,wf,lr,Wf,Xf,tr,Kf,Ia,ba,ka,$a,me,Le,rr,Qf,Ca,Aa,xa,Se,Pe,ir,jf,Ua,L,sl,ar,Jf,zf,fl,or,Zf,Ff,sr,Vf,Yf,nl,fr,gf,en,cl,nr,ln,tn,cr,rn,an,ur,hr,on,sn,ul,dr,fn,nn,hl,vr,cn,un,Bl,hn,q,Er,dn,vn,_r,En,_n,pr,pn,ya,Ie,be,mr,mn,Ra,R,Lr,Sr,Ln,Sn,Pr,Ir,Pn,In,br,kr,bn,Ma,ke,$e,$r,kn,Na,Ce,dl,Cr,$n,Cn,Ar,xr,An,xn,Ur,yr,Un,Ba,Ae,xe,Rr,yn,Ha,S,Mr,Nr,Rn,Mn,Br,Hr,Nn,Bn,Gr,Or,Hn,Gn,vl,Tr,On,Tn,D,qr,qn,Dn,Dr,wn,Wn,wr,Xn,Ga,Oa,Ta,qa,Ue,ye,Wr,Kn,Da,wa,Wa,Re,Me,Xr,Qn,Xa,E,Kr,Qr,jn,Jn,jr,Jr,zn,Zn,zr,Zr,Fn,Vn,Fr,Vr,Yn,gn,El,Hl,Yr,ec,lc,tc,w,gr,rc,ic,ei,ac,oc,li,sc,Ka,Ne,Be,ti,fc,Qa,He,ri,nc,cc,Ge,uc,ii,hc,dc,_l,pl,vc,ai,Ec,_c,pc,Gl,mc,oi,si,Lc,ja,Oe,Te,fi,Sc,Ja,M,ni,ci,Pc,Ic,ml,ui,bc,kc,C,hi,$c,Cc,di,Ac,xc,vi,Uc,yc,Ei,Rc,Mc,_i,pi,Nc,za,Ol,mi,Bc,Za,qe,De,Li,Hc,Fa,we,Si,Gc,Oc,Pi,Tc,Va,Tl,Ii,qc,Ya,We,Xe,bi,Dc,ga,P,ki,wc,Wc,$i,Xc,Kc,Ci,Qc,jc,Ai,Jc,eo,lo,to,ro,Ke,Qe,xi,zc,io,ao,oo,ql,W,Ll,Dl,Uu,Zc,Fc,Vc,Sl,Yc,so;return g=new Xi({props:{$$slots:{default:[vd]},$$scope:{ctx:I}}}),ee=new Xi({props:{$$slots:{default:[Ed]},$$scope:{ctx:I}}}),ae=new Xi({props:{$$slots:{default:[_d]},$$scope:{ctx:I}}}),de=new Xi({props:{$$slots:{default:[pd]},$$scope:{ctx:I}}}),ve=new Xi({props:{$$slots:{default:[md]},$$scope:{ctx:I}}}),{c(){v=r("p"),d=r("strong"),_=o("Effective Concurrency in Go"),No=o("를 읽던 중, 동시성 관련해서 좋은 내용들이 많이 나와서 한 번 개념을 정리해보았읍니다."),Ki=c(),Pl=r("ul"),rt=r("li"),Bo=o("본 포스트 안에서 쓰레드와 고루틴을 혼용해서 사용했는데, 얼추 비슷한 애들이라고 생각하시면 됩니다."),Qi=c(),ji=r("br"),Ji=r("br"),zi=c(),K=r("h2"),Q=r("a"),it=r("span"),Ho=o("동시성(Concurrency) vs 병렬성(Parallelism)"),Zi=c(),Fi=r("hr"),Vi=c(),j=r("h3"),J=r("a"),at=r("span"),Go=o("동시성(Concurrency)"),Yi=c(),z=r("ul"),ot=r("li"),p=r("p"),Oo=o("여러 작업을 동시에 수행하는 것"),st=r("strong"),To=o("처럼 보이는 것"),qo=r("br"),Do=o(`
실제로는 여러 작업을 `),ft=r("strong"),wo=o("동시에 수행하는 것이 아니라, 짧은 시간 간격으로 번갈아가며 수행하는 것"),Wo=o("이다."),Xo=r("br"),Ko=o(`
싱글 코어에서도 동시성을 구현할 수 있음.`),Qo=c(),nt=r("li"),B=r("p"),jo=o("엄밀한 정의는, "),ct=r("strong"),Jo=o("결과에 영향을 주지 않고, 프로그램의 서로 다른 부분이 partial order 또는 순서에 관계없이 실행될 수 있는 것"),zo=o("을 의미함."),Zo=r("br"),Fo=o(`
프로그램이 A,B,C로 구성되어 있을 때, A,C,B 또는 B,C,A 등로 실행되어도 결과에 영향을 주지 않는다면, 이 프로그램은 동시성을 가지고 있다고 할 수 있음.`),gi=c(),Z=r("h3"),F=r("a"),ut=r("span"),Vo=o("병렬성(Parallelism)"),ea=c(),Il=r("ul"),b=r("li"),Yo=o("여러 작업을 "),ht=r("strong"),go=o("동시에 수행하는 것"),es=r("br"),ls=o(`
실제로 여러 작업이 `),dt=r("strong"),ts=o("동시에 수행됨"),rs=r("br"),is=o(`
멀티 코어, 즉 서로 다른 CPU 코어에서 돌아가는 프로세스나 쓰레드가 이에 해당함.`),la=c(),V=r("h3"),Y=r("a"),vt=r("span"),as=o("동시성과 병렬성의 차이"),ta=c(),A=r("p"),os=o("동시성은 프로그램이 "),Oi(g.$$.fragment),ss=o("에 관련된 것이고, 병렬성은 프로그램이 "),Oi(ee.$$.fragment),fs=o("에 관련된 것이다."),ra=c(),ia=r("br"),aa=r("br"),oa=c(),le=r("h2"),te=r("a"),Et=r("span"),ns=o("동시성 프로그래밍"),sa=c(),fa=r("hr"),na=c(),x=r("ul"),_t=r("li"),cs=o("문제를 실행 단위로 나누어 time sharing 또는 병렬적으로 실행될 수 있게끔 하는 것"),us=c(),pt=r("li"),hs=o("이들은 서로 병렬적으로 또는 인터리빙(interleaving)되어 실행될 수 있으며, 메시지를 통해 통신할 수 있음."),ds=c(),mt=r("li"),vs=o("따라서 동시성 프로그래밍은 객체지향이나 함수형 프로그래밍처럼, 프로그램을 작성하는 방식이라고도 할 수 있음."),ca=c(),re=r("h3"),ie=r("a"),Lt=r("span"),Es=o("Time Sharing과 Context Switching"),ua=c(),m=r("ul"),St=r("li"),_s=o("컴퓨팅 리소스(주로 CPU)를 여러 프로그램이 공유하는 것."),ps=c(),bl=r("li"),ms=o("어떤 프로세스가 여러 쓰레드로 구성되어 있다 할 때, 한 쓰레드가 일정한 time quantum 동안 CPU를 사용하고, 그 다음 쓰레드가 CPU를 사용하는 방식으로 진행됨."),H=r("ul"),el=r("li"),Ls=o("이를 "),Oi(ae.$$.fragment),Ss=o("이라고 함."),Ps=c(),Pt=r("li"),Is=o("쓰레드의 실행 컨텍스트에는 해당 쓰레드의 state(레지스터 값, 프로그램 카운터, Stack Pointer 등)가 저장되어 있음."),bs=c(),It=r("li"),ks=o("Context Switching이 발생하면, 현재 쓰레드의 state가 저장되고, 다음 쓰레드의 state가 복원됨."),$s=c(),kl=r("li"),bt=r("strong"),Cs=o("Preemptive Thread Scheduling"),As=o("에서는 쓰레드가 실행되는 도중 Context Switching이 발생할 수 있음."),xs=c(),oe=r("li"),kt=r("strong"),Us=o("Non-Preemptive Thread Scheduling"),ys=o("("),$t=r("strong"),Rs=o("Cooperative Threading"),Ms=o(")에서는 쓰레드가 실행을 마칠 때까지 Context Switching이 발생하지 않음."),ha=c(),$l=r("blockquote"),Ct=r("p"),Ns=o("정보) Go 언어에서는 1.14 이전까지는 Non-Preemptive Thread Scheduling을 사용하였으나, 1.14부터 Preemptive Thread Scheduling을 사용하도록 변경되었다."),da=c(),Cl=r("ul"),Al=r("li"),Bs=o("쓰레드의 상태와 스케줄링"),k=r("ul"),G=r("li"),Hs=o("쓰레드가 실행되면 "),At=r("em"),Gs=o("Ready"),Os=o(" state로 들어가고, CPU를 사용할 수 있을 때 "),xt=r("em"),Ts=o("Running"),qs=o(" state로 들어감."),Ds=c(),se=r("li"),Ut=r("em"),ws=o("Running"),Ws=o(" state의 쓰레드는 time quantum이 끝나면 다시 "),yt=r("em"),Xs=o("Ready"),Ks=o(" state로 돌아감."),Qs=c(),fe=r("li"),Rt=r("em"),js=o("Running"),Js=o(" state의 쓰레드가 I/O 작업 등으로 인한 인터럽트가 발생하거나, lock을 획득하지 못하면 "),Mt=r("em"),zs=o("Blocked"),Zs=o(" state로 들어감."),Fs=c(),O=r("li"),Nt=r("em"),Vs=o("Blocked"),Ys=o(" state의 쓰레드는 I/O 작업이 끝나거나, lock을 획득하면 다시 "),Bt=r("em"),gs=o("Ready"),ef=o(" state로 돌아가게 되고, 스케줄러에 의해 선택되기를 기다림."),Ht=r("ul"),ll=r("li"),lf=o("이 때 "),Gt=r("em"),tf=o("Ready"),rf=o(" state의 쓰레드가 바로 실행되리라는 보장은 없음."),va=c(),ne=r("h3"),ce=r("a"),Ot=r("span"),af=o("동시성 프로그래밍은 왜 어려운가?"),Ea=c(),xl=r("p"),of=o("상태 관리의 어려움 때문임"),_a=c(),U=r("ul"),Ul=r("li"),sf=o("각각의 Sequantial Program은 상태(state)를 가지고 있음."),tl=r("ul"),Tt=r("li"),ff=o("state는 Sequantial Program의 실행 위치와 메모리에 저장된 값을 의미함"),nf=c(),qt=r("li"),cf=o("프로그램의 현재 state에 따라 다음 state를 예측할 수 있음"),uf=c(),Dt=r("li"),hf=o("그런데 동시에 여러 프로그램이 실행되면 각각의 Sequantial Program이 가지고 있는 state가 서로 영향을 미칠 수 있음."),df=c(),yl=r("li"),vf=o("Sequantial Program이 많아질수록, 가능한 state의 수가 많아질수록 전체 프로그램이 가질 수 있는 state의 경우의 수가 기하급수적으로 증가함"),wt=r("ul"),Wt=r("li"),Ef=o("n개의 state가 있는 Sequantial Program이 m개 실행되면 n^m개의 state가 존재함"),pa=c(),Rl=r("p"),_f=o("따라서, 일반적인 state 분석으로 동시성 프로그램의 행동을 예측하기 어려움."),ma=c(),ue=r("h3"),he=r("a"),Xt=r("span"),pf=o("Happened-Before 관계"),La=c(),y=r("ul"),Kt=r("li"),mf=o("두 개의 서로 같지 않은 정수가 있다면, 이들의 대소 관계를 알 수 있음."),Lf=c(),Ml=r("li"),Sf=o("마찬가지로 한 Sequantial Program에서 발생한 서로 다른 두 이벤트가 있다면, 한 이벤트는 반드시 다른 이벤트보다 먼저 발생했을 것임."),Qt=r("ul"),rl=r("li"),Pf=o("이를 "),Oi(de.$$.fragment),If=o("라고 함."),bf=c(),Nl=r("li"),kf=o("서로 다른 프로세스에서 발생한 이벤트에 순서를 정하는 것은 불가능하지만, Message Passing 등을 통해 이벤트의 순서를 일부 정의할 수 있음."),jt=r("ul"),il=r("li"),$f=o("이를 "),Oi(ve.$$.fragment),Cf=o("라고 함."),Sa=c(),Ee=r("h3"),_e=r("a"),Jt=r("span"),Af=o("Dining Philosopher Problem"),Pa=c(),pe=r("ul"),al=r("li"),zt=r("p"),xf=o("문제 정의"),Uf=c(),$=r("ul"),Zt=r("li"),yf=o("철학자들이 원형 테이블에 앉아있음."),Rf=c(),Ft=r("li"),Mf=o("테이블 위에는 포크가 5개 놓여있음."),Nf=c(),Vt=r("li"),Bf=o("철학자들은 생각을 하다가 배가 고파지면 양 옆의 포크를 집어들어 먹기 시작함."),Hf=c(),Yt=r("li"),Gf=o("식사를 마치면 포크를 내려놓고 다시 생각을 하기 시작함."),Of=c(),ol=r("li"),gt=r("p"),Tf=o("Deadlock 발생 가능성"),qf=c(),T=r("ul"),er=r("li"),Df=o("모든 철학자가 자신의 왼쪽 포크만을 집어든 상태라면, 모든 철학자는 다음 포크를 집어들기 위해 오른쪽 철학자가 포크를 내려놓기를 기다려야 함."),wf=c(),lr=r("li"),Wf=o("이 상태에서는 모든 철학자가 포크를 내려놓기를 기다리는 상태로 무한 대기 상태에 빠짐."),Xf=c(),tr=r("li"),Kf=o("한 철학자가 자신의 포크를 내려놓지 않는 이상, 다른 철학자들은 포크를 집어들 수 없음."),Ia=c(),ba=r("br"),ka=r("br"),$a=c(),me=r("h2"),Le=r("a"),rr=r("span"),Qf=o("Shared Memory와 Message Passing"),Ca=c(),Aa=r("hr"),xa=c(),Se=r("h3"),Pe=r("a"),ir=r("span"),jf=o("관련 Computer Architecture 지식"),Ua=c(),L=r("ul"),sl=r("li"),ar=r("p"),Jf=o("UMA(Uniform Memory Access)"),zf=c(),fl=r("ul"),or=r("li"),Zf=o("메모리에 접근할 때 모든 프로세서가 동일한 권한을 가지고 있음."),Ff=c(),sr=r("li"),Vf=o("동일한 메모리 액세스 버스가 공유되기 때문에 처리량이 감소할 수 있음."),Yf=c(),nl=r("li"),fr=r("p"),gf=o("NUMA(Non-Uniform Memory Access)"),en=c(),cl=r("ul"),nr=r("li"),ln=o("프로세서는 메모리의 특정 영역에 대해서만 접근 권한을 가짐"),tn=c(),cr=r("li"),rn=o("OS가 프로세서에서 필요한 메모리를 해당 영역에 할당함으로써 전용 메모리 액세스 버스를 사용할 수 있기 때문에 처리량이 증가할 수 있음."),an=c(),ur=r("li"),hr=r("p"),on=o("대부분의 프로세서는 캐시 메모리를 사용하며, 캐시 일관성(Cache Coherence) 프로토콜을 사용하여 캐시 메모리의 일관성을 유지함."),sn=c(),ul=r("li"),dr=r("p"),fn=o("현대 프로세서는 메모리 read 및 write가 완료될 때까지 기다리지 않음. 파이프라이닝(Pipelining)을 통해 다음 명령어를 동시에 실행함."),nn=c(),hl=r("ul"),vr=r("li"),cn=o("이 때 파이프라이닝의 최적화를 위해서 컴파일러가 명령어의 순서를 바꿀 수 있음."),un=c(),Bl=r("li"),hn=o("그래서 한 쓰레드에서 읽은 메모리의 값이 다른 쓰레드에서 쓰인(write) 값이라고 확신할 수 없음."),q=r("ul"),Er=r("li"),dn=o("따라서 컴파일러 및 프로세서가 모든 변경사항을 메모리에 커밋(commit)하는 방법이 필요함."),vn=c(),_r=r("li"),En=o("메모리 배리어(Memory Barrier)는 가장 저수준의 메모리 일관성 프로토콜로, 프로세서와 컴파일러에 특정 순서 제약을 강제함. 메모리 배리어 이전에 실행되는 모든 작업은 반드시 메모리 배리어 이후에 실행되는 명령어보다 먼저 완료되어야 함."),_n=c(),pr=r("li"),pn=o("Go의 채널, Atomic 연산, 뮤텍스, condition variable 등은 모두 메모리 배리어를 사용함."),ya=c(),Ie=r("h3"),be=r("a"),mr=r("span"),mn=o("Shared Memory"),Ra=c(),R=r("ul"),Lr=r("li"),Sr=r("p"),Ln=o("단일 프로그램 내에서 Shared memory란 일반적으로 여러 쓰레드가 공유하는 변수 등의 메모리 공간을 의미함."),Sn=c(),Pr=r("li"),Ir=r("p"),Pn=o(`Shared Memory를 통해 통신하는 경우 버그가 발생할 수 있는 가능성이 높아짐.
이 때 동시성으로 인해 발생하는 버그는 사실상 무작위적으로 발생하기에, 버그를 재현 및 디버깅하기가 어려움.`),In=c(),br=r("li"),kr=r("p"),bn=o("lock을 통해 Happened-Before 관계를 정의함"),Ma=c(),ke=r("h3"),$e=r("a"),$r=r("span"),kn=o("Message Passing"),Na=c(),Ce=r("ul"),dl=r("li"),Cr=r("p"),$n=o("UNIX나 LINUX의 철학은 프로세스가 서로 독립적이어야 하며, 메시지를 송수신하는 방식으로 통신해야 한다는 것임."),Cn=c(),Ar=r("ul"),xr=r("li"),An=o("프로세스는 한 종류의 일을 잘 하도록 설계되며, 이러한 프로세스들이 모여 시스템을 구성함."),xn=c(),Ur=r("li"),yr=r("p"),Un=o("메시지를 통홰 Happened-Before 관계를 정의함. (메시지 패싱을 통해 두 쓰레드는 작업의 선후 관계를 정의할 수 있음)"),Ba=c(),Ae=r("h3"),xe=r("a"),Rr=r("span"),yn=o("Hybrid Approach"),Ha=c(),S=r("ul"),Mr=r("li"),Nr=r("p"),Rn=o("Shared Memory와 Message Passing을 혼용하는 방식"),Mn=c(),Br=r("li"),Hr=r("p"),Nn=o("보통 Shared Memory는 빠르고 활용성이 좋지만 data race가 발생할 수 있는 위협이 있음. 이러한 경우 Message Passing을 사용함."),Bn=c(),Gr=r("li"),Or=r("p"),Hn=o("하지만 의도치 않게 메모리를 공유되는 경우가 발생할 수 있음."),Gn=c(),vl=r("li"),Tr=r("p"),On=o("Golang에서의 접근 방식"),Tn=c(),D=r("ul"),qr=r("li"),qn=o("어떤 고루틴이 데이터 객체를 채널로 전달하면, 해당 데이터 객체의 소유권을 잃음."),Dn=c(),Dr=r("li"),wn=o("해당 채널에서 데이터 객체를 꺼낸 고루틴이 소유권을 가짐."),Wn=c(),wr=r("li"),Xn=o("채널로 데이터 객체를 전달한 고루틴은, mutual exclusion을 충족시키지 않는 한 해당 데이터 객체에 다시 접근할 수 없음."),Ga=c(),Oa=r("br"),Ta=r("br"),qa=c(),Ue=r("h2"),ye=r("a"),Wr=r("span"),Kn=o("Atomicity, Race, Deadlock, Starvation"),Da=c(),wa=r("hr"),Wa=c(),Re=r("h3"),Me=r("a"),Xr=r("span"),Qn=o("Race Condition"),Xa=c(),E=r("ul"),Kr=r("li"),Qr=r("p"),jn=o("동시성 프로그램의 실행 순서 및 타이밍에 따라 실행 결과가 달라지는 것."),Jn=c(),jr=r("li"),Jr=r("p"),zn=o("각 쓰레드가 인터리빙되어 실행되기 때문에 발생함."),Zn=c(),zr=r("li"),Zr=r("p"),Fn=o("이상적이지 않은 결과가 발생할 수 있음."),Vn=c(),Fr=r("li"),Vr=r("p"),Yn=o("실질적으로 재현이 어려움."),gn=c(),El=r("li"),Hl=r("p"),Yr=r("strong"),ec=o("Data race"),lc=o("는 다음과 같은 항목에 해당하는 Race Condition의 특수한 케이스임."),tc=c(),w=r("ul"),gr=r("li"),rc=o("두 개 이상의 쓰레드가 동일한 메모리에 접근함"),ic=c(),ei=r("li"),ac=o("한 개 이상의 쓰레드가 메모라에 쓰기 연산을 수행함"),oc=c(),li=r("li"),sc=o("두 쓰레드의 작업 순서를 보장하기 위한 동기화 및 lock이 없음"),Ka=c(),Ne=r("h3"),Be=r("a"),ti=r("span"),fc=o("Atomicity"),Qa=c(),He=r("ul"),ri=r("li"),nc=o("어떤 작업 및 그 하위 작업이 실행될 때 모두 완료되거나, 아니면 전혀 실행되지 않는 것을 의미함."),cc=c(),Ge=r("li"),uc=o("프로그램의 특정 영역에 반드시 한 쓰레드만 접근할 수 있게 하는 "),ii=r("strong"),hc=o("Critical Section"),dc=o("을 사용하여 구현할 수 있음."),_l=r("ul"),pl=r("li"),vc=o("Mutual Exclusion(Mutex)를 통해 "),ai=r("strong"),Ec=o("Critical Section"),_c=o("을 설정함."),pc=c(),Gl=r("li"),mc=o("여러 shared object와 상호작용해야 하는 경우, Mutex의 사용이 복잡해짐."),oi=r("ul"),si=r("li"),Lc=o("상황에 따라 Deadlock이 발생할 수도 있음."),ja=c(),Oe=r("h3"),Te=r("a"),fi=r("span"),Sc=o("Deadlock"),Ja=c(),M=r("ul"),ni=r("li"),ci=r("p"),Pc=o("두 개 이상의 쓰레드가 서로의 작업이 끝나기를 기다리는 상황"),Ic=c(),ml=r("li"),ui=r("p"),bc=o("Deadlock이 발생하려면 Coffman 조건이 충족되어야 함."),kc=c(),C=r("ul"),hi=r("li"),$c=o("Mutual Exclusion: 한 쓰레드가 Critical Section에 들어가면, 다른 쓰레드는 해당 Critical Section에 들어갈 수 없음."),Cc=c(),di=r("li"),Ac=o("Hold and Wait: 쓰레드는 어떤 자원을 점유한 상태에서, 다른 쓰레드가 점유한 자원을 기다림."),xc=c(),vi=r("li"),Uc=o("No Preemption: 쓰레드는 점유한 자원을 다른 쓰레드가 강제로 빼앗을 수 없음."),yc=c(),Ei=r("li"),Rc=o("Circular Wait: 쓰레드 간에 자원을 순환적으로 기다림."),Mc=c(),_i=r("li"),pi=r("p"),Nc=o("Deadlock을 예방하기 위해 shared resoruce에 대한 일관된 lock 순서를 정의할 수 있으나, 모든 Deadlock을 예방할 수는 없음."),za=c(),Ol=r("blockquote"),mi=r("p"),Bc=o(`정보) Go에서는 모든 Goroutine이 Block된 상태이면 Deadlock이 발생했다고 판단하고, panic을 발생시킴.
그래서 모든 Goroutine이 아닌 일부 Goroutine에서만 Deadlock이 발생했다면 이를 감지하지 못함.`),Za=c(),qe=r("h3"),De=r("a"),Li=r("span"),Hc=o("Starvation"),Fa=c(),we=r("ul"),Si=r("li"),Gc=o("일부 쓰레드가 Critical Section에 들어가기 위해 계속해서 기다리지만, 다른 쓰레드가 먼저 Critical Section에 들어감으로 인해 Critical Section에 지속적으로 접근하지 못하는 상황"),Oc=c(),Pi=r("li"),Tc=o("DoS(Denial of Service) 공격의 기본 원리임."),Va=c(),Tl=r("blockquote"),Ii=r("p"),qc=o("정보) Go 런타임은 특정 Goroutine이 Starvation 상태에 빠지는 것을 감지하지는 못한다."),Ya=c(),We=r("h3"),Xe=r("a"),bi=r("span"),Dc=o("Livelock"),ga=c(),P=r("ul"),ki=r("li"),wc=o("Deadlock처럼 보이지만, 쓰레드가 lock을 획득하려고 시도하는 연산을 계속 반복하기 때문에 실제로는 차단된 쓰레드가 없는 상황"),Wc=c(),$i=r("li"),Xc=o("쓰레드가 작동하더라도 실제로는 유의미한 작업을 수행하지 못하기 때문에, Starvation과 유사함."),Kc=c(),Ci=r("li"),Qc=o("Livelock은 몇번 반복하다 보면 해결될 수 있기 때문에 확인하기 어려움."),jc=c(),Ai=r("li"),Jc=o("lock을 획득하기 위해 재시도 및 무작위적인 대기 시간을 추가하는 방법으로 해결할 수 있음."),eo=c(),lo=r("br"),to=r("br"),ro=c(),Ke=r("h2"),Qe=r("a"),xi=r("span"),zc=o("References"),io=c(),ao=r("hr"),oo=c(),ql=r("center"),W=r("p"),Ll=r("a"),Dl=r("img"),Zc=c(),Fc=r("br"),Vc=c(),Sl=r("a"),Yc=o("Jon Bodner, 『Learning Go』, O’Reilly Media, Inc."),this.h()},l(t){v=i(t,"P",{});var f=a(v);d=i(f,"STRONG",{});var Ui=a(d);_=s(Ui,"Effective Concurrency in Go"),Ui.forEach(l),No=s(f,"를 읽던 중, 동시성 관련해서 좋은 내용들이 많이 나와서 한 번 개념을 정리해보았읍니다."),f.forEach(l),Ki=u(t),Pl=i(t,"UL",{});var yi=a(Pl);rt=i(yi,"LI",{});var Ri=a(rt);Bo=s(Ri,"본 포스트 안에서 쓰레드와 고루틴을 혼용해서 사용했는데, 얼추 비슷한 애들이라고 생각하시면 됩니다."),Ri.forEach(l),yi.forEach(l),Qi=u(t),ji=i(t,"BR",{}),Ji=i(t,"BR",{}),zi=u(t),K=i(t,"H2",{id:!0});var wl=a(K);Q=i(wl,"A",{"aria-hidden":!0,tabindex:!0,href:!0});var Mi=a(Q);it=i(Mi,"SPAN",{class:!0}),a(it).forEach(l),Mi.forEach(l),Ho=s(wl,"동시성(Concurrency) vs 병렬성(Parallelism)"),wl.forEach(l),Zi=u(t),Fi=i(t,"HR",{}),Vi=u(t),j=i(t,"H3",{id:!0});var gc=a(j);J=i(gc,"A",{"aria-hidden":!0,tabindex:!0,href:!0});var yu=a(J);at=i(yu,"SPAN",{class:!0}),a(at).forEach(l),yu.forEach(l),Go=s(gc,"동시성(Concurrency)"),gc.forEach(l),Yi=u(t),z=i(t,"UL",{});var fo=a(z);ot=i(fo,"LI",{});var Ru=a(ot);p=i(Ru,"P",{});var X=a(p);Oo=s(X,"여러 작업을 동시에 수행하는 것"),st=i(X,"STRONG",{});var Mu=a(st);To=s(Mu,"처럼 보이는 것"),Mu.forEach(l),qo=i(X,"BR",{}),Do=s(X,`
실제로는 여러 작업을 `),ft=i(X,"STRONG",{});var Nu=a(ft);wo=s(Nu,"동시에 수행하는 것이 아니라, 짧은 시간 간격으로 번갈아가며 수행하는 것"),Nu.forEach(l),Wo=s(X,"이다."),Xo=i(X,"BR",{}),Ko=s(X,`
싱글 코어에서도 동시성을 구현할 수 있음.`),X.forEach(l),Ru.forEach(l),Qo=u(fo),nt=i(fo,"LI",{});var Bu=a(nt);B=i(Bu,"P",{});var Wl=a(B);jo=s(Wl,"엄밀한 정의는, "),ct=i(Wl,"STRONG",{});var Hu=a(ct);Jo=s(Hu,"결과에 영향을 주지 않고, 프로그램의 서로 다른 부분이 partial order 또는 순서에 관계없이 실행될 수 있는 것"),Hu.forEach(l),zo=s(Wl,"을 의미함."),Zo=i(Wl,"BR",{}),Fo=s(Wl,`
프로그램이 A,B,C로 구성되어 있을 때, A,C,B 또는 B,C,A 등로 실행되어도 결과에 영향을 주지 않는다면, 이 프로그램은 동시성을 가지고 있다고 할 수 있음.`),Wl.forEach(l),Bu.forEach(l),fo.forEach(l),gi=u(t),Z=i(t,"H3",{id:!0});var eu=a(Z);F=i(eu,"A",{"aria-hidden":!0,tabindex:!0,href:!0});var Gu=a(F);ut=i(Gu,"SPAN",{class:!0}),a(ut).forEach(l),Gu.forEach(l),Vo=s(eu,"병렬성(Parallelism)"),eu.forEach(l),ea=u(t),Il=i(t,"UL",{});var Ou=a(Il);b=i(Ou,"LI",{});var je=a(b);Yo=s(je,"여러 작업을 "),ht=i(je,"STRONG",{});var Tu=a(ht);go=s(Tu,"동시에 수행하는 것"),Tu.forEach(l),es=i(je,"BR",{}),ls=s(je,`
실제로 여러 작업이 `),dt=i(je,"STRONG",{});var qu=a(dt);ts=s(qu,"동시에 수행됨"),qu.forEach(l),rs=i(je,"BR",{}),is=s(je,`
멀티 코어, 즉 서로 다른 CPU 코어에서 돌아가는 프로세스나 쓰레드가 이에 해당함.`),je.forEach(l),Ou.forEach(l),la=u(t),V=i(t,"H3",{id:!0});var lu=a(V);Y=i(lu,"A",{"aria-hidden":!0,tabindex:!0,href:!0});var Du=a(Y);vt=i(Du,"SPAN",{class:!0}),a(vt).forEach(l),Du.forEach(l),as=s(lu,"동시성과 병렬성의 차이"),lu.forEach(l),ta=u(t),A=i(t,"P",{});var Xl=a(A);os=s(Xl,"동시성은 프로그램이 "),Ti(g.$$.fragment,Xl),ss=s(Xl,"에 관련된 것이고, 병렬성은 프로그램이 "),Ti(ee.$$.fragment,Xl),fs=s(Xl,"에 관련된 것이다."),Xl.forEach(l),ra=u(t),ia=i(t,"BR",{}),aa=i(t,"BR",{}),oa=u(t),le=i(t,"H2",{id:!0});var tu=a(le);te=i(tu,"A",{"aria-hidden":!0,tabindex:!0,href:!0});var wu=a(te);Et=i(wu,"SPAN",{class:!0}),a(Et).forEach(l),wu.forEach(l),ns=s(tu,"동시성 프로그래밍"),tu.forEach(l),sa=u(t),fa=i(t,"HR",{}),na=u(t),x=i(t,"UL",{});var Kl=a(x);_t=i(Kl,"LI",{});var Wu=a(_t);cs=s(Wu,"문제를 실행 단위로 나누어 time sharing 또는 병렬적으로 실행될 수 있게끔 하는 것"),Wu.forEach(l),us=u(Kl),pt=i(Kl,"LI",{});var Xu=a(pt);hs=s(Xu,"이들은 서로 병렬적으로 또는 인터리빙(interleaving)되어 실행될 수 있으며, 메시지를 통해 통신할 수 있음."),Xu.forEach(l),ds=u(Kl),mt=i(Kl,"LI",{});var Ku=a(mt);vs=s(Ku,"따라서 동시성 프로그래밍은 객체지향이나 함수형 프로그래밍처럼, 프로그램을 작성하는 방식이라고도 할 수 있음."),Ku.forEach(l),Kl.forEach(l),ca=u(t),re=i(t,"H3",{id:!0});var ru=a(re);ie=i(ru,"A",{"aria-hidden":!0,tabindex:!0,href:!0});var Qu=a(ie);Lt=i(Qu,"SPAN",{class:!0}),a(Lt).forEach(l),Qu.forEach(l),Es=s(ru,"Time Sharing과 Context Switching"),ru.forEach(l),ua=u(t),m=i(t,"UL",{});var Je=a(m);St=i(Je,"LI",{});var ju=a(St);_s=s(ju,"컴퓨팅 리소스(주로 CPU)를 여러 프로그램이 공유하는 것."),ju.forEach(l),ps=u(Je),bl=i(Je,"LI",{});var iu=a(bl);ms=s(iu,"어떤 프로세스가 여러 쓰레드로 구성되어 있다 할 때, 한 쓰레드가 일정한 time quantum 동안 CPU를 사용하고, 그 다음 쓰레드가 CPU를 사용하는 방식으로 진행됨."),H=i(iu,"UL",{});var Ql=a(H);el=i(Ql,"LI",{});var no=a(el);Ls=s(no,"이를 "),Ti(ae.$$.fragment,no),Ss=s(no,"이라고 함."),no.forEach(l),Ps=u(Ql),Pt=i(Ql,"LI",{});var Ju=a(Pt);Is=s(Ju,"쓰레드의 실행 컨텍스트에는 해당 쓰레드의 state(레지스터 값, 프로그램 카운터, Stack Pointer 등)가 저장되어 있음."),Ju.forEach(l),bs=u(Ql),It=i(Ql,"LI",{});var zu=a(It);ks=s(zu,"Context Switching이 발생하면, 현재 쓰레드의 state가 저장되고, 다음 쓰레드의 state가 복원됨."),zu.forEach(l),Ql.forEach(l),iu.forEach(l),$s=u(Je),kl=i(Je,"LI",{});var au=a(kl);bt=i(au,"STRONG",{});var Zu=a(bt);Cs=s(Zu,"Preemptive Thread Scheduling"),Zu.forEach(l),As=s(au,"에서는 쓰레드가 실행되는 도중 Context Switching이 발생할 수 있음."),au.forEach(l),xs=u(Je),oe=i(Je,"LI",{});var Ni=a(oe);kt=i(Ni,"STRONG",{});var Fu=a(kt);Us=s(Fu,"Non-Preemptive Thread Scheduling"),Fu.forEach(l),ys=s(Ni,"("),$t=i(Ni,"STRONG",{});var Vu=a($t);Rs=s(Vu,"Cooperative Threading"),Vu.forEach(l),Ms=s(Ni,")에서는 쓰레드가 실행을 마칠 때까지 Context Switching이 발생하지 않음."),Ni.forEach(l),Je.forEach(l),ha=u(t),$l=i(t,"BLOCKQUOTE",{});var Yu=a($l);Ct=i(Yu,"P",{});var gu=a(Ct);Ns=s(gu,"정보) Go 언어에서는 1.14 이전까지는 Non-Preemptive Thread Scheduling을 사용하였으나, 1.14부터 Preemptive Thread Scheduling을 사용하도록 변경되었다."),gu.forEach(l),Yu.forEach(l),da=u(t),Cl=i(t,"UL",{});var e1=a(Cl);Al=i(e1,"LI",{});var ou=a(Al);Bs=s(ou,"쓰레드의 상태와 스케줄링"),k=i(ou,"UL",{});var ze=a(k);G=i(ze,"LI",{});var jl=a(G);Hs=s(jl,"쓰레드가 실행되면 "),At=i(jl,"EM",{});var l1=a(At);Gs=s(l1,"Ready"),l1.forEach(l),Os=s(jl," state로 들어가고, CPU를 사용할 수 있을 때 "),xt=i(jl,"EM",{});var t1=a(xt);Ts=s(t1,"Running"),t1.forEach(l),qs=s(jl," state로 들어감."),jl.forEach(l),Ds=u(ze),se=i(ze,"LI",{});var Bi=a(se);Ut=i(Bi,"EM",{});var r1=a(Ut);ws=s(r1,"Running"),r1.forEach(l),Ws=s(Bi," state의 쓰레드는 time quantum이 끝나면 다시 "),yt=i(Bi,"EM",{});var i1=a(yt);Xs=s(i1,"Ready"),i1.forEach(l),Ks=s(Bi," state로 돌아감."),Bi.forEach(l),Qs=u(ze),fe=i(ze,"LI",{});var Hi=a(fe);Rt=i(Hi,"EM",{});var a1=a(Rt);js=s(a1,"Running"),a1.forEach(l),Js=s(Hi," state의 쓰레드가 I/O 작업 등으로 인한 인터럽트가 발생하거나, lock을 획득하지 못하면 "),Mt=i(Hi,"EM",{});var o1=a(Mt);zs=s(o1,"Blocked"),o1.forEach(l),Zs=s(Hi," state로 들어감."),Hi.forEach(l),Fs=u(ze),O=i(ze,"LI",{});var Jl=a(O);Nt=i(Jl,"EM",{});var s1=a(Nt);Vs=s(s1,"Blocked"),s1.forEach(l),Ys=s(Jl," state의 쓰레드는 I/O 작업이 끝나거나, lock을 획득하면 다시 "),Bt=i(Jl,"EM",{});var f1=a(Bt);gs=s(f1,"Ready"),f1.forEach(l),ef=s(Jl," state로 돌아가게 되고, 스케줄러에 의해 선택되기를 기다림."),Ht=i(Jl,"UL",{});var n1=a(Ht);ll=i(n1,"LI",{});var co=a(ll);lf=s(co,"이 때 "),Gt=i(co,"EM",{});var c1=a(Gt);tf=s(c1,"Ready"),c1.forEach(l),rf=s(co," state의 쓰레드가 바로 실행되리라는 보장은 없음."),co.forEach(l),n1.forEach(l),Jl.forEach(l),ze.forEach(l),ou.forEach(l),e1.forEach(l),va=u(t),ne=i(t,"H3",{id:!0});var su=a(ne);ce=i(su,"A",{"aria-hidden":!0,tabindex:!0,href:!0});var u1=a(ce);Ot=i(u1,"SPAN",{class:!0}),a(Ot).forEach(l),u1.forEach(l),af=s(su,"동시성 프로그래밍은 왜 어려운가?"),su.forEach(l),Ea=u(t),xl=i(t,"P",{});var h1=a(xl);of=s(h1,"상태 관리의 어려움 때문임"),h1.forEach(l),_a=u(t),U=i(t,"UL",{});var zl=a(U);Ul=i(zl,"LI",{});var fu=a(Ul);sf=s(fu,"각각의 Sequantial Program은 상태(state)를 가지고 있음."),tl=i(fu,"UL",{});var uo=a(tl);Tt=i(uo,"LI",{});var d1=a(Tt);ff=s(d1,"state는 Sequantial Program의 실행 위치와 메모리에 저장된 값을 의미함"),d1.forEach(l),nf=u(uo),qt=i(uo,"LI",{});var v1=a(qt);cf=s(v1,"프로그램의 현재 state에 따라 다음 state를 예측할 수 있음"),v1.forEach(l),uo.forEach(l),fu.forEach(l),uf=u(zl),Dt=i(zl,"LI",{});var E1=a(Dt);hf=s(E1,"그런데 동시에 여러 프로그램이 실행되면 각각의 Sequantial Program이 가지고 있는 state가 서로 영향을 미칠 수 있음."),E1.forEach(l),df=u(zl),yl=i(zl,"LI",{});var nu=a(yl);vf=s(nu,"Sequantial Program이 많아질수록, 가능한 state의 수가 많아질수록 전체 프로그램이 가질 수 있는 state의 경우의 수가 기하급수적으로 증가함"),wt=i(nu,"UL",{});var _1=a(wt);Wt=i(_1,"LI",{});var p1=a(Wt);Ef=s(p1,"n개의 state가 있는 Sequantial Program이 m개 실행되면 n^m개의 state가 존재함"),p1.forEach(l),_1.forEach(l),nu.forEach(l),zl.forEach(l),pa=u(t),Rl=i(t,"P",{});var m1=a(Rl);_f=s(m1,"따라서, 일반적인 state 분석으로 동시성 프로그램의 행동을 예측하기 어려움."),m1.forEach(l),ma=u(t),ue=i(t,"H3",{id:!0});var cu=a(ue);he=i(cu,"A",{"aria-hidden":!0,tabindex:!0,href:!0});var L1=a(he);Xt=i(L1,"SPAN",{class:!0}),a(Xt).forEach(l),L1.forEach(l),pf=s(cu,"Happened-Before 관계"),cu.forEach(l),La=u(t),y=i(t,"UL",{});var Zl=a(y);Kt=i(Zl,"LI",{});var S1=a(Kt);mf=s(S1,"두 개의 서로 같지 않은 정수가 있다면, 이들의 대소 관계를 알 수 있음."),S1.forEach(l),Lf=u(Zl),Ml=i(Zl,"LI",{});var uu=a(Ml);Sf=s(uu,"마찬가지로 한 Sequantial Program에서 발생한 서로 다른 두 이벤트가 있다면, 한 이벤트는 반드시 다른 이벤트보다 먼저 발생했을 것임."),Qt=i(uu,"UL",{});var P1=a(Qt);rl=i(P1,"LI",{});var ho=a(rl);Pf=s(ho,"이를 "),Ti(de.$$.fragment,ho),If=s(ho,"라고 함."),ho.forEach(l),P1.forEach(l),uu.forEach(l),bf=u(Zl),Nl=i(Zl,"LI",{});var hu=a(Nl);kf=s(hu,"서로 다른 프로세스에서 발생한 이벤트에 순서를 정하는 것은 불가능하지만, Message Passing 등을 통해 이벤트의 순서를 일부 정의할 수 있음."),jt=i(hu,"UL",{});var I1=a(jt);il=i(I1,"LI",{});var vo=a(il);$f=s(vo,"이를 "),Ti(ve.$$.fragment,vo),Cf=s(vo,"라고 함."),vo.forEach(l),I1.forEach(l),hu.forEach(l),Zl.forEach(l),Sa=u(t),Ee=i(t,"H3",{id:!0});var du=a(Ee);_e=i(du,"A",{"aria-hidden":!0,tabindex:!0,href:!0});var b1=a(_e);Jt=i(b1,"SPAN",{class:!0}),a(Jt).forEach(l),b1.forEach(l),Af=s(du,"Dining Philosopher Problem"),du.forEach(l),Pa=u(t),pe=i(t,"UL",{});var Eo=a(pe);al=i(Eo,"LI",{});var _o=a(al);zt=i(_o,"P",{});var k1=a(zt);xf=s(k1,"문제 정의"),k1.forEach(l),Uf=u(_o),$=i(_o,"UL",{});var Ze=a($);Zt=i(Ze,"LI",{});var $1=a(Zt);yf=s($1,"철학자들이 원형 테이블에 앉아있음."),$1.forEach(l),Rf=u(Ze),Ft=i(Ze,"LI",{});var C1=a(Ft);Mf=s(C1,"테이블 위에는 포크가 5개 놓여있음."),C1.forEach(l),Nf=u(Ze),Vt=i(Ze,"LI",{});var A1=a(Vt);Bf=s(A1,"철학자들은 생각을 하다가 배가 고파지면 양 옆의 포크를 집어들어 먹기 시작함."),A1.forEach(l),Hf=u(Ze),Yt=i(Ze,"LI",{});var x1=a(Yt);Gf=s(x1,"식사를 마치면 포크를 내려놓고 다시 생각을 하기 시작함."),x1.forEach(l),Ze.forEach(l),_o.forEach(l),Of=u(Eo),ol=i(Eo,"LI",{});var po=a(ol);gt=i(po,"P",{});var U1=a(gt);Tf=s(U1,"Deadlock 발생 가능성"),U1.forEach(l),qf=u(po),T=i(po,"UL",{});var Fl=a(T);er=i(Fl,"LI",{});var y1=a(er);Df=s(y1,"모든 철학자가 자신의 왼쪽 포크만을 집어든 상태라면, 모든 철학자는 다음 포크를 집어들기 위해 오른쪽 철학자가 포크를 내려놓기를 기다려야 함."),y1.forEach(l),wf=u(Fl),lr=i(Fl,"LI",{});var R1=a(lr);Wf=s(R1,"이 상태에서는 모든 철학자가 포크를 내려놓기를 기다리는 상태로 무한 대기 상태에 빠짐."),R1.forEach(l),Xf=u(Fl),tr=i(Fl,"LI",{});var M1=a(tr);Kf=s(M1,"한 철학자가 자신의 포크를 내려놓지 않는 이상, 다른 철학자들은 포크를 집어들 수 없음."),M1.forEach(l),Fl.forEach(l),po.forEach(l),Eo.forEach(l),Ia=u(t),ba=i(t,"BR",{}),ka=i(t,"BR",{}),$a=u(t),me=i(t,"H2",{id:!0});var vu=a(me);Le=i(vu,"A",{"aria-hidden":!0,tabindex:!0,href:!0});var N1=a(Le);rr=i(N1,"SPAN",{class:!0}),a(rr).forEach(l),N1.forEach(l),Qf=s(vu,"Shared Memory와 Message Passing"),vu.forEach(l),Ca=u(t),Aa=i(t,"HR",{}),xa=u(t),Se=i(t,"H3",{id:!0});var Eu=a(Se);Pe=i(Eu,"A",{"aria-hidden":!0,tabindex:!0,href:!0});var B1=a(Pe);ir=i(B1,"SPAN",{class:!0}),a(ir).forEach(l),B1.forEach(l),jf=s(Eu,"관련 Computer Architecture 지식"),Eu.forEach(l),Ua=u(t),L=i(t,"UL",{});var Fe=a(L);sl=i(Fe,"LI",{});var mo=a(sl);ar=i(mo,"P",{});var H1=a(ar);Jf=s(H1,"UMA(Uniform Memory Access)"),H1.forEach(l),zf=u(mo),fl=i(mo,"UL",{});var Lo=a(fl);or=i(Lo,"LI",{});var G1=a(or);Zf=s(G1,"메모리에 접근할 때 모든 프로세서가 동일한 권한을 가지고 있음."),G1.forEach(l),Ff=u(Lo),sr=i(Lo,"LI",{});var O1=a(sr);Vf=s(O1,"동일한 메모리 액세스 버스가 공유되기 때문에 처리량이 감소할 수 있음."),O1.forEach(l),Lo.forEach(l),mo.forEach(l),Yf=u(Fe),nl=i(Fe,"LI",{});var So=a(nl);fr=i(So,"P",{});var T1=a(fr);gf=s(T1,"NUMA(Non-Uniform Memory Access)"),T1.forEach(l),en=u(So),cl=i(So,"UL",{});var Po=a(cl);nr=i(Po,"LI",{});var q1=a(nr);ln=s(q1,"프로세서는 메모리의 특정 영역에 대해서만 접근 권한을 가짐"),q1.forEach(l),tn=u(Po),cr=i(Po,"LI",{});var D1=a(cr);rn=s(D1,"OS가 프로세서에서 필요한 메모리를 해당 영역에 할당함으로써 전용 메모리 액세스 버스를 사용할 수 있기 때문에 처리량이 증가할 수 있음."),D1.forEach(l),Po.forEach(l),So.forEach(l),an=u(Fe),ur=i(Fe,"LI",{});var w1=a(ur);hr=i(w1,"P",{});var W1=a(hr);on=s(W1,"대부분의 프로세서는 캐시 메모리를 사용하며, 캐시 일관성(Cache Coherence) 프로토콜을 사용하여 캐시 메모리의 일관성을 유지함."),W1.forEach(l),w1.forEach(l),sn=u(Fe),ul=i(Fe,"LI",{});var Io=a(ul);dr=i(Io,"P",{});var X1=a(dr);fn=s(X1,"현대 프로세서는 메모리 read 및 write가 완료될 때까지 기다리지 않음. 파이프라이닝(Pipelining)을 통해 다음 명령어를 동시에 실행함."),X1.forEach(l),nn=u(Io),hl=i(Io,"UL",{});var bo=a(hl);vr=i(bo,"LI",{});var K1=a(vr);cn=s(K1,"이 때 파이프라이닝의 최적화를 위해서 컴파일러가 명령어의 순서를 바꿀 수 있음."),K1.forEach(l),un=u(bo),Bl=i(bo,"LI",{});var _u=a(Bl);hn=s(_u,"그래서 한 쓰레드에서 읽은 메모리의 값이 다른 쓰레드에서 쓰인(write) 값이라고 확신할 수 없음."),q=i(_u,"UL",{});var Vl=a(q);Er=i(Vl,"LI",{});var Q1=a(Er);dn=s(Q1,"따라서 컴파일러 및 프로세서가 모든 변경사항을 메모리에 커밋(commit)하는 방법이 필요함."),Q1.forEach(l),vn=u(Vl),_r=i(Vl,"LI",{});var j1=a(_r);En=s(j1,"메모리 배리어(Memory Barrier)는 가장 저수준의 메모리 일관성 프로토콜로, 프로세서와 컴파일러에 특정 순서 제약을 강제함. 메모리 배리어 이전에 실행되는 모든 작업은 반드시 메모리 배리어 이후에 실행되는 명령어보다 먼저 완료되어야 함."),j1.forEach(l),_n=u(Vl),pr=i(Vl,"LI",{});var J1=a(pr);pn=s(J1,"Go의 채널, Atomic 연산, 뮤텍스, condition variable 등은 모두 메모리 배리어를 사용함."),J1.forEach(l),Vl.forEach(l),_u.forEach(l),bo.forEach(l),Io.forEach(l),Fe.forEach(l),ya=u(t),Ie=i(t,"H3",{id:!0});var pu=a(Ie);be=i(pu,"A",{"aria-hidden":!0,tabindex:!0,href:!0});var z1=a(be);mr=i(z1,"SPAN",{class:!0}),a(mr).forEach(l),z1.forEach(l),mn=s(pu,"Shared Memory"),pu.forEach(l),Ra=u(t),R=i(t,"UL",{});var Yl=a(R);Lr=i(Yl,"LI",{});var Z1=a(Lr);Sr=i(Z1,"P",{});var F1=a(Sr);Ln=s(F1,"단일 프로그램 내에서 Shared memory란 일반적으로 여러 쓰레드가 공유하는 변수 등의 메모리 공간을 의미함."),F1.forEach(l),Z1.forEach(l),Sn=u(Yl),Pr=i(Yl,"LI",{});var V1=a(Pr);Ir=i(V1,"P",{});var Y1=a(Ir);Pn=s(Y1,`Shared Memory를 통해 통신하는 경우 버그가 발생할 수 있는 가능성이 높아짐.
이 때 동시성으로 인해 발생하는 버그는 사실상 무작위적으로 발생하기에, 버그를 재현 및 디버깅하기가 어려움.`),Y1.forEach(l),V1.forEach(l),In=u(Yl),br=i(Yl,"LI",{});var g1=a(br);kr=i(g1,"P",{});var eh=a(kr);bn=s(eh,"lock을 통해 Happened-Before 관계를 정의함"),eh.forEach(l),g1.forEach(l),Yl.forEach(l),Ma=u(t),ke=i(t,"H3",{id:!0});var mu=a(ke);$e=i(mu,"A",{"aria-hidden":!0,tabindex:!0,href:!0});var lh=a($e);$r=i(lh,"SPAN",{class:!0}),a($r).forEach(l),lh.forEach(l),kn=s(mu,"Message Passing"),mu.forEach(l),Na=u(t),Ce=i(t,"UL",{});var ko=a(Ce);dl=i(ko,"LI",{});var $o=a(dl);Cr=i($o,"P",{});var th=a(Cr);$n=s(th,"UNIX나 LINUX의 철학은 프로세스가 서로 독립적이어야 하며, 메시지를 송수신하는 방식으로 통신해야 한다는 것임."),th.forEach(l),Cn=u($o),Ar=i($o,"UL",{});var rh=a(Ar);xr=i(rh,"LI",{});var ih=a(xr);An=s(ih,"프로세스는 한 종류의 일을 잘 하도록 설계되며, 이러한 프로세스들이 모여 시스템을 구성함."),ih.forEach(l),rh.forEach(l),$o.forEach(l),xn=u(ko),Ur=i(ko,"LI",{});var ah=a(Ur);yr=i(ah,"P",{});var oh=a(yr);Un=s(oh,"메시지를 통홰 Happened-Before 관계를 정의함. (메시지 패싱을 통해 두 쓰레드는 작업의 선후 관계를 정의할 수 있음)"),oh.forEach(l),ah.forEach(l),ko.forEach(l),Ba=u(t),Ae=i(t,"H3",{id:!0});var Lu=a(Ae);xe=i(Lu,"A",{"aria-hidden":!0,tabindex:!0,href:!0});var sh=a(xe);Rr=i(sh,"SPAN",{class:!0}),a(Rr).forEach(l),sh.forEach(l),yn=s(Lu,"Hybrid Approach"),Lu.forEach(l),Ha=u(t),S=i(t,"UL",{});var Ve=a(S);Mr=i(Ve,"LI",{});var fh=a(Mr);Nr=i(fh,"P",{});var nh=a(Nr);Rn=s(nh,"Shared Memory와 Message Passing을 혼용하는 방식"),nh.forEach(l),fh.forEach(l),Mn=u(Ve),Br=i(Ve,"LI",{});var ch=a(Br);Hr=i(ch,"P",{});var uh=a(Hr);Nn=s(uh,"보통 Shared Memory는 빠르고 활용성이 좋지만 data race가 발생할 수 있는 위협이 있음. 이러한 경우 Message Passing을 사용함."),uh.forEach(l),ch.forEach(l),Bn=u(Ve),Gr=i(Ve,"LI",{});var hh=a(Gr);Or=i(hh,"P",{});var dh=a(Or);Hn=s(dh,"하지만 의도치 않게 메모리를 공유되는 경우가 발생할 수 있음."),dh.forEach(l),hh.forEach(l),Gn=u(Ve),vl=i(Ve,"LI",{});var Co=a(vl);Tr=i(Co,"P",{});var vh=a(Tr);On=s(vh,"Golang에서의 접근 방식"),vh.forEach(l),Tn=u(Co),D=i(Co,"UL",{});var gl=a(D);qr=i(gl,"LI",{});var Eh=a(qr);qn=s(Eh,"어떤 고루틴이 데이터 객체를 채널로 전달하면, 해당 데이터 객체의 소유권을 잃음."),Eh.forEach(l),Dn=u(gl),Dr=i(gl,"LI",{});var _h=a(Dr);wn=s(_h,"해당 채널에서 데이터 객체를 꺼낸 고루틴이 소유권을 가짐."),_h.forEach(l),Wn=u(gl),wr=i(gl,"LI",{});var ph=a(wr);Xn=s(ph,"채널로 데이터 객체를 전달한 고루틴은, mutual exclusion을 충족시키지 않는 한 해당 데이터 객체에 다시 접근할 수 없음."),ph.forEach(l),gl.forEach(l),Co.forEach(l),Ve.forEach(l),Ga=u(t),Oa=i(t,"BR",{}),Ta=i(t,"BR",{}),qa=u(t),Ue=i(t,"H2",{id:!0});var Su=a(Ue);ye=i(Su,"A",{"aria-hidden":!0,tabindex:!0,href:!0});var mh=a(ye);Wr=i(mh,"SPAN",{class:!0}),a(Wr).forEach(l),mh.forEach(l),Kn=s(Su,"Atomicity, Race, Deadlock, Starvation"),Su.forEach(l),Da=u(t),wa=i(t,"HR",{}),Wa=u(t),Re=i(t,"H3",{id:!0});var Pu=a(Re);Me=i(Pu,"A",{"aria-hidden":!0,tabindex:!0,href:!0});var Lh=a(Me);Xr=i(Lh,"SPAN",{class:!0}),a(Xr).forEach(l),Lh.forEach(l),Qn=s(Pu,"Race Condition"),Pu.forEach(l),Xa=u(t),E=i(t,"UL",{});var N=a(E);Kr=i(N,"LI",{});var Sh=a(Kr);Qr=i(Sh,"P",{});var Ph=a(Qr);jn=s(Ph,"동시성 프로그램의 실행 순서 및 타이밍에 따라 실행 결과가 달라지는 것."),Ph.forEach(l),Sh.forEach(l),Jn=u(N),jr=i(N,"LI",{});var Ih=a(jr);Jr=i(Ih,"P",{});var bh=a(Jr);zn=s(bh,"각 쓰레드가 인터리빙되어 실행되기 때문에 발생함."),bh.forEach(l),Ih.forEach(l),Zn=u(N),zr=i(N,"LI",{});var kh=a(zr);Zr=i(kh,"P",{});var $h=a(Zr);Fn=s($h,"이상적이지 않은 결과가 발생할 수 있음."),$h.forEach(l),kh.forEach(l),Vn=u(N),Fr=i(N,"LI",{});var Ch=a(Fr);Vr=i(Ch,"P",{});var Ah=a(Vr);Yn=s(Ah,"실질적으로 재현이 어려움."),Ah.forEach(l),Ch.forEach(l),gn=u(N),El=i(N,"LI",{});var Ao=a(El);Hl=i(Ao,"P",{});var Iu=a(Hl);Yr=i(Iu,"STRONG",{});var xh=a(Yr);ec=s(xh,"Data race"),xh.forEach(l),lc=s(Iu,"는 다음과 같은 항목에 해당하는 Race Condition의 특수한 케이스임."),Iu.forEach(l),tc=u(Ao),w=i(Ao,"UL",{});var et=a(w);gr=i(et,"LI",{});var Uh=a(gr);rc=s(Uh,"두 개 이상의 쓰레드가 동일한 메모리에 접근함"),Uh.forEach(l),ic=u(et),ei=i(et,"LI",{});var yh=a(ei);ac=s(yh,"한 개 이상의 쓰레드가 메모라에 쓰기 연산을 수행함"),yh.forEach(l),oc=u(et),li=i(et,"LI",{});var Rh=a(li);sc=s(Rh,"두 쓰레드의 작업 순서를 보장하기 위한 동기화 및 lock이 없음"),Rh.forEach(l),et.forEach(l),Ao.forEach(l),N.forEach(l),Ka=u(t),Ne=i(t,"H3",{id:!0});var bu=a(Ne);Be=i(bu,"A",{"aria-hidden":!0,tabindex:!0,href:!0});var Mh=a(Be);ti=i(Mh,"SPAN",{class:!0}),a(ti).forEach(l),Mh.forEach(l),fc=s(bu,"Atomicity"),bu.forEach(l),Qa=u(t),He=i(t,"UL",{});var xo=a(He);ri=i(xo,"LI",{});var Nh=a(ri);nc=s(Nh,"어떤 작업 및 그 하위 작업이 실행될 때 모두 완료되거나, 아니면 전혀 실행되지 않는 것을 의미함."),Nh.forEach(l),cc=u(xo),Ge=i(xo,"LI",{});var Gi=a(Ge);uc=s(Gi,"프로그램의 특정 영역에 반드시 한 쓰레드만 접근할 수 있게 하는 "),ii=i(Gi,"STRONG",{});var Bh=a(ii);hc=s(Bh,"Critical Section"),Bh.forEach(l),dc=s(Gi,"을 사용하여 구현할 수 있음."),_l=i(Gi,"UL",{});var Uo=a(_l);pl=i(Uo,"LI",{});var yo=a(pl);vc=s(yo,"Mutual Exclusion(Mutex)를 통해 "),ai=i(yo,"STRONG",{});var Hh=a(ai);Ec=s(Hh,"Critical Section"),Hh.forEach(l),_c=s(yo,"을 설정함."),yo.forEach(l),pc=u(Uo),Gl=i(Uo,"LI",{});var ku=a(Gl);mc=s(ku,"여러 shared object와 상호작용해야 하는 경우, Mutex의 사용이 복잡해짐."),oi=i(ku,"UL",{});var Gh=a(oi);si=i(Gh,"LI",{});var Oh=a(si);Lc=s(Oh,"상황에 따라 Deadlock이 발생할 수도 있음."),Oh.forEach(l),Gh.forEach(l),ku.forEach(l),Uo.forEach(l),Gi.forEach(l),xo.forEach(l),ja=u(t),Oe=i(t,"H3",{id:!0});var $u=a(Oe);Te=i($u,"A",{"aria-hidden":!0,tabindex:!0,href:!0});var Th=a(Te);fi=i(Th,"SPAN",{class:!0}),a(fi).forEach(l),Th.forEach(l),Sc=s($u,"Deadlock"),$u.forEach(l),Ja=u(t),M=i(t,"UL",{});var lt=a(M);ni=i(lt,"LI",{});var qh=a(ni);ci=i(qh,"P",{});var Dh=a(ci);Pc=s(Dh,"두 개 이상의 쓰레드가 서로의 작업이 끝나기를 기다리는 상황"),Dh.forEach(l),qh.forEach(l),Ic=u(lt),ml=i(lt,"LI",{});var Ro=a(ml);ui=i(Ro,"P",{});var wh=a(ui);bc=s(wh,"Deadlock이 발생하려면 Coffman 조건이 충족되어야 함."),wh.forEach(l),kc=u(Ro),C=i(Ro,"UL",{});var Ye=a(C);hi=i(Ye,"LI",{});var Wh=a(hi);$c=s(Wh,"Mutual Exclusion: 한 쓰레드가 Critical Section에 들어가면, 다른 쓰레드는 해당 Critical Section에 들어갈 수 없음."),Wh.forEach(l),Cc=u(Ye),di=i(Ye,"LI",{});var Xh=a(di);Ac=s(Xh,"Hold and Wait: 쓰레드는 어떤 자원을 점유한 상태에서, 다른 쓰레드가 점유한 자원을 기다림."),Xh.forEach(l),xc=u(Ye),vi=i(Ye,"LI",{});var Kh=a(vi);Uc=s(Kh,"No Preemption: 쓰레드는 점유한 자원을 다른 쓰레드가 강제로 빼앗을 수 없음."),Kh.forEach(l),yc=u(Ye),Ei=i(Ye,"LI",{});var Qh=a(Ei);Rc=s(Qh,"Circular Wait: 쓰레드 간에 자원을 순환적으로 기다림."),Qh.forEach(l),Ye.forEach(l),Ro.forEach(l),Mc=u(lt),_i=i(lt,"LI",{});var jh=a(_i);pi=i(jh,"P",{});var Jh=a(pi);Nc=s(Jh,"Deadlock을 예방하기 위해 shared resoruce에 대한 일관된 lock 순서를 정의할 수 있으나, 모든 Deadlock을 예방할 수는 없음."),Jh.forEach(l),jh.forEach(l),lt.forEach(l),za=u(t),Ol=i(t,"BLOCKQUOTE",{});var zh=a(Ol);mi=i(zh,"P",{});var Zh=a(mi);Bc=s(Zh,`정보) Go에서는 모든 Goroutine이 Block된 상태이면 Deadlock이 발생했다고 판단하고, panic을 발생시킴.
그래서 모든 Goroutine이 아닌 일부 Goroutine에서만 Deadlock이 발생했다면 이를 감지하지 못함.`),Zh.forEach(l),zh.forEach(l),Za=u(t),qe=i(t,"H3",{id:!0});var Cu=a(qe);De=i(Cu,"A",{"aria-hidden":!0,tabindex:!0,href:!0});var Fh=a(De);Li=i(Fh,"SPAN",{class:!0}),a(Li).forEach(l),Fh.forEach(l),Hc=s(Cu,"Starvation"),Cu.forEach(l),Fa=u(t),we=i(t,"UL",{});var Mo=a(we);Si=i(Mo,"LI",{});var Vh=a(Si);Gc=s(Vh,"일부 쓰레드가 Critical Section에 들어가기 위해 계속해서 기다리지만, 다른 쓰레드가 먼저 Critical Section에 들어감으로 인해 Critical Section에 지속적으로 접근하지 못하는 상황"),Vh.forEach(l),Oc=u(Mo),Pi=i(Mo,"LI",{});var Yh=a(Pi);Tc=s(Yh,"DoS(Denial of Service) 공격의 기본 원리임."),Yh.forEach(l),Mo.forEach(l),Va=u(t),Tl=i(t,"BLOCKQUOTE",{});var gh=a(Tl);Ii=i(gh,"P",{});var ed=a(Ii);qc=s(ed,"정보) Go 런타임은 특정 Goroutine이 Starvation 상태에 빠지는 것을 감지하지는 못한다."),ed.forEach(l),gh.forEach(l),Ya=u(t),We=i(t,"H3",{id:!0});var Au=a(We);Xe=i(Au,"A",{"aria-hidden":!0,tabindex:!0,href:!0});var ld=a(Xe);bi=i(ld,"SPAN",{class:!0}),a(bi).forEach(l),ld.forEach(l),Dc=s(Au,"Livelock"),Au.forEach(l),ga=u(t),P=i(t,"UL",{});var ge=a(P);ki=i(ge,"LI",{});var td=a(ki);wc=s(td,"Deadlock처럼 보이지만, 쓰레드가 lock을 획득하려고 시도하는 연산을 계속 반복하기 때문에 실제로는 차단된 쓰레드가 없는 상황"),td.forEach(l),Wc=u(ge),$i=i(ge,"LI",{});var rd=a($i);Xc=s(rd,"쓰레드가 작동하더라도 실제로는 유의미한 작업을 수행하지 못하기 때문에, Starvation과 유사함."),rd.forEach(l),Kc=u(ge),Ci=i(ge,"LI",{});var id=a(Ci);Qc=s(id,"Livelock은 몇번 반복하다 보면 해결될 수 있기 때문에 확인하기 어려움."),id.forEach(l),jc=u(ge),Ai=i(ge,"LI",{});var ad=a(Ai);Jc=s(ad,"lock을 획득하기 위해 재시도 및 무작위적인 대기 시간을 추가하는 방법으로 해결할 수 있음."),ad.forEach(l),ge.forEach(l),eo=u(t),lo=i(t,"BR",{}),to=i(t,"BR",{}),ro=u(t),Ke=i(t,"H2",{id:!0});var xu=a(Ke);Qe=i(xu,"A",{"aria-hidden":!0,tabindex:!0,href:!0});var od=a(Qe);xi=i(od,"SPAN",{class:!0}),a(xi).forEach(l),od.forEach(l),zc=s(xu,"References"),xu.forEach(l),io=u(t),ao=i(t,"HR",{}),oo=u(t),ql=i(t,"CENTER",{});var sd=a(ql);W=i(sd,"P",{});var tt=a(W);Ll=i(tt,"A",{href:!0,rel:!0});var fd=a(Ll);Dl=i(fd,"IMG",{src:!0,alt:!0}),fd.forEach(l),Zc=u(tt),Fc=i(tt,"BR",{}),Vc=u(tt),Sl=i(tt,"A",{href:!0,rel:!0});var nd=a(Sl);Yc=s(nd,"Jon Bodner, 『Learning Go』, O’Reilly Media, Inc."),nd.forEach(l),tt.forEach(l),sd.forEach(l),this.h()},h(){h(it,"class","icon icon-link"),h(Q,"aria-hidden","true"),h(Q,"tabindex","-1"),h(Q,"href","#동시성concurrency-vs-병렬성parallelism"),h(K,"id","동시성concurrency-vs-병렬성parallelism"),h(at,"class","icon icon-link"),h(J,"aria-hidden","true"),h(J,"tabindex","-1"),h(J,"href","#동시성concurrency"),h(j,"id","동시성concurrency"),h(ut,"class","icon icon-link"),h(F,"aria-hidden","true"),h(F,"tabindex","-1"),h(F,"href","#병렬성parallelism"),h(Z,"id","병렬성parallelism"),h(vt,"class","icon icon-link"),h(Y,"aria-hidden","true"),h(Y,"tabindex","-1"),h(Y,"href","#동시성과-병렬성의-차이"),h(V,"id","동시성과-병렬성의-차이"),h(Et,"class","icon icon-link"),h(te,"aria-hidden","true"),h(te,"tabindex","-1"),h(te,"href","#동시성-프로그래밍"),h(le,"id","동시성-프로그래밍"),h(Lt,"class","icon icon-link"),h(ie,"aria-hidden","true"),h(ie,"tabindex","-1"),h(ie,"href","#time-sharing과-context-switching"),h(re,"id","time-sharing과-context-switching"),h(Ot,"class","icon icon-link"),h(ce,"aria-hidden","true"),h(ce,"tabindex","-1"),h(ce,"href","#동시성-프로그래밍은-왜-어려운가"),h(ne,"id","동시성-프로그래밍은-왜-어려운가"),h(Xt,"class","icon icon-link"),h(he,"aria-hidden","true"),h(he,"tabindex","-1"),h(he,"href","#happened-before-관계"),h(ue,"id","happened-before-관계"),h(Jt,"class","icon icon-link"),h(_e,"aria-hidden","true"),h(_e,"tabindex","-1"),h(_e,"href","#dining-philosopher-problem"),h(Ee,"id","dining-philosopher-problem"),h(rr,"class","icon icon-link"),h(Le,"aria-hidden","true"),h(Le,"tabindex","-1"),h(Le,"href","#shared-memory와-message-passing"),h(me,"id","shared-memory와-message-passing"),h(ir,"class","icon icon-link"),h(Pe,"aria-hidden","true"),h(Pe,"tabindex","-1"),h(Pe,"href","#관련-computer-architecture-지식"),h(Se,"id","관련-computer-architecture-지식"),h(mr,"class","icon icon-link"),h(be,"aria-hidden","true"),h(be,"tabindex","-1"),h(be,"href","#shared-memory"),h(Ie,"id","shared-memory"),h($r,"class","icon icon-link"),h($e,"aria-hidden","true"),h($e,"tabindex","-1"),h($e,"href","#message-passing"),h(ke,"id","message-passing"),h(Rr,"class","icon icon-link"),h(xe,"aria-hidden","true"),h(xe,"tabindex","-1"),h(xe,"href","#hybrid-approach"),h(Ae,"id","hybrid-approach"),h(Wr,"class","icon icon-link"),h(ye,"aria-hidden","true"),h(ye,"tabindex","-1"),h(ye,"href","#atomicity-race-deadlock-starvation"),h(Ue,"id","atomicity-race-deadlock-starvation"),h(Xr,"class","icon icon-link"),h(Me,"aria-hidden","true"),h(Me,"tabindex","-1"),h(Me,"href","#race-condition"),h(Re,"id","race-condition"),h(ti,"class","icon icon-link"),h(Be,"aria-hidden","true"),h(Be,"tabindex","-1"),h(Be,"href","#atomicity"),h(Ne,"id","atomicity"),h(fi,"class","icon icon-link"),h(Te,"aria-hidden","true"),h(Te,"tabindex","-1"),h(Te,"href","#deadlock"),h(Oe,"id","deadlock"),h(Li,"class","icon icon-link"),h(De,"aria-hidden","true"),h(De,"tabindex","-1"),h(De,"href","#starvation"),h(qe,"id","starvation"),h(bi,"class","icon icon-link"),h(Xe,"aria-hidden","true"),h(Xe,"tabindex","-1"),h(Xe,"href","#livelock"),h(We,"id","livelock"),h(xi,"class","icon icon-link"),h(Qe,"aria-hidden","true"),h(Qe,"tabindex","-1"),h(Qe,"href","#references"),h(Ke,"id","references"),dd(Dl.src,Uu="https://learning.oreilly.com/covers/urn:orm:book:9781804619070/400w/")||h(Dl,"src",Uu),h(Dl,"alt","Effective Concurrency in Go"),h(Ll,"href","https://learning.oreilly.com/library/view/effective-concurrency-in/9781804619070/"),h(Ll,"rel","nofollow"),h(Sl,"href","https://learning.oreilly.com/library/view/effective-concurrency-in/9781804619070/"),h(Sl,"rel","nofollow")},m(t,f){n(t,v,f),e(v,d),e(d,_),e(v,No),n(t,Ki,f),n(t,Pl,f),e(Pl,rt),e(rt,Bo),n(t,Qi,f),n(t,ji,f),n(t,Ji,f),n(t,zi,f),n(t,K,f),e(K,Q),e(Q,it),e(K,Ho),n(t,Zi,f),n(t,Fi,f),n(t,Vi,f),n(t,j,f),e(j,J),e(J,at),e(j,Go),n(t,Yi,f),n(t,z,f),e(z,ot),e(ot,p),e(p,Oo),e(p,st),e(st,To),e(p,qo),e(p,Do),e(p,ft),e(ft,wo),e(p,Wo),e(p,Xo),e(p,Ko),e(z,Qo),e(z,nt),e(nt,B),e(B,jo),e(B,ct),e(ct,Jo),e(B,zo),e(B,Zo),e(B,Fo),n(t,gi,f),n(t,Z,f),e(Z,F),e(F,ut),e(Z,Vo),n(t,ea,f),n(t,Il,f),e(Il,b),e(b,Yo),e(b,ht),e(ht,go),e(b,es),e(b,ls),e(b,dt),e(dt,ts),e(b,rs),e(b,is),n(t,la,f),n(t,V,f),e(V,Y),e(Y,vt),e(V,as),n(t,ta,f),n(t,A,f),e(A,os),qi(g,A,null),e(A,ss),qi(ee,A,null),e(A,fs),n(t,ra,f),n(t,ia,f),n(t,aa,f),n(t,oa,f),n(t,le,f),e(le,te),e(te,Et),e(le,ns),n(t,sa,f),n(t,fa,f),n(t,na,f),n(t,x,f),e(x,_t),e(_t,cs),e(x,us),e(x,pt),e(pt,hs),e(x,ds),e(x,mt),e(mt,vs),n(t,ca,f),n(t,re,f),e(re,ie),e(ie,Lt),e(re,Es),n(t,ua,f),n(t,m,f),e(m,St),e(St,_s),e(m,ps),e(m,bl),e(bl,ms),e(bl,H),e(H,el),e(el,Ls),qi(ae,el,null),e(el,Ss),e(H,Ps),e(H,Pt),e(Pt,Is),e(H,bs),e(H,It),e(It,ks),e(m,$s),e(m,kl),e(kl,bt),e(bt,Cs),e(kl,As),e(m,xs),e(m,oe),e(oe,kt),e(kt,Us),e(oe,ys),e(oe,$t),e($t,Rs),e(oe,Ms),n(t,ha,f),n(t,$l,f),e($l,Ct),e(Ct,Ns),n(t,da,f),n(t,Cl,f),e(Cl,Al),e(Al,Bs),e(Al,k),e(k,G),e(G,Hs),e(G,At),e(At,Gs),e(G,Os),e(G,xt),e(xt,Ts),e(G,qs),e(k,Ds),e(k,se),e(se,Ut),e(Ut,ws),e(se,Ws),e(se,yt),e(yt,Xs),e(se,Ks),e(k,Qs),e(k,fe),e(fe,Rt),e(Rt,js),e(fe,Js),e(fe,Mt),e(Mt,zs),e(fe,Zs),e(k,Fs),e(k,O),e(O,Nt),e(Nt,Vs),e(O,Ys),e(O,Bt),e(Bt,gs),e(O,ef),e(O,Ht),e(Ht,ll),e(ll,lf),e(ll,Gt),e(Gt,tf),e(ll,rf),n(t,va,f),n(t,ne,f),e(ne,ce),e(ce,Ot),e(ne,af),n(t,Ea,f),n(t,xl,f),e(xl,of),n(t,_a,f),n(t,U,f),e(U,Ul),e(Ul,sf),e(Ul,tl),e(tl,Tt),e(Tt,ff),e(tl,nf),e(tl,qt),e(qt,cf),e(U,uf),e(U,Dt),e(Dt,hf),e(U,df),e(U,yl),e(yl,vf),e(yl,wt),e(wt,Wt),e(Wt,Ef),n(t,pa,f),n(t,Rl,f),e(Rl,_f),n(t,ma,f),n(t,ue,f),e(ue,he),e(he,Xt),e(ue,pf),n(t,La,f),n(t,y,f),e(y,Kt),e(Kt,mf),e(y,Lf),e(y,Ml),e(Ml,Sf),e(Ml,Qt),e(Qt,rl),e(rl,Pf),qi(de,rl,null),e(rl,If),e(y,bf),e(y,Nl),e(Nl,kf),e(Nl,jt),e(jt,il),e(il,$f),qi(ve,il,null),e(il,Cf),n(t,Sa,f),n(t,Ee,f),e(Ee,_e),e(_e,Jt),e(Ee,Af),n(t,Pa,f),n(t,pe,f),e(pe,al),e(al,zt),e(zt,xf),e(al,Uf),e(al,$),e($,Zt),e(Zt,yf),e($,Rf),e($,Ft),e(Ft,Mf),e($,Nf),e($,Vt),e(Vt,Bf),e($,Hf),e($,Yt),e(Yt,Gf),e(pe,Of),e(pe,ol),e(ol,gt),e(gt,Tf),e(ol,qf),e(ol,T),e(T,er),e(er,Df),e(T,wf),e(T,lr),e(lr,Wf),e(T,Xf),e(T,tr),e(tr,Kf),n(t,Ia,f),n(t,ba,f),n(t,ka,f),n(t,$a,f),n(t,me,f),e(me,Le),e(Le,rr),e(me,Qf),n(t,Ca,f),n(t,Aa,f),n(t,xa,f),n(t,Se,f),e(Se,Pe),e(Pe,ir),e(Se,jf),n(t,Ua,f),n(t,L,f),e(L,sl),e(sl,ar),e(ar,Jf),e(sl,zf),e(sl,fl),e(fl,or),e(or,Zf),e(fl,Ff),e(fl,sr),e(sr,Vf),e(L,Yf),e(L,nl),e(nl,fr),e(fr,gf),e(nl,en),e(nl,cl),e(cl,nr),e(nr,ln),e(cl,tn),e(cl,cr),e(cr,rn),e(L,an),e(L,ur),e(ur,hr),e(hr,on),e(L,sn),e(L,ul),e(ul,dr),e(dr,fn),e(ul,nn),e(ul,hl),e(hl,vr),e(vr,cn),e(hl,un),e(hl,Bl),e(Bl,hn),e(Bl,q),e(q,Er),e(Er,dn),e(q,vn),e(q,_r),e(_r,En),e(q,_n),e(q,pr),e(pr,pn),n(t,ya,f),n(t,Ie,f),e(Ie,be),e(be,mr),e(Ie,mn),n(t,Ra,f),n(t,R,f),e(R,Lr),e(Lr,Sr),e(Sr,Ln),e(R,Sn),e(R,Pr),e(Pr,Ir),e(Ir,Pn),e(R,In),e(R,br),e(br,kr),e(kr,bn),n(t,Ma,f),n(t,ke,f),e(ke,$e),e($e,$r),e(ke,kn),n(t,Na,f),n(t,Ce,f),e(Ce,dl),e(dl,Cr),e(Cr,$n),e(dl,Cn),e(dl,Ar),e(Ar,xr),e(xr,An),e(Ce,xn),e(Ce,Ur),e(Ur,yr),e(yr,Un),n(t,Ba,f),n(t,Ae,f),e(Ae,xe),e(xe,Rr),e(Ae,yn),n(t,Ha,f),n(t,S,f),e(S,Mr),e(Mr,Nr),e(Nr,Rn),e(S,Mn),e(S,Br),e(Br,Hr),e(Hr,Nn),e(S,Bn),e(S,Gr),e(Gr,Or),e(Or,Hn),e(S,Gn),e(S,vl),e(vl,Tr),e(Tr,On),e(vl,Tn),e(vl,D),e(D,qr),e(qr,qn),e(D,Dn),e(D,Dr),e(Dr,wn),e(D,Wn),e(D,wr),e(wr,Xn),n(t,Ga,f),n(t,Oa,f),n(t,Ta,f),n(t,qa,f),n(t,Ue,f),e(Ue,ye),e(ye,Wr),e(Ue,Kn),n(t,Da,f),n(t,wa,f),n(t,Wa,f),n(t,Re,f),e(Re,Me),e(Me,Xr),e(Re,Qn),n(t,Xa,f),n(t,E,f),e(E,Kr),e(Kr,Qr),e(Qr,jn),e(E,Jn),e(E,jr),e(jr,Jr),e(Jr,zn),e(E,Zn),e(E,zr),e(zr,Zr),e(Zr,Fn),e(E,Vn),e(E,Fr),e(Fr,Vr),e(Vr,Yn),e(E,gn),e(E,El),e(El,Hl),e(Hl,Yr),e(Yr,ec),e(Hl,lc),e(El,tc),e(El,w),e(w,gr),e(gr,rc),e(w,ic),e(w,ei),e(ei,ac),e(w,oc),e(w,li),e(li,sc),n(t,Ka,f),n(t,Ne,f),e(Ne,Be),e(Be,ti),e(Ne,fc),n(t,Qa,f),n(t,He,f),e(He,ri),e(ri,nc),e(He,cc),e(He,Ge),e(Ge,uc),e(Ge,ii),e(ii,hc),e(Ge,dc),e(Ge,_l),e(_l,pl),e(pl,vc),e(pl,ai),e(ai,Ec),e(pl,_c),e(_l,pc),e(_l,Gl),e(Gl,mc),e(Gl,oi),e(oi,si),e(si,Lc),n(t,ja,f),n(t,Oe,f),e(Oe,Te),e(Te,fi),e(Oe,Sc),n(t,Ja,f),n(t,M,f),e(M,ni),e(ni,ci),e(ci,Pc),e(M,Ic),e(M,ml),e(ml,ui),e(ui,bc),e(ml,kc),e(ml,C),e(C,hi),e(hi,$c),e(C,Cc),e(C,di),e(di,Ac),e(C,xc),e(C,vi),e(vi,Uc),e(C,yc),e(C,Ei),e(Ei,Rc),e(M,Mc),e(M,_i),e(_i,pi),e(pi,Nc),n(t,za,f),n(t,Ol,f),e(Ol,mi),e(mi,Bc),n(t,Za,f),n(t,qe,f),e(qe,De),e(De,Li),e(qe,Hc),n(t,Fa,f),n(t,we,f),e(we,Si),e(Si,Gc),e(we,Oc),e(we,Pi),e(Pi,Tc),n(t,Va,f),n(t,Tl,f),e(Tl,Ii),e(Ii,qc),n(t,Ya,f),n(t,We,f),e(We,Xe),e(Xe,bi),e(We,Dc),n(t,ga,f),n(t,P,f),e(P,ki),e(ki,wc),e(P,Wc),e(P,$i),e($i,Xc),e(P,Kc),e(P,Ci),e(Ci,Qc),e(P,jc),e(P,Ai),e(Ai,Jc),n(t,eo,f),n(t,lo,f),n(t,to,f),n(t,ro,f),n(t,Ke,f),e(Ke,Qe),e(Qe,xi),e(Ke,zc),n(t,io,f),n(t,ao,f),n(t,oo,f),n(t,ql,f),e(ql,W),e(W,Ll),e(Ll,Dl),e(W,Zc),e(W,Fc),e(W,Vc),e(W,Sl),e(Sl,Yc),so=!0},p(t,[f]){const Ui={};f&1&&(Ui.$$scope={dirty:f,ctx:t}),g.$set(Ui);const yi={};f&1&&(yi.$$scope={dirty:f,ctx:t}),ee.$set(yi);const Ri={};f&1&&(Ri.$$scope={dirty:f,ctx:t}),ae.$set(Ri);const wl={};f&1&&(wl.$$scope={dirty:f,ctx:t}),de.$set(wl);const Mi={};f&1&&(Mi.$$scope={dirty:f,ctx:t}),ve.$set(Mi)},i(t){so||(Di(g.$$.fragment,t),Di(ee.$$.fragment,t),Di(ae.$$.fragment,t),Di(de.$$.fragment,t),Di(ve.$$.fragment,t),so=!0)},o(t){wi(g.$$.fragment,t),wi(ee.$$.fragment,t),wi(ae.$$.fragment,t),wi(de.$$.fragment,t),wi(ve.$$.fragment,t),so=!1},d(t){t&&l(v),t&&l(Ki),t&&l(Pl),t&&l(Qi),t&&l(ji),t&&l(Ji),t&&l(zi),t&&l(K),t&&l(Zi),t&&l(Fi),t&&l(Vi),t&&l(j),t&&l(Yi),t&&l(z),t&&l(gi),t&&l(Z),t&&l(ea),t&&l(Il),t&&l(la),t&&l(V),t&&l(ta),t&&l(A),Wi(g),Wi(ee),t&&l(ra),t&&l(ia),t&&l(aa),t&&l(oa),t&&l(le),t&&l(sa),t&&l(fa),t&&l(na),t&&l(x),t&&l(ca),t&&l(re),t&&l(ua),t&&l(m),Wi(ae),t&&l(ha),t&&l($l),t&&l(da),t&&l(Cl),t&&l(va),t&&l(ne),t&&l(Ea),t&&l(xl),t&&l(_a),t&&l(U),t&&l(pa),t&&l(Rl),t&&l(ma),t&&l(ue),t&&l(La),t&&l(y),Wi(de),Wi(ve),t&&l(Sa),t&&l(Ee),t&&l(Pa),t&&l(pe),t&&l(Ia),t&&l(ba),t&&l(ka),t&&l($a),t&&l(me),t&&l(Ca),t&&l(Aa),t&&l(xa),t&&l(Se),t&&l(Ua),t&&l(L),t&&l(ya),t&&l(Ie),t&&l(Ra),t&&l(R),t&&l(Ma),t&&l(ke),t&&l(Na),t&&l(Ce),t&&l(Ba),t&&l(Ae),t&&l(Ha),t&&l(S),t&&l(Ga),t&&l(Oa),t&&l(Ta),t&&l(qa),t&&l(Ue),t&&l(Da),t&&l(wa),t&&l(Wa),t&&l(Re),t&&l(Xa),t&&l(E),t&&l(Ka),t&&l(Ne),t&&l(Qa),t&&l(He),t&&l(ja),t&&l(Oe),t&&l(Ja),t&&l(M),t&&l(za),t&&l(Ol),t&&l(Za),t&&l(qe),t&&l(Fa),t&&l(we),t&&l(Va),t&&l(Tl),t&&l(Ya),t&&l(We),t&&l(ga),t&&l(P),t&&l(eo),t&&l(lo),t&&l(to),t&&l(ro),t&&l(Ke),t&&l(io),t&&l(ao),t&&l(oo),t&&l(ql)}}}const Id={title:"동시성 관련 개념 정리",date:"2023-08-18T00:00:00.000Z",excerpt:"Concepts about concurrency",categories:["Computer Science","OS","Golang"],coverImage:"/post_img/Computer Science/OS/Concurrency/cover.png",coverWidth:16,coverHeight:9,indexed:!0,exposed:!0};class bd extends cd{constructor(v){super(),ud(this,v,null,Ld,hd,{})}}export{bd as default,Id as metadata};
