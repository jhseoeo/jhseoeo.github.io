import{S as Xo,i as Yo,s as qo,k as e,a as i,q as l,y as Vo,l as o,c as r,m as u,r as c,h as s,z as Wo,n as k,b as p,E as a,A as Ko,M as Qo,g as ho,d as go,B as nl}from"./index.d78780bf.js";import{I as sl}from"./Image.605b14b5.js";function al(Eo){let rn,bs,kn,et,vs,Es,_s,ys,B,G,Rn,ot,ds,Ps,ws,fn,lt,Rs,mn,ct,Ms,q,_o=`<code class="language-go"><span class="token keyword">var</span> x <span class="token builtin">int32</span> <span class="token operator">=</span> <span class="token number">10</span>
<span class="token keyword">var</span> y <span class="token builtin">bool</span> <span class="token operator">=</span> <span class="token boolean">true</span>

pointerX <span class="token operator">:=</span> <span class="token operator">&amp;</span>x
pointerY <span class="token operator">:=</span> <span class="token operator">&amp;</span>y
<span class="token keyword">var</span> pointerZ <span class="token operator">*</span><span class="token builtin">string</span>

fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>pointerX<span class="token punctuation">,</span> pointerY<span class="token punctuation">,</span> pointerZ<span class="token punctuation">)</span> <span class="token comment">// addresses of variables</span>
fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>pointerZ <span class="token operator">==</span> <span class="token boolean">nil</span><span class="token punctuation">)</span>              <span class="token comment">// referencing *pointerZ occurs an runtime error(panics), because pointerZ is nil</span>
fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token operator">*</span>pointerX<span class="token punctuation">,</span> <span class="token operator">*</span>pointerY<span class="token punctuation">)</span>         <span class="token comment">// * is indirection operator.</span>
<span class="token operator">*</span>pointerX<span class="token punctuation">,</span> <span class="token operator">*</span>pointerY <span class="token operator">=</span> <span class="token number">8</span><span class="token punctuation">,</span> <span class="token boolean">false</span>
fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span> y<span class="token punctuation">)</span> <span class="token comment">// by changing pointer's values, we can change origin value</span></code>`,xs,E,Mn,ut,it,xn,rt,kt,Cn,ft,mt,Bn,bt,vt,Cs,bn,Et,Bs,V,yo=`<code class="language-go"><span class="token number">0xc0000b8000</span> <span class="token number">0xc0000b8004</span> <span class="token operator">&lt;</span><span class="token boolean">nil</span><span class="token operator">></span>
<span class="token boolean">true</span>
<span class="token number">10</span> <span class="token boolean">true</span>
<span class="token number">8</span> <span class="token boolean">false</span></code>`,Gs,m,_t,Gn,yt,dt,On,Pt,wt,Hn,Rt,Mt,xt,Ct,Sn,Bt,Gt,Os,Hs,Ss,W,Nn,Ot,Ht,Ns,K,Po=`<code class="language-go"><span class="token keyword">var</span> a <span class="token operator">=</span> <span class="token function">new</span><span class="token punctuation">(</span><span class="token builtin">int</span><span class="token punctuation">)</span>      <span class="token comment">// built-in function &#96;new&#96; creates a pointer variable</span>
fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>a <span class="token operator">==</span> <span class="token boolean">nil</span><span class="token punctuation">)</span> <span class="token comment">// false</span>
fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token operator">*</span>a<span class="token punctuation">)</span>       <span class="token comment">// it points zero value of given type</span>
<span class="token operator">*</span>a <span class="token operator">=</span> <span class="token number">2</span>
fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token operator">*</span>a<span class="token punctuation">)</span></code>`,Ds,O,St,Dn,Nt,Dt,Ls,Ts,As,Q,Ln,Lt,Tt,Fs,vn,At,Zs,h,wo=`<code class="language-go">	x <span class="token operator">:=</span> <span class="token operator">&amp;</span>Foo<span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span>
	<span class="token comment">// z := &amp;"string" // this statement occurs an error</span>
	<span class="token keyword">var</span> y <span class="token builtin">string</span>
	z <span class="token operator">:=</span> <span class="token operator">&amp;</span>y <span class="token comment">// to point to a primitive type, declare a variable first</span>

	fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span> z<span class="token punctuation">)</span></code>`,Us,H,Ft,Tn,Zt,Ut,Js,g,Ro=`<code class="language-go"><span class="token keyword">type</span> person <span class="token keyword">struct</span> <span class="token punctuation">&#123;</span>
	FirstName  <span class="token builtin">string</span>
	MiddleName <span class="token operator">*</span><span class="token builtin">string</span>
	LastName   <span class="token builtin">string</span>
<span class="token punctuation">&#125;</span>

<span class="token keyword">func</span> <span class="token function">stringp</span><span class="token punctuation">(</span>s <span class="token builtin">string</span><span class="token punctuation">)</span> <span class="token operator">*</span><span class="token builtin">string</span> <span class="token punctuation">&#123;</span>
	<span class="token comment">// helper function that returns address of parameter variable</span>
	<span class="token keyword">return</span> <span class="token operator">&amp;</span>s
<span class="token punctuation">&#125;</span>

<span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
	p <span class="token operator">:=</span> person<span class="token punctuation">&#123;</span>
		FirstName<span class="token punctuation">:</span> <span class="token string">"Pat"</span><span class="token punctuation">,</span>
		<span class="token comment">// MiddleName: "Perry",  // or</span>
		<span class="token comment">// MiddleName: &amp;"Perry", // this lines won't compile</span>
		MiddleName<span class="token punctuation">:</span> <span class="token function">stringp</span><span class="token punctuation">(</span><span class="token string">"Perry"</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token comment">// helper function turned a constant value into a pointer</span>
		LastName<span class="token punctuation">:</span>   <span class="token string">"Peterson"</span><span class="token punctuation">,</span>
	<span class="token punctuation">&#125;</span>

	fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span>
<span class="token punctuation">&#125;</span></code>`,$s,zs,Is,js,S,N,An,Jt,Xs,Ys,qs,Vs,Ws,D,L,Fn,$t,Ks,T,zt,Zn,It,jt,Qs,nn,Mo=`<code class="language-go"><span class="token keyword">type</span> person <span class="token keyword">struct</span> <span class="token punctuation">&#123;</span>
	name <span class="token builtin">string</span>
	age  <span class="token builtin">int</span>
<span class="token punctuation">&#125;</span>

<span class="token keyword">func</span> <span class="token function">modifyFails</span><span class="token punctuation">(</span>i <span class="token builtin">int</span><span class="token punctuation">,</span> s <span class="token builtin">string</span><span class="token punctuation">,</span> p person<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token comment">// all the parameters are passed by value(copied), not referenced or aliased</span>
	i <span class="token operator">*=</span> <span class="token number">2</span>
	s <span class="token operator">=</span> <span class="token string">"goodbye"</span>
	p<span class="token punctuation">.</span>name <span class="token operator">=</span> <span class="token string">"Bob"</span> <span class="token comment">// even for the struct, cannot change the origin value by modifying parameters.</span>
<span class="token punctuation">&#125;</span>

<span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
	p<span class="token punctuation">,</span> i<span class="token punctuation">,</span> s <span class="token operator">:=</span> person<span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token string">"hello"</span>
	<span class="token function">modifyFails</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span> s<span class="token punctuation">,</span> p<span class="token punctuation">)</span> <span class="token comment">// this invocation of function can't make any change on variables above</span>
	fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span> s<span class="token punctuation">,</span> p<span class="token punctuation">)</span>
<span class="token punctuation">&#125;</span></code>`,hs,gs,na,_,Xt,Un,Yt,qt,Jn,Vt,Wt,$n,Kt,Qt,sa,sn,xo=`<code class="language-go"><span class="token comment">// slices and maps are passed passed by pointers</span>
<span class="token keyword">func</span> <span class="token function">modifyMap</span><span class="token punctuation">(</span>m <span class="token keyword">map</span><span class="token punctuation">[</span><span class="token builtin">int</span><span class="token punctuation">]</span><span class="token builtin">string</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
	<span class="token comment">// changing map parameters are reflected in the variables passed into the function</span>
	m<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">"hello"</span>
	m<span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">"goodbye"</span>
<span class="token punctuation">&#125;</span>

<span class="token keyword">func</span> <span class="token function">modifySlice</span><span class="token punctuation">(</span>s <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
	<span class="token comment">// we can modify any element in the slice, but can't lengthen the slice</span>
	<span class="token keyword">for</span> k<span class="token punctuation">,</span> v <span class="token operator">:=</span> <span class="token keyword">range</span> s <span class="token punctuation">&#123;</span>
		s<span class="token punctuation">[</span>k<span class="token punctuation">]</span> <span class="token operator">=</span> v <span class="token operator">*</span> <span class="token number">2</span>
	<span class="token punctuation">&#125;</span>
	s <span class="token operator">=</span> <span class="token function">append</span><span class="token punctuation">(</span>s<span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">)</span> <span class="token comment">// this line actually did not append a value to origin variable</span>
<span class="token punctuation">&#125;</span>

<span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    i <span class="token operator">:=</span> <span class="token number">20</span>
    <span class="token function">modify</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span>
    fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span>
<span class="token punctuation">&#125;</span></code>`,aa,ta,pa,w,ht,zn,gt,np,In,sp,ap,ea,an,Co=`<code class="language-go">
<span class="token keyword">func</span> <span class="token function">update</span><span class="token punctuation">(</span>g <span class="token operator">*</span><span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
	<span class="token operator">*</span>g <span class="token operator">=</span> <span class="token number">10</span> <span class="token comment">// dereferencing => success to change original value</span>
<span class="token punctuation">&#125;</span>

<span class="token keyword">func</span> <span class="token function">failedUpdate</span><span class="token punctuation">(</span>g <span class="token operator">*</span><span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
	x <span class="token operator">:=</span> <span class="token number">20</span>
	g <span class="token operator">=</span> <span class="token operator">&amp;</span>x <span class="token comment">// where the pointer is pointing at is changed</span>
<span class="token punctuation">&#125;</span>

<span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
	<span class="token keyword">var</span> x <span class="token operator">*</span><span class="token builtin">int</span>
	<span class="token keyword">var</span> y <span class="token builtin">int</span>

	<span class="token comment">// update(x) // this invocation occurs an error. cannot dereference nil</span>
	<span class="token function">update</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>y<span class="token punctuation">)</span>
	fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>y<span class="token punctuation">)</span>

	<span class="token function">failedUpdate</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span>
	<span class="token function">failedUpdate</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>y<span class="token punctuation">)</span> <span class="token comment">// those two invocations cannot changed x and y's values</span>

	fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span> y<span class="token punctuation">)</span>
<span class="token punctuation">&#125;</span></code>`,oa,la,ca,R,tp,jn,pp,ep,Xn,op,lp,ua,tn,Bo=`<code class="language-go"><span class="token keyword">func</span> <span class="token function">modifySlice</span><span class="token punctuation">(</span>s <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
	<span class="token comment">// we can modify any element in the slice, but can't lengthen the slice</span>
	<span class="token keyword">for</span> k<span class="token punctuation">,</span> v <span class="token operator">:=</span> <span class="token keyword">range</span> s <span class="token punctuation">&#123;</span>
		s<span class="token punctuation">[</span>k<span class="token punctuation">]</span> <span class="token operator">=</span> v <span class="token operator">*</span> <span class="token number">2</span>
	<span class="token punctuation">&#125;</span>
	s <span class="token operator">=</span> <span class="token function">append</span><span class="token punctuation">(</span>s<span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">)</span> <span class="token comment">// this line actually did not append a value to origin variable</span>
<span class="token punctuation">&#125;</span></code>`,ia,M,cp,Yn,up,ip,qn,rp,kp,ra,ka,fa,ma,A,F,Vn,fp,ba,Z,mp,Wn,bp,vp,va,pn,Go=`<code class="language-go"><span class="token keyword">type</span> Foo <span class="token keyword">struct</span> <span class="token punctuation">&#123;</span>
	foo <span class="token builtin">int</span>
	bar <span class="token builtin">string</span>
<span class="token punctuation">&#125;</span>

<span class="token keyword">func</span> <span class="token function">MakeFoo1</span><span class="token punctuation">(</span>f <span class="token operator">*</span>Foo<span class="token punctuation">)</span> <span class="token builtin">error</span> <span class="token punctuation">&#123;</span>
	<span class="token comment">// not +recommended format</span>
	f<span class="token punctuation">.</span>foo <span class="token operator">=</span> <span class="token number">20</span>
	f<span class="token punctuation">.</span>bar <span class="token operator">=</span> <span class="token string">"val"</span>
	<span class="token keyword">return</span> <span class="token boolean">nil</span>
<span class="token punctuation">&#125;</span>

<span class="token comment">// rather than using pointer parameter to pass a value, just return this.</span>
<span class="token keyword">func</span> <span class="token function">MakeFoo2</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">(</span>Foo<span class="token punctuation">,</span> <span class="token builtin">error</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
	<span class="token comment">// recommended format</span>
	f <span class="token operator">:=</span> Foo<span class="token punctuation">&#123;</span>
		foo<span class="token punctuation">:</span> <span class="token number">20</span><span class="token punctuation">,</span>
		bar<span class="token punctuation">:</span> <span class="token string">"val"</span><span class="token punctuation">,</span>
	<span class="token punctuation">&#125;</span>
	<span class="token keyword">return</span> f<span class="token punctuation">,</span> <span class="token boolean">nil</span>
<span class="token punctuation">&#125;</span>

<span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
	a <span class="token operator">:=</span> Foo<span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span>
	<span class="token function">MakeFoo1</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>a<span class="token punctuation">)</span> <span class="token comment">// rather than using this pattern,</span>

	b<span class="token punctuation">,</span> <span class="token boolean">_</span> <span class="token operator">:=</span> <span class="token function">MakeFoo2</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">// use this pattern</span>

	fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> b<span class="token punctuation">)</span>
<span class="token punctuation">&#125;</span></code>`,Ea,U,Ep,Kn,_p,yp,_a,ya,da,J,dp,Qn,Pp,wp,Pa,en,Oo=`<code class="language-go">	f <span class="token operator">:=</span> <span class="token keyword">struct</span> <span class="token punctuation">&#123;</span>
		Name <span class="token builtin">string</span> <span class="token string">&#96;json:"name"&#96;</span>
		Age  <span class="token builtin">int</span>    <span class="token string">&#96;json:"age"&#96;</span>
	<span class="token punctuation">&#125;</span><span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span>
	err <span class="token operator">:=</span> json<span class="token punctuation">.</span><span class="token function">Unmarshal</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token function">byte</span><span class="token punctuation">(</span><span class="token string">&#96;&#123;"name": "Bob", "age": 30&#125;&#96;</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>f<span class="token punctuation">)</span>
	<span class="token keyword">if</span> err <span class="token operator">==</span> <span class="token boolean">nil</span> <span class="token punctuation">&#123;</span>
		fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>f<span class="token punctuation">)</span>
	<span class="token punctuation">&#125;</span></code>`,wa,Ra,Ma,En,Rp,xa,Ca,Ba,Ga,$,z,hn,Mp,Oa,Ha,Sa,_n,xp,Na,Da,La,on,Ho=`<code class="language-go">r <span class="token operator">:=</span> <span class="token function">open_resource</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
while r<span class="token punctuation">.</span><span class="token function">has_data</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
	data_chunk <span class="token operator">:=</span> r<span class="token punctuation">.</span><span class="token function">next_chunk</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
	<span class="token function">process</span><span class="token punctuation">(</span>data_chunk<span class="token punctuation">)</span>
<span class="token punctuation">&#125;</span>
r<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span></code>`,Ta,y,Cp,gn,Bp,Gp,ns,Op,Hp,ss,Sp,Np,Aa,v,Dp,as,Lp,Tp,ts,Ap,Fp,ps,Zp,Up,es,Jp,$p,Fa,ln,So=`<code class="language-go">file<span class="token punctuation">,</span> err <span class="token operator">:=</span> os<span class="token punctuation">.</span><span class="token function">Open</span><span class="token punctuation">(</span>fileName<span class="token punctuation">)</span>
<span class="token keyword">if</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">&#123;</span>
	<span class="token keyword">return</span> err
<span class="token punctuation">&#125;</span>
<span class="token keyword">defer</span> file<span class="token punctuation">.</span><span class="token function">Close</span><span class="token punctuation">(</span><span class="token punctuation">)</span>

<span class="token comment">// this pattern is good at reducing the garbage collector's workload</span>
data <span class="token operator">:=</span> <span class="token function">make</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">byte</span><span class="token punctuation">,</span> <span class="token number">100</span><span class="token punctuation">)</span> <span class="token comment">// using slice as a buffer</span>
<span class="token keyword">for</span> <span class="token punctuation">&#123;</span>
	count<span class="token punctuation">,</span> err <span class="token operator">:=</span> file<span class="token punctuation">.</span><span class="token function">Read</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span>
	<span class="token keyword">if</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">&#123;</span>
		<span class="token keyword">return</span> err
	<span class="token punctuation">&#125;</span>
	<span class="token keyword">if</span> count <span class="token operator">==</span> <span class="token number">0</span> <span class="token punctuation">&#123;</span>
		<span class="token keyword">return</span> <span class="token boolean">nil</span>
	<span class="token punctuation">&#125;</span>
	<span class="token function">process</span><span class="token punctuation">(</span>data<span class="token punctuation">[</span><span class="token punctuation">:</span>count<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token comment">// it passes next block of bytes in to the slice (up to 100)</span>
<span class="token punctuation">&#125;</span></code>`,Za,Ua,Ja,f,zp,os,Ip,jp,ls,Xp,Yp,cs,qp,Vp,us,Wp,Kp,is,Qp,hp,rs,gp,ne,ks,se,ae,$a,yn,te,za,Ia,ja,Xa,I,j,fs,pe,Ya,qa,Va,P,ms,ee,oe,cn,le,ce,ue,Wa,Ka,Qa,ha;return cn=new sl({props:{alt:"Learning Go Book Cover",src:"https://learning.oreilly.com/covers/urn:orm:book:9781492077206/400w/"}}),{c(){rn=e("br"),bs=i(),kn=e("p"),et=l("본 글은 Golang을 공부하며 주요 내용이라 생각되는 것들을 기록해둔 자료이며, Ubuntu 20.04 LTS 기준으로 작성되었습니다."),vs=i(),Es=e("br"),_s=e("br"),ys=i(),B=e("h2"),G=e("a"),Rn=e("span"),ot=l("Pointer"),ds=i(),Ps=e("hr"),ws=i(),fn=e("p"),lt=l(`놀랍게도 Go에는 포인터가 있다. C++ 공부하며 다신 보기 싫었던 친구인데 다시 보게 되니 감회가 새롭다.
다들 알다시피 포인터는 특정 변수가 저장된 메모리의 주소를 가리키는 변수를 의미한다. C/C++의 포인터와 크게 다르지 않다.`),Rs=i(),mn=e("p"),ct=l("포인터 변수는 가리키고자 하는 메모리 주소의 첫 번째 byte address를 저장한다."),Ms=i(),q=e("pre"),xs=i(),E=e("p"),Mn=e("code"),ut=l("&"),it=l("는 변수의 주소값을 반환하는 연산자이며, "),xn=e("code"),rt=l("*"),kt=l(`는 indirection 연산자로, 해당 포인터가 가리키는 주소에 저장된 값을 반환한다.
`),Cn=e("code"),ft=l("*"),mt=l("를 통해 메모리 주소에 저장된 값에 접근하는 것을 "),Bn=e("strong"),bt=l("dereferencing"),vt=l("이라고 한다."),Cs=i(),bn=e("p"),Et=l("위 코드의 출력 결과는 아래와 같다."),Bs=i(),V=e("pre"),Gs=i(),m=e("p"),_t=l("위의 "),Gn=e("code"),yt=l("pointerZ"),dt=l(" 변수처럼 포인터 변수를 선언하고 아무런 주소값도 할당하지 않으면 "),On=e("code"),Pt=l("nil"),wt=l("이 할당된다. 포인터 변수의 Zero value가 "),Hn=e("code"),Rt=l("nil"),Mt=l("인 셈이다."),xt=e("br"),Ct=l(`
만약 주소가 `),Sn=e("code"),Bt=l("nil"),Gt=l("인 접근하려고 하면 panic(런타임 에러)이 발생한다."),Os=i(),Hs=e("br"),Ss=i(),W=e("p"),Nn=e("code"),Ot=l("new()"),Ht=l(" 함수는 포인터 변수를 생성하는 built-in 함수이다. 포인터가 가리키는 값은 파라미터로 주어진 타입의 Zero value로 초기화된다."),Ns=i(),K=e("pre"),Ds=i(),O=e("p"),St=l("근데 "),Dn=e("code"),Nt=l("new()"),Dt=l(" 함수는 자주 쓰이지는 않는다고 한다."),Ls=i(),Ts=e("br"),As=i(),Q=e("p"),Ln=e("code"),Lt=l("&"),Tt=l(" 연산자를 통해서 상수나 리터럴의 주소값을 얻을 수는 없다. 이런 애들은 메모리 주소가 따로 존재하지 않기 때문이다."),Fs=i(),vn=e("p"),At=l("따라서 특정 값을 가진 포인터 변수를 생셩하려면, 먼저 일반 변수를 선언해서 값을 할당한 뒤, 해당 변수의 주소값을 넘겨주어야 한다."),Zs=i(),h=e("pre"),Us=i(),H=e("p"),Ft=l(`이러한 방식이 직관적이기는 하지만 코드의 길이가 쓸데없이 길어진다는 단점이 있다.
그렇다면 `),Tn=e("em"),Zt=l("helper function"),Ut=l("이란 것을 만들어서 값을 할당해줄 수 있다."),Js=i(),g=e("pre"),$s=i(),zs=e("br"),Is=e("br"),js=i(),S=e("h2"),N=e("a"),An=e("span"),Jt=l("Passing Pointers"),Xs=i(),Ys=e("hr"),qs=i(),Vs=e("br"),Ws=i(),D=e("h3"),L=e("a"),Fn=e("span"),$t=l("Pass by Pointer"),Ks=i(),T=e("p"),zt=l(`다들 알다시피, struct를 비롯한 원시 타입의 변수를 함수의 파라미터로 넘기면, 함수 안에서 해당 파라미터를 어떻게 수정하든 그 값이 바뀌지 않는다.
Go는 `),Zn=e("strong"),It=l("Call by Value"),jt=l(" 기반이기 때문."),Qs=i(),nn=e("pre"),hs=i(),gs=e("br"),na=i(),_=e("p"),Xt=l("다만 이는 파라미터로 넘기는 변수의 타입이 "),Un=e("em"),Yt=l("slice"),qt=l("이거나 "),Jn=e("em"),Vt=l("map"),Wt=l("이면 달라지는데, slice와 map은 "),$n=e("strong"),Kt=l("Pass by Pointer"),Qt=l(`로 넘겨진다.
따라서 파라미터로 받은 함수에서 값을 변경할 수 있다.`),sa=i(),sn=e("pre"),aa=i(),ta=e("br"),pa=i(),w=e("p"),ht=l(`파라미터로 넘기는 변수를 포인터로 지정해주면 Pass by Pointer가 된다.
이 경우 `),zn=e("em"),gt=l("dereferencing"),np=l(`을 통해 메모리 주소에 직접 접근하여 변수의 값을 변경할 수 있다.
다만 포인터 변수에 새로운 변수의 주소값을 할당한다고 해서 원래의 값이 바뀌지는 않는다(아래 예제의 `),In=e("code"),sp=l("failedUpdate()"),ap=l("함수 참조)."),ea=i(),an=e("pre"),oa=i(),la=e("br"),ca=i(),R=e("p"),tp=l("따라서 위에서 보았던 "),jn=e("code"),pp=l("modifySlice()"),ep=l(" 함수에서, 파라미터로 넘긴 변수가 "),Xn=e("code"),op=l("s = append(s, 10)"),lp=l(" 라인에 의해 변경되지 않으리라는 것을 알 수 있다."),ua=i(),tn=e("pre"),ia=i(),M=e("p"),cp=l("추가적으로, Go 내부적으로 slice는 원소들이 저장되는 메모리 주소에 대한 포인터, "),Yn=e("code"),up=l("cap"),ip=l(", "),qn=e("code"),rp=l("len"),kp=l(`, 이렇게 세 개의 원소로 구성된 struct 구조체라고 볼 수 있다.
따라서 slice가 파라미터로 넘어오면 원본 slice의 cap, len은 복사된 정수로 변경할 수 없는데 반해, 원소들이 저장된 메모리 공간에 대한 변경은 가능한 것이다.`),ra=i(),ka=e("br"),fa=e("br"),ma=i(),A=e("h3"),F=e("a"),Vn=e("span"),fp=l("Avoid Passing by Pointer"),ba=i(),Z=e("p"),mp=l("일반적으로 구조체 등 데이터를 생성하거나 설정하고자 할 때, 이를 "),Wn=e("em"),bp=l("Pass by Pointer"),vp=l(`로 넘기는 방식은 직관적이지 않다.
경우에 따라 오히려 이를 수행하는데 필요한 자원이 더 많이 소모하게 될 수도 있다.`),va=i(),pn=e("pre"),Ea=i(),U=e("p"),Ep=l("위 예시처럼 "),Kn=e("em"),_p=l("Pass by Pointer"),yp=l("를 사용하기보단, 그냥 그 값을 반환하는 형식이 시각적으로도 더 좋다."),_a=i(),ya=e("br"),da=i(),J=e("p"),dp=l("다만 예외사항이 좀 있다. 이를테면 JSON을 파싱하는 경우, "),Qn=e("code"),Pp=l("Unmarshal()"),wp=l("과 같은 일부 함수들은 포인터 파라미터를 사용하기도 한다."),Pa=i(),en=e("pre"),wa=i(),Ra=e("br"),Ma=i(),En=e("p"),Rp=l("또는, 반환해야 할(또는 파라미터로 넘겨야 할) 데이터가 메가바이트 단위 이상일 경우, Pass by Pointer를 사용하는 것이 훨씬 빠르다고 한다."),xa=i(),Ca=e("br"),Ba=e("br"),Ga=i(),$=e("h2"),z=e("a"),hn=e("span"),Mp=l("Garbage Collector"),Oa=i(),Ha=e("hr"),Sa=i(),_n=e("p"),xp=l(`Go에는 가비지 콜렉터가 존재한다. 이녀석의 역할은 더 이상 사용되지 않는 메모리 공간을 반환하는 것으로, Go는 메모리 관리를 프로그램 레벨에서 해준다.
다만 가비지 콜렉터가 존재한다고 해도 생각없이 코드를 짜면 가비지 콜렉터의 워크로드가 늘어나 프로그램이 느려질 수 있다.`),Na=i(),Da=e("br"),La=i(),on=e("pre"),Ta=i(),y=e("p"),Cp=l("위 코드는 안좋은 예로, 매 이터레이션마다 "),gn=e("code"),Bp=l("r.next_chunk()"),Gp=l("의 반환값을 받아들이는 "),ns=e("code"),Op=l("data_chunk"),Hp=l(` 변수가 생성된다.
이터레이션이 끝날 때마다 `),ss=e("code"),Sp=l("data_chunk"),Np=l("에 저장된 값은 필요 없는 메모리 공간이 되고, 가비지 콜렉터가 해야 하는 일이 쌓이게 되는 것이다."),Aa=i(),v=e("p"),Dp=l("아래 예제는 "),as=e("em"),Lp=l("Slice"),Tp=l("를 "),ts=e("em"),Ap=l("Buffer"),Fp=l(`처럼 사용하여, 파일의 데이터를 읽어오는 예제이다.
매 이터레이션마다 변수 `),ps=e("code"),Zp=l("data"),Up=l("에 값을 불러오고, 변수 "),es=e("code"),Jp=l("data"),$p=l("는 전체 이터레이션에서 재사용되므로, 가비지 콜렉터가 해야 할 일이 줄어든다."),Fa=i(),ln=e("pre"),Za=i(),Ua=e("br"),Ja=i(),f=e("p"),zp=l("Go에서는 기본적으로 "),os=e("em"),Ip=l("Stack"),jp=l("에 저장할 수 없는 가변적인 크기의 데이터들은 "),ls=e("em"),Xp=l("Heap"),Yp=l("에 저장되며, "),cs=e("em"),qp=l("Heap"),Vp=l(`은 가비지 콜렉터에 의해 관리된다.
가비지 콜렉터는 어떠한 포인터도 가리키지 않는 데이터(`),us=e("em"),Wp=l("garbage"),Kp=l(`)들을 청소하는 알고리즘이다.
사용가능한 데이터를 찾기 위해 한번에 최대한 많은 데이터를, 가능한한 빨리 찾게끔 디자인되어있기 때문에,
우리가 짠 Go 코드가 `),is=e("em"),Qp=l("garbage"),hp=l("를 많이 생성할수록 "),rs=e("em"),gp=l("garbage"),ne=l("찾지 못할 확률이 높아지며, "),ks=e("em"),se=l("garbage"),ae=l(`를 찾는데 더욱 오래 걸리게 된다.
게다가 보통 포인터가 가리키는 데이터들은 메모리 상에서 흩어져서 저장되기 때문에 찾기가 더 힘들어진다.`),$a=i(),yn=e("p"),te=l(`비록 Go가 Python, Java, Javascript와 같은 여타 언어들에 비해 가비지 콜렉터의 성능이 뛰어난 편이라고는 해도,
가비지 컬렉터가 해야 할 일을 줄여서 코드를 최적화시키는게 당연히 좋을 것이다.`),za=i(),Ia=e("br"),ja=e("br"),Xa=i(),I=e("h2"),j=e("a"),fs=e("span"),pe=l("References"),Ya=i(),qa=e("hr"),Va=i(),P=e("center"),ms=e("p"),ee=l("["),oe=i(),Vo(cn.$$.fragment),le=l(`
](https://learning.oreilly.com/library/view/learning-go/9781492077206/) `),ce=e("br"),ue=l(`
[Jon Bodner, 『Learning Go』, O'Reilly Media, Inc.](https://learning.oreilly.com/library/view/learning-go/9781492077206/)`),Wa=i(),Ka=e("br"),Qa=e("br"),this.h()},l(n){rn=o(n,"BR",{}),bs=r(n),kn=o(n,"P",{});var t=u(kn);et=c(t,"본 글은 Golang을 공부하며 주요 내용이라 생각되는 것들을 기록해둔 자료이며, Ubuntu 20.04 LTS 기준으로 작성되었습니다."),t.forEach(s),vs=r(n),Es=o(n,"BR",{}),_s=o(n,"BR",{}),ys=r(n),B=o(n,"H2",{id:!0});var ie=u(B);G=o(ie,"A",{"aria-hidden":!0,tabindex:!0,href:!0});var _e=u(G);Rn=o(_e,"SPAN",{class:!0}),u(Rn).forEach(s),_e.forEach(s),ot=c(ie,"Pointer"),ie.forEach(s),ds=r(n),Ps=o(n,"HR",{}),ws=r(n),fn=o(n,"P",{});var ye=u(fn);lt=c(ye,`놀랍게도 Go에는 포인터가 있다. C++ 공부하며 다신 보기 싫었던 친구인데 다시 보게 되니 감회가 새롭다.
다들 알다시피 포인터는 특정 변수가 저장된 메모리의 주소를 가리키는 변수를 의미한다. C/C++의 포인터와 크게 다르지 않다.`),ye.forEach(s),Rs=r(n),mn=o(n,"P",{});var de=u(mn);ct=c(de,"포인터 변수는 가리키고자 하는 메모리 주소의 첫 번째 byte address를 저장한다."),de.forEach(s),Ms=r(n),q=o(n,"PRE",{class:!0});var No=u(q);No.forEach(s),xs=r(n),E=o(n,"P",{});var C=u(E);Mn=o(C,"CODE",{});var Pe=u(Mn);ut=c(Pe,"&"),Pe.forEach(s),it=c(C,"는 변수의 주소값을 반환하는 연산자이며, "),xn=o(C,"CODE",{});var we=u(xn);rt=c(we,"*"),we.forEach(s),kt=c(C,`는 indirection 연산자로, 해당 포인터가 가리키는 주소에 저장된 값을 반환한다.
`),Cn=o(C,"CODE",{});var Re=u(Cn);ft=c(Re,"*"),Re.forEach(s),mt=c(C,"를 통해 메모리 주소에 저장된 값에 접근하는 것을 "),Bn=o(C,"STRONG",{});var Me=u(Bn);bt=c(Me,"dereferencing"),Me.forEach(s),vt=c(C,"이라고 한다."),C.forEach(s),Cs=r(n),bn=o(n,"P",{});var xe=u(bn);Et=c(xe,"위 코드의 출력 결과는 아래와 같다."),xe.forEach(s),Bs=r(n),V=o(n,"PRE",{class:!0});var Do=u(V);Do.forEach(s),Gs=r(n),m=o(n,"P",{});var d=u(m);_t=c(d,"위의 "),Gn=o(d,"CODE",{});var Ce=u(Gn);yt=c(Ce,"pointerZ"),Ce.forEach(s),dt=c(d," 변수처럼 포인터 변수를 선언하고 아무런 주소값도 할당하지 않으면 "),On=o(d,"CODE",{});var Be=u(On);Pt=c(Be,"nil"),Be.forEach(s),wt=c(d,"이 할당된다. 포인터 변수의 Zero value가 "),Hn=o(d,"CODE",{});var Ge=u(Hn);Rt=c(Ge,"nil"),Ge.forEach(s),Mt=c(d,"인 셈이다."),xt=o(d,"BR",{}),Ct=c(d,`
만약 주소가 `),Sn=o(d,"CODE",{});var Oe=u(Sn);Bt=c(Oe,"nil"),Oe.forEach(s),Gt=c(d,"인 접근하려고 하면 panic(런타임 에러)이 발생한다."),d.forEach(s),Os=r(n),Hs=o(n,"BR",{}),Ss=r(n),W=o(n,"P",{});var re=u(W);Nn=o(re,"CODE",{});var He=u(Nn);Ot=c(He,"new()"),He.forEach(s),Ht=c(re," 함수는 포인터 변수를 생성하는 built-in 함수이다. 포인터가 가리키는 값은 파라미터로 주어진 타입의 Zero value로 초기화된다."),re.forEach(s),Ns=r(n),K=o(n,"PRE",{class:!0});var Lo=u(K);Lo.forEach(s),Ds=r(n),O=o(n,"P",{});var ga=u(O);St=c(ga,"근데 "),Dn=o(ga,"CODE",{});var Se=u(Dn);Nt=c(Se,"new()"),Se.forEach(s),Dt=c(ga," 함수는 자주 쓰이지는 않는다고 한다."),ga.forEach(s),Ls=r(n),Ts=o(n,"BR",{}),As=r(n),Q=o(n,"P",{});var ke=u(Q);Ln=o(ke,"CODE",{});var Ne=u(Ln);Lt=c(Ne,"&"),Ne.forEach(s),Tt=c(ke," 연산자를 통해서 상수나 리터럴의 주소값을 얻을 수는 없다. 이런 애들은 메모리 주소가 따로 존재하지 않기 때문이다."),ke.forEach(s),Fs=r(n),vn=o(n,"P",{});var De=u(vn);At=c(De,"따라서 특정 값을 가진 포인터 변수를 생셩하려면, 먼저 일반 변수를 선언해서 값을 할당한 뒤, 해당 변수의 주소값을 넘겨주어야 한다."),De.forEach(s),Zs=r(n),h=o(n,"PRE",{class:!0});var To=u(h);To.forEach(s),Us=r(n),H=o(n,"P",{});var nt=u(H);Ft=c(nt,`이러한 방식이 직관적이기는 하지만 코드의 길이가 쓸데없이 길어진다는 단점이 있다.
그렇다면 `),Tn=o(nt,"EM",{});var Le=u(Tn);Zt=c(Le,"helper function"),Le.forEach(s),Ut=c(nt,"이란 것을 만들어서 값을 할당해줄 수 있다."),nt.forEach(s),Js=r(n),g=o(n,"PRE",{class:!0});var Ao=u(g);Ao.forEach(s),$s=r(n),zs=o(n,"BR",{}),Is=o(n,"BR",{}),js=r(n),S=o(n,"H2",{id:!0});var fe=u(S);N=o(fe,"A",{"aria-hidden":!0,tabindex:!0,href:!0});var Te=u(N);An=o(Te,"SPAN",{class:!0}),u(An).forEach(s),Te.forEach(s),Jt=c(fe,"Passing Pointers"),fe.forEach(s),Xs=r(n),Ys=o(n,"HR",{}),qs=r(n),Vs=o(n,"BR",{}),Ws=r(n),D=o(n,"H3",{id:!0});var me=u(D);L=o(me,"A",{"aria-hidden":!0,tabindex:!0,href:!0});var Ae=u(L);Fn=o(Ae,"SPAN",{class:!0}),u(Fn).forEach(s),Ae.forEach(s),$t=c(me,"Pass by Pointer"),me.forEach(s),Ks=r(n),T=o(n,"P",{});var st=u(T);zt=c(st,`다들 알다시피, struct를 비롯한 원시 타입의 변수를 함수의 파라미터로 넘기면, 함수 안에서 해당 파라미터를 어떻게 수정하든 그 값이 바뀌지 않는다.
Go는 `),Zn=o(st,"STRONG",{});var Fe=u(Zn);It=c(Fe,"Call by Value"),Fe.forEach(s),jt=c(st," 기반이기 때문."),st.forEach(s),Qs=r(n),nn=o(n,"PRE",{class:!0});var Fo=u(nn);Fo.forEach(s),hs=r(n),gs=o(n,"BR",{}),na=r(n),_=o(n,"P",{});var X=u(_);Xt=c(X,"다만 이는 파라미터로 넘기는 변수의 타입이 "),Un=o(X,"EM",{});var Ze=u(Un);Yt=c(Ze,"slice"),Ze.forEach(s),qt=c(X,"이거나 "),Jn=o(X,"EM",{});var Ue=u(Jn);Vt=c(Ue,"map"),Ue.forEach(s),Wt=c(X,"이면 달라지는데, slice와 map은 "),$n=o(X,"STRONG",{});var Je=u($n);Kt=c(Je,"Pass by Pointer"),Je.forEach(s),Qt=c(X,`로 넘겨진다.
따라서 파라미터로 받은 함수에서 값을 변경할 수 있다.`),X.forEach(s),sa=r(n),sn=o(n,"PRE",{class:!0});var Zo=u(sn);Zo.forEach(s),aa=r(n),ta=o(n,"BR",{}),pa=r(n),w=o(n,"P",{});var dn=u(w);ht=c(dn,`파라미터로 넘기는 변수를 포인터로 지정해주면 Pass by Pointer가 된다.
이 경우 `),zn=o(dn,"EM",{});var $e=u(zn);gt=c($e,"dereferencing"),$e.forEach(s),np=c(dn,`을 통해 메모리 주소에 직접 접근하여 변수의 값을 변경할 수 있다.
다만 포인터 변수에 새로운 변수의 주소값을 할당한다고 해서 원래의 값이 바뀌지는 않는다(아래 예제의 `),In=o(dn,"CODE",{});var ze=u(In);sp=c(ze,"failedUpdate()"),ze.forEach(s),ap=c(dn,"함수 참조)."),dn.forEach(s),ea=r(n),an=o(n,"PRE",{class:!0});var Uo=u(an);Uo.forEach(s),oa=r(n),la=o(n,"BR",{}),ca=r(n),R=o(n,"P",{});var Pn=u(R);tp=c(Pn,"따라서 위에서 보았던 "),jn=o(Pn,"CODE",{});var Ie=u(jn);pp=c(Ie,"modifySlice()"),Ie.forEach(s),ep=c(Pn," 함수에서, 파라미터로 넘긴 변수가 "),Xn=o(Pn,"CODE",{});var je=u(Xn);op=c(je,"s = append(s, 10)"),je.forEach(s),lp=c(Pn," 라인에 의해 변경되지 않으리라는 것을 알 수 있다."),Pn.forEach(s),ua=r(n),tn=o(n,"PRE",{class:!0});var Jo=u(tn);Jo.forEach(s),ia=r(n),M=o(n,"P",{});var wn=u(M);cp=c(wn,"추가적으로, Go 내부적으로 slice는 원소들이 저장되는 메모리 주소에 대한 포인터, "),Yn=o(wn,"CODE",{});var Xe=u(Yn);up=c(Xe,"cap"),Xe.forEach(s),ip=c(wn,", "),qn=o(wn,"CODE",{});var Ye=u(qn);rp=c(Ye,"len"),Ye.forEach(s),kp=c(wn,`, 이렇게 세 개의 원소로 구성된 struct 구조체라고 볼 수 있다.
따라서 slice가 파라미터로 넘어오면 원본 slice의 cap, len은 복사된 정수로 변경할 수 없는데 반해, 원소들이 저장된 메모리 공간에 대한 변경은 가능한 것이다.`),wn.forEach(s),ra=r(n),ka=o(n,"BR",{}),fa=o(n,"BR",{}),ma=r(n),A=o(n,"H3",{id:!0});var be=u(A);F=o(be,"A",{"aria-hidden":!0,tabindex:!0,href:!0});var qe=u(F);Vn=o(qe,"SPAN",{class:!0}),u(Vn).forEach(s),qe.forEach(s),fp=c(be,"Avoid Passing by Pointer"),be.forEach(s),ba=r(n),Z=o(n,"P",{});var at=u(Z);mp=c(at,"일반적으로 구조체 등 데이터를 생성하거나 설정하고자 할 때, 이를 "),Wn=o(at,"EM",{});var Ve=u(Wn);bp=c(Ve,"Pass by Pointer"),Ve.forEach(s),vp=c(at,`로 넘기는 방식은 직관적이지 않다.
경우에 따라 오히려 이를 수행하는데 필요한 자원이 더 많이 소모하게 될 수도 있다.`),at.forEach(s),va=r(n),pn=o(n,"PRE",{class:!0});var $o=u(pn);$o.forEach(s),Ea=r(n),U=o(n,"P",{});var tt=u(U);Ep=c(tt,"위 예시처럼 "),Kn=o(tt,"EM",{});var We=u(Kn);_p=c(We,"Pass by Pointer"),We.forEach(s),yp=c(tt,"를 사용하기보단, 그냥 그 값을 반환하는 형식이 시각적으로도 더 좋다."),tt.forEach(s),_a=r(n),ya=o(n,"BR",{}),da=r(n),J=o(n,"P",{});var pt=u(J);dp=c(pt,"다만 예외사항이 좀 있다. 이를테면 JSON을 파싱하는 경우, "),Qn=o(pt,"CODE",{});var Ke=u(Qn);Pp=c(Ke,"Unmarshal()"),Ke.forEach(s),wp=c(pt,"과 같은 일부 함수들은 포인터 파라미터를 사용하기도 한다."),pt.forEach(s),Pa=r(n),en=o(n,"PRE",{class:!0});var zo=u(en);zo.forEach(s),wa=r(n),Ra=o(n,"BR",{}),Ma=r(n),En=o(n,"P",{});var Qe=u(En);Rp=c(Qe,"또는, 반환해야 할(또는 파라미터로 넘겨야 할) 데이터가 메가바이트 단위 이상일 경우, Pass by Pointer를 사용하는 것이 훨씬 빠르다고 한다."),Qe.forEach(s),xa=r(n),Ca=o(n,"BR",{}),Ba=o(n,"BR",{}),Ga=r(n),$=o(n,"H2",{id:!0});var ve=u($);z=o(ve,"A",{"aria-hidden":!0,tabindex:!0,href:!0});var he=u(z);hn=o(he,"SPAN",{class:!0}),u(hn).forEach(s),he.forEach(s),Mp=c(ve,"Garbage Collector"),ve.forEach(s),Oa=r(n),Ha=o(n,"HR",{}),Sa=r(n),_n=o(n,"P",{});var ge=u(_n);xp=c(ge,`Go에는 가비지 콜렉터가 존재한다. 이녀석의 역할은 더 이상 사용되지 않는 메모리 공간을 반환하는 것으로, Go는 메모리 관리를 프로그램 레벨에서 해준다.
다만 가비지 콜렉터가 존재한다고 해도 생각없이 코드를 짜면 가비지 콜렉터의 워크로드가 늘어나 프로그램이 느려질 수 있다.`),ge.forEach(s),Na=r(n),Da=o(n,"BR",{}),La=r(n),on=o(n,"PRE",{class:!0});var Io=u(on);Io.forEach(s),Ta=r(n),y=o(n,"P",{});var Y=u(y);Cp=c(Y,"위 코드는 안좋은 예로, 매 이터레이션마다 "),gn=o(Y,"CODE",{});var no=u(gn);Bp=c(no,"r.next_chunk()"),no.forEach(s),Gp=c(Y,"의 반환값을 받아들이는 "),ns=o(Y,"CODE",{});var so=u(ns);Op=c(so,"data_chunk"),so.forEach(s),Hp=c(Y,` 변수가 생성된다.
이터레이션이 끝날 때마다 `),ss=o(Y,"CODE",{});var ao=u(ss);Sp=c(ao,"data_chunk"),ao.forEach(s),Np=c(Y,"에 저장된 값은 필요 없는 메모리 공간이 되고, 가비지 콜렉터가 해야 하는 일이 쌓이게 되는 것이다."),Y.forEach(s),Aa=r(n),v=o(n,"P",{});var x=u(v);Dp=c(x,"아래 예제는 "),as=o(x,"EM",{});var to=u(as);Lp=c(to,"Slice"),to.forEach(s),Tp=c(x,"를 "),ts=o(x,"EM",{});var po=u(ts);Ap=c(po,"Buffer"),po.forEach(s),Fp=c(x,`처럼 사용하여, 파일의 데이터를 읽어오는 예제이다.
매 이터레이션마다 변수 `),ps=o(x,"CODE",{});var eo=u(ps);Zp=c(eo,"data"),eo.forEach(s),Up=c(x,"에 값을 불러오고, 변수 "),es=o(x,"CODE",{});var oo=u(es);Jp=c(oo,"data"),oo.forEach(s),$p=c(x,"는 전체 이터레이션에서 재사용되므로, 가비지 콜렉터가 해야 할 일이 줄어든다."),x.forEach(s),Fa=r(n),ln=o(n,"PRE",{class:!0});var jo=u(ln);jo.forEach(s),Za=r(n),Ua=o(n,"BR",{}),Ja=r(n),f=o(n,"P",{});var b=u(f);zp=c(b,"Go에서는 기본적으로 "),os=o(b,"EM",{});var lo=u(os);Ip=c(lo,"Stack"),lo.forEach(s),jp=c(b,"에 저장할 수 없는 가변적인 크기의 데이터들은 "),ls=o(b,"EM",{});var co=u(ls);Xp=c(co,"Heap"),co.forEach(s),Yp=c(b,"에 저장되며, "),cs=o(b,"EM",{});var uo=u(cs);qp=c(uo,"Heap"),uo.forEach(s),Vp=c(b,`은 가비지 콜렉터에 의해 관리된다.
가비지 콜렉터는 어떠한 포인터도 가리키지 않는 데이터(`),us=o(b,"EM",{});var io=u(us);Wp=c(io,"garbage"),io.forEach(s),Kp=c(b,`)들을 청소하는 알고리즘이다.
사용가능한 데이터를 찾기 위해 한번에 최대한 많은 데이터를, 가능한한 빨리 찾게끔 디자인되어있기 때문에,
우리가 짠 Go 코드가 `),is=o(b,"EM",{});var ro=u(is);Qp=c(ro,"garbage"),ro.forEach(s),hp=c(b,"를 많이 생성할수록 "),rs=o(b,"EM",{});var ko=u(rs);gp=c(ko,"garbage"),ko.forEach(s),ne=c(b,"찾지 못할 확률이 높아지며, "),ks=o(b,"EM",{});var fo=u(ks);se=c(fo,"garbage"),fo.forEach(s),ae=c(b,`를 찾는데 더욱 오래 걸리게 된다.
게다가 보통 포인터가 가리키는 데이터들은 메모리 상에서 흩어져서 저장되기 때문에 찾기가 더 힘들어진다.`),b.forEach(s),$a=r(n),yn=o(n,"P",{});var mo=u(yn);te=c(mo,`비록 Go가 Python, Java, Javascript와 같은 여타 언어들에 비해 가비지 콜렉터의 성능이 뛰어난 편이라고는 해도,
가비지 컬렉터가 해야 할 일을 줄여서 코드를 최적화시키는게 당연히 좋을 것이다.`),mo.forEach(s),za=r(n),Ia=o(n,"BR",{}),ja=o(n,"BR",{}),Xa=r(n),I=o(n,"H2",{id:!0});var Ee=u(I);j=o(Ee,"A",{"aria-hidden":!0,tabindex:!0,href:!0});var bo=u(j);fs=o(bo,"SPAN",{class:!0}),u(fs).forEach(s),bo.forEach(s),pe=c(Ee,"References"),Ee.forEach(s),Ya=r(n),qa=o(n,"HR",{}),Va=r(n),P=o(n,"CENTER",{});var un=u(P);ms=o(un,"P",{});var vo=u(ms);ee=c(vo,"["),vo.forEach(s),oe=r(un),Wo(cn.$$.fragment,un),le=c(un,`
](https://learning.oreilly.com/library/view/learning-go/9781492077206/) `),ce=o(un,"BR",{}),ue=c(un,`
[Jon Bodner, 『Learning Go』, O'Reilly Media, Inc.](https://learning.oreilly.com/library/view/learning-go/9781492077206/)`),un.forEach(s),Wa=r(n),Ka=o(n,"BR",{}),Qa=o(n,"BR",{}),this.h()},h(){k(Rn,"class","icon icon-link"),k(G,"aria-hidden","true"),k(G,"tabindex","-1"),k(G,"href","#pointer"),k(B,"id","pointer"),k(q,"class","language-go"),k(V,"class","language-go"),k(K,"class","language-go"),k(h,"class","language-go"),k(g,"class","language-go"),k(An,"class","icon icon-link"),k(N,"aria-hidden","true"),k(N,"tabindex","-1"),k(N,"href","#passing-pointers"),k(S,"id","passing-pointers"),k(Fn,"class","icon icon-link"),k(L,"aria-hidden","true"),k(L,"tabindex","-1"),k(L,"href","#pass-by-pointer"),k(D,"id","pass-by-pointer"),k(nn,"class","language-go"),k(sn,"class","language-go"),k(an,"class","language-go"),k(tn,"class","language-go"),k(Vn,"class","icon icon-link"),k(F,"aria-hidden","true"),k(F,"tabindex","-1"),k(F,"href","#avoid-passing-by-pointer"),k(A,"id","avoid-passing-by-pointer"),k(pn,"class","language-go"),k(en,"class","language-go"),k(hn,"class","icon icon-link"),k(z,"aria-hidden","true"),k(z,"tabindex","-1"),k(z,"href","#garbage-collector"),k($,"id","garbage-collector"),k(on,"class","language-go"),k(ln,"class","language-go"),k(fs,"class","icon icon-link"),k(j,"aria-hidden","true"),k(j,"tabindex","-1"),k(j,"href","#references"),k(I,"id","references")},m(n,t){p(n,rn,t),p(n,bs,t),p(n,kn,t),a(kn,et),p(n,vs,t),p(n,Es,t),p(n,_s,t),p(n,ys,t),p(n,B,t),a(B,G),a(G,Rn),a(B,ot),p(n,ds,t),p(n,Ps,t),p(n,ws,t),p(n,fn,t),a(fn,lt),p(n,Rs,t),p(n,mn,t),a(mn,ct),p(n,Ms,t),p(n,q,t),q.innerHTML=_o,p(n,xs,t),p(n,E,t),a(E,Mn),a(Mn,ut),a(E,it),a(E,xn),a(xn,rt),a(E,kt),a(E,Cn),a(Cn,ft),a(E,mt),a(E,Bn),a(Bn,bt),a(E,vt),p(n,Cs,t),p(n,bn,t),a(bn,Et),p(n,Bs,t),p(n,V,t),V.innerHTML=yo,p(n,Gs,t),p(n,m,t),a(m,_t),a(m,Gn),a(Gn,yt),a(m,dt),a(m,On),a(On,Pt),a(m,wt),a(m,Hn),a(Hn,Rt),a(m,Mt),a(m,xt),a(m,Ct),a(m,Sn),a(Sn,Bt),a(m,Gt),p(n,Os,t),p(n,Hs,t),p(n,Ss,t),p(n,W,t),a(W,Nn),a(Nn,Ot),a(W,Ht),p(n,Ns,t),p(n,K,t),K.innerHTML=Po,p(n,Ds,t),p(n,O,t),a(O,St),a(O,Dn),a(Dn,Nt),a(O,Dt),p(n,Ls,t),p(n,Ts,t),p(n,As,t),p(n,Q,t),a(Q,Ln),a(Ln,Lt),a(Q,Tt),p(n,Fs,t),p(n,vn,t),a(vn,At),p(n,Zs,t),p(n,h,t),h.innerHTML=wo,p(n,Us,t),p(n,H,t),a(H,Ft),a(H,Tn),a(Tn,Zt),a(H,Ut),p(n,Js,t),p(n,g,t),g.innerHTML=Ro,p(n,$s,t),p(n,zs,t),p(n,Is,t),p(n,js,t),p(n,S,t),a(S,N),a(N,An),a(S,Jt),p(n,Xs,t),p(n,Ys,t),p(n,qs,t),p(n,Vs,t),p(n,Ws,t),p(n,D,t),a(D,L),a(L,Fn),a(D,$t),p(n,Ks,t),p(n,T,t),a(T,zt),a(T,Zn),a(Zn,It),a(T,jt),p(n,Qs,t),p(n,nn,t),nn.innerHTML=Mo,p(n,hs,t),p(n,gs,t),p(n,na,t),p(n,_,t),a(_,Xt),a(_,Un),a(Un,Yt),a(_,qt),a(_,Jn),a(Jn,Vt),a(_,Wt),a(_,$n),a($n,Kt),a(_,Qt),p(n,sa,t),p(n,sn,t),sn.innerHTML=xo,p(n,aa,t),p(n,ta,t),p(n,pa,t),p(n,w,t),a(w,ht),a(w,zn),a(zn,gt),a(w,np),a(w,In),a(In,sp),a(w,ap),p(n,ea,t),p(n,an,t),an.innerHTML=Co,p(n,oa,t),p(n,la,t),p(n,ca,t),p(n,R,t),a(R,tp),a(R,jn),a(jn,pp),a(R,ep),a(R,Xn),a(Xn,op),a(R,lp),p(n,ua,t),p(n,tn,t),tn.innerHTML=Bo,p(n,ia,t),p(n,M,t),a(M,cp),a(M,Yn),a(Yn,up),a(M,ip),a(M,qn),a(qn,rp),a(M,kp),p(n,ra,t),p(n,ka,t),p(n,fa,t),p(n,ma,t),p(n,A,t),a(A,F),a(F,Vn),a(A,fp),p(n,ba,t),p(n,Z,t),a(Z,mp),a(Z,Wn),a(Wn,bp),a(Z,vp),p(n,va,t),p(n,pn,t),pn.innerHTML=Go,p(n,Ea,t),p(n,U,t),a(U,Ep),a(U,Kn),a(Kn,_p),a(U,yp),p(n,_a,t),p(n,ya,t),p(n,da,t),p(n,J,t),a(J,dp),a(J,Qn),a(Qn,Pp),a(J,wp),p(n,Pa,t),p(n,en,t),en.innerHTML=Oo,p(n,wa,t),p(n,Ra,t),p(n,Ma,t),p(n,En,t),a(En,Rp),p(n,xa,t),p(n,Ca,t),p(n,Ba,t),p(n,Ga,t),p(n,$,t),a($,z),a(z,hn),a($,Mp),p(n,Oa,t),p(n,Ha,t),p(n,Sa,t),p(n,_n,t),a(_n,xp),p(n,Na,t),p(n,Da,t),p(n,La,t),p(n,on,t),on.innerHTML=Ho,p(n,Ta,t),p(n,y,t),a(y,Cp),a(y,gn),a(gn,Bp),a(y,Gp),a(y,ns),a(ns,Op),a(y,Hp),a(y,ss),a(ss,Sp),a(y,Np),p(n,Aa,t),p(n,v,t),a(v,Dp),a(v,as),a(as,Lp),a(v,Tp),a(v,ts),a(ts,Ap),a(v,Fp),a(v,ps),a(ps,Zp),a(v,Up),a(v,es),a(es,Jp),a(v,$p),p(n,Fa,t),p(n,ln,t),ln.innerHTML=So,p(n,Za,t),p(n,Ua,t),p(n,Ja,t),p(n,f,t),a(f,zp),a(f,os),a(os,Ip),a(f,jp),a(f,ls),a(ls,Xp),a(f,Yp),a(f,cs),a(cs,qp),a(f,Vp),a(f,us),a(us,Wp),a(f,Kp),a(f,is),a(is,Qp),a(f,hp),a(f,rs),a(rs,gp),a(f,ne),a(f,ks),a(ks,se),a(f,ae),p(n,$a,t),p(n,yn,t),a(yn,te),p(n,za,t),p(n,Ia,t),p(n,ja,t),p(n,Xa,t),p(n,I,t),a(I,j),a(j,fs),a(I,pe),p(n,Ya,t),p(n,qa,t),p(n,Va,t),p(n,P,t),a(P,ms),a(ms,ee),a(P,oe),Ko(cn,P,null),a(P,le),a(P,ce),a(P,ue),p(n,Wa,t),p(n,Ka,t),p(n,Qa,t),ha=!0},p:Qo,i(n){ha||(ho(cn.$$.fragment,n),ha=!0)},o(n){go(cn.$$.fragment,n),ha=!1},d(n){n&&s(rn),n&&s(bs),n&&s(kn),n&&s(vs),n&&s(Es),n&&s(_s),n&&s(ys),n&&s(B),n&&s(ds),n&&s(Ps),n&&s(ws),n&&s(fn),n&&s(Rs),n&&s(mn),n&&s(Ms),n&&s(q),n&&s(xs),n&&s(E),n&&s(Cs),n&&s(bn),n&&s(Bs),n&&s(V),n&&s(Gs),n&&s(m),n&&s(Os),n&&s(Hs),n&&s(Ss),n&&s(W),n&&s(Ns),n&&s(K),n&&s(Ds),n&&s(O),n&&s(Ls),n&&s(Ts),n&&s(As),n&&s(Q),n&&s(Fs),n&&s(vn),n&&s(Zs),n&&s(h),n&&s(Us),n&&s(H),n&&s(Js),n&&s(g),n&&s($s),n&&s(zs),n&&s(Is),n&&s(js),n&&s(S),n&&s(Xs),n&&s(Ys),n&&s(qs),n&&s(Vs),n&&s(Ws),n&&s(D),n&&s(Ks),n&&s(T),n&&s(Qs),n&&s(nn),n&&s(hs),n&&s(gs),n&&s(na),n&&s(_),n&&s(sa),n&&s(sn),n&&s(aa),n&&s(ta),n&&s(pa),n&&s(w),n&&s(ea),n&&s(an),n&&s(oa),n&&s(la),n&&s(ca),n&&s(R),n&&s(ua),n&&s(tn),n&&s(ia),n&&s(M),n&&s(ra),n&&s(ka),n&&s(fa),n&&s(ma),n&&s(A),n&&s(ba),n&&s(Z),n&&s(va),n&&s(pn),n&&s(Ea),n&&s(U),n&&s(_a),n&&s(ya),n&&s(da),n&&s(J),n&&s(Pa),n&&s(en),n&&s(wa),n&&s(Ra),n&&s(Ma),n&&s(En),n&&s(xa),n&&s(Ca),n&&s(Ba),n&&s(Ga),n&&s($),n&&s(Oa),n&&s(Ha),n&&s(Sa),n&&s(_n),n&&s(Na),n&&s(Da),n&&s(La),n&&s(on),n&&s(Ta),n&&s(y),n&&s(Aa),n&&s(v),n&&s(Fa),n&&s(ln),n&&s(Za),n&&s(Ua),n&&s(Ja),n&&s(f),n&&s($a),n&&s(yn),n&&s(za),n&&s(Ia),n&&s(ja),n&&s(Xa),n&&s(I),n&&s(Ya),n&&s(qa),n&&s(Va),n&&s(P),nl(cn),n&&s(Wa),n&&s(Ka),n&&s(Qa)}}}const el={title:"포인터",date:"2022-08-07T00:00:00.000Z",excerpt:"Pointer",categories:["Golang","Basic Golang"],coverImage:"/post_img/Go/Golang_basics/cover.png",coverWidth:16,coverHeight:9,indexed:!1,exposed:!0};class ol extends Xo{constructor(rn){super(),Yo(this,rn,null,al,qo,{})}}export{ol as default,el as metadata};
