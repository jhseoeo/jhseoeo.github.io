import{S as zp,i as Gp,s as qp,k as t,q as l,a as u,y as Hp,l as o,m as s,r as c,h as n,c as d,z as Mp,n as i,U as Up,b as p,E as e,A as Wp,g as Np,d as $p,B as Tp}from"./index.5621e629.js";import{H as Xp}from"./Highlight.2decd09b.js";function Yp(no){let k;return{c(){k=l("메모리 모델")},l(A){k=c(A,"메모리 모델")},m(A,qe){p(A,k,qe)},d(A){A&&n(k)}}}function Jp(no){let k,A,qe,He,ao,ga,N,to,$,oo,et,Me,so,nt,Ue,lo,at,tt,ot,st,T,X,vn,co,lt,ct,rt,Y,J,_n,mn,ro,pt,D,v,po,bn,io,uo,yn,fo,ho,On,ko,Eo,vo,Ln,_o,mo,wn,bo,it,V,Z,Dn,Cn,yo,ut,C,be,xn,Oo,Lo,ye,Rn,wo,Do,Bn,Co,xo,Pn,_,Ro,An,Bo,Po,In,Ao,Io,Sn,So,zo,Go,zn,Gn,qo,dt,j,F,qn,Hn,Ho,ft,x,Mn,Mo,Uo,E,Un,Wo,No,Wn,$o,To,Nn,Xo,Yo,$n,Jo,Vo,Zo,f,Tn,jo,Fo,Xn,Ko,Qo,Yn,go,es,Jn,ns,as,Vn,ts,os,ht,We,ss,kt,Et,vt,_t,K,Q,Zn,ls,mt,Ne,cs,bt,g,ee,jn,rs,yt,$e,I,ps,Fn,is,us,Kn,ds,fs,Ot,ne,ae,Qn,hs,Lt,Te,m,S,ks,gn,Es,vs,ea,_s,ms,bs,na,Oe,ys,aa,Os,Ls,ws,Xe,Cp=`<code class="language-go">a <span class="token operator">:=</span> <span class="token string">"Before goroutine"</span>
<span class="token keyword">go</span> <span class="token keyword">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span> fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span> <span class="token punctuation">&#125;</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token keyword">select</span><span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span></code>`,Ds,ta,oa,Cs,wt,te,oe,sa,xs,Dt,R,la,ca,Rs,Bs,Le,ra,Ps,As,pa,ia,Is,Ss,z,we,zs,ua,Gs,qs,Hs,Ye,xp=`<code class="language-go">  <span class="token keyword">var</span> x <span class="token builtin">int</span>
  ch <span class="token operator">:=</span> <span class="token function">make</span><span class="token punctuation">(</span><span class="token keyword">chan</span> <span class="token builtin">int</span><span class="token punctuation">)</span>
  <span class="token keyword">go</span> <span class="token keyword">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    ch <span class="token operator">&lt;-</span> <span class="token number">0</span>
    fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span>
  <span class="token punctuation">&#125;</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
  x <span class="token operator">=</span> <span class="token number">1</span>
  <span class="token operator">&lt;-</span>ch
  <span class="token keyword">select</span><span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span></code>`,Ms,b,De,da,Us,Ws,fa,Ns,$s,Ce,ha,Ts,Xs,ka,Ys,Js,xe,Ea,Vs,Zs,va,js,Fs,se,Ks,_a,Qs,gs,ma,el,Ct,le,ce,ba,nl,xt,Je,G,ya,al,tl,Re,Oa,ol,sl,Be,ll,La,cl,rl,pl,Ve,Rp=`<code class="language-go"><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
  <span class="token keyword">var</span> m sync<span class="token punctuation">.</span>Mutex
  <span class="token keyword">var</span> a <span class="token builtin">int</span>
  done <span class="token operator">:=</span> <span class="token function">make</span><span class="token punctuation">(</span><span class="token keyword">chan</span> <span class="token keyword">struct</span><span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span>
  m<span class="token punctuation">.</span><span class="token function">Lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span>

  <span class="token keyword">go</span> <span class="token keyword">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
      m<span class="token punctuation">.</span><span class="token function">Lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
      fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span>
      m<span class="token punctuation">.</span><span class="token function">Unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
      <span class="token function">close</span><span class="token punctuation">(</span>done<span class="token punctuation">)</span>
  <span class="token punctuation">&#125;</span><span class="token punctuation">(</span><span class="token punctuation">)</span>

  <span class="token keyword">go</span> <span class="token keyword">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
      a <span class="token operator">=</span> <span class="token number">1</span>
      m<span class="token punctuation">.</span><span class="token function">Unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
  <span class="token punctuation">&#125;</span>

  <span class="token operator">&lt;-</span>done

<span class="token punctuation">&#125;</span></code>`,Rt,re,pe,wa,il,Bt,B,Da,Ze,Ca,ul,dl,fl,xa,Ra,hl,kl,Pe,Ba,El,vl,je,Bp=`<code class="language-go">  <span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
      <span class="token keyword">var</span> i <span class="token builtin">int</span>
      <span class="token keyword">var</span> v atomic<span class="token punctuation">.</span>Value
      done <span class="token operator">:=</span> <span class="token function">make</span><span class="token punctuation">(</span><span class="token keyword">chan</span> <span class="token keyword">struct</span><span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span>
      <span class="token keyword">go</span> <span class="token keyword">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
          i <span class="token operator">=</span> <span class="token number">1</span>
          v<span class="token punctuation">.</span><span class="token function">Store</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>
      <span class="token punctuation">&#125;</span><span class="token punctuation">(</span><span class="token punctuation">)</span>

      <span class="token keyword">go</span> <span class="token keyword">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
          <span class="token keyword">for</span> <span class="token punctuation">&#123;</span>
              <span class="token keyword">if</span> val<span class="token punctuation">,</span> <span class="token boolean">_</span> <span class="token operator">:=</span> v<span class="token punctuation">.</span><span class="token function">Load</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token punctuation">(</span><span class="token builtin">int</span><span class="token punctuation">)</span><span class="token punctuation">;</span> val <span class="token operator">==</span> <span class="token number">1</span> <span class="token punctuation">&#123;</span>
                  fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span>
                  <span class="token function">close</span><span class="token punctuation">(</span>done<span class="token punctuation">)</span>
                  <span class="token keyword">return</span>
              <span class="token punctuation">&#125;</span>
          <span class="token punctuation">&#125;</span>
      <span class="token punctuation">&#125;</span><span class="token punctuation">(</span><span class="token punctuation">)</span>

      <span class="token operator">&lt;-</span>done
  <span class="token punctuation">&#125;</span></code>`,Pt,ie,ue,Pa,_l,At,P,Ae,Fe,Aa,ml,bl,yl,y,q,Ol,Ia,Ll,wl,Sa,Dl,Cl,xl,H,Rl,za,Bl,Pl,Ga,Al,Il,Sl,qa,zl,Gl,Ke,Ha,ql,Hl,Ml,Ie,Qe,Ma,Ul,Wl,Nl,M,ge,Ua,$l,Tl,Xl,Se,Yl,Wa,Jl,Vl,Zl,O,jl,Na,Fl,Kl,$a,Ql,gl,Ta,ec,nc,ac,Xa,h,Ya,tc,oc,Ja,sc,lc,Va,cc,rc,Za,pc,ic,ja,uc,dc,It,St,zt,Gt,de,fe,Fa,fc,qt,Ht,Mt,en,U,ze,nn,Gc,hc,kc,Ec,Ge,vc,Ut;return $=new Xp({props:{$$slots:{default:[Yp]},$$scope:{ctx:no}}}),{c(){k=t("p"),A=l(`어떤 언어든 그 언어를 딥하게 파고 제대로 이해하기 위해서는 그 언어의 메모리 모델을 이해하는 것이 중요하다고 생각한다.
그만큼 Go를 열심히 공부하는 입장으로서 Go의 메모리 모델을 이해하는 것은 필수적이다.`),qe=u(),He=t("p"),ao=l(`단일 프로세서의 성능 향상에 한계가 오면서 멀티 코어 프로세서가 등장하게 되었고, 대부분의 성능 향상은 멀티 코어 프로세서에서 동작하는 것이 대전제가 되었다.
한편 현대 컴파일러 또한 극한의 최적화를 위해 코드를 재배치하는 일이 비일비재하다.
이는 sequantial program에서는 문제가 되지 않지만, concurrent program에서는 문제가 될 수 있다.`),ga=u(),N=t("p"),to=l("이러한 문제를 해결하기 위해서 "),Hp($.$$.fragment),oo=l(`이 정의된다.
메모리 모델은 컴파일러 빌더가 보장해야 하고, 프로그래머가 기대할 수 있는 것들을 정의한다.
즉, 메모리 모델은 하드웨어에 대한 컴파일러 빌더의 동작이 정의된 것이라고 볼 수 있다.`),et=u(),Me=t("p"),so=l(`여러 고루틴에서 동시에 엑세스되는 데이터를 수정하는 프로그램은 이러한 액세스를 직렬화해야 함을 언급하며 Go의 메모리 모델 문서가 시작되는데, 이는 쉬운 일이 아니다.
동시성 프로그램의 모든 가능성을 고려하는 것은 불가능하기 때문이다.
대신 메모리 모델에 대한 인사이트를 가지고 있다면 동시성 프로그램의 문제를 해결하는 데 도움이 될 수 있다.`),nt=u(),Ue=t("p"),lo=l(`물론 메모리 모델과 너무 가깝게 작성된 코드를 짜는 것은 좋지 않지만, 알고 하지 않는 것과 모르고 하지 않는 것은 차이가 있다.
Go의 메모리 모델에 대해 본격적으로 알아보자.`),at=u(),tt=t("br"),ot=t("br"),st=u(),T=t("h2"),X=t("a"),vn=t("span"),co=l("메모리 연산 순서 모델"),lt=u(),ct=t("hr"),rt=u(),Y=t("h3"),J=t("a"),_n=t("span"),mn=t("strong"),ro=l("Sequenced-Before Relationship"),pt=u(),D=t("ul"),v=t("li"),po=l("만약 "),bn=t("code"),io=l("A is sequenced before B"),uo=l("라면, "),yn=t("code"),fo=l("A"),ho=l("가 "),On=t("code"),ko=l("B"),Eo=l("보다 먼저 실행되었음을 의미함"),vo=u(),Ln=t("li"),_o=l("하지만 Sequenced-Before Relationship은 동시성을 고려하지 않음"),mo=u(),wn=t("li"),bo=l("메모리 read 연산이 변수에 쓰여진 마지막 값을 읽는 한, 컴파일러에 의해 instruction reordering이 발생할 수 있음"),it=u(),V=t("h3"),Z=t("a"),Dn=t("span"),Cn=t("strong"),yo=l("Synchronized-Before Relationship"),ut=u(),C=t("ul"),be=t("li"),xn=t("p"),Oo=l("일반적인 메모리 연산 외에도 동기화 메모리 작업(Synchronizing Memory Operation)이 존재함"),Lo=u(),ye=t("ul"),Rn=t("li"),wo=l("Syncrhonizing Read Operation: Mutex lock, Channel receive, atomic read, atomic compare-and-swap"),Do=u(),Bn=t("li"),Co=l("Synchrornizing Write Operation: Mutex unlock, Channel send, Channel close, atomic write, atomic compare-and-swap"),xo=u(),Pn=t("li"),_=t("p"),Ro=l("만약 "),An=t("code"),Bo=l("A is synchronized before B"),Po=l("라면, 동기화 연산 "),In=t("code"),Ao=l("A"),Io=l("가 동기화 연산 "),Sn=t("code"),So=l("B"),zo=l("보다 먼저 실행되었음을 의미함"),Go=u(),zn=t("li"),Gn=t("p"),qo=l("Sequenced-Before Relationship이 단일 고루틴에서의 일반적인 메모리 연산 순서를 정의한다면, Synchronized-Before Relationship은 여러 고루틴에서의 메모리 연산 순서를 정의할 수 있음"),dt=u(),j=t("h3"),F=t("a"),qn=t("span"),Hn=t("strong"),Ho=l("Happened-Before Relationship"),ft=u(),x=t("ul"),Mn=t("li"),Mo=l("Sequenced-Before Relationship와 Synchronized-Before Relationship의 조합"),Uo=u(),E=t("li"),Un=t("code"),Wo=l("W"),No=l("가 메모리 쓰기 작업이고 "),Wn=t("code"),$o=l("R"),To=l("이 메모리 읽기 작업일 때, 만약 "),Nn=t("code"),Xo=l("W synchronized before R"),Yo=l("이면, "),$n=t("code"),Jo=l("W happened before R"),Vo=l("임"),Zo=u(),f=t("li"),Tn=t("code"),jo=l("X"),Fo=l("가 메모리 쓰기 작업이고 "),Xn=t("code"),Ko=l("Y"),Qo=l("이 메모리 읽기 작업일 때, 만약 "),Yn=t("code"),go=l("X sequenced before W"),es=l("이고 "),Jn=t("code"),ns=l("Y is sequenced after R"),as=l("이면, "),Vn=t("code"),ts=l("X happened before Y"),os=l("임"),ht=u(),We=t("p"),ss=l("만약 read 및 write 연산간 happened-before relationship을 정의할 수 없다면, 이들은 동시에 일어남."),kt=u(),Et=t("br"),vt=t("br"),_t=u(),K=t("h2"),Q=t("a"),Zn=t("span"),ls=l("Golang의 동기화 모델"),mt=u(),Ne=t("p"),cs=l("앞선 Happened-Before Relationship을 통해 Go의 동기화 모델을 확인할 수 있음."),bt=u(),g=t("h3"),ee=t("a"),jn=t("span"),rs=l("패키지 초기화"),yt=u(),$e=t("ul"),I=t("li"),ps=l("패키지 A가 다른 패키지 B를 임포트한다면, 패키지 B의 "),Fn=t("code"),is=l("init()"),us=l(" 함수가 패키지 A의 "),Kn=t("code"),ds=l("init()"),fs=l(" 함수보다 먼저 실행됨"),Ot=u(),ne=t("h3"),ae=t("a"),Qn=t("span"),hs=l("고루틴"),Lt=u(),Te=t("ul"),m=t("li"),S=t("p"),ks=l("프로그램이 고루틴을 생성할 때, "),gn=t("code"),Es=l("go"),vs=l(" 문은 고루틴 실행 이전에 동기화됨 ("),ea=t("code"),_s=l("go"),ms=l(" statement is synchronized before the start of goroutine’s execution)"),bs=u(),na=t("ul"),Oe=t("li"),ys=l("다음의 예시 코드는 항상 "),aa=t("code"),Os=l("Before goroutine"),Ls=l("을 출력함"),ws=u(),Xe=t("pre"),Ds=u(),ta=t("ul"),oa=t("li"),Cs=l("하지만 고루팀이 종료될 때 명시적인 방식으로 통신을 하지 않는 이상, 고루틴의 종료 시점은 동기화되지 않음"),wt=u(),te=t("h3"),oe=t("a"),sa=t("span"),xs=l("채널"),Dt=u(),R=t("ul"),la=t("li"),ca=t("p"),Rs=l("unbuffered channel을 통해 전송되는 send 및 close 연산은 채널의 receive 연산과 동기화됨 (send or close is synchronized before the receive)"),Bs=u(),Le=t("li"),ra=t("p"),Ps=l("buffered channel을 통해 전송되는 send 및 close 연산은 채널의 receive 연산과 동기화됨(receive is synchronized before the send or close)"),As=u(),pa=t("ul"),ia=t("li"),Is=l("syncrhonized before이면 happened before임"),Ss=u(),z=t("li"),we=t("p"),zs=l("다음의 예시 코드는 항상 "),ua=t("code"),Gs=l("1"),qs=l("을 출력함"),Hs=u(),Ye=t("pre"),Ms=u(),b=t("ul"),De=t("li"),da=t("code"),Us=l("x = 1"),Ws=l(" is sequenced before "),fa=t("code"),Ns=l("<-ch"),$s=u(),Ce=t("li"),ha=t("code"),Ts=l("<-ch"),Xs=l(" is synchronized before "),ka=t("code"),Ys=l("ch <- 0"),Js=u(),xe=t("li"),Ea=t("code"),Vs=l("ch <- 0"),Zs=l(" is sequenced before "),va=t("code"),js=l("fmt.Println(x)"),Fs=u(),se=t("li"),Ks=l("따라서, "),_a=t("code"),Qs=l("x = 1"),gs=l(" is happened before "),ma=t("code"),el=l("fmt.Println(x)"),Ct=u(),le=t("h3"),ce=t("a"),ba=t("span"),nl=l("뮤텍스"),xt=u(),Je=t("ul"),G=t("li"),ya=t("p"),al=l("두 고루틴 A와 B가 있을 때 A가 먼저 획득한 뮤텍스를 unlock하면 B가 뮤텍스를 lock할 수 있음."),tl=u(),Re=t("ul"),Oa=t("li"),ol=l("이 때 unlock은 lock보다 먼저 동기화됨 (unlock is synchronized before the lock)"),sl=u(),Be=t("li"),ll=l("다음의 예시 코드는 항상 "),La=t("code"),cl=l("1"),rl=l("을 출력함"),pl=u(),Ve=t("pre"),Rt=u(),re=t("h3"),pe=t("a"),wa=t("span"),il=l("Atomic 연산"),Bt=u(),B=t("ul"),Da=t("li"),Ze=t("p"),Ca=t("code"),ul=l("sync/atomic"),dl=l(" 패키지는 저수준의 원자적 메모리 읽기/쓰기 연산을 제공함"),fl=u(),xa=t("li"),Ra=t("p"),hl=l("만약 atomic write의 결과가 atomic read에서 확인된다면, atomic write는 atomic read보다 먼저 동기화됨 (atomic write is synchronized before the atomic read)"),kl=u(),Pe=t("li"),Ba=t("p"),El=l("다음의 코드는 항상 1을 출력함"),vl=u(),je=t("pre"),Pt=u(),ie=t("h3"),ue=t("a"),Pa=t("span"),_l=l("Map, Once, WaitGroup"),At=u(),P=t("ul"),Ae=t("li"),Fe=t("p"),Aa=t("code"),ml=l("sync.Map"),bl=l("은 별도로 뮤텍스 로직을 구현하지 않아도 안전하게 사용할 수 있는 thread-safe map 타입임"),yl=u(),y=t("ul"),q=t("li"),Ol=l("데이터가 한번 write되지만 여러 번 read되는 경우나 여러 고루틴이 각각의 키로 접근하는 경우, 일반 "),Ia=t("code"),Ll=l("map"),wl=l("에 뮤텍스를 사용하여 구현하는 것보다 "),Sa=t("code"),Dl=l("sync.Map"),Cl=l("을 사용하는 것이 더 좋은 성능을 보임"),xl=u(),H=t("li"),Rl=l("하지만 "),za=t("code"),Bl=l("sync.Map"),Pl=l("은 "),Ga=t("code"),Al=l("map"),Il=l("과 달리 타입 안정성을 보장하지 않음"),Sl=u(),qa=t("li"),zl=l("간단하게 캐시같은거 구현할 때 사용하면 좋다고 함"),Gl=u(),Ke=t("li"),Ha=t("code"),ql=l("sync.Map"),Hl=l("에서 어떤 read 연산이 write 연산의 결과를 확인한다면, write 연산은 read 연산보다 먼저 발생함 (write is happened before the read)"),Ml=u(),Ie=t("li"),Qe=t("p"),Ma=t("code"),Ul=l("sync.Once"),Wl=l("는 여러 고루틴에서 무언가를 초기화하고자 할 때 유용함"),Nl=u(),M=t("ul"),ge=t("li"),Ua=t("code"),$l=l("sync.Once.Do()"),Tl=l("를 호출하여 함수를 넘기면 초기화가 실행됨"),Xl=u(),Se=t("li"),Yl=l("여러 고루틴에서 "),Wa=t("code"),Jl=l("sync.Once.Do()"),Vl=l("를 호출하더라도, 초기화 함수는 한 번만 실행되고, 다른 고루틴에서는 초기화 함수가 실행되지 않고 block되었다가 초기화 함수가 실행된 후에 unblock됨"),Zl=u(),O=t("li"),jl=l("한 고루틴에서 "),Na=t("code"),Fl=l("sync.Once.Do()"),Kl=l("를 호출하면 다른 고루틴에서 "),$a=t("code"),Ql=l("sync.Once.Do()"),gl=l("가 끝나기 이전에 그 초기화 함수가 종료됨 (the completion of initialization function is happened before the return from "),Ta=t("code"),ec=l("sync.Once.Do()"),nc=l(")"),ac=u(),Xa=t("li"),h=t("p"),Ya=t("code"),tc=l("sync.WaitGroup"),oc=l("의 모든 "),Ja=t("code"),sc=l("Done()"),lc=l(" 메소드 호출은 "),Va=t("code"),cc=l("Wait()"),rc=l(" 메소드의 반환 이전에 동기화됨 (the completion of "),Za=t("code"),pc=l("Done()"),ic=l(" is happened before the return from "),ja=t("code"),uc=l("Wait()"),dc=l(")"),It=u(),St=t("br"),zt=t("br"),Gt=u(),de=t("h2"),fe=t("a"),Fa=t("span"),fc=l("References"),qt=u(),Ht=t("hr"),Mt=u(),en=t("center"),U=t("p"),ze=t("a"),nn=t("img"),hc=u(),kc=t("br"),Ec=u(),Ge=t("a"),vc=l("Jon Bodner, 『Learning Go』, O’Reilly Media, Inc."),this.h()},l(a){k=o(a,"P",{});var r=s(k);A=c(r,`어떤 언어든 그 언어를 딥하게 파고 제대로 이해하기 위해서는 그 언어의 메모리 모델을 이해하는 것이 중요하다고 생각한다.
그만큼 Go를 열심히 공부하는 입장으로서 Go의 메모리 모델을 이해하는 것은 필수적이다.`),r.forEach(n),qe=d(a),He=o(a,"P",{});var Ka=s(He);ao=c(Ka,`단일 프로세서의 성능 향상에 한계가 오면서 멀티 코어 프로세서가 등장하게 되었고, 대부분의 성능 향상은 멀티 코어 프로세서에서 동작하는 것이 대전제가 되었다.
한편 현대 컴파일러 또한 극한의 최적화를 위해 코드를 재배치하는 일이 비일비재하다.
이는 sequantial program에서는 문제가 되지 않지만, concurrent program에서는 문제가 될 수 있다.`),Ka.forEach(n),ga=d(a),N=o(a,"P",{});var Wt=s(N);to=c(Wt,"이러한 문제를 해결하기 위해서 "),Mp($.$$.fragment,Wt),oo=c(Wt,`이 정의된다.
메모리 모델은 컴파일러 빌더가 보장해야 하고, 프로그래머가 기대할 수 있는 것들을 정의한다.
즉, 메모리 모델은 하드웨어에 대한 컴파일러 빌더의 동작이 정의된 것이라고 볼 수 있다.`),Wt.forEach(n),et=d(a),Me=o(a,"P",{});var qc=s(Me);so=c(qc,`여러 고루틴에서 동시에 엑세스되는 데이터를 수정하는 프로그램은 이러한 액세스를 직렬화해야 함을 언급하며 Go의 메모리 모델 문서가 시작되는데, 이는 쉬운 일이 아니다.
동시성 프로그램의 모든 가능성을 고려하는 것은 불가능하기 때문이다.
대신 메모리 모델에 대한 인사이트를 가지고 있다면 동시성 프로그램의 문제를 해결하는 데 도움이 될 수 있다.`),qc.forEach(n),nt=d(a),Ue=o(a,"P",{});var Hc=s(Ue);lo=c(Hc,`물론 메모리 모델과 너무 가깝게 작성된 코드를 짜는 것은 좋지 않지만, 알고 하지 않는 것과 모르고 하지 않는 것은 차이가 있다.
Go의 메모리 모델에 대해 본격적으로 알아보자.`),Hc.forEach(n),at=d(a),tt=o(a,"BR",{}),ot=o(a,"BR",{}),st=d(a),T=o(a,"H2",{id:!0});var _c=s(T);X=o(_c,"A",{"aria-hidden":!0,tabindex:!0,href:!0});var Mc=s(X);vn=o(Mc,"SPAN",{class:!0}),s(vn).forEach(n),Mc.forEach(n),co=c(_c,"메모리 연산 순서 모델"),_c.forEach(n),lt=d(a),ct=o(a,"HR",{}),rt=d(a),Y=o(a,"H3",{id:!0});var mc=s(Y);J=o(mc,"A",{"aria-hidden":!0,tabindex:!0,href:!0});var Uc=s(J);_n=o(Uc,"SPAN",{class:!0}),s(_n).forEach(n),Uc.forEach(n),mn=o(mc,"STRONG",{});var Wc=s(mn);ro=c(Wc,"Sequenced-Before Relationship"),Wc.forEach(n),mc.forEach(n),pt=d(a),D=o(a,"UL",{});var an=s(D);v=o(an,"LI",{});var he=s(v);po=c(he,"만약 "),bn=o(he,"CODE",{});var Nc=s(bn);io=c(Nc,"A is sequenced before B"),Nc.forEach(n),uo=c(he,"라면, "),yn=o(he,"CODE",{});var $c=s(yn);fo=c($c,"A"),$c.forEach(n),ho=c(he,"가 "),On=o(he,"CODE",{});var Tc=s(On);ko=c(Tc,"B"),Tc.forEach(n),Eo=c(he,"보다 먼저 실행되었음을 의미함"),he.forEach(n),vo=d(an),Ln=o(an,"LI",{});var Xc=s(Ln);_o=c(Xc,"하지만 Sequenced-Before Relationship은 동시성을 고려하지 않음"),Xc.forEach(n),mo=d(an),wn=o(an,"LI",{});var Yc=s(wn);bo=c(Yc,"메모리 read 연산이 변수에 쓰여진 마지막 값을 읽는 한, 컴파일러에 의해 instruction reordering이 발생할 수 있음"),Yc.forEach(n),an.forEach(n),it=d(a),V=o(a,"H3",{id:!0});var bc=s(V);Z=o(bc,"A",{"aria-hidden":!0,tabindex:!0,href:!0});var Jc=s(Z);Dn=o(Jc,"SPAN",{class:!0}),s(Dn).forEach(n),Jc.forEach(n),Cn=o(bc,"STRONG",{});var Vc=s(Cn);yo=c(Vc,"Synchronized-Before Relationship"),Vc.forEach(n),bc.forEach(n),ut=d(a),C=o(a,"UL",{});var tn=s(C);be=o(tn,"LI",{});var Nt=s(be);xn=o(Nt,"P",{});var Zc=s(xn);Oo=c(Zc,"일반적인 메모리 연산 외에도 동기화 메모리 작업(Synchronizing Memory Operation)이 존재함"),Zc.forEach(n),Lo=d(Nt),ye=o(Nt,"UL",{});var $t=s(ye);Rn=o($t,"LI",{});var jc=s(Rn);wo=c(jc,"Syncrhonizing Read Operation: Mutex lock, Channel receive, atomic read, atomic compare-and-swap"),jc.forEach(n),Do=d($t),Bn=o($t,"LI",{});var Fc=s(Bn);Co=c(Fc,"Synchrornizing Write Operation: Mutex unlock, Channel send, Channel close, atomic write, atomic compare-and-swap"),Fc.forEach(n),$t.forEach(n),Nt.forEach(n),xo=d(tn),Pn=o(tn,"LI",{});var Kc=s(Pn);_=o(Kc,"P",{});var ke=s(_);Ro=c(ke,"만약 "),An=o(ke,"CODE",{});var Qc=s(An);Bo=c(Qc,"A is synchronized before B"),Qc.forEach(n),Po=c(ke,"라면, 동기화 연산 "),In=o(ke,"CODE",{});var gc=s(In);Ao=c(gc,"A"),gc.forEach(n),Io=c(ke,"가 동기화 연산 "),Sn=o(ke,"CODE",{});var er=s(Sn);So=c(er,"B"),er.forEach(n),zo=c(ke,"보다 먼저 실행되었음을 의미함"),ke.forEach(n),Kc.forEach(n),Go=d(tn),zn=o(tn,"LI",{});var nr=s(zn);Gn=o(nr,"P",{});var ar=s(Gn);qo=c(ar,"Sequenced-Before Relationship이 단일 고루틴에서의 일반적인 메모리 연산 순서를 정의한다면, Synchronized-Before Relationship은 여러 고루틴에서의 메모리 연산 순서를 정의할 수 있음"),ar.forEach(n),nr.forEach(n),tn.forEach(n),dt=d(a),j=o(a,"H3",{id:!0});var yc=s(j);F=o(yc,"A",{"aria-hidden":!0,tabindex:!0,href:!0});var tr=s(F);qn=o(tr,"SPAN",{class:!0}),s(qn).forEach(n),tr.forEach(n),Hn=o(yc,"STRONG",{});var or=s(Hn);Ho=c(or,"Happened-Before Relationship"),or.forEach(n),yc.forEach(n),ft=d(a),x=o(a,"UL",{});var on=s(x);Mn=o(on,"LI",{});var sr=s(Mn);Mo=c(sr,"Sequenced-Before Relationship와 Synchronized-Before Relationship의 조합"),sr.forEach(n),Uo=d(on),E=o(on,"LI",{});var W=s(E);Un=o(W,"CODE",{});var lr=s(Un);Wo=c(lr,"W"),lr.forEach(n),No=c(W,"가 메모리 쓰기 작업이고 "),Wn=o(W,"CODE",{});var cr=s(Wn);$o=c(cr,"R"),cr.forEach(n),To=c(W,"이 메모리 읽기 작업일 때, 만약 "),Nn=o(W,"CODE",{});var rr=s(Nn);Xo=c(rr,"W synchronized before R"),rr.forEach(n),Yo=c(W,"이면, "),$n=o(W,"CODE",{});var pr=s($n);Jo=c(pr,"W happened before R"),pr.forEach(n),Vo=c(W,"임"),W.forEach(n),Zo=d(on),f=o(on,"LI",{});var L=s(f);Tn=o(L,"CODE",{});var ir=s(Tn);jo=c(ir,"X"),ir.forEach(n),Fo=c(L,"가 메모리 쓰기 작업이고 "),Xn=o(L,"CODE",{});var ur=s(Xn);Ko=c(ur,"Y"),ur.forEach(n),Qo=c(L,"이 메모리 읽기 작업일 때, 만약 "),Yn=o(L,"CODE",{});var dr=s(Yn);go=c(dr,"X sequenced before W"),dr.forEach(n),es=c(L,"이고 "),Jn=o(L,"CODE",{});var fr=s(Jn);ns=c(fr,"Y is sequenced after R"),fr.forEach(n),as=c(L,"이면, "),Vn=o(L,"CODE",{});var hr=s(Vn);ts=c(hr,"X happened before Y"),hr.forEach(n),os=c(L,"임"),L.forEach(n),on.forEach(n),ht=d(a),We=o(a,"P",{});var kr=s(We);ss=c(kr,"만약 read 및 write 연산간 happened-before relationship을 정의할 수 없다면, 이들은 동시에 일어남."),kr.forEach(n),kt=d(a),Et=o(a,"BR",{}),vt=o(a,"BR",{}),_t=d(a),K=o(a,"H2",{id:!0});var Oc=s(K);Q=o(Oc,"A",{"aria-hidden":!0,tabindex:!0,href:!0});var Er=s(Q);Zn=o(Er,"SPAN",{class:!0}),s(Zn).forEach(n),Er.forEach(n),ls=c(Oc,"Golang의 동기화 모델"),Oc.forEach(n),mt=d(a),Ne=o(a,"P",{});var vr=s(Ne);cs=c(vr,"앞선 Happened-Before Relationship을 통해 Go의 동기화 모델을 확인할 수 있음."),vr.forEach(n),bt=d(a),g=o(a,"H3",{id:!0});var Lc=s(g);ee=o(Lc,"A",{"aria-hidden":!0,tabindex:!0,href:!0});var _r=s(ee);jn=o(_r,"SPAN",{class:!0}),s(jn).forEach(n),_r.forEach(n),rs=c(Lc,"패키지 초기화"),Lc.forEach(n),yt=d(a),$e=o(a,"UL",{});var mr=s($e);I=o(mr,"LI",{});var sn=s(I);ps=c(sn,"패키지 A가 다른 패키지 B를 임포트한다면, 패키지 B의 "),Fn=o(sn,"CODE",{});var br=s(Fn);is=c(br,"init()"),br.forEach(n),us=c(sn," 함수가 패키지 A의 "),Kn=o(sn,"CODE",{});var yr=s(Kn);ds=c(yr,"init()"),yr.forEach(n),fs=c(sn," 함수보다 먼저 실행됨"),sn.forEach(n),mr.forEach(n),Ot=d(a),ne=o(a,"H3",{id:!0});var wc=s(ne);ae=o(wc,"A",{"aria-hidden":!0,tabindex:!0,href:!0});var Or=s(ae);Qn=o(Or,"SPAN",{class:!0}),s(Qn).forEach(n),Or.forEach(n),hs=c(wc,"고루틴"),wc.forEach(n),Lt=d(a),Te=o(a,"UL",{});var Lr=s(Te);m=o(Lr,"LI",{});var Ee=s(m);S=o(Ee,"P",{});var ln=s(S);ks=c(ln,"프로그램이 고루틴을 생성할 때, "),gn=o(ln,"CODE",{});var wr=s(gn);Es=c(wr,"go"),wr.forEach(n),vs=c(ln," 문은 고루틴 실행 이전에 동기화됨 ("),ea=o(ln,"CODE",{});var Dr=s(ea);_s=c(Dr,"go"),Dr.forEach(n),ms=c(ln," statement is synchronized before the start of goroutine’s execution)"),ln.forEach(n),bs=d(Ee),na=o(Ee,"UL",{});var Cr=s(na);Oe=o(Cr,"LI",{});var Tt=s(Oe);ys=c(Tt,"다음의 예시 코드는 항상 "),aa=o(Tt,"CODE",{});var xr=s(aa);Os=c(xr,"Before goroutine"),xr.forEach(n),Ls=c(Tt,"을 출력함"),Tt.forEach(n),Cr.forEach(n),ws=d(Ee),Xe=o(Ee,"PRE",{class:!0});var Pp=s(Xe);Pp.forEach(n),Ds=d(Ee),ta=o(Ee,"UL",{});var Rr=s(ta);oa=o(Rr,"LI",{});var Br=s(oa);Cs=c(Br,"하지만 고루팀이 종료될 때 명시적인 방식으로 통신을 하지 않는 이상, 고루틴의 종료 시점은 동기화되지 않음"),Br.forEach(n),Rr.forEach(n),Ee.forEach(n),Lr.forEach(n),wt=d(a),te=o(a,"H3",{id:!0});var Dc=s(te);oe=o(Dc,"A",{"aria-hidden":!0,tabindex:!0,href:!0});var Pr=s(oe);sa=o(Pr,"SPAN",{class:!0}),s(sa).forEach(n),Pr.forEach(n),xs=c(Dc,"채널"),Dc.forEach(n),Dt=d(a),R=o(a,"UL",{});var cn=s(R);la=o(cn,"LI",{});var Ar=s(la);ca=o(Ar,"P",{});var Ir=s(ca);Rs=c(Ir,"unbuffered channel을 통해 전송되는 send 및 close 연산은 채널의 receive 연산과 동기화됨 (send or close is synchronized before the receive)"),Ir.forEach(n),Ar.forEach(n),Bs=d(cn),Le=o(cn,"LI",{});var Xt=s(Le);ra=o(Xt,"P",{});var Sr=s(ra);Ps=c(Sr,"buffered channel을 통해 전송되는 send 및 close 연산은 채널의 receive 연산과 동기화됨(receive is synchronized before the send or close)"),Sr.forEach(n),As=d(Xt),pa=o(Xt,"UL",{});var zr=s(pa);ia=o(zr,"LI",{});var Gr=s(ia);Is=c(Gr,"syncrhonized before이면 happened before임"),Gr.forEach(n),zr.forEach(n),Xt.forEach(n),Ss=d(cn),z=o(cn,"LI",{});var rn=s(z);we=o(rn,"P",{});var Yt=s(we);zs=c(Yt,"다음의 예시 코드는 항상 "),ua=o(Yt,"CODE",{});var qr=s(ua);Gs=c(qr,"1"),qr.forEach(n),qs=c(Yt,"을 출력함"),Yt.forEach(n),Hs=d(rn),Ye=o(rn,"PRE",{class:!0});var Ap=s(Ye);Ap.forEach(n),Ms=d(rn),b=o(rn,"UL",{});var ve=s(b);De=o(ve,"LI",{});var Jt=s(De);da=o(Jt,"CODE",{});var Hr=s(da);Us=c(Hr,"x = 1"),Hr.forEach(n),Ws=c(Jt," is sequenced before "),fa=o(Jt,"CODE",{});var Mr=s(fa);Ns=c(Mr,"<-ch"),Mr.forEach(n),Jt.forEach(n),$s=d(ve),Ce=o(ve,"LI",{});var Vt=s(Ce);ha=o(Vt,"CODE",{});var Ur=s(ha);Ts=c(Ur,"<-ch"),Ur.forEach(n),Xs=c(Vt," is synchronized before "),ka=o(Vt,"CODE",{});var Wr=s(ka);Ys=c(Wr,"ch <- 0"),Wr.forEach(n),Vt.forEach(n),Js=d(ve),xe=o(ve,"LI",{});var Zt=s(xe);Ea=o(Zt,"CODE",{});var Nr=s(Ea);Vs=c(Nr,"ch <- 0"),Nr.forEach(n),Zs=c(Zt," is sequenced before "),va=o(Zt,"CODE",{});var $r=s(va);js=c($r,"fmt.Println(x)"),$r.forEach(n),Zt.forEach(n),Fs=d(ve),se=o(ve,"LI",{});var Qa=s(se);Ks=c(Qa,"따라서, "),_a=o(Qa,"CODE",{});var Tr=s(_a);Qs=c(Tr,"x = 1"),Tr.forEach(n),gs=c(Qa," is happened before "),ma=o(Qa,"CODE",{});var Xr=s(ma);el=c(Xr,"fmt.Println(x)"),Xr.forEach(n),Qa.forEach(n),ve.forEach(n),rn.forEach(n),cn.forEach(n),Ct=d(a),le=o(a,"H3",{id:!0});var Cc=s(le);ce=o(Cc,"A",{"aria-hidden":!0,tabindex:!0,href:!0});var Yr=s(ce);ba=o(Yr,"SPAN",{class:!0}),s(ba).forEach(n),Yr.forEach(n),nl=c(Cc,"뮤텍스"),Cc.forEach(n),xt=d(a),Je=o(a,"UL",{});var Jr=s(Je);G=o(Jr,"LI",{});var pn=s(G);ya=o(pn,"P",{});var Vr=s(ya);al=c(Vr,"두 고루틴 A와 B가 있을 때 A가 먼저 획득한 뮤텍스를 unlock하면 B가 뮤텍스를 lock할 수 있음."),Vr.forEach(n),tl=d(pn),Re=o(pn,"UL",{});var jt=s(Re);Oa=o(jt,"LI",{});var Zr=s(Oa);ol=c(Zr,"이 때 unlock은 lock보다 먼저 동기화됨 (unlock is synchronized before the lock)"),Zr.forEach(n),sl=d(jt),Be=o(jt,"LI",{});var Ft=s(Be);ll=c(Ft,"다음의 예시 코드는 항상 "),La=o(Ft,"CODE",{});var jr=s(La);cl=c(jr,"1"),jr.forEach(n),rl=c(Ft,"을 출력함"),Ft.forEach(n),jt.forEach(n),pl=d(pn),Ve=o(pn,"PRE",{class:!0});var Ip=s(Ve);Ip.forEach(n),pn.forEach(n),Jr.forEach(n),Rt=d(a),re=o(a,"H3",{id:!0});var xc=s(re);pe=o(xc,"A",{"aria-hidden":!0,tabindex:!0,href:!0});var Fr=s(pe);wa=o(Fr,"SPAN",{class:!0}),s(wa).forEach(n),Fr.forEach(n),il=c(xc,"Atomic 연산"),xc.forEach(n),Bt=d(a),B=o(a,"UL",{});var un=s(B);Da=o(un,"LI",{});var Kr=s(Da);Ze=o(Kr,"P",{});var Rc=s(Ze);Ca=o(Rc,"CODE",{});var Qr=s(Ca);ul=c(Qr,"sync/atomic"),Qr.forEach(n),dl=c(Rc," 패키지는 저수준의 원자적 메모리 읽기/쓰기 연산을 제공함"),Rc.forEach(n),Kr.forEach(n),fl=d(un),xa=o(un,"LI",{});var gr=s(xa);Ra=o(gr,"P",{});var ep=s(Ra);hl=c(ep,"만약 atomic write의 결과가 atomic read에서 확인된다면, atomic write는 atomic read보다 먼저 동기화됨 (atomic write is synchronized before the atomic read)"),ep.forEach(n),gr.forEach(n),kl=d(un),Pe=o(un,"LI",{});var Kt=s(Pe);Ba=o(Kt,"P",{});var np=s(Ba);El=c(np,"다음의 코드는 항상 1을 출력함"),np.forEach(n),vl=d(Kt),je=o(Kt,"PRE",{class:!0});var Sp=s(je);Sp.forEach(n),Kt.forEach(n),un.forEach(n),Pt=d(a),ie=o(a,"H3",{id:!0});var Bc=s(ie);ue=o(Bc,"A",{"aria-hidden":!0,tabindex:!0,href:!0});var ap=s(ue);Pa=o(ap,"SPAN",{class:!0}),s(Pa).forEach(n),ap.forEach(n),_l=c(Bc,"Map, Once, WaitGroup"),Bc.forEach(n),At=d(a),P=o(a,"UL",{});var dn=s(P);Ae=o(dn,"LI",{});var Qt=s(Ae);Fe=o(Qt,"P",{});var Pc=s(Fe);Aa=o(Pc,"CODE",{});var tp=s(Aa);ml=c(tp,"sync.Map"),tp.forEach(n),bl=c(Pc,"은 별도로 뮤텍스 로직을 구현하지 않아도 안전하게 사용할 수 있는 thread-safe map 타입임"),Pc.forEach(n),yl=d(Qt),y=o(Qt,"UL",{});var _e=s(y);q=o(_e,"LI",{});var fn=s(q);Ol=c(fn,"데이터가 한번 write되지만 여러 번 read되는 경우나 여러 고루틴이 각각의 키로 접근하는 경우, 일반 "),Ia=o(fn,"CODE",{});var op=s(Ia);Ll=c(op,"map"),op.forEach(n),wl=c(fn,"에 뮤텍스를 사용하여 구현하는 것보다 "),Sa=o(fn,"CODE",{});var sp=s(Sa);Dl=c(sp,"sync.Map"),sp.forEach(n),Cl=c(fn,"을 사용하는 것이 더 좋은 성능을 보임"),fn.forEach(n),xl=d(_e),H=o(_e,"LI",{});var hn=s(H);Rl=c(hn,"하지만 "),za=o(hn,"CODE",{});var lp=s(za);Bl=c(lp,"sync.Map"),lp.forEach(n),Pl=c(hn,"은 "),Ga=o(hn,"CODE",{});var cp=s(Ga);Al=c(cp,"map"),cp.forEach(n),Il=c(hn,"과 달리 타입 안정성을 보장하지 않음"),hn.forEach(n),Sl=d(_e),qa=o(_e,"LI",{});var rp=s(qa);zl=c(rp,"간단하게 캐시같은거 구현할 때 사용하면 좋다고 함"),rp.forEach(n),Gl=d(_e),Ke=o(_e,"LI",{});var Ac=s(Ke);Ha=o(Ac,"CODE",{});var pp=s(Ha);ql=c(pp,"sync.Map"),pp.forEach(n),Hl=c(Ac,"에서 어떤 read 연산이 write 연산의 결과를 확인한다면, write 연산은 read 연산보다 먼저 발생함 (write is happened before the read)"),Ac.forEach(n),_e.forEach(n),Qt.forEach(n),Ml=d(dn),Ie=o(dn,"LI",{});var gt=s(Ie);Qe=o(gt,"P",{});var Ic=s(Qe);Ma=o(Ic,"CODE",{});var ip=s(Ma);Ul=c(ip,"sync.Once"),ip.forEach(n),Wl=c(Ic,"는 여러 고루틴에서 무언가를 초기화하고자 할 때 유용함"),Ic.forEach(n),Nl=d(gt),M=o(gt,"UL",{});var kn=s(M);ge=o(kn,"LI",{});var Sc=s(ge);Ua=o(Sc,"CODE",{});var up=s(Ua);$l=c(up,"sync.Once.Do()"),up.forEach(n),Tl=c(Sc,"를 호출하여 함수를 넘기면 초기화가 실행됨"),Sc.forEach(n),Xl=d(kn),Se=o(kn,"LI",{});var eo=s(Se);Yl=c(eo,"여러 고루틴에서 "),Wa=o(eo,"CODE",{});var dp=s(Wa);Jl=c(dp,"sync.Once.Do()"),dp.forEach(n),Vl=c(eo,"를 호출하더라도, 초기화 함수는 한 번만 실행되고, 다른 고루틴에서는 초기화 함수가 실행되지 않고 block되었다가 초기화 함수가 실행된 후에 unblock됨"),eo.forEach(n),Zl=d(kn),O=o(kn,"LI",{});var me=s(O);jl=c(me,"한 고루틴에서 "),Na=o(me,"CODE",{});var fp=s(Na);Fl=c(fp,"sync.Once.Do()"),fp.forEach(n),Kl=c(me,"를 호출하면 다른 고루틴에서 "),$a=o(me,"CODE",{});var hp=s($a);Ql=c(hp,"sync.Once.Do()"),hp.forEach(n),gl=c(me,"가 끝나기 이전에 그 초기화 함수가 종료됨 (the completion of initialization function is happened before the return from "),Ta=o(me,"CODE",{});var kp=s(Ta);ec=c(kp,"sync.Once.Do()"),kp.forEach(n),nc=c(me,")"),me.forEach(n),kn.forEach(n),gt.forEach(n),ac=d(dn),Xa=o(dn,"LI",{});var Ep=s(Xa);h=o(Ep,"P",{});var w=s(h);Ya=o(w,"CODE",{});var vp=s(Ya);tc=c(vp,"sync.WaitGroup"),vp.forEach(n),oc=c(w,"의 모든 "),Ja=o(w,"CODE",{});var _p=s(Ja);sc=c(_p,"Done()"),_p.forEach(n),lc=c(w," 메소드 호출은 "),Va=o(w,"CODE",{});var mp=s(Va);cc=c(mp,"Wait()"),mp.forEach(n),rc=c(w," 메소드의 반환 이전에 동기화됨 (the completion of "),Za=o(w,"CODE",{});var bp=s(Za);pc=c(bp,"Done()"),bp.forEach(n),ic=c(w," is happened before the return from "),ja=o(w,"CODE",{});var yp=s(ja);uc=c(yp,"Wait()"),yp.forEach(n),dc=c(w,")"),w.forEach(n),Ep.forEach(n),dn.forEach(n),It=d(a),St=o(a,"BR",{}),zt=o(a,"BR",{}),Gt=d(a),de=o(a,"H2",{id:!0});var zc=s(de);fe=o(zc,"A",{"aria-hidden":!0,tabindex:!0,href:!0});var Op=s(fe);Fa=o(Op,"SPAN",{class:!0}),s(Fa).forEach(n),Op.forEach(n),fc=c(zc,"References"),zc.forEach(n),qt=d(a),Ht=o(a,"HR",{}),Mt=d(a),en=o(a,"CENTER",{});var Lp=s(en);U=o(Lp,"P",{});var En=s(U);ze=o(En,"A",{href:!0,rel:!0});var wp=s(ze);nn=o(wp,"IMG",{src:!0,alt:!0}),wp.forEach(n),hc=d(En),kc=o(En,"BR",{}),Ec=d(En),Ge=o(En,"A",{href:!0,rel:!0});var Dp=s(Ge);vc=c(Dp,"Jon Bodner, 『Learning Go』, O’Reilly Media, Inc."),Dp.forEach(n),En.forEach(n),Lp.forEach(n),this.h()},h(){i(vn,"class","icon icon-link"),i(X,"aria-hidden","true"),i(X,"tabindex","-1"),i(X,"href","#메모리-연산-순서-모델"),i(T,"id","메모리-연산-순서-모델"),i(_n,"class","icon icon-link"),i(J,"aria-hidden","true"),i(J,"tabindex","-1"),i(J,"href","#sequenced-before-relationship"),i(Y,"id","sequenced-before-relationship"),i(Dn,"class","icon icon-link"),i(Z,"aria-hidden","true"),i(Z,"tabindex","-1"),i(Z,"href","#synchronized-before-relationship"),i(V,"id","synchronized-before-relationship"),i(qn,"class","icon icon-link"),i(F,"aria-hidden","true"),i(F,"tabindex","-1"),i(F,"href","#happened-before-relationship"),i(j,"id","happened-before-relationship"),i(Zn,"class","icon icon-link"),i(Q,"aria-hidden","true"),i(Q,"tabindex","-1"),i(Q,"href","#golang의-동기화-모델"),i(K,"id","golang의-동기화-모델"),i(jn,"class","icon icon-link"),i(ee,"aria-hidden","true"),i(ee,"tabindex","-1"),i(ee,"href","#패키지-초기화"),i(g,"id","패키지-초기화"),i(Qn,"class","icon icon-link"),i(ae,"aria-hidden","true"),i(ae,"tabindex","-1"),i(ae,"href","#고루틴"),i(ne,"id","고루틴"),i(Xe,"class","language-go"),i(sa,"class","icon icon-link"),i(oe,"aria-hidden","true"),i(oe,"tabindex","-1"),i(oe,"href","#채널"),i(te,"id","채널"),i(Ye,"class","language-go"),i(ba,"class","icon icon-link"),i(ce,"aria-hidden","true"),i(ce,"tabindex","-1"),i(ce,"href","#뮤텍스"),i(le,"id","뮤텍스"),i(Ve,"class","language-go"),i(wa,"class","icon icon-link"),i(pe,"aria-hidden","true"),i(pe,"tabindex","-1"),i(pe,"href","#atomic-연산"),i(re,"id","atomic-연산"),i(je,"class","language-go"),i(Pa,"class","icon icon-link"),i(ue,"aria-hidden","true"),i(ue,"tabindex","-1"),i(ue,"href","#map-once-waitgroup"),i(ie,"id","map-once-waitgroup"),i(Fa,"class","icon icon-link"),i(fe,"aria-hidden","true"),i(fe,"tabindex","-1"),i(fe,"href","#references"),i(de,"id","references"),Up(nn.src,Gc="https://learning.oreilly.com/covers/urn:orm:book:9781804619070/400w/")||i(nn,"src",Gc),i(nn,"alt","Effective Concurrency in Go"),i(ze,"href","https://learning.oreilly.com/library/view/effective-concurrency-in/9781804619070/"),i(ze,"rel","nofollow"),i(Ge,"href","https://learning.oreilly.com/library/view/effective-concurrency-in/9781804619070/"),i(Ge,"rel","nofollow")},m(a,r){p(a,k,r),e(k,A),p(a,qe,r),p(a,He,r),e(He,ao),p(a,ga,r),p(a,N,r),e(N,to),Wp($,N,null),e(N,oo),p(a,et,r),p(a,Me,r),e(Me,so),p(a,nt,r),p(a,Ue,r),e(Ue,lo),p(a,at,r),p(a,tt,r),p(a,ot,r),p(a,st,r),p(a,T,r),e(T,X),e(X,vn),e(T,co),p(a,lt,r),p(a,ct,r),p(a,rt,r),p(a,Y,r),e(Y,J),e(J,_n),e(Y,mn),e(mn,ro),p(a,pt,r),p(a,D,r),e(D,v),e(v,po),e(v,bn),e(bn,io),e(v,uo),e(v,yn),e(yn,fo),e(v,ho),e(v,On),e(On,ko),e(v,Eo),e(D,vo),e(D,Ln),e(Ln,_o),e(D,mo),e(D,wn),e(wn,bo),p(a,it,r),p(a,V,r),e(V,Z),e(Z,Dn),e(V,Cn),e(Cn,yo),p(a,ut,r),p(a,C,r),e(C,be),e(be,xn),e(xn,Oo),e(be,Lo),e(be,ye),e(ye,Rn),e(Rn,wo),e(ye,Do),e(ye,Bn),e(Bn,Co),e(C,xo),e(C,Pn),e(Pn,_),e(_,Ro),e(_,An),e(An,Bo),e(_,Po),e(_,In),e(In,Ao),e(_,Io),e(_,Sn),e(Sn,So),e(_,zo),e(C,Go),e(C,zn),e(zn,Gn),e(Gn,qo),p(a,dt,r),p(a,j,r),e(j,F),e(F,qn),e(j,Hn),e(Hn,Ho),p(a,ft,r),p(a,x,r),e(x,Mn),e(Mn,Mo),e(x,Uo),e(x,E),e(E,Un),e(Un,Wo),e(E,No),e(E,Wn),e(Wn,$o),e(E,To),e(E,Nn),e(Nn,Xo),e(E,Yo),e(E,$n),e($n,Jo),e(E,Vo),e(x,Zo),e(x,f),e(f,Tn),e(Tn,jo),e(f,Fo),e(f,Xn),e(Xn,Ko),e(f,Qo),e(f,Yn),e(Yn,go),e(f,es),e(f,Jn),e(Jn,ns),e(f,as),e(f,Vn),e(Vn,ts),e(f,os),p(a,ht,r),p(a,We,r),e(We,ss),p(a,kt,r),p(a,Et,r),p(a,vt,r),p(a,_t,r),p(a,K,r),e(K,Q),e(Q,Zn),e(K,ls),p(a,mt,r),p(a,Ne,r),e(Ne,cs),p(a,bt,r),p(a,g,r),e(g,ee),e(ee,jn),e(g,rs),p(a,yt,r),p(a,$e,r),e($e,I),e(I,ps),e(I,Fn),e(Fn,is),e(I,us),e(I,Kn),e(Kn,ds),e(I,fs),p(a,Ot,r),p(a,ne,r),e(ne,ae),e(ae,Qn),e(ne,hs),p(a,Lt,r),p(a,Te,r),e(Te,m),e(m,S),e(S,ks),e(S,gn),e(gn,Es),e(S,vs),e(S,ea),e(ea,_s),e(S,ms),e(m,bs),e(m,na),e(na,Oe),e(Oe,ys),e(Oe,aa),e(aa,Os),e(Oe,Ls),e(m,ws),e(m,Xe),Xe.innerHTML=Cp,e(m,Ds),e(m,ta),e(ta,oa),e(oa,Cs),p(a,wt,r),p(a,te,r),e(te,oe),e(oe,sa),e(te,xs),p(a,Dt,r),p(a,R,r),e(R,la),e(la,ca),e(ca,Rs),e(R,Bs),e(R,Le),e(Le,ra),e(ra,Ps),e(Le,As),e(Le,pa),e(pa,ia),e(ia,Is),e(R,Ss),e(R,z),e(z,we),e(we,zs),e(we,ua),e(ua,Gs),e(we,qs),e(z,Hs),e(z,Ye),Ye.innerHTML=xp,e(z,Ms),e(z,b),e(b,De),e(De,da),e(da,Us),e(De,Ws),e(De,fa),e(fa,Ns),e(b,$s),e(b,Ce),e(Ce,ha),e(ha,Ts),e(Ce,Xs),e(Ce,ka),e(ka,Ys),e(b,Js),e(b,xe),e(xe,Ea),e(Ea,Vs),e(xe,Zs),e(xe,va),e(va,js),e(b,Fs),e(b,se),e(se,Ks),e(se,_a),e(_a,Qs),e(se,gs),e(se,ma),e(ma,el),p(a,Ct,r),p(a,le,r),e(le,ce),e(ce,ba),e(le,nl),p(a,xt,r),p(a,Je,r),e(Je,G),e(G,ya),e(ya,al),e(G,tl),e(G,Re),e(Re,Oa),e(Oa,ol),e(Re,sl),e(Re,Be),e(Be,ll),e(Be,La),e(La,cl),e(Be,rl),e(G,pl),e(G,Ve),Ve.innerHTML=Rp,p(a,Rt,r),p(a,re,r),e(re,pe),e(pe,wa),e(re,il),p(a,Bt,r),p(a,B,r),e(B,Da),e(Da,Ze),e(Ze,Ca),e(Ca,ul),e(Ze,dl),e(B,fl),e(B,xa),e(xa,Ra),e(Ra,hl),e(B,kl),e(B,Pe),e(Pe,Ba),e(Ba,El),e(Pe,vl),e(Pe,je),je.innerHTML=Bp,p(a,Pt,r),p(a,ie,r),e(ie,ue),e(ue,Pa),e(ie,_l),p(a,At,r),p(a,P,r),e(P,Ae),e(Ae,Fe),e(Fe,Aa),e(Aa,ml),e(Fe,bl),e(Ae,yl),e(Ae,y),e(y,q),e(q,Ol),e(q,Ia),e(Ia,Ll),e(q,wl),e(q,Sa),e(Sa,Dl),e(q,Cl),e(y,xl),e(y,H),e(H,Rl),e(H,za),e(za,Bl),e(H,Pl),e(H,Ga),e(Ga,Al),e(H,Il),e(y,Sl),e(y,qa),e(qa,zl),e(y,Gl),e(y,Ke),e(Ke,Ha),e(Ha,ql),e(Ke,Hl),e(P,Ml),e(P,Ie),e(Ie,Qe),e(Qe,Ma),e(Ma,Ul),e(Qe,Wl),e(Ie,Nl),e(Ie,M),e(M,ge),e(ge,Ua),e(Ua,$l),e(ge,Tl),e(M,Xl),e(M,Se),e(Se,Yl),e(Se,Wa),e(Wa,Jl),e(Se,Vl),e(M,Zl),e(M,O),e(O,jl),e(O,Na),e(Na,Fl),e(O,Kl),e(O,$a),e($a,Ql),e(O,gl),e(O,Ta),e(Ta,ec),e(O,nc),e(P,ac),e(P,Xa),e(Xa,h),e(h,Ya),e(Ya,tc),e(h,oc),e(h,Ja),e(Ja,sc),e(h,lc),e(h,Va),e(Va,cc),e(h,rc),e(h,Za),e(Za,pc),e(h,ic),e(h,ja),e(ja,uc),e(h,dc),p(a,It,r),p(a,St,r),p(a,zt,r),p(a,Gt,r),p(a,de,r),e(de,fe),e(fe,Fa),e(de,fc),p(a,qt,r),p(a,Ht,r),p(a,Mt,r),p(a,en,r),e(en,U),e(U,ze),e(ze,nn),e(U,hc),e(U,kc),e(U,Ec),e(U,Ge),e(Ge,vc),Ut=!0},p(a,[r]){const Ka={};r&1&&(Ka.$$scope={dirty:r,ctx:a}),$.$set(Ka)},i(a){Ut||(Np($.$$.fragment,a),Ut=!0)},o(a){$p($.$$.fragment,a),Ut=!1},d(a){a&&n(k),a&&n(qe),a&&n(He),a&&n(ga),a&&n(N),Tp($),a&&n(et),a&&n(Me),a&&n(nt),a&&n(Ue),a&&n(at),a&&n(tt),a&&n(ot),a&&n(st),a&&n(T),a&&n(lt),a&&n(ct),a&&n(rt),a&&n(Y),a&&n(pt),a&&n(D),a&&n(it),a&&n(V),a&&n(ut),a&&n(C),a&&n(dt),a&&n(j),a&&n(ft),a&&n(x),a&&n(ht),a&&n(We),a&&n(kt),a&&n(Et),a&&n(vt),a&&n(_t),a&&n(K),a&&n(mt),a&&n(Ne),a&&n(bt),a&&n(g),a&&n(yt),a&&n($e),a&&n(Ot),a&&n(ne),a&&n(Lt),a&&n(Te),a&&n(wt),a&&n(te),a&&n(Dt),a&&n(R),a&&n(Ct),a&&n(le),a&&n(xt),a&&n(Je),a&&n(Rt),a&&n(re),a&&n(Bt),a&&n(B),a&&n(Pt),a&&n(ie),a&&n(At),a&&n(P),a&&n(It),a&&n(St),a&&n(zt),a&&n(Gt),a&&n(de),a&&n(qt),a&&n(Ht),a&&n(Mt),a&&n(en)}}}const jp={title:"Go의 메모리 모델",date:"2023-08-31T00:00:00.000Z",excerpt:"Go의 메모리 모델",categories:["Golang","Concurrency in Go"],coverImage:"/post_img/Go/Concurrency in Go/cover.png",coverWidth:16,coverHeight:9,indexed:!1,exposed:!0};class Fp extends zp{constructor(k){super(),Gp(this,k,null,Jp,qp,{})}}export{Fp as default,jp as metadata};
