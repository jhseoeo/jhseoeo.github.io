import{S as o1,i as n1,s as s1,k as a,q as s,a as i,y as Ff,l as o,m as n,r,h as l,c,z as Kf,n as f,b as p,E as e,A as Qf,g as Jf,d as Xf,B as Yf}from"./index.d78780bf.js";import{H as r1}from"./Highlight.1019e7a6.js";import{I as i1}from"./Image.605b14b5.js";function c1($n){let d;return{c(){d=s("Mutual Exclusion")},l(w){d=r(w,"Mutual Exclusion")},m(w,ol){p(w,d,ol)},d(w){w&&l(d)}}}function u1($n){let d,w,ol,q,Tl,Nn,Tn,Vl,Vn,oo,no,so,z,jn,We,qn,zn,ro,nl,Fn,io,co,uo,po,F,K,jl,Kn,fo,ho,Eo,Q,J,ql,Qn,vo,I,we,zl,Jn,Xn,h,Fl,Yn,Zn,Kl,gn,es,Ql,ls,ts,Jl,as,os,Xl,ns,ss,De,Yl,rs,is,Zl,gl,cs,us,Ae,et,ps,fs,lt,tt,ds,_o,X,Y,at,hs,ko,x,ot,nt,Es,vs,Be,st,_s,ks,He,D,Ls,rt,bs,ms,it,Cs,Is,xs,ct,ys,Rs,$e,ut,Gs,Ss,Ne,pt,Ps,Os,sl,ft,Us,Ms,Lo,Z,g,dt,Ws,bo,rl,il,ws,ht,cl,Ds,Et,vt,As,mo,Co,Io,xo,ee,le,_t,Bs,yo,Ro,Go,te,ae,kt,Hs,So,y,Lt,bt,$s,Ns,mt,Ct,Ts,Vs,k,It,js,qs,xt,yt,zs,Fs,ul,Zf=`<code class="language-go"><span class="token keyword">if</span> <span class="token function">len</span><span class="token punctuation">(</span>ch<span class="token punctuation">)</span> <span class="token operator">></span> <span class="token number">0</span> <span class="token punctuation">&#123;</span>
  x <span class="token operator">:=</span> <span class="token operator">&lt;-</span>ch
<span class="token punctuation">&#125;</span></code>`,Ks,A,Rt,Qs,Js,Gt,Xs,Ys,St,Zs,Po,oe,ne,Pt,gs,Oo,v,pl,er,Ot,Ut,lr,tr,se,ar,Mt,or,nr,Wt,wt,sr,rr,fl,ir,Dt,At,cr,ur,Bt,pr,Uo,re,ie,Ht,fr,Mo,ce,B,dr,$t,hr,Er,Nt,vr,_r,kr,R,Lr,Tt,br,mr,Vt,Cr,Ir,Te,dl,xr,Ve,jt,yr,Rr,qt,Gr,Sr,hl,Pr,zt,Ft,Or,Wo,ue,pe,Kt,Ur,wo,G,je,Qt,Mr,Wr,qe,Jt,wr,Dr,Xt,Ar,Br,L,fe,Yt,Hr,$r,Zt,Nr,Tr,Vr,ze,gt,jr,qr,Fe,zr,ea,Fr,Kr,Qr,El,gf=`<code class="language-go"><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
  <span class="token keyword">var</span> i <span class="token builtin">int</span>
  f <span class="token operator">:=</span> <span class="token keyword">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    i<span class="token operator">++</span>
    <span class="token keyword">return</span> i
  <span class="token punctuation">&#125;</span>
  ch1 <span class="token operator">:=</span> <span class="token function">make</span><span class="token punctuation">(</span><span class="token keyword">chan</span> <span class="token builtin">int</span><span class="token punctuation">)</span>
  ch2 <span class="token operator">:=</span> <span class="token function">make</span><span class="token punctuation">(</span><span class="token keyword">chan</span> <span class="token builtin">int</span><span class="token punctuation">)</span>

  <span class="token keyword">select</span> <span class="token punctuation">&#123;</span>
  <span class="token keyword">case</span> ch1 <span class="token operator">&lt;-</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
  <span class="token keyword">case</span> ch2 <span class="token operator">&lt;-</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">:</span>
  <span class="token keyword">default</span><span class="token punctuation">:</span>
  <span class="token punctuation">&#125;</span>
  fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span>
<span class="token punctuation">&#125;</span></code>`,Jr,Ke,_,la,Xr,Yr,ta,Zr,gr,aa,ei,li,oa,ti,ai,oi,na,ni,si,H,de,sa,ri,ii,ra,ci,ui,pi,vl,e1=`<code class="language-go">ch1 <span class="token operator">:=</span> <span class="token function">make</span><span class="token punctuation">(</span><span class="token keyword">chan</span> <span class="token builtin">int</span><span class="token punctuation">)</span>
ch2 <span class="token operator">:=</span> <span class="token function">make</span><span class="token punctuation">(</span><span class="token keyword">chan</span> <span class="token builtin">int</span><span class="token punctuation">)</span>

<span class="token keyword">go</span> <span class="token keyword">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
  ch2 <span class="token operator">&lt;-</span> <span class="token number">1</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token keyword">go</span> <span class="token keyword">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
  fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token operator">&lt;-</span>ch1<span class="token punctuation">)</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">(</span><span class="token punctuation">)</span>

<span class="token keyword">select</span> <span class="token punctuation">&#123;</span>
<span class="token keyword">case</span> ch1<span class="token operator">&lt;-</span> <span class="token operator">&lt;-</span>ch2<span class="token punctuation">:</span>
  time<span class="token punctuation">.</span><span class="token function">Sleep</span><span class="token punctuation">(</span>time<span class="token punctuation">.</span>Second<span class="token punctuation">)</span>
<span class="token keyword">default</span><span class="token punctuation">:</span>
<span class="token punctuation">&#125;</span></code>`,fi,b,m,di,ia,hi,Ei,ca,vi,_i,ua,ki,Li,bi,$,mi,pa,Ci,Ii,fa,xi,yi,Ri,E,Gi,da,Si,Pi,ha,Oi,Ui,Ea,Mi,Wi,va,wi,Di,Ai,_a,Bi,Do,Ao,Bo,Ho,he,Ee,ka,Hi,$o,No,To,S,Qe,$i,ve,Ni,Ti,N,Vi,La,ji,qi,ba,zi,Fi,Ki,_l,Qi,ma,Ca,Ji,Vo,_e,ke,Ia,Xi,jo,P,xa,Yi,Zi,kl,gi,ya,Ra,ec,lc,Ll,tc,Je,Ga,ac,oc,Sa,nc,qo,zo,Fo,Ko,Le,be,Pa,sc,Qo,Jo,Xo,O,Oa,rc,ic,Ua,cc,uc,bl,pc,Xe,Ye,fc,Ma,dc,hc,Ec,ml,Wa,vc,_c,Yo,Zo,go,en,me,Ce,wa,kc,ln,tn,an,U,Da,Lc,bc,Aa,mc,Cc,Ba,Ic,on,Ie,Ha,$a,xc,yc,T,Na,Rc,Gc,Ta,Sc,Pc,Cl,Oc,Va,ja,Uc,nn,xe,Ze,qa,Mc,Wc,V,Il,za,wc,Dc,Ac,xl,Fa,Bc,Hc,$c,ye,Ka,Nc,Tc,Qa,Vc,jc,qc,ge,Ja,zc,Fc,Xa,Ya,Kc,sn,rn,cn,un,Re,Ge,Za,Qc,pn,fn,dn,C,ga,Jc,Xc,el,Yc,Zc,gc,hn;return ve=new r1({props:{$$slots:{default:[c1]},$$scope:{ctx:$n}}}),el=new i1({props:{alt:"Effective Concurrency in Go",src:"https://learning.oreilly.com/covers/urn:orm:book:9781804619070/400w/"}}),{c(){d=a("p"),w=s(`****---
title: Go의 동시성 지원
date: 2023-08-25
excerpt: Go에서 동시성을 지원하는 방법들
categories:`),ol=i(),q=a("ul"),Tl=a("li"),Nn=s("‘Golang’"),Tn=i(),Vl=a("li"),Vn=s(`‘Concurrency in Go’
coverImage: ‘/post_img/Go/Concurrency in Go/cover.png’
coverWidth: 16
coverHeight: 9
indexed: false
exposed: true`),oo=i(),no=a("hr"),so=i(),z=a("p"),jn=s("내용의 상당 부분이 "),We=a("a"),qn=s("https://jhseoeo.github.io/posts/post/Go/Golang%20Basics/GO10"),zn=s("의 내용과 중복되므로, 해당 포스트를 먼저 읽고 오시는 것을 추천드립니다."),ro=i(),nl=a("p"),Fn=s("해당 포스트에서 다루지 않은 내용만 중점적으로 다루려 합니다."),io=i(),co=a("br"),uo=a("br"),po=i(),F=a("h2"),K=a("a"),jl=a("span"),Kn=s("Goroutine"),fo=i(),ho=a("hr"),Eo=i(),Q=a("h3"),J=a("a"),ql=a("span"),Qn=s("Goroutine이 빠른 이유"),vo=i(),I=a("ul"),we=a("li"),zl=a("p"),Jn=s("Go 런타임은 실행될 때 기본적으로 플랫폼의 프로세서(코어) 수만큼의 쓰레드를 생성함"),Xn=i(),h=a("ul"),Fl=a("li"),Yn=s("이 쓰레드 풀 위에서 Goroutine이 실행됨"),Zn=i(),Kl=a("li"),gn=s("만약 그 이하의 쓰레드를 생성하면 CPU utilization이 떨어짐"),es=i(),Ql=a("li"),ls=s("만약 그 이상의 쓰레드를 생성하면 Time Sharing때문에 Context Switching 오버헤드가 발생"),ts=i(),Jl=a("li"),as=s("만일 고루틴이 Channel, Mutex 등에 의해 block되면 해당 고루틴을 실행시키는 쓰레드는 다른 고루틴을 실행시킴"),os=i(),Xl=a("li"),ns=s("만일 고루틴이 동기 I/O에 의해 block되면 해당 고루틴을 실행시키는 쓰레드 자체가 block되므로, 새로운 쓰레드를 생성하거나 기존의 쓰레드를 재사용하여 다른 고루틴을 실행시킴"),ss=i(),De=a("li"),Yl=a("p"),rs=s("Go Scheduler는 user space에 있기 때문에 OS Thread를 사용하는 것보다 오버헤드가 적음"),is=i(),Zl=a("ul"),gl=a("li"),cs=s("따라서 쓰레드 생성 및 관리에 대한 오버헤드가 적음"),us=i(),Ae=a("li"),et=a("p"),ps=s("Goroutine은 OS Thread보다 훨씬 적은 메모리를 사용함"),fs=i(),lt=a("ul"),tt=a("li"),ds=s("Goroutine의 Stack 크기는 2KB 정도인 반면, OS Thread의 Stack 크기는 MB 단위임"),_o=i(),X=a("h3"),Y=a("a"),at=a("span"),hs=s("Goroutine의 특징"),ko=i(),x=a("ul"),ot=a("li"),nt=a("p"),Es=s("OS Thread는 스케줄링 우선순위가 존재하지만, Goroutine은 존재하지 않음(Starvation이 발생하는 고루틴을 우선 선택하는 스케줄링 알고리즘이 있긴 하지만, 이를 지향하지는 않음)"),vs=i(),Be=a("li"),st=a("p"),_s=s("Go 프로그램을 실행시키면 main 고루틴과 가비지 컬렉터 고루틴이 생성됨"),ks=i(),He=a("ul"),D=a("li"),Ls=s("main 고루틴은 "),rt=a("code"),bs=s("main"),ms=s(" 패키지의 "),it=a("code"),Cs=s("main"),Is=s(" 함수에서 생성됨"),xs=i(),ct=a("li"),ys=s("main 함수가 종료되면 모든 고루틴이 종료되고 프로그램이 종료됨"),Rs=i(),$e=a("li"),ut=a("p"),Gs=s("Goroutine을 일시정지 혹은 종료시키는 magic function은 없음"),Ss=i(),Ne=a("ul"),pt=a("li"),Ps=s("고루틴이 중단되어야 함을 정의하는 message 또는 flag를 사용하는 것이 일반적"),Os=i(),sl=a("li"),ft=a("code"),Us=s("panic"),Ms=s("은 고루틴을 종료시킬 수 있음. panic이 발생한 해당 고루틴이 종료됨"),Lo=i(),Z=a("h3"),g=a("a"),dt=a("span"),Ws=s("Closure"),bo=i(),rl=a("ul"),il=a("li"),ws=s("어떤 익명 함수가 그 함수 내부 컨텍스트에 있는 변수를 참조하면, 그 익명 함수를 클로저(Closure)라고 함"),ht=a("ul"),cl=a("li"),Ds=s("클로저가 참조하는 로컬 변수는 stack에서 heap으로 옮겨짐(escape to heap)"),Et=a("ul"),vt=a("li"),As=s("stack에 저장되면 함수가 종료되면서 로컬 변수가 사라지기 때문"),mo=i(),Co=a("br"),Io=a("br"),xo=i(),ee=a("h2"),le=a("a"),_t=a("span"),Bs=s("Channel"),yo=i(),Ro=a("hr"),Go=i(),te=a("h3"),ae=a("a"),kt=a("span"),Hs=s("Channel의 length와 capacity"),So=i(),y=a("ul"),Lt=a("li"),bt=a("p"),$s=s("Channel은 내부적으로 FIFO 큐로 구현되어 있음"),Ns=i(),mt=a("li"),Ct=a("p"),Ts=s("Channel의 capacity는 채널 버퍼의 크기를 의미함"),Vs=i(),k=a("li"),It=a("p"),js=s("Channel의 length는 현재 큐에 들어있는 element의 개수를 의미함"),qs=i(),xt=a("ul"),yt=a("li"),zs=s("아래와 같은 코드는 좋지 않음"),Fs=i(),ul=a("pre"),Ks=i(),A=a("ul"),Rt=a("li"),Qs=s("이 코드는 ch에 element가 들어있는지 확인한 후, 들어있다면 element를 읽어옴"),Js=i(),Gt=a("li"),Xs=s("이 때 length를 가져오는 것은 데이터를 읽어오는 것과는 달리 mutual exclusive하지 않음"),Ys=i(),St=a("li"),Zs=s("따라서 데이터를 읽어오려고 할 때 채널의 값을 다른 고루틴이 이미 읽어버리는 race condition이 발생할 수도 있음"),Po=i(),oe=a("h3"),ne=a("a"),Pt=a("span"),gs=s("Channel의 close"),Oo=i(),v=a("ul"),pl=a("li"),er=s("원래 채널은 1:1 통신만 가능함."),Ot=a("ul"),Ut=a("li"),lr=s("채널에서 데이터를 읽는 고루틴이 여러 개이고 데이터를 쓰는 고루틴이 하나라면, 쓰기 고루틴이 데이터를 쓸 때 무작위로 읽기 고루틴 중 하나에게 데이터를 전송함"),tr=i(),se=a("li"),ar=s("하지만 채널을 "),Mt=a("code"),or=s("close"),nr=s("하면 해당 채널을 receive하는 모든 고루틴이 이를 감지할 수 있음"),Wt=a("ul"),wt=a("li"),sr=s("일종의 일회성 Broadcast인 셈"),rr=i(),fl=a("li"),ir=s("닫힌 채널로부터 데이터를 읽어오면 해당 타입의 zero value를 읽어옴"),Dt=a("ul"),At=a("li"),cr=s("comma ok idiom을 사용하면 닫힌 채널인지 확인할 수 있음"),ur=i(),Bt=a("li"),pr=s("닫힌 채널에 데이터를 쓰려고 하면 panic이 발생함"),Uo=i(),re=a("h3"),ie=a("a"),Ht=a("span"),fr=s("메모리 공유"),Mo=i(),ce=a("ul"),B=a("li"),dr=s("채널을 통해 전송한 데이터가 "),$t=a("code"),hr=s("int"),Er=s(", "),Nt=a("code"),vr=s("float"),_r=s(" 등의 primitive type이라면, 해당 데이터는 복사되어 전송됨"),kr=i(),R=a("li"),Lr=s("채널을 통해 전송한 데이터가 "),Tt=a("code"),br=s("slice"),mr=s(", "),Vt=a("code"),Cr=s("map"),Ir=s(" 등의 reference type이라면, 해당 데이터의 포인터 주소가 전송됨"),Te=a("ul"),dl=a("li"),xr=s("이 때 이 데이터의 ownership은 전송된 고루틴에게 넘어가지 않고 메모리는 공유됨."),Ve=a("ul"),jt=a("li"),yr=s("결과적으로 shared memory를 사용하는 것과 같은 상태가 됨"),Rr=i(),qt=a("li"),Gr=s("이 상태는 data race임."),Sr=i(),hl=a("li"),Pr=s("보통 채널을 통해 reference type의 데이터를 전송하고 나면 그 데이터를 사용하지 않는 것이 좋음."),zt=a("ul"),Ft=a("li"),Or=s("deep copy를 통해 복사본을 만들어 사용하거나, Mutex를 사용할 수도 있음"),Wo=i(),ue=a("h3"),pe=a("a"),Kt=a("span"),Ur=s("Non-blocking Channel"),wo=i(),G=a("ul"),je=a("li"),Qt=a("p"),Mr=s("원래 채널은 blocking 성질을 가지고 있음"),Wr=i(),qe=a("ul"),Jt=a("li"),wr=s("채널에 데이터를 쓰려고 하면 채널에 데이터가 들어올 때까지 기다림"),Dr=i(),Xt=a("li"),Ar=s("채널에서 데이터를 읽으려고 하면 채널에 데이터가 들어올 때까지 기다림"),Br=i(),L=a("li"),fe=a("p"),Yt=a("code"),Hr=s("select"),$r=s("문에 "),Zt=a("code"),Nr=s("default"),Tr=s(" 케이스가 있으면 non-blocking 채널이 됨."),Vr=i(),ze=a("ul"),gt=a("li"),jr=s("이 때 주의할 점은 채널에 대한 send, receive 연산의 우선순위가 가장 높지는 않다는 것임"),qr=i(),Fe=a("li"),zr=s("예를 들면 아래 코드의 출력 결과는 "),ea=a("code"),Fr=s("2"),Kr=s("임."),Qr=i(),El=a("pre"),Jr=i(),Ke=a("ul"),_=a("li"),la=a("code"),Xr=s("default"),Yr=s(" 케이스로 넘어가기 이전 "),ta=a("code"),Zr=s("ch1"),gr=s(", "),aa=a("code"),ei=s("ch2"),li=s(" 케이스에서 채널 blocking 여부를 확인하는데, 그 이전에 "),oa=a("code"),ti=s("f()"),ai=s("가 한 번씩 호출되기 때문"),oi=i(),na=a("li"),ni=s("함수를 stateless하게 짜는 버릇을 들이자."),si=i(),H=a("li"),de=a("p"),sa=a("code"),ri=s("select"),ii=s("문의 "),ra=a("code"),ci=s("case"),ui=s(" 옆에 채널 연산자가 여러 개 붙어버리면 의도한 대로 동작 안할 수도 있음"),pi=i(),vl=a("pre"),fi=i(),b=a("ul"),m=a("li"),di=s("위 코드는 "),ia=a("code"),hi=s("ch1"),Ei=s("에 "),ca=a("code"),vi=s("ch2"),_i=s("의 값을 전송하고, "),ua=a("code"),ki=s("ch1"),Li=s("에서 값을 읽어와서 출력함"),bi=i(),$=a("li"),mi=s("이 때 "),pa=a("code"),Ci=s("<-ch2"),Ii=s("가 먼저 실행되는데, "),fa=a("code"),xi=s("ch2"),yi=s("에 값이 없을 때 읽어오려 하면 채널이 blocking됨"),Ri=i(),E=a("li"),Gi=s("하지만 "),da=a("code"),Si=s("default"),Pi=s(" 케이스로 넘어가지 않음. "),ha=a("code"),Oi=s("ch1<-"),Ui=s("가 blocking될 때 "),Ea=a("code"),Mi=s("default"),Wi=s("로 넘어가고, "),va=a("code"),wi=s("<-ch2"),Di=s("는 그냥 blocking됨"),Ai=i(),_a=a("li"),Bi=s("그러니까 이렇게 짜지 말자;;"),Do=i(),Ao=a("br"),Bo=a("br"),Ho=i(),he=a("h2"),Ee=a("a"),ka=a("span"),Hi=s("Mutex"),$o=i(),No=a("hr"),To=i(),S=a("ul"),Qe=a("li"),$i=s("Mutex는 "),Ff(ve.$$.fragment),Ni=s("의 약자로, critical section에 대한 여러 고루틴의 동시 접근을 막기 위해 사용됨."),Ti=i(),N=a("li"),Vi=s("기본적으로 선언과 동시에 사용할 수 있으며, "),La=a("code"),ji=s("lock"),qi=s(" 및 "),ba=a("code"),zi=s("unlock"),Fi=s(" 메소드를 지원함"),Ki=i(),_l=a("li"),Qi=s("Mutex 자체는 shared object여야 함. 단, Mutex가 복사되어선 안됨."),ma=a("ul"),Ca=a("li"),Ji=s("Mutex가 복사되면 복사된 Mutex들이 각자의 lock을 가지게 되므로, 동시 접근을 막을 수 없음"),Vo=i(),_e=a("h3"),ke=a("a"),Ia=a("span"),Xi=s("RWMutex"),jo=i(),P=a("ul"),xa=a("li"),Yi=s("데이터의 Reader는 여러 명이어도 상관 없지만, Writer는 한 명 뿐이어야 함"),Zi=i(),kl=a("li"),gi=s("RWMutex.RLock() 메소드를 통해 Reader가 lock을 획득하고, RWMutex.RUnlock() 메소드를 통해 lock을 해제함"),ya=a("ul"),Ra=a("li"),ec=s("RWMutex.RLock()을 호출하는 여러 Reader 고루틴은 동시에 Critical Section에 접근할 수 있음"),lc=i(),Ll=a("li"),tc=s("RWMutex.Lock() 메소드를 통해 Writer가 lock을 획득하고, RWMutex.Unlock() 메소드를 통해 lock을 해제함"),Je=a("ul"),Ga=a("li"),ac=s("RWMutex.Lock()을 호출하는 Writer 고루틴은 Critical Section에 접근할 수 있음"),oc=i(),Sa=a("li"),nc=s("이 때 RWMutex.RLock()을 호출하는 Reader 고루틴은 Critical Section에 접근할 수 없음"),qo=i(),zo=a("br"),Fo=a("br"),Ko=i(),Le=a("h2"),be=a("a"),Pa=a("span"),sc=s("WaitGroup"),Qo=i(),Jo=a("hr"),Xo=i(),O=a("ul"),Oa=a("li"),rc=s("WaitGroup은 지정된 개수의 고루틴이 모두 종료될 때까지 기다리는 기능을 제공함"),ic=i(),Ua=a("li"),cc=s("주로 여러 서비스를 호출하여 그 결과를 모아서 처리해야 할 때 유용하게 사용할 수 있음"),uc=i(),bl=a("li"),pc=s("WaitGroup과 Channel을 동시에 사용하는 경우 올바른 순서로 사용해야 함"),Xe=a("ul"),Ye=a("li"),fc=s("만약 채널에서 데이터를 읽어오기 전에 "),Ma=a("code"),dc=s("Wg.Wait()"),hc=s("를 호출하면, Deadlock이 발생할 수 있음"),Ec=i(),ml=a("li"),Wa=a("code"),vc=s("Wg.Wait()"),_c=s(" 이후 채널을 닫는 로직 또는 채널로부터 데이터를 읽어오는 로직을 별도의 고루틴으로 분리하는 것이 좋은 방법이 될 수 있음"),Yo=i(),Zo=a("br"),go=a("br"),en=i(),me=a("h2"),Ce=a("a"),wa=a("span"),kc=s("Conditional Variable"),ln=i(),tn=a("hr"),an=i(),U=a("ul"),Da=a("li"),Lc=s("Conditional Variable은 조건이 발생할 때까지 여러 고루틴이 기다리고, 조건이 발생하면 다른 고루틴에 이를 알리는 기능을 제공함"),bc=i(),Aa=a("li"),mc=s("Go에서 Conditional Variable은 대부분 Channel로 대체될 수 있음"),Cc=i(),Ba=a("li"),Ic=s("하지만 Shared Memory 시스템에서 Producer-Consumer 문제 등, 여러 문제를 해결할 때 유용할 수 있음"),on=i(),Ie=a("blockquote"),Ha=a("p"),$a=a("strong"),xc=s("Producer-Consumer 문제"),yc=i(),T=a("ul"),Na=a("li"),Rc=s("Producer-Consumer 문제는 데이터를 생산하는 Producer와, 데이터를 소비하는 Consumer에 대한 문제임"),Gc=i(),Ta=a("li"),Sc=s("1개 이상의 Producer와 Consumer가 존재할 수 있음"),Pc=i(),Cl=a("li"),Oc=s("일반적으로 Producer가 데이터를 쓰고 Consumer가 데이터를 읽어오는 대기열(Queue)를 사용함"),Va=a("ul"),ja=a("li"),Uc=s("Go에서는 이 대기열을 Channel로 구현할 수 있지만, Shared Memory 시스템에서는 Conditional Variable을 사용함"),nn=i(),xe=a("ul"),Ze=a("li"),qa=a("p"),Mc=s("세개의 주요 오퍼레이션이 존재함"),Wc=i(),V=a("ul"),Il=a("li"),za=a("code"),wc=s("Wait()"),Dc=s(": 조건이 발생할 때까지 기다림"),Ac=i(),xl=a("li"),Fa=a("code"),Bc=s("Signal()"),Hc=s(": 조건이 발생했음을 알림"),$c=i(),ye=a("li"),Ka=a("code"),Nc=s("Broadcast()"),Tc=s(": 조건이 발생했음을 알림. "),Qa=a("code"),Vc=s("Signal()"),jc=s("과 달리 모든 고루틴에게 알림"),qc=i(),ge=a("li"),Ja=a("p"),zc=s("Conditional Variable은 Mutex와 함께 사용됨"),Fc=i(),Xa=a("ul"),Ya=a("li"),Kc=s("Conditional Variable은 Critical Section 안에서만 수정할 수 있음"),sn=i(),rn=a("br"),cn=a("br"),un=i(),Re=a("h2"),Ge=a("a"),Za=a("span"),Qc=s("References"),pn=i(),fn=a("hr"),dn=i(),C=a("center"),ga=a("p"),Jc=s("["),Xc=i(),Ff(el.$$.fragment),Yc=s(`
](https://learning.oreilly.com/library/view/effective-concurrency-in/9781804619070/)`),Zc=a("br"),gc=s(`
[Burak Serdar, 『Effective Concurrency in Go』, Packt Publishing](https://learning.oreilly.com/library/view/effective-concurrency-in/9781804619070/)`),this.h()},l(t){d=o(t,"P",{});var u=n(d);w=r(u,`****---
title: Go의 동시성 지원
date: 2023-08-25
excerpt: Go에서 동시성을 지원하는 방법들
categories:`),u.forEach(l),ol=c(t),q=o(t,"UL",{});var ll=n(q);Tl=o(ll,"LI",{});var Pu=n(Tl);Nn=r(Pu,"‘Golang’"),Pu.forEach(l),Tn=c(ll),Vl=o(ll,"LI",{});var Ou=n(Vl);Vn=r(Ou,`‘Concurrency in Go’
coverImage: ‘/post_img/Go/Concurrency in Go/cover.png’
coverWidth: 16
coverHeight: 9
indexed: false
exposed: true`),Ou.forEach(l),ll.forEach(l),oo=c(t),no=o(t,"HR",{}),so=c(t),z=o(t,"P",{});var En=n(z);jn=r(En,"내용의 상당 부분이 "),We=o(En,"A",{href:!0,rel:!0});var Uu=n(We);qn=r(Uu,"https://jhseoeo.github.io/posts/post/Go/Golang%20Basics/GO10"),Uu.forEach(l),zn=r(En,"의 내용과 중복되므로, 해당 포스트를 먼저 읽고 오시는 것을 추천드립니다."),En.forEach(l),ro=c(t),nl=o(t,"P",{});var Mu=n(nl);Fn=r(Mu,"해당 포스트에서 다루지 않은 내용만 중점적으로 다루려 합니다."),Mu.forEach(l),io=c(t),co=o(t,"BR",{}),uo=o(t,"BR",{}),po=c(t),F=o(t,"H2",{id:!0});var eu=n(F);K=o(eu,"A",{"aria-hidden":!0,tabindex:!0,href:!0});var Wu=n(K);jl=o(Wu,"SPAN",{class:!0}),n(jl).forEach(l),Wu.forEach(l),Kn=r(eu,"Goroutine"),eu.forEach(l),fo=c(t),ho=o(t,"HR",{}),Eo=c(t),Q=o(t,"H3",{id:!0});var lu=n(Q);J=o(lu,"A",{"aria-hidden":!0,tabindex:!0,href:!0});var wu=n(J);ql=o(wu,"SPAN",{class:!0}),n(ql).forEach(l),wu.forEach(l),Qn=r(lu,"Goroutine이 빠른 이유"),lu.forEach(l),vo=c(t),I=o(t,"UL",{});var yl=n(I);we=o(yl,"LI",{});var vn=n(we);zl=o(vn,"P",{});var Du=n(zl);Jn=r(Du,"Go 런타임은 실행될 때 기본적으로 플랫폼의 프로세서(코어) 수만큼의 쓰레드를 생성함"),Du.forEach(l),Xn=c(vn),h=o(vn,"UL",{});var M=n(h);Fl=o(M,"LI",{});var Au=n(Fl);Yn=r(Au,"이 쓰레드 풀 위에서 Goroutine이 실행됨"),Au.forEach(l),Zn=c(M),Kl=o(M,"LI",{});var Bu=n(Kl);gn=r(Bu,"만약 그 이하의 쓰레드를 생성하면 CPU utilization이 떨어짐"),Bu.forEach(l),es=c(M),Ql=o(M,"LI",{});var Hu=n(Ql);ls=r(Hu,"만약 그 이상의 쓰레드를 생성하면 Time Sharing때문에 Context Switching 오버헤드가 발생"),Hu.forEach(l),ts=c(M),Jl=o(M,"LI",{});var $u=n(Jl);as=r($u,"만일 고루틴이 Channel, Mutex 등에 의해 block되면 해당 고루틴을 실행시키는 쓰레드는 다른 고루틴을 실행시킴"),$u.forEach(l),os=c(M),Xl=o(M,"LI",{});var Nu=n(Xl);ns=r(Nu,"만일 고루틴이 동기 I/O에 의해 block되면 해당 고루틴을 실행시키는 쓰레드 자체가 block되므로, 새로운 쓰레드를 생성하거나 기존의 쓰레드를 재사용하여 다른 고루틴을 실행시킴"),Nu.forEach(l),M.forEach(l),vn.forEach(l),ss=c(yl),De=o(yl,"LI",{});var _n=n(De);Yl=o(_n,"P",{});var Tu=n(Yl);rs=r(Tu,"Go Scheduler는 user space에 있기 때문에 OS Thread를 사용하는 것보다 오버헤드가 적음"),Tu.forEach(l),is=c(_n),Zl=o(_n,"UL",{});var Vu=n(Zl);gl=o(Vu,"LI",{});var ju=n(gl);cs=r(ju,"따라서 쓰레드 생성 및 관리에 대한 오버헤드가 적음"),ju.forEach(l),Vu.forEach(l),_n.forEach(l),us=c(yl),Ae=o(yl,"LI",{});var kn=n(Ae);et=o(kn,"P",{});var qu=n(et);ps=r(qu,"Goroutine은 OS Thread보다 훨씬 적은 메모리를 사용함"),qu.forEach(l),fs=c(kn),lt=o(kn,"UL",{});var zu=n(lt);tt=o(zu,"LI",{});var Fu=n(tt);ds=r(Fu,"Goroutine의 Stack 크기는 2KB 정도인 반면, OS Thread의 Stack 크기는 MB 단위임"),Fu.forEach(l),zu.forEach(l),kn.forEach(l),yl.forEach(l),_o=c(t),X=o(t,"H3",{id:!0});var tu=n(X);Y=o(tu,"A",{"aria-hidden":!0,tabindex:!0,href:!0});var Ku=n(Y);at=o(Ku,"SPAN",{class:!0}),n(at).forEach(l),Ku.forEach(l),hs=r(tu,"Goroutine의 특징"),tu.forEach(l),ko=c(t),x=o(t,"UL",{});var Rl=n(x);ot=o(Rl,"LI",{});var Qu=n(ot);nt=o(Qu,"P",{});var Ju=n(nt);Es=r(Ju,"OS Thread는 스케줄링 우선순위가 존재하지만, Goroutine은 존재하지 않음(Starvation이 발생하는 고루틴을 우선 선택하는 스케줄링 알고리즘이 있긴 하지만, 이를 지향하지는 않음)"),Ju.forEach(l),Qu.forEach(l),vs=c(Rl),Be=o(Rl,"LI",{});var Ln=n(Be);st=o(Ln,"P",{});var Xu=n(st);_s=r(Xu,"Go 프로그램을 실행시키면 main 고루틴과 가비지 컬렉터 고루틴이 생성됨"),Xu.forEach(l),ks=c(Ln),He=o(Ln,"UL",{});var bn=n(He);D=o(bn,"LI",{});var Gl=n(D);Ls=r(Gl,"main 고루틴은 "),rt=o(Gl,"CODE",{});var Yu=n(rt);bs=r(Yu,"main"),Yu.forEach(l),ms=r(Gl," 패키지의 "),it=o(Gl,"CODE",{});var Zu=n(it);Cs=r(Zu,"main"),Zu.forEach(l),Is=r(Gl," 함수에서 생성됨"),Gl.forEach(l),xs=c(bn),ct=o(bn,"LI",{});var gu=n(ct);ys=r(gu,"main 함수가 종료되면 모든 고루틴이 종료되고 프로그램이 종료됨"),gu.forEach(l),bn.forEach(l),Ln.forEach(l),Rs=c(Rl),$e=o(Rl,"LI",{});var mn=n($e);ut=o(mn,"P",{});var ep=n(ut);Gs=r(ep,"Goroutine을 일시정지 혹은 종료시키는 magic function은 없음"),ep.forEach(l),Ss=c(mn),Ne=o(mn,"UL",{});var Cn=n(Ne);pt=o(Cn,"LI",{});var lp=n(pt);Ps=r(lp,"고루틴이 중단되어야 함을 정의하는 message 또는 flag를 사용하는 것이 일반적"),lp.forEach(l),Os=c(Cn),sl=o(Cn,"LI",{});var au=n(sl);ft=o(au,"CODE",{});var tp=n(ft);Us=r(tp,"panic"),tp.forEach(l),Ms=r(au,"은 고루틴을 종료시킬 수 있음. panic이 발생한 해당 고루틴이 종료됨"),au.forEach(l),Cn.forEach(l),mn.forEach(l),Rl.forEach(l),Lo=c(t),Z=o(t,"H3",{id:!0});var ou=n(Z);g=o(ou,"A",{"aria-hidden":!0,tabindex:!0,href:!0});var ap=n(g);dt=o(ap,"SPAN",{class:!0}),n(dt).forEach(l),ap.forEach(l),Ws=r(ou,"Closure"),ou.forEach(l),bo=c(t),rl=o(t,"UL",{});var op=n(rl);il=o(op,"LI",{});var nu=n(il);ws=r(nu,"어떤 익명 함수가 그 함수 내부 컨텍스트에 있는 변수를 참조하면, 그 익명 함수를 클로저(Closure)라고 함"),ht=o(nu,"UL",{});var np=n(ht);cl=o(np,"LI",{});var su=n(cl);Ds=r(su,"클로저가 참조하는 로컬 변수는 stack에서 heap으로 옮겨짐(escape to heap)"),Et=o(su,"UL",{});var sp=n(Et);vt=o(sp,"LI",{});var rp=n(vt);As=r(rp,"stack에 저장되면 함수가 종료되면서 로컬 변수가 사라지기 때문"),rp.forEach(l),sp.forEach(l),su.forEach(l),np.forEach(l),nu.forEach(l),op.forEach(l),mo=c(t),Co=o(t,"BR",{}),Io=o(t,"BR",{}),xo=c(t),ee=o(t,"H2",{id:!0});var ru=n(ee);le=o(ru,"A",{"aria-hidden":!0,tabindex:!0,href:!0});var ip=n(le);_t=o(ip,"SPAN",{class:!0}),n(_t).forEach(l),ip.forEach(l),Bs=r(ru,"Channel"),ru.forEach(l),yo=c(t),Ro=o(t,"HR",{}),Go=c(t),te=o(t,"H3",{id:!0});var iu=n(te);ae=o(iu,"A",{"aria-hidden":!0,tabindex:!0,href:!0});var cp=n(ae);kt=o(cp,"SPAN",{class:!0}),n(kt).forEach(l),cp.forEach(l),Hs=r(iu,"Channel의 length와 capacity"),iu.forEach(l),So=c(t),y=o(t,"UL",{});var Sl=n(y);Lt=o(Sl,"LI",{});var up=n(Lt);bt=o(up,"P",{});var pp=n(bt);$s=r(pp,"Channel은 내부적으로 FIFO 큐로 구현되어 있음"),pp.forEach(l),up.forEach(l),Ns=c(Sl),mt=o(Sl,"LI",{});var fp=n(mt);Ct=o(fp,"P",{});var dp=n(Ct);Ts=r(dp,"Channel의 capacity는 채널 버퍼의 크기를 의미함"),dp.forEach(l),fp.forEach(l),Vs=c(Sl),k=o(Sl,"LI",{});var Se=n(k);It=o(Se,"P",{});var hp=n(It);js=r(hp,"Channel의 length는 현재 큐에 들어있는 element의 개수를 의미함"),hp.forEach(l),qs=c(Se),xt=o(Se,"UL",{});var Ep=n(xt);yt=o(Ep,"LI",{});var vp=n(yt);zs=r(vp,"아래와 같은 코드는 좋지 않음"),vp.forEach(l),Ep.forEach(l),Fs=c(Se),ul=o(Se,"PRE",{class:!0});var l1=n(ul);l1.forEach(l),Ks=c(Se),A=o(Se,"UL",{});var Pl=n(A);Rt=o(Pl,"LI",{});var _p=n(Rt);Qs=r(_p,"이 코드는 ch에 element가 들어있는지 확인한 후, 들어있다면 element를 읽어옴"),_p.forEach(l),Js=c(Pl),Gt=o(Pl,"LI",{});var kp=n(Gt);Xs=r(kp,"이 때 length를 가져오는 것은 데이터를 읽어오는 것과는 달리 mutual exclusive하지 않음"),kp.forEach(l),Ys=c(Pl),St=o(Pl,"LI",{});var Lp=n(St);Zs=r(Lp,"따라서 데이터를 읽어오려고 할 때 채널의 값을 다른 고루틴이 이미 읽어버리는 race condition이 발생할 수도 있음"),Lp.forEach(l),Pl.forEach(l),Se.forEach(l),Sl.forEach(l),Po=c(t),oe=o(t,"H3",{id:!0});var cu=n(oe);ne=o(cu,"A",{"aria-hidden":!0,tabindex:!0,href:!0});var bp=n(ne);Pt=o(bp,"SPAN",{class:!0}),n(Pt).forEach(l),bp.forEach(l),gs=r(cu,"Channel의 close"),cu.forEach(l),Oo=c(t),v=o(t,"UL",{});var Pe=n(v);pl=o(Pe,"LI",{});var uu=n(pl);er=r(uu,"원래 채널은 1:1 통신만 가능함."),Ot=o(uu,"UL",{});var mp=n(Ot);Ut=o(mp,"LI",{});var Cp=n(Ut);lr=r(Cp,"채널에서 데이터를 읽는 고루틴이 여러 개이고 데이터를 쓰는 고루틴이 하나라면, 쓰기 고루틴이 데이터를 쓸 때 무작위로 읽기 고루틴 중 하나에게 데이터를 전송함"),Cp.forEach(l),mp.forEach(l),uu.forEach(l),tr=c(Pe),se=o(Pe,"LI",{});var eo=n(se);ar=r(eo,"하지만 채널을 "),Mt=o(eo,"CODE",{});var Ip=n(Mt);or=r(Ip,"close"),Ip.forEach(l),nr=r(eo,"하면 해당 채널을 receive하는 모든 고루틴이 이를 감지할 수 있음"),Wt=o(eo,"UL",{});var xp=n(Wt);wt=o(xp,"LI",{});var yp=n(wt);sr=r(yp,"일종의 일회성 Broadcast인 셈"),yp.forEach(l),xp.forEach(l),eo.forEach(l),rr=c(Pe),fl=o(Pe,"LI",{});var pu=n(fl);ir=r(pu,"닫힌 채널로부터 데이터를 읽어오면 해당 타입의 zero value를 읽어옴"),Dt=o(pu,"UL",{});var Rp=n(Dt);At=o(Rp,"LI",{});var Gp=n(At);cr=r(Gp,"comma ok idiom을 사용하면 닫힌 채널인지 확인할 수 있음"),Gp.forEach(l),Rp.forEach(l),pu.forEach(l),ur=c(Pe),Bt=o(Pe,"LI",{});var Sp=n(Bt);pr=r(Sp,"닫힌 채널에 데이터를 쓰려고 하면 panic이 발생함"),Sp.forEach(l),Pe.forEach(l),Uo=c(t),re=o(t,"H3",{id:!0});var fu=n(re);ie=o(fu,"A",{"aria-hidden":!0,tabindex:!0,href:!0});var Pp=n(ie);Ht=o(Pp,"SPAN",{class:!0}),n(Ht).forEach(l),Pp.forEach(l),fr=r(fu,"메모리 공유"),fu.forEach(l),Mo=c(t),ce=o(t,"UL",{});var In=n(ce);B=o(In,"LI",{});var Ol=n(B);dr=r(Ol,"채널을 통해 전송한 데이터가 "),$t=o(Ol,"CODE",{});var Op=n($t);hr=r(Op,"int"),Op.forEach(l),Er=r(Ol,", "),Nt=o(Ol,"CODE",{});var Up=n(Nt);vr=r(Up,"float"),Up.forEach(l),_r=r(Ol," 등의 primitive type이라면, 해당 데이터는 복사되어 전송됨"),Ol.forEach(l),kr=c(In),R=o(In,"LI",{});var tl=n(R);Lr=r(tl,"채널을 통해 전송한 데이터가 "),Tt=o(tl,"CODE",{});var Mp=n(Tt);br=r(Mp,"slice"),Mp.forEach(l),mr=r(tl,", "),Vt=o(tl,"CODE",{});var Wp=n(Vt);Cr=r(Wp,"map"),Wp.forEach(l),Ir=r(tl," 등의 reference type이라면, 해당 데이터의 포인터 주소가 전송됨"),Te=o(tl,"UL",{});var xn=n(Te);dl=o(xn,"LI",{});var du=n(dl);xr=r(du,"이 때 이 데이터의 ownership은 전송된 고루틴에게 넘어가지 않고 메모리는 공유됨."),Ve=o(du,"UL",{});var yn=n(Ve);jt=o(yn,"LI",{});var wp=n(jt);yr=r(wp,"결과적으로 shared memory를 사용하는 것과 같은 상태가 됨"),wp.forEach(l),Rr=c(yn),qt=o(yn,"LI",{});var Dp=n(qt);Gr=r(Dp,"이 상태는 data race임."),Dp.forEach(l),yn.forEach(l),du.forEach(l),Sr=c(xn),hl=o(xn,"LI",{});var hu=n(hl);Pr=r(hu,"보통 채널을 통해 reference type의 데이터를 전송하고 나면 그 데이터를 사용하지 않는 것이 좋음."),zt=o(hu,"UL",{});var Ap=n(zt);Ft=o(Ap,"LI",{});var Bp=n(Ft);Or=r(Bp,"deep copy를 통해 복사본을 만들어 사용하거나, Mutex를 사용할 수도 있음"),Bp.forEach(l),Ap.forEach(l),hu.forEach(l),xn.forEach(l),tl.forEach(l),In.forEach(l),Wo=c(t),ue=o(t,"H3",{id:!0});var Eu=n(ue);pe=o(Eu,"A",{"aria-hidden":!0,tabindex:!0,href:!0});var Hp=n(pe);Kt=o(Hp,"SPAN",{class:!0}),n(Kt).forEach(l),Hp.forEach(l),Ur=r(Eu,"Non-blocking Channel"),Eu.forEach(l),wo=c(t),G=o(t,"UL",{});var Ul=n(G);je=o(Ul,"LI",{});var Rn=n(je);Qt=o(Rn,"P",{});var $p=n(Qt);Mr=r($p,"원래 채널은 blocking 성질을 가지고 있음"),$p.forEach(l),Wr=c(Rn),qe=o(Rn,"UL",{});var Gn=n(qe);Jt=o(Gn,"LI",{});var Np=n(Jt);wr=r(Np,"채널에 데이터를 쓰려고 하면 채널에 데이터가 들어올 때까지 기다림"),Np.forEach(l),Dr=c(Gn),Xt=o(Gn,"LI",{});var Tp=n(Xt);Ar=r(Tp,"채널에서 데이터를 읽으려고 하면 채널에 데이터가 들어올 때까지 기다림"),Tp.forEach(l),Gn.forEach(l),Rn.forEach(l),Br=c(Ul),L=o(Ul,"LI",{});var Oe=n(L);fe=o(Oe,"P",{});var lo=n(fe);Yt=o(lo,"CODE",{});var Vp=n(Yt);Hr=r(Vp,"select"),Vp.forEach(l),$r=r(lo,"문에 "),Zt=o(lo,"CODE",{});var jp=n(Zt);Nr=r(jp,"default"),jp.forEach(l),Tr=r(lo," 케이스가 있으면 non-blocking 채널이 됨."),lo.forEach(l),Vr=c(Oe),ze=o(Oe,"UL",{});var Sn=n(ze);gt=o(Sn,"LI",{});var qp=n(gt);jr=r(qp,"이 때 주의할 점은 채널에 대한 send, receive 연산의 우선순위가 가장 높지는 않다는 것임"),qp.forEach(l),qr=c(Sn),Fe=o(Sn,"LI",{});var Pn=n(Fe);zr=r(Pn,"예를 들면 아래 코드의 출력 결과는 "),ea=o(Pn,"CODE",{});var zp=n(ea);Fr=r(zp,"2"),zp.forEach(l),Kr=r(Pn,"임."),Pn.forEach(l),Sn.forEach(l),Qr=c(Oe),El=o(Oe,"PRE",{class:!0});var t1=n(El);t1.forEach(l),Jr=c(Oe),Ke=o(Oe,"UL",{});var On=n(Ke);_=o(On,"LI",{});var j=n(_);la=o(j,"CODE",{});var Fp=n(la);Xr=r(Fp,"default"),Fp.forEach(l),Yr=r(j," 케이스로 넘어가기 이전 "),ta=o(j,"CODE",{});var Kp=n(ta);Zr=r(Kp,"ch1"),Kp.forEach(l),gr=r(j,", "),aa=o(j,"CODE",{});var Qp=n(aa);ei=r(Qp,"ch2"),Qp.forEach(l),li=r(j," 케이스에서 채널 blocking 여부를 확인하는데, 그 이전에 "),oa=o(j,"CODE",{});var Jp=n(oa);ti=r(Jp,"f()"),Jp.forEach(l),ai=r(j,"가 한 번씩 호출되기 때문"),j.forEach(l),oi=c(On),na=o(On,"LI",{});var Xp=n(na);ni=r(Xp,"함수를 stateless하게 짜는 버릇을 들이자."),Xp.forEach(l),On.forEach(l),Oe.forEach(l),si=c(Ul),H=o(Ul,"LI",{});var Ml=n(H);de=o(Ml,"P",{});var to=n(de);sa=o(to,"CODE",{});var Yp=n(sa);ri=r(Yp,"select"),Yp.forEach(l),ii=r(to,"문의 "),ra=o(to,"CODE",{});var Zp=n(ra);ci=r(Zp,"case"),Zp.forEach(l),ui=r(to," 옆에 채널 연산자가 여러 개 붙어버리면 의도한 대로 동작 안할 수도 있음"),to.forEach(l),pi=c(Ml),vl=o(Ml,"PRE",{class:!0});var a1=n(vl);a1.forEach(l),fi=c(Ml),b=o(Ml,"UL",{});var Ue=n(b);m=o(Ue,"LI",{});var Me=n(m);di=r(Me,"위 코드는 "),ia=o(Me,"CODE",{});var gp=n(ia);hi=r(gp,"ch1"),gp.forEach(l),Ei=r(Me,"에 "),ca=o(Me,"CODE",{});var ef=n(ca);vi=r(ef,"ch2"),ef.forEach(l),_i=r(Me,"의 값을 전송하고, "),ua=o(Me,"CODE",{});var lf=n(ua);ki=r(lf,"ch1"),lf.forEach(l),Li=r(Me,"에서 값을 읽어와서 출력함"),Me.forEach(l),bi=c(Ue),$=o(Ue,"LI",{});var Wl=n($);mi=r(Wl,"이 때 "),pa=o(Wl,"CODE",{});var tf=n(pa);Ci=r(tf,"<-ch2"),tf.forEach(l),Ii=r(Wl,"가 먼저 실행되는데, "),fa=o(Wl,"CODE",{});var af=n(fa);xi=r(af,"ch2"),af.forEach(l),yi=r(Wl,"에 값이 없을 때 읽어오려 하면 채널이 blocking됨"),Wl.forEach(l),Ri=c(Ue),E=o(Ue,"LI",{});var W=n(E);Gi=r(W,"하지만 "),da=o(W,"CODE",{});var of=n(da);Si=r(of,"default"),of.forEach(l),Pi=r(W," 케이스로 넘어가지 않음. "),ha=o(W,"CODE",{});var nf=n(ha);Oi=r(nf,"ch1<-"),nf.forEach(l),Ui=r(W,"가 blocking될 때 "),Ea=o(W,"CODE",{});var sf=n(Ea);Mi=r(sf,"default"),sf.forEach(l),Wi=r(W,"로 넘어가고, "),va=o(W,"CODE",{});var rf=n(va);wi=r(rf,"<-ch2"),rf.forEach(l),Di=r(W,"는 그냥 blocking됨"),W.forEach(l),Ai=c(Ue),_a=o(Ue,"LI",{});var cf=n(_a);Bi=r(cf,"그러니까 이렇게 짜지 말자;;"),cf.forEach(l),Ue.forEach(l),Ml.forEach(l),Ul.forEach(l),Do=c(t),Ao=o(t,"BR",{}),Bo=o(t,"BR",{}),Ho=c(t),he=o(t,"H2",{id:!0});var vu=n(he);Ee=o(vu,"A",{"aria-hidden":!0,tabindex:!0,href:!0});var uf=n(Ee);ka=o(uf,"SPAN",{class:!0}),n(ka).forEach(l),uf.forEach(l),Hi=r(vu,"Mutex"),vu.forEach(l),$o=c(t),No=o(t,"HR",{}),To=c(t),S=o(t,"UL",{});var wl=n(S);Qe=o(wl,"LI",{});var Un=n(Qe);$i=r(Un,"Mutex는 "),Kf(ve.$$.fragment,Un),Ni=r(Un,"의 약자로, critical section에 대한 여러 고루틴의 동시 접근을 막기 위해 사용됨."),Un.forEach(l),Ti=c(wl),N=o(wl,"LI",{});var Dl=n(N);Vi=r(Dl,"기본적으로 선언과 동시에 사용할 수 있으며, "),La=o(Dl,"CODE",{});var pf=n(La);ji=r(pf,"lock"),pf.forEach(l),qi=r(Dl," 및 "),ba=o(Dl,"CODE",{});var ff=n(ba);zi=r(ff,"unlock"),ff.forEach(l),Fi=r(Dl," 메소드를 지원함"),Dl.forEach(l),Ki=c(wl),_l=o(wl,"LI",{});var _u=n(_l);Qi=r(_u,"Mutex 자체는 shared object여야 함. 단, Mutex가 복사되어선 안됨."),ma=o(_u,"UL",{});var df=n(ma);Ca=o(df,"LI",{});var hf=n(Ca);Ji=r(hf,"Mutex가 복사되면 복사된 Mutex들이 각자의 lock을 가지게 되므로, 동시 접근을 막을 수 없음"),hf.forEach(l),df.forEach(l),_u.forEach(l),wl.forEach(l),Vo=c(t),_e=o(t,"H3",{id:!0});var ku=n(_e);ke=o(ku,"A",{"aria-hidden":!0,tabindex:!0,href:!0});var Ef=n(ke);Ia=o(Ef,"SPAN",{class:!0}),n(Ia).forEach(l),Ef.forEach(l),Xi=r(ku,"RWMutex"),ku.forEach(l),jo=c(t),P=o(t,"UL",{});var Al=n(P);xa=o(Al,"LI",{});var vf=n(xa);Yi=r(vf,"데이터의 Reader는 여러 명이어도 상관 없지만, Writer는 한 명 뿐이어야 함"),vf.forEach(l),Zi=c(Al),kl=o(Al,"LI",{});var Lu=n(kl);gi=r(Lu,"RWMutex.RLock() 메소드를 통해 Reader가 lock을 획득하고, RWMutex.RUnlock() 메소드를 통해 lock을 해제함"),ya=o(Lu,"UL",{});var _f=n(ya);Ra=o(_f,"LI",{});var kf=n(Ra);ec=r(kf,"RWMutex.RLock()을 호출하는 여러 Reader 고루틴은 동시에 Critical Section에 접근할 수 있음"),kf.forEach(l),_f.forEach(l),Lu.forEach(l),lc=c(Al),Ll=o(Al,"LI",{});var bu=n(Ll);tc=r(bu,"RWMutex.Lock() 메소드를 통해 Writer가 lock을 획득하고, RWMutex.Unlock() 메소드를 통해 lock을 해제함"),Je=o(bu,"UL",{});var Mn=n(Je);Ga=o(Mn,"LI",{});var Lf=n(Ga);ac=r(Lf,"RWMutex.Lock()을 호출하는 Writer 고루틴은 Critical Section에 접근할 수 있음"),Lf.forEach(l),oc=c(Mn),Sa=o(Mn,"LI",{});var bf=n(Sa);nc=r(bf,"이 때 RWMutex.RLock()을 호출하는 Reader 고루틴은 Critical Section에 접근할 수 없음"),bf.forEach(l),Mn.forEach(l),bu.forEach(l),Al.forEach(l),qo=c(t),zo=o(t,"BR",{}),Fo=o(t,"BR",{}),Ko=c(t),Le=o(t,"H2",{id:!0});var mu=n(Le);be=o(mu,"A",{"aria-hidden":!0,tabindex:!0,href:!0});var mf=n(be);Pa=o(mf,"SPAN",{class:!0}),n(Pa).forEach(l),mf.forEach(l),sc=r(mu,"WaitGroup"),mu.forEach(l),Qo=c(t),Jo=o(t,"HR",{}),Xo=c(t),O=o(t,"UL",{});var Bl=n(O);Oa=o(Bl,"LI",{});var Cf=n(Oa);rc=r(Cf,"WaitGroup은 지정된 개수의 고루틴이 모두 종료될 때까지 기다리는 기능을 제공함"),Cf.forEach(l),ic=c(Bl),Ua=o(Bl,"LI",{});var If=n(Ua);cc=r(If,"주로 여러 서비스를 호출하여 그 결과를 모아서 처리해야 할 때 유용하게 사용할 수 있음"),If.forEach(l),uc=c(Bl),bl=o(Bl,"LI",{});var Cu=n(bl);pc=r(Cu,"WaitGroup과 Channel을 동시에 사용하는 경우 올바른 순서로 사용해야 함"),Xe=o(Cu,"UL",{});var Wn=n(Xe);Ye=o(Wn,"LI",{});var wn=n(Ye);fc=r(wn,"만약 채널에서 데이터를 읽어오기 전에 "),Ma=o(wn,"CODE",{});var xf=n(Ma);dc=r(xf,"Wg.Wait()"),xf.forEach(l),hc=r(wn,"를 호출하면, Deadlock이 발생할 수 있음"),wn.forEach(l),Ec=c(Wn),ml=o(Wn,"LI",{});var Iu=n(ml);Wa=o(Iu,"CODE",{});var yf=n(Wa);vc=r(yf,"Wg.Wait()"),yf.forEach(l),_c=r(Iu," 이후 채널을 닫는 로직 또는 채널로부터 데이터를 읽어오는 로직을 별도의 고루틴으로 분리하는 것이 좋은 방법이 될 수 있음"),Iu.forEach(l),Wn.forEach(l),Cu.forEach(l),Bl.forEach(l),Yo=c(t),Zo=o(t,"BR",{}),go=o(t,"BR",{}),en=c(t),me=o(t,"H2",{id:!0});var xu=n(me);Ce=o(xu,"A",{"aria-hidden":!0,tabindex:!0,href:!0});var Rf=n(Ce);wa=o(Rf,"SPAN",{class:!0}),n(wa).forEach(l),Rf.forEach(l),kc=r(xu,"Conditional Variable"),xu.forEach(l),ln=c(t),tn=o(t,"HR",{}),an=c(t),U=o(t,"UL",{});var Hl=n(U);Da=o(Hl,"LI",{});var Gf=n(Da);Lc=r(Gf,"Conditional Variable은 조건이 발생할 때까지 여러 고루틴이 기다리고, 조건이 발생하면 다른 고루틴에 이를 알리는 기능을 제공함"),Gf.forEach(l),bc=c(Hl),Aa=o(Hl,"LI",{});var Sf=n(Aa);mc=r(Sf,"Go에서 Conditional Variable은 대부분 Channel로 대체될 수 있음"),Sf.forEach(l),Cc=c(Hl),Ba=o(Hl,"LI",{});var Pf=n(Ba);Ic=r(Pf,"하지만 Shared Memory 시스템에서 Producer-Consumer 문제 등, 여러 문제를 해결할 때 유용할 수 있음"),Pf.forEach(l),Hl.forEach(l),on=c(t),Ie=o(t,"BLOCKQUOTE",{});var Dn=n(Ie);Ha=o(Dn,"P",{});var Of=n(Ha);$a=o(Of,"STRONG",{});var Uf=n($a);xc=r(Uf,"Producer-Consumer 문제"),Uf.forEach(l),Of.forEach(l),yc=c(Dn),T=o(Dn,"UL",{});var $l=n(T);Na=o($l,"LI",{});var Mf=n(Na);Rc=r(Mf,"Producer-Consumer 문제는 데이터를 생산하는 Producer와, 데이터를 소비하는 Consumer에 대한 문제임"),Mf.forEach(l),Gc=c($l),Ta=o($l,"LI",{});var Wf=n(Ta);Sc=r(Wf,"1개 이상의 Producer와 Consumer가 존재할 수 있음"),Wf.forEach(l),Pc=c($l),Cl=o($l,"LI",{});var yu=n(Cl);Oc=r(yu,"일반적으로 Producer가 데이터를 쓰고 Consumer가 데이터를 읽어오는 대기열(Queue)를 사용함"),Va=o(yu,"UL",{});var wf=n(Va);ja=o(wf,"LI",{});var Df=n(ja);Uc=r(Df,"Go에서는 이 대기열을 Channel로 구현할 수 있지만, Shared Memory 시스템에서는 Conditional Variable을 사용함"),Df.forEach(l),wf.forEach(l),yu.forEach(l),$l.forEach(l),Dn.forEach(l),nn=c(t),xe=o(t,"UL",{});var An=n(xe);Ze=o(An,"LI",{});var Bn=n(Ze);qa=o(Bn,"P",{});var Af=n(qa);Mc=r(Af,"세개의 주요 오퍼레이션이 존재함"),Af.forEach(l),Wc=c(Bn),V=o(Bn,"UL",{});var Nl=n(V);Il=o(Nl,"LI",{});var Ru=n(Il);za=o(Ru,"CODE",{});var Bf=n(za);wc=r(Bf,"Wait()"),Bf.forEach(l),Dc=r(Ru,": 조건이 발생할 때까지 기다림"),Ru.forEach(l),Ac=c(Nl),xl=o(Nl,"LI",{});var Gu=n(xl);Fa=o(Gu,"CODE",{});var Hf=n(Fa);Bc=r(Hf,"Signal()"),Hf.forEach(l),Hc=r(Gu,": 조건이 발생했음을 알림"),Gu.forEach(l),$c=c(Nl),ye=o(Nl,"LI",{});var ao=n(ye);Ka=o(ao,"CODE",{});var $f=n(Ka);Nc=r($f,"Broadcast()"),$f.forEach(l),Tc=r(ao,": 조건이 발생했음을 알림. "),Qa=o(ao,"CODE",{});var Nf=n(Qa);Vc=r(Nf,"Signal()"),Nf.forEach(l),jc=r(ao,"과 달리 모든 고루틴에게 알림"),ao.forEach(l),Nl.forEach(l),Bn.forEach(l),qc=c(An),ge=o(An,"LI",{});var Hn=n(ge);Ja=o(Hn,"P",{});var Tf=n(Ja);zc=r(Tf,"Conditional Variable은 Mutex와 함께 사용됨"),Tf.forEach(l),Fc=c(Hn),Xa=o(Hn,"UL",{});var Vf=n(Xa);Ya=o(Vf,"LI",{});var jf=n(Ya);Kc=r(jf,"Conditional Variable은 Critical Section 안에서만 수정할 수 있음"),jf.forEach(l),Vf.forEach(l),Hn.forEach(l),An.forEach(l),sn=c(t),rn=o(t,"BR",{}),cn=o(t,"BR",{}),un=c(t),Re=o(t,"H2",{id:!0});var Su=n(Re);Ge=o(Su,"A",{"aria-hidden":!0,tabindex:!0,href:!0});var qf=n(Ge);Za=o(qf,"SPAN",{class:!0}),n(Za).forEach(l),qf.forEach(l),Qc=r(Su,"References"),Su.forEach(l),pn=c(t),fn=o(t,"HR",{}),dn=c(t),C=o(t,"CENTER",{});var al=n(C);ga=o(al,"P",{});var zf=n(ga);Jc=r(zf,"["),zf.forEach(l),Xc=c(al),Kf(el.$$.fragment,al),Yc=r(al,`
](https://learning.oreilly.com/library/view/effective-concurrency-in/9781804619070/)`),Zc=o(al,"BR",{}),gc=r(al,`
[Burak Serdar, 『Effective Concurrency in Go』, Packt Publishing](https://learning.oreilly.com/library/view/effective-concurrency-in/9781804619070/)`),al.forEach(l),this.h()},h(){f(We,"href","https://jhseoeo.github.io/posts/post/Go/Golang%20Basics/GO10"),f(We,"rel","nofollow"),f(jl,"class","icon icon-link"),f(K,"aria-hidden","true"),f(K,"tabindex","-1"),f(K,"href","#goroutine"),f(F,"id","goroutine"),f(ql,"class","icon icon-link"),f(J,"aria-hidden","true"),f(J,"tabindex","-1"),f(J,"href","#goroutine이-빠른-이유"),f(Q,"id","goroutine이-빠른-이유"),f(at,"class","icon icon-link"),f(Y,"aria-hidden","true"),f(Y,"tabindex","-1"),f(Y,"href","#goroutine의-특징"),f(X,"id","goroutine의-특징"),f(dt,"class","icon icon-link"),f(g,"aria-hidden","true"),f(g,"tabindex","-1"),f(g,"href","#closure"),f(Z,"id","closure"),f(_t,"class","icon icon-link"),f(le,"aria-hidden","true"),f(le,"tabindex","-1"),f(le,"href","#channel"),f(ee,"id","channel"),f(kt,"class","icon icon-link"),f(ae,"aria-hidden","true"),f(ae,"tabindex","-1"),f(ae,"href","#channel의-length와-capacity"),f(te,"id","channel의-length와-capacity"),f(ul,"class","language-go"),f(Pt,"class","icon icon-link"),f(ne,"aria-hidden","true"),f(ne,"tabindex","-1"),f(ne,"href","#channel의-close"),f(oe,"id","channel의-close"),f(Ht,"class","icon icon-link"),f(ie,"aria-hidden","true"),f(ie,"tabindex","-1"),f(ie,"href","#메모리-공유"),f(re,"id","메모리-공유"),f(Kt,"class","icon icon-link"),f(pe,"aria-hidden","true"),f(pe,"tabindex","-1"),f(pe,"href","#non-blocking-channel"),f(ue,"id","non-blocking-channel"),f(El,"class","language-go"),f(vl,"class","language-go"),f(ka,"class","icon icon-link"),f(Ee,"aria-hidden","true"),f(Ee,"tabindex","-1"),f(Ee,"href","#mutex"),f(he,"id","mutex"),f(Ia,"class","icon icon-link"),f(ke,"aria-hidden","true"),f(ke,"tabindex","-1"),f(ke,"href","#rwmutex"),f(_e,"id","rwmutex"),f(Pa,"class","icon icon-link"),f(be,"aria-hidden","true"),f(be,"tabindex","-1"),f(be,"href","#waitgroup"),f(Le,"id","waitgroup"),f(wa,"class","icon icon-link"),f(Ce,"aria-hidden","true"),f(Ce,"tabindex","-1"),f(Ce,"href","#conditional-variable"),f(me,"id","conditional-variable"),f(Za,"class","icon icon-link"),f(Ge,"aria-hidden","true"),f(Ge,"tabindex","-1"),f(Ge,"href","#references"),f(Re,"id","references")},m(t,u){p(t,d,u),e(d,w),p(t,ol,u),p(t,q,u),e(q,Tl),e(Tl,Nn),e(q,Tn),e(q,Vl),e(Vl,Vn),p(t,oo,u),p(t,no,u),p(t,so,u),p(t,z,u),e(z,jn),e(z,We),e(We,qn),e(z,zn),p(t,ro,u),p(t,nl,u),e(nl,Fn),p(t,io,u),p(t,co,u),p(t,uo,u),p(t,po,u),p(t,F,u),e(F,K),e(K,jl),e(F,Kn),p(t,fo,u),p(t,ho,u),p(t,Eo,u),p(t,Q,u),e(Q,J),e(J,ql),e(Q,Qn),p(t,vo,u),p(t,I,u),e(I,we),e(we,zl),e(zl,Jn),e(we,Xn),e(we,h),e(h,Fl),e(Fl,Yn),e(h,Zn),e(h,Kl),e(Kl,gn),e(h,es),e(h,Ql),e(Ql,ls),e(h,ts),e(h,Jl),e(Jl,as),e(h,os),e(h,Xl),e(Xl,ns),e(I,ss),e(I,De),e(De,Yl),e(Yl,rs),e(De,is),e(De,Zl),e(Zl,gl),e(gl,cs),e(I,us),e(I,Ae),e(Ae,et),e(et,ps),e(Ae,fs),e(Ae,lt),e(lt,tt),e(tt,ds),p(t,_o,u),p(t,X,u),e(X,Y),e(Y,at),e(X,hs),p(t,ko,u),p(t,x,u),e(x,ot),e(ot,nt),e(nt,Es),e(x,vs),e(x,Be),e(Be,st),e(st,_s),e(Be,ks),e(Be,He),e(He,D),e(D,Ls),e(D,rt),e(rt,bs),e(D,ms),e(D,it),e(it,Cs),e(D,Is),e(He,xs),e(He,ct),e(ct,ys),e(x,Rs),e(x,$e),e($e,ut),e(ut,Gs),e($e,Ss),e($e,Ne),e(Ne,pt),e(pt,Ps),e(Ne,Os),e(Ne,sl),e(sl,ft),e(ft,Us),e(sl,Ms),p(t,Lo,u),p(t,Z,u),e(Z,g),e(g,dt),e(Z,Ws),p(t,bo,u),p(t,rl,u),e(rl,il),e(il,ws),e(il,ht),e(ht,cl),e(cl,Ds),e(cl,Et),e(Et,vt),e(vt,As),p(t,mo,u),p(t,Co,u),p(t,Io,u),p(t,xo,u),p(t,ee,u),e(ee,le),e(le,_t),e(ee,Bs),p(t,yo,u),p(t,Ro,u),p(t,Go,u),p(t,te,u),e(te,ae),e(ae,kt),e(te,Hs),p(t,So,u),p(t,y,u),e(y,Lt),e(Lt,bt),e(bt,$s),e(y,Ns),e(y,mt),e(mt,Ct),e(Ct,Ts),e(y,Vs),e(y,k),e(k,It),e(It,js),e(k,qs),e(k,xt),e(xt,yt),e(yt,zs),e(k,Fs),e(k,ul),ul.innerHTML=Zf,e(k,Ks),e(k,A),e(A,Rt),e(Rt,Qs),e(A,Js),e(A,Gt),e(Gt,Xs),e(A,Ys),e(A,St),e(St,Zs),p(t,Po,u),p(t,oe,u),e(oe,ne),e(ne,Pt),e(oe,gs),p(t,Oo,u),p(t,v,u),e(v,pl),e(pl,er),e(pl,Ot),e(Ot,Ut),e(Ut,lr),e(v,tr),e(v,se),e(se,ar),e(se,Mt),e(Mt,or),e(se,nr),e(se,Wt),e(Wt,wt),e(wt,sr),e(v,rr),e(v,fl),e(fl,ir),e(fl,Dt),e(Dt,At),e(At,cr),e(v,ur),e(v,Bt),e(Bt,pr),p(t,Uo,u),p(t,re,u),e(re,ie),e(ie,Ht),e(re,fr),p(t,Mo,u),p(t,ce,u),e(ce,B),e(B,dr),e(B,$t),e($t,hr),e(B,Er),e(B,Nt),e(Nt,vr),e(B,_r),e(ce,kr),e(ce,R),e(R,Lr),e(R,Tt),e(Tt,br),e(R,mr),e(R,Vt),e(Vt,Cr),e(R,Ir),e(R,Te),e(Te,dl),e(dl,xr),e(dl,Ve),e(Ve,jt),e(jt,yr),e(Ve,Rr),e(Ve,qt),e(qt,Gr),e(Te,Sr),e(Te,hl),e(hl,Pr),e(hl,zt),e(zt,Ft),e(Ft,Or),p(t,Wo,u),p(t,ue,u),e(ue,pe),e(pe,Kt),e(ue,Ur),p(t,wo,u),p(t,G,u),e(G,je),e(je,Qt),e(Qt,Mr),e(je,Wr),e(je,qe),e(qe,Jt),e(Jt,wr),e(qe,Dr),e(qe,Xt),e(Xt,Ar),e(G,Br),e(G,L),e(L,fe),e(fe,Yt),e(Yt,Hr),e(fe,$r),e(fe,Zt),e(Zt,Nr),e(fe,Tr),e(L,Vr),e(L,ze),e(ze,gt),e(gt,jr),e(ze,qr),e(ze,Fe),e(Fe,zr),e(Fe,ea),e(ea,Fr),e(Fe,Kr),e(L,Qr),e(L,El),El.innerHTML=gf,e(L,Jr),e(L,Ke),e(Ke,_),e(_,la),e(la,Xr),e(_,Yr),e(_,ta),e(ta,Zr),e(_,gr),e(_,aa),e(aa,ei),e(_,li),e(_,oa),e(oa,ti),e(_,ai),e(Ke,oi),e(Ke,na),e(na,ni),e(G,si),e(G,H),e(H,de),e(de,sa),e(sa,ri),e(de,ii),e(de,ra),e(ra,ci),e(de,ui),e(H,pi),e(H,vl),vl.innerHTML=e1,e(H,fi),e(H,b),e(b,m),e(m,di),e(m,ia),e(ia,hi),e(m,Ei),e(m,ca),e(ca,vi),e(m,_i),e(m,ua),e(ua,ki),e(m,Li),e(b,bi),e(b,$),e($,mi),e($,pa),e(pa,Ci),e($,Ii),e($,fa),e(fa,xi),e($,yi),e(b,Ri),e(b,E),e(E,Gi),e(E,da),e(da,Si),e(E,Pi),e(E,ha),e(ha,Oi),e(E,Ui),e(E,Ea),e(Ea,Mi),e(E,Wi),e(E,va),e(va,wi),e(E,Di),e(b,Ai),e(b,_a),e(_a,Bi),p(t,Do,u),p(t,Ao,u),p(t,Bo,u),p(t,Ho,u),p(t,he,u),e(he,Ee),e(Ee,ka),e(he,Hi),p(t,$o,u),p(t,No,u),p(t,To,u),p(t,S,u),e(S,Qe),e(Qe,$i),Qf(ve,Qe,null),e(Qe,Ni),e(S,Ti),e(S,N),e(N,Vi),e(N,La),e(La,ji),e(N,qi),e(N,ba),e(ba,zi),e(N,Fi),e(S,Ki),e(S,_l),e(_l,Qi),e(_l,ma),e(ma,Ca),e(Ca,Ji),p(t,Vo,u),p(t,_e,u),e(_e,ke),e(ke,Ia),e(_e,Xi),p(t,jo,u),p(t,P,u),e(P,xa),e(xa,Yi),e(P,Zi),e(P,kl),e(kl,gi),e(kl,ya),e(ya,Ra),e(Ra,ec),e(P,lc),e(P,Ll),e(Ll,tc),e(Ll,Je),e(Je,Ga),e(Ga,ac),e(Je,oc),e(Je,Sa),e(Sa,nc),p(t,qo,u),p(t,zo,u),p(t,Fo,u),p(t,Ko,u),p(t,Le,u),e(Le,be),e(be,Pa),e(Le,sc),p(t,Qo,u),p(t,Jo,u),p(t,Xo,u),p(t,O,u),e(O,Oa),e(Oa,rc),e(O,ic),e(O,Ua),e(Ua,cc),e(O,uc),e(O,bl),e(bl,pc),e(bl,Xe),e(Xe,Ye),e(Ye,fc),e(Ye,Ma),e(Ma,dc),e(Ye,hc),e(Xe,Ec),e(Xe,ml),e(ml,Wa),e(Wa,vc),e(ml,_c),p(t,Yo,u),p(t,Zo,u),p(t,go,u),p(t,en,u),p(t,me,u),e(me,Ce),e(Ce,wa),e(me,kc),p(t,ln,u),p(t,tn,u),p(t,an,u),p(t,U,u),e(U,Da),e(Da,Lc),e(U,bc),e(U,Aa),e(Aa,mc),e(U,Cc),e(U,Ba),e(Ba,Ic),p(t,on,u),p(t,Ie,u),e(Ie,Ha),e(Ha,$a),e($a,xc),e(Ie,yc),e(Ie,T),e(T,Na),e(Na,Rc),e(T,Gc),e(T,Ta),e(Ta,Sc),e(T,Pc),e(T,Cl),e(Cl,Oc),e(Cl,Va),e(Va,ja),e(ja,Uc),p(t,nn,u),p(t,xe,u),e(xe,Ze),e(Ze,qa),e(qa,Mc),e(Ze,Wc),e(Ze,V),e(V,Il),e(Il,za),e(za,wc),e(Il,Dc),e(V,Ac),e(V,xl),e(xl,Fa),e(Fa,Bc),e(xl,Hc),e(V,$c),e(V,ye),e(ye,Ka),e(Ka,Nc),e(ye,Tc),e(ye,Qa),e(Qa,Vc),e(ye,jc),e(xe,qc),e(xe,ge),e(ge,Ja),e(Ja,zc),e(ge,Fc),e(ge,Xa),e(Xa,Ya),e(Ya,Kc),p(t,sn,u),p(t,rn,u),p(t,cn,u),p(t,un,u),p(t,Re,u),e(Re,Ge),e(Ge,Za),e(Re,Qc),p(t,pn,u),p(t,fn,u),p(t,dn,u),p(t,C,u),e(C,ga),e(ga,Jc),e(C,Xc),Qf(el,C,null),e(C,Yc),e(C,Zc),e(C,gc),hn=!0},p(t,[u]){const ll={};u&1&&(ll.$$scope={dirty:u,ctx:t}),ve.$set(ll)},i(t){hn||(Jf(ve.$$.fragment,t),Jf(el.$$.fragment,t),hn=!0)},o(t){Xf(ve.$$.fragment,t),Xf(el.$$.fragment,t),hn=!1},d(t){t&&l(d),t&&l(ol),t&&l(q),t&&l(oo),t&&l(no),t&&l(so),t&&l(z),t&&l(ro),t&&l(nl),t&&l(io),t&&l(co),t&&l(uo),t&&l(po),t&&l(F),t&&l(fo),t&&l(ho),t&&l(Eo),t&&l(Q),t&&l(vo),t&&l(I),t&&l(_o),t&&l(X),t&&l(ko),t&&l(x),t&&l(Lo),t&&l(Z),t&&l(bo),t&&l(rl),t&&l(mo),t&&l(Co),t&&l(Io),t&&l(xo),t&&l(ee),t&&l(yo),t&&l(Ro),t&&l(Go),t&&l(te),t&&l(So),t&&l(y),t&&l(Po),t&&l(oe),t&&l(Oo),t&&l(v),t&&l(Uo),t&&l(re),t&&l(Mo),t&&l(ce),t&&l(Wo),t&&l(ue),t&&l(wo),t&&l(G),t&&l(Do),t&&l(Ao),t&&l(Bo),t&&l(Ho),t&&l(he),t&&l($o),t&&l(No),t&&l(To),t&&l(S),Yf(ve),t&&l(Vo),t&&l(_e),t&&l(jo),t&&l(P),t&&l(qo),t&&l(zo),t&&l(Fo),t&&l(Ko),t&&l(Le),t&&l(Qo),t&&l(Jo),t&&l(Xo),t&&l(O),t&&l(Yo),t&&l(Zo),t&&l(go),t&&l(en),t&&l(me),t&&l(ln),t&&l(tn),t&&l(an),t&&l(U),t&&l(on),t&&l(Ie),t&&l(nn),t&&l(xe),t&&l(sn),t&&l(rn),t&&l(cn),t&&l(un),t&&l(Re),t&&l(pn),t&&l(fn),t&&l(dn),t&&l(C),Yf(el)}}}class h1 extends o1{constructor(d){super(),n1(this,d,null,u1,s1,{})}}export{h1 as default};
