import{S as Ko,i as Qo,s as $o,k as e,a as i,q as l,l as o,c as r,m as u,r as c,h as s,n as k,U as ho,b as p,E as a,M as _e}from"./index.d78780bf.js";function go(wo){let rn,Es,kn,ot,_s,ds,ys,Ps,B,G,Cn,lt,ws,Rs,Ms,fn,ct,xs,mn,ut,Cs,V,Ro=`<code class="language-go"><span class="token keyword">var</span> x <span class="token builtin">int32</span> <span class="token operator">=</span> <span class="token number">10</span>
<span class="token keyword">var</span> y <span class="token builtin">bool</span> <span class="token operator">=</span> <span class="token boolean">true</span>

pointerX <span class="token operator">:=</span> <span class="token operator">&amp;</span>x
pointerY <span class="token operator">:=</span> <span class="token operator">&amp;</span>y
<span class="token keyword">var</span> pointerZ <span class="token operator">*</span><span class="token builtin">string</span>

fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>pointerX<span class="token punctuation">,</span> pointerY<span class="token punctuation">,</span> pointerZ<span class="token punctuation">)</span> <span class="token comment">// addresses of variables</span>
fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>pointerZ <span class="token operator">==</span> <span class="token boolean">nil</span><span class="token punctuation">)</span>              <span class="token comment">// referencing *pointerZ occurs an runtime error(panics), because pointerZ is nil</span>
fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token operator">*</span>pointerX<span class="token punctuation">,</span> <span class="token operator">*</span>pointerY<span class="token punctuation">)</span>         <span class="token comment">// * is indirection operator.</span>
<span class="token operator">*</span>pointerX<span class="token punctuation">,</span> <span class="token operator">*</span>pointerY <span class="token operator">=</span> <span class="token number">8</span><span class="token punctuation">,</span> <span class="token boolean">false</span>
fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span> y<span class="token punctuation">)</span> <span class="token comment">// by changing pointer's values, we can change origin value</span></code>`,Bs,E,Bn,it,rt,Gn,kt,ft,On,mt,bt,Hn,vt,Et,Gs,bn,_t,Os,W,Mo=`<code class="language-go"><span class="token number">0xc0000b8000</span> <span class="token number">0xc0000b8004</span> <span class="token operator">&lt;</span><span class="token boolean">nil</span><span class="token operator">></span>
<span class="token boolean">true</span>
<span class="token number">10</span> <span class="token boolean">true</span>
<span class="token number">8</span> <span class="token boolean">false</span></code>`,Hs,m,dt,Sn,yt,Pt,Nn,wt,Rt,Dn,Mt,xt,Ct,Bt,Ln,Gt,Ot,Ss,Ns,Ds,K,Tn,Ht,St,Ls,Q,xo=`<code class="language-go"><span class="token keyword">var</span> a <span class="token operator">=</span> <span class="token function">new</span><span class="token punctuation">(</span><span class="token builtin">int</span><span class="token punctuation">)</span>      <span class="token comment">// built-in function &#96;new&#96; creates a pointer variable</span>
fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>a <span class="token operator">==</span> <span class="token boolean">nil</span><span class="token punctuation">)</span> <span class="token comment">// false</span>
fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token operator">*</span>a<span class="token punctuation">)</span>       <span class="token comment">// it points zero value of given type</span>
<span class="token operator">*</span>a <span class="token operator">=</span> <span class="token number">2</span>
fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token operator">*</span>a<span class="token punctuation">)</span></code>`,Ts,O,Nt,An,Dt,Lt,As,Fs,Zs,$,Fn,Tt,At,Us,vn,Ft,Js,h,Co=`<code class="language-go">	x <span class="token operator">:=</span> <span class="token operator">&amp;</span>Foo<span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span>
	<span class="token comment">// z := &amp;"string" // this statement occurs an error</span>
	<span class="token keyword">var</span> y <span class="token builtin">string</span>
	z <span class="token operator">:=</span> <span class="token operator">&amp;</span>y <span class="token comment">// to point to a primitive type, declare a variable first</span>

	fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span> z<span class="token punctuation">)</span></code>`,js,H,Zt,Zn,Ut,Jt,zs,g,Bo=`<code class="language-go"><span class="token keyword">type</span> person <span class="token keyword">struct</span> <span class="token punctuation">&#123;</span>
	FirstName  <span class="token builtin">string</span>
	MiddleName <span class="token operator">*</span><span class="token builtin">string</span>
	LastName   <span class="token builtin">string</span>
<span class="token punctuation">&#125;</span>

<span class="token keyword">func</span> <span class="token function">stringp</span><span class="token punctuation">(</span>s <span class="token builtin">string</span><span class="token punctuation">)</span> <span class="token operator">*</span><span class="token builtin">string</span> <span class="token punctuation">&#123;</span>
	<span class="token comment">// helper function that returns address of parameter variable</span>
	<span class="token keyword">return</span> <span class="token operator">&amp;</span>s
<span class="token punctuation">&#125;</span>

<span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
	p <span class="token operator">:=</span> person<span class="token punctuation">&#123;</span>
		FirstName<span class="token punctuation">:</span> <span class="token string">"Pat"</span><span class="token punctuation">,</span>
		<span class="token comment">// MiddleName: "Perry",  // or</span>
		<span class="token comment">// MiddleName: &amp;"Perry", // this lines won't compile</span>
		MiddleName<span class="token punctuation">:</span> <span class="token function">stringp</span><span class="token punctuation">(</span><span class="token string">"Perry"</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token comment">// helper function turned a constant value into a pointer</span>
		LastName<span class="token punctuation">:</span>   <span class="token string">"Peterson"</span><span class="token punctuation">,</span>
	<span class="token punctuation">&#125;</span>

	fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span>
<span class="token punctuation">&#125;</span></code>`,Is,Xs,Ys,qs,S,N,Un,jt,Vs,Ws,Ks,Qs,$s,D,L,Jn,zt,hs,T,It,jn,Xt,Yt,gs,nn,Go=`<code class="language-go"><span class="token keyword">type</span> person <span class="token keyword">struct</span> <span class="token punctuation">&#123;</span>
	name <span class="token builtin">string</span>
	age  <span class="token builtin">int</span>
<span class="token punctuation">&#125;</span>

<span class="token keyword">func</span> <span class="token function">modifyFails</span><span class="token punctuation">(</span>i <span class="token builtin">int</span><span class="token punctuation">,</span> s <span class="token builtin">string</span><span class="token punctuation">,</span> p person<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span> <span class="token comment">// all the parameters are passed by value(copied), not referenced or aliased</span>
	i <span class="token operator">*=</span> <span class="token number">2</span>
	s <span class="token operator">=</span> <span class="token string">"goodbye"</span>
	p<span class="token punctuation">.</span>name <span class="token operator">=</span> <span class="token string">"Bob"</span> <span class="token comment">// even for the struct, cannot change the origin value by modifying parameters.</span>
<span class="token punctuation">&#125;</span>

<span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
	p<span class="token punctuation">,</span> i<span class="token punctuation">,</span> s <span class="token operator">:=</span> person<span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token string">"hello"</span>
	<span class="token function">modifyFails</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span> s<span class="token punctuation">,</span> p<span class="token punctuation">)</span> <span class="token comment">// this invocation of function can't make any change on variables above</span>
	fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span> s<span class="token punctuation">,</span> p<span class="token punctuation">)</span>
<span class="token punctuation">&#125;</span></code>`,na,sa,aa,_,qt,zn,Vt,Wt,In,Kt,Qt,Xn,$t,ht,ta,sn,Oo=`<code class="language-go"><span class="token comment">// slices and maps are passed passed by pointers</span>
<span class="token keyword">func</span> <span class="token function">modifyMap</span><span class="token punctuation">(</span>m <span class="token keyword">map</span><span class="token punctuation">[</span><span class="token builtin">int</span><span class="token punctuation">]</span><span class="token builtin">string</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
	<span class="token comment">// changing map parameters are reflected in the variables passed into the function</span>
	m<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">"hello"</span>
	m<span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">"goodbye"</span>
<span class="token punctuation">&#125;</span>

<span class="token keyword">func</span> <span class="token function">modifySlice</span><span class="token punctuation">(</span>s <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
	<span class="token comment">// we can modify any element in the slice, but can't lengthen the slice</span>
	<span class="token keyword">for</span> k<span class="token punctuation">,</span> v <span class="token operator">:=</span> <span class="token keyword">range</span> s <span class="token punctuation">&#123;</span>
		s<span class="token punctuation">[</span>k<span class="token punctuation">]</span> <span class="token operator">=</span> v <span class="token operator">*</span> <span class="token number">2</span>
	<span class="token punctuation">&#125;</span>
	s <span class="token operator">=</span> <span class="token function">append</span><span class="token punctuation">(</span>s<span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">)</span> <span class="token comment">// this line actually did not append a value to origin variable</span>
<span class="token punctuation">&#125;</span>

<span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    i <span class="token operator">:=</span> <span class="token number">20</span>
    <span class="token function">modify</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span>
    fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span>
<span class="token punctuation">&#125;</span></code>`,pa,ea,oa,P,gt,Yn,np,sp,qn,ap,tp,la,an,Ho=`<code class="language-go">
<span class="token keyword">func</span> <span class="token function">update</span><span class="token punctuation">(</span>g <span class="token operator">*</span><span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
	<span class="token operator">*</span>g <span class="token operator">=</span> <span class="token number">10</span> <span class="token comment">// dereferencing => success to change original value</span>
<span class="token punctuation">&#125;</span>

<span class="token keyword">func</span> <span class="token function">failedUpdate</span><span class="token punctuation">(</span>g <span class="token operator">*</span><span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
	x <span class="token operator">:=</span> <span class="token number">20</span>
	g <span class="token operator">=</span> <span class="token operator">&amp;</span>x <span class="token comment">// where the pointer is pointing at is changed</span>
<span class="token punctuation">&#125;</span>

<span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
	<span class="token keyword">var</span> x <span class="token operator">*</span><span class="token builtin">int</span>
	<span class="token keyword">var</span> y <span class="token builtin">int</span>

	<span class="token comment">// update(x) // this invocation occurs an error. cannot dereference nil</span>
	<span class="token function">update</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>y<span class="token punctuation">)</span>
	fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>y<span class="token punctuation">)</span>

	<span class="token function">failedUpdate</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span>
	<span class="token function">failedUpdate</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>y<span class="token punctuation">)</span> <span class="token comment">// those two invocations cannot changed x and y's values</span>

	fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span> y<span class="token punctuation">)</span>
<span class="token punctuation">&#125;</span></code>`,ca,ua,ia,w,pp,Vn,ep,op,Wn,lp,cp,ra,tn,So=`<code class="language-go"><span class="token keyword">func</span> <span class="token function">modifySlice</span><span class="token punctuation">(</span>s <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
	<span class="token comment">// we can modify any element in the slice, but can't lengthen the slice</span>
	<span class="token keyword">for</span> k<span class="token punctuation">,</span> v <span class="token operator">:=</span> <span class="token keyword">range</span> s <span class="token punctuation">&#123;</span>
		s<span class="token punctuation">[</span>k<span class="token punctuation">]</span> <span class="token operator">=</span> v <span class="token operator">*</span> <span class="token number">2</span>
	<span class="token punctuation">&#125;</span>
	s <span class="token operator">=</span> <span class="token function">append</span><span class="token punctuation">(</span>s<span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">)</span> <span class="token comment">// this line actually did not append a value to origin variable</span>
<span class="token punctuation">&#125;</span></code>`,ka,R,up,Kn,ip,rp,Qn,kp,fp,fa,ma,ba,va,A,F,$n,mp,Ea,Z,bp,hn,vp,Ep,_a,pn,No=`<code class="language-go"><span class="token keyword">type</span> Foo <span class="token keyword">struct</span> <span class="token punctuation">&#123;</span>
	foo <span class="token builtin">int</span>
	bar <span class="token builtin">string</span>
<span class="token punctuation">&#125;</span>

<span class="token keyword">func</span> <span class="token function">MakeFoo1</span><span class="token punctuation">(</span>f <span class="token operator">*</span>Foo<span class="token punctuation">)</span> <span class="token builtin">error</span> <span class="token punctuation">&#123;</span>
	<span class="token comment">// not +recommended format</span>
	f<span class="token punctuation">.</span>foo <span class="token operator">=</span> <span class="token number">20</span>
	f<span class="token punctuation">.</span>bar <span class="token operator">=</span> <span class="token string">"val"</span>
	<span class="token keyword">return</span> <span class="token boolean">nil</span>
<span class="token punctuation">&#125;</span>

<span class="token comment">// rather than using pointer parameter to pass a value, just return this.</span>
<span class="token keyword">func</span> <span class="token function">MakeFoo2</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">(</span>Foo<span class="token punctuation">,</span> <span class="token builtin">error</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
	<span class="token comment">// recommended format</span>
	f <span class="token operator">:=</span> Foo<span class="token punctuation">&#123;</span>
		foo<span class="token punctuation">:</span> <span class="token number">20</span><span class="token punctuation">,</span>
		bar<span class="token punctuation">:</span> <span class="token string">"val"</span><span class="token punctuation">,</span>
	<span class="token punctuation">&#125;</span>
	<span class="token keyword">return</span> f<span class="token punctuation">,</span> <span class="token boolean">nil</span>
<span class="token punctuation">&#125;</span>

<span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
	a <span class="token operator">:=</span> Foo<span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span>
	<span class="token function">MakeFoo1</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>a<span class="token punctuation">)</span> <span class="token comment">// rather than using this pattern,</span>

	b<span class="token punctuation">,</span> <span class="token boolean">_</span> <span class="token operator">:=</span> <span class="token function">MakeFoo2</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">// use this pattern</span>

	fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> b<span class="token punctuation">)</span>
<span class="token punctuation">&#125;</span></code>`,da,U,_p,gn,dp,yp,ya,Pa,wa,J,Pp,ns,wp,Rp,Ra,en,Do=`<code class="language-go">	f <span class="token operator">:=</span> <span class="token keyword">struct</span> <span class="token punctuation">&#123;</span>
		Name <span class="token builtin">string</span> <span class="token string">&#96;json:"name"&#96;</span>
		Age  <span class="token builtin">int</span>    <span class="token string">&#96;json:"age"&#96;</span>
	<span class="token punctuation">&#125;</span><span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span>
	err <span class="token operator">:=</span> json<span class="token punctuation">.</span><span class="token function">Unmarshal</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token function">byte</span><span class="token punctuation">(</span><span class="token string">&#96;&#123;"name": "Bob", "age": 30&#125;&#96;</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token operator">&amp;</span>f<span class="token punctuation">)</span>
	<span class="token keyword">if</span> err <span class="token operator">==</span> <span class="token boolean">nil</span> <span class="token punctuation">&#123;</span>
		fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>f<span class="token punctuation">)</span>
	<span class="token punctuation">&#125;</span></code>`,Ma,xa,Ca,En,Mp,Ba,Ga,Oa,Ha,j,z,ss,xp,Sa,Na,Da,_n,Cp,La,Ta,Aa,on,Lo=`<code class="language-go">r <span class="token operator">:=</span> <span class="token function">open_resource</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
while r<span class="token punctuation">.</span><span class="token function">has_data</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
	data_chunk <span class="token operator">:=</span> r<span class="token punctuation">.</span><span class="token function">next_chunk</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
	<span class="token function">process</span><span class="token punctuation">(</span>data_chunk<span class="token punctuation">)</span>
<span class="token punctuation">&#125;</span>
r<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span></code>`,Fa,d,Bp,as,Gp,Op,ts,Hp,Sp,ps,Np,Dp,Za,v,Lp,es,Tp,Ap,os,Fp,Zp,ls,Up,Jp,cs,jp,zp,Ua,ln,To=`<code class="language-go">file<span class="token punctuation">,</span> err <span class="token operator">:=</span> os<span class="token punctuation">.</span><span class="token function">Open</span><span class="token punctuation">(</span>fileName<span class="token punctuation">)</span>
<span class="token keyword">if</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">&#123;</span>
	<span class="token keyword">return</span> err
<span class="token punctuation">&#125;</span>
<span class="token keyword">defer</span> file<span class="token punctuation">.</span><span class="token function">Close</span><span class="token punctuation">(</span><span class="token punctuation">)</span>

<span class="token comment">// this pattern is good at reducing the garbage collector's workload</span>
data <span class="token operator">:=</span> <span class="token function">make</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">byte</span><span class="token punctuation">,</span> <span class="token number">100</span><span class="token punctuation">)</span> <span class="token comment">// using slice as a buffer</span>
<span class="token keyword">for</span> <span class="token punctuation">&#123;</span>
	count<span class="token punctuation">,</span> err <span class="token operator">:=</span> file<span class="token punctuation">.</span><span class="token function">Read</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span>
	<span class="token keyword">if</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">&#123;</span>
		<span class="token keyword">return</span> err
	<span class="token punctuation">&#125;</span>
	<span class="token keyword">if</span> count <span class="token operator">==</span> <span class="token number">0</span> <span class="token punctuation">&#123;</span>
		<span class="token keyword">return</span> <span class="token boolean">nil</span>
	<span class="token punctuation">&#125;</span>
	<span class="token function">process</span><span class="token punctuation">(</span>data<span class="token punctuation">[</span><span class="token punctuation">:</span>count<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token comment">// it passes next block of bytes in to the slice (up to 100)</span>
<span class="token punctuation">&#125;</span></code>`,Ja,ja,za,f,Ip,us,Xp,Yp,is,qp,Vp,rs,Wp,Kp,ks,Qp,$p,fs,hp,gp,ms,ne,se,bs,ae,te,Ia,dn,pe,Xa,Ya,qa,Va,I,X,vs,ee,Wa,Ka,Qa,yn,x,cn,Pn,de,oe,le,ce,un,ue,$a,ha,ga;return{c(){rn=e("br"),Es=i(),kn=e("p"),ot=l("본 글은 Golang을 공부하며 주요 내용이라 생각되는 것들을 기록해둔 자료이며, Ubuntu 20.04 LTS 기준으로 작성되었습니다."),_s=i(),ds=e("br"),ys=e("br"),Ps=i(),B=e("h2"),G=e("a"),Cn=e("span"),lt=l("Pointer"),ws=i(),Rs=e("hr"),Ms=i(),fn=e("p"),ct=l(`놀랍게도 Go에는 포인터가 있다. C++ 공부하며 다신 보기 싫었던 친구인데 다시 보게 되니 감회가 새롭다.
다들 알다시피 포인터는 특정 변수가 저장된 메모리의 주소를 가리키는 변수를 의미한다. C/C++의 포인터와 크게 다르지 않다.`),xs=i(),mn=e("p"),ut=l("포인터 변수는 가리키고자 하는 메모리 주소의 첫 번째 byte address를 저장한다."),Cs=i(),V=e("pre"),Bs=i(),E=e("p"),Bn=e("code"),it=l("&"),rt=l("는 변수의 주소값을 반환하는 연산자이며, "),Gn=e("code"),kt=l("*"),ft=l(`는 indirection 연산자로, 해당 포인터가 가리키는 주소에 저장된 값을 반환한다.
`),On=e("code"),mt=l("*"),bt=l("를 통해 메모리 주소에 저장된 값에 접근하는 것을 "),Hn=e("strong"),vt=l("dereferencing"),Et=l("이라고 한다."),Gs=i(),bn=e("p"),_t=l("위 코드의 출력 결과는 아래와 같다."),Os=i(),W=e("pre"),Hs=i(),m=e("p"),dt=l("위의 "),Sn=e("code"),yt=l("pointerZ"),Pt=l(" 변수처럼 포인터 변수를 선언하고 아무런 주소값도 할당하지 않으면 "),Nn=e("code"),wt=l("nil"),Rt=l("이 할당된다. 포인터 변수의 Zero value가 "),Dn=e("code"),Mt=l("nil"),xt=l("인 셈이다."),Ct=e("br"),Bt=l(`
만약 주소가 `),Ln=e("code"),Gt=l("nil"),Ot=l("인 접근하려고 하면 panic(런타임 에러)이 발생한다."),Ss=i(),Ns=e("br"),Ds=i(),K=e("p"),Tn=e("code"),Ht=l("new()"),St=l(" 함수는 포인터 변수를 생성하는 built-in 함수이다. 포인터가 가리키는 값은 파라미터로 주어진 타입의 Zero value로 초기화된다."),Ls=i(),Q=e("pre"),Ts=i(),O=e("p"),Nt=l("근데 "),An=e("code"),Dt=l("new()"),Lt=l(" 함수는 자주 쓰이지는 않는다고 한다."),As=i(),Fs=e("br"),Zs=i(),$=e("p"),Fn=e("code"),Tt=l("&"),At=l(" 연산자를 통해서 상수나 리터럴의 주소값을 얻을 수는 없다. 이런 애들은 메모리 주소가 따로 존재하지 않기 때문이다."),Us=i(),vn=e("p"),Ft=l("따라서 특정 값을 가진 포인터 변수를 생셩하려면, 먼저 일반 변수를 선언해서 값을 할당한 뒤, 해당 변수의 주소값을 넘겨주어야 한다."),Js=i(),h=e("pre"),js=i(),H=e("p"),Zt=l(`이러한 방식이 직관적이기는 하지만 코드의 길이가 쓸데없이 길어진다는 단점이 있다.
그렇다면 `),Zn=e("em"),Ut=l("helper function"),Jt=l("이란 것을 만들어서 값을 할당해줄 수 있다."),zs=i(),g=e("pre"),Is=i(),Xs=e("br"),Ys=e("br"),qs=i(),S=e("h2"),N=e("a"),Un=e("span"),jt=l("Passing Pointers"),Vs=i(),Ws=e("hr"),Ks=i(),Qs=e("br"),$s=i(),D=e("h3"),L=e("a"),Jn=e("span"),zt=l("Pass by Pointer"),hs=i(),T=e("p"),It=l(`다들 알다시피, struct를 비롯한 원시 타입의 변수를 함수의 파라미터로 넘기면, 함수 안에서 해당 파라미터를 어떻게 수정하든 그 값이 바뀌지 않는다.
Go는 `),jn=e("strong"),Xt=l("Call by Value"),Yt=l(" 기반이기 때문."),gs=i(),nn=e("pre"),na=i(),sa=e("br"),aa=i(),_=e("p"),qt=l("다만 이는 파라미터로 넘기는 변수의 타입이 "),zn=e("em"),Vt=l("slice"),Wt=l("이거나 "),In=e("em"),Kt=l("map"),Qt=l("이면 달라지는데, slice와 map은 "),Xn=e("strong"),$t=l("Pass by Pointer"),ht=l(`로 넘겨진다.
따라서 파라미터로 받은 함수에서 값을 변경할 수 있다.`),ta=i(),sn=e("pre"),pa=i(),ea=e("br"),oa=i(),P=e("p"),gt=l(`파라미터로 넘기는 변수를 포인터로 지정해주면 Pass by Pointer가 된다.
이 경우 `),Yn=e("em"),np=l("dereferencing"),sp=l(`을 통해 메모리 주소에 직접 접근하여 변수의 값을 변경할 수 있다.
다만 포인터 변수에 새로운 변수의 주소값을 할당한다고 해서 원래의 값이 바뀌지는 않는다(아래 예제의 `),qn=e("code"),ap=l("failedUpdate()"),tp=l("함수 참조)."),la=i(),an=e("pre"),ca=i(),ua=e("br"),ia=i(),w=e("p"),pp=l("따라서 위에서 보았던 "),Vn=e("code"),ep=l("modifySlice()"),op=l(" 함수에서, 파라미터로 넘긴 변수가 "),Wn=e("code"),lp=l("s = append(s, 10)"),cp=l(" 라인에 의해 변경되지 않으리라는 것을 알 수 있다."),ra=i(),tn=e("pre"),ka=i(),R=e("p"),up=l("추가적으로, Go 내부적으로 slice는 원소들이 저장되는 메모리 주소에 대한 포인터, "),Kn=e("code"),ip=l("cap"),rp=l(", "),Qn=e("code"),kp=l("len"),fp=l(`, 이렇게 세 개의 원소로 구성된 struct 구조체라고 볼 수 있다.
따라서 slice가 파라미터로 넘어오면 원본 slice의 cap, len은 복사된 정수로 변경할 수 없는데 반해, 원소들이 저장된 메모리 공간에 대한 변경은 가능한 것이다.`),fa=i(),ma=e("br"),ba=e("br"),va=i(),A=e("h3"),F=e("a"),$n=e("span"),mp=l("Avoid Passing by Pointer"),Ea=i(),Z=e("p"),bp=l("일반적으로 구조체 등 데이터를 생성하거나 설정하고자 할 때, 이를 "),hn=e("em"),vp=l("Pass by Pointer"),Ep=l(`로 넘기는 방식은 직관적이지 않다.
경우에 따라 오히려 이를 수행하는데 필요한 자원이 더 많이 소모하게 될 수도 있다.`),_a=i(),pn=e("pre"),da=i(),U=e("p"),_p=l("위 예시처럼 "),gn=e("em"),dp=l("Pass by Pointer"),yp=l("를 사용하기보단, 그냥 그 값을 반환하는 형식이 시각적으로도 더 좋다."),ya=i(),Pa=e("br"),wa=i(),J=e("p"),Pp=l("다만 예외사항이 좀 있다. 이를테면 JSON을 파싱하는 경우, "),ns=e("code"),wp=l("Unmarshal()"),Rp=l("과 같은 일부 함수들은 포인터 파라미터를 사용하기도 한다."),Ra=i(),en=e("pre"),Ma=i(),xa=e("br"),Ca=i(),En=e("p"),Mp=l("또는, 반환해야 할(또는 파라미터로 넘겨야 할) 데이터가 메가바이트 단위 이상일 경우, Pass by Pointer를 사용하는 것이 훨씬 빠르다고 한다."),Ba=i(),Ga=e("br"),Oa=e("br"),Ha=i(),j=e("h2"),z=e("a"),ss=e("span"),xp=l("Garbage Collector"),Sa=i(),Na=e("hr"),Da=i(),_n=e("p"),Cp=l(`Go에는 가비지 콜렉터가 존재한다. 이녀석의 역할은 더 이상 사용되지 않는 메모리 공간을 반환하는 것으로, Go는 메모리 관리를 프로그램 레벨에서 해준다.
다만 가비지 콜렉터가 존재한다고 해도 생각없이 코드를 짜면 가비지 콜렉터의 워크로드가 늘어나 프로그램이 느려질 수 있다.`),La=i(),Ta=e("br"),Aa=i(),on=e("pre"),Fa=i(),d=e("p"),Bp=l("위 코드는 안좋은 예로, 매 이터레이션마다 "),as=e("code"),Gp=l("r.next_chunk()"),Op=l("의 반환값을 받아들이는 "),ts=e("code"),Hp=l("data_chunk"),Sp=l(` 변수가 생성된다.
이터레이션이 끝날 때마다 `),ps=e("code"),Np=l("data_chunk"),Dp=l("에 저장된 값은 필요 없는 메모리 공간이 되고, 가비지 콜렉터가 해야 하는 일이 쌓이게 되는 것이다."),Za=i(),v=e("p"),Lp=l("아래 예제는 "),es=e("em"),Tp=l("Slice"),Ap=l("를 "),os=e("em"),Fp=l("Buffer"),Zp=l(`처럼 사용하여, 파일의 데이터를 읽어오는 예제이다.
매 이터레이션마다 변수 `),ls=e("code"),Up=l("data"),Jp=l("에 값을 불러오고, 변수 "),cs=e("code"),jp=l("data"),zp=l("는 전체 이터레이션에서 재사용되므로, 가비지 콜렉터가 해야 할 일이 줄어든다."),Ua=i(),ln=e("pre"),Ja=i(),ja=e("br"),za=i(),f=e("p"),Ip=l("Go에서는 기본적으로 "),us=e("em"),Xp=l("Stack"),Yp=l("에 저장할 수 없는 가변적인 크기의 데이터들은 "),is=e("em"),qp=l("Heap"),Vp=l("에 저장되며, "),rs=e("em"),Wp=l("Heap"),Kp=l(`은 가비지 콜렉터에 의해 관리된다.
가비지 콜렉터는 어떠한 포인터도 가리키지 않는 데이터(`),ks=e("em"),Qp=l("garbage"),$p=l(`)들을 청소하는 알고리즘이다.
사용가능한 데이터를 찾기 위해 한번에 최대한 많은 데이터를, 가능한한 빨리 찾게끔 디자인되어있기 때문에,
우리가 짠 Go 코드가 `),fs=e("em"),hp=l("garbage"),gp=l("를 많이 생성할수록 "),ms=e("em"),ne=l("garbage"),se=l("찾지 못할 확률이 높아지며, "),bs=e("em"),ae=l("garbage"),te=l(`를 찾는데 더욱 오래 걸리게 된다.
게다가 보통 포인터가 가리키는 데이터들은 메모리 상에서 흩어져서 저장되기 때문에 찾기가 더 힘들어진다.`),Ia=i(),dn=e("p"),pe=l(`비록 Go가 Python, Java, Javascript와 같은 여타 언어들에 비해 가비지 콜렉터의 성능이 뛰어난 편이라고는 해도,
가비지 컬렉터가 해야 할 일을 줄여서 코드를 최적화시키는게 당연히 좋을 것이다.`),Xa=i(),Ya=e("br"),qa=e("br"),Va=i(),I=e("h2"),X=e("a"),vs=e("span"),ee=l("References"),Wa=i(),Ka=e("hr"),Qa=i(),yn=e("center"),x=e("p"),cn=e("a"),Pn=e("img"),oe=i(),le=e("br"),ce=i(),un=e("a"),ue=l("Jon Bodner, 『Learning Go』, O’Reilly Media, Inc."),$a=i(),ha=e("br"),ga=e("br"),this.h()},l(n){rn=o(n,"BR",{}),Es=r(n),kn=o(n,"P",{});var t=u(kn);ot=c(t,"본 글은 Golang을 공부하며 주요 내용이라 생각되는 것들을 기록해둔 자료이며, Ubuntu 20.04 LTS 기준으로 작성되었습니다."),t.forEach(s),_s=r(n),ds=o(n,"BR",{}),ys=o(n,"BR",{}),Ps=r(n),B=o(n,"H2",{id:!0});var ie=u(B);G=o(ie,"A",{"aria-hidden":!0,tabindex:!0,href:!0});var ye=u(G);Cn=o(ye,"SPAN",{class:!0}),u(Cn).forEach(s),ye.forEach(s),lt=c(ie,"Pointer"),ie.forEach(s),ws=r(n),Rs=o(n,"HR",{}),Ms=r(n),fn=o(n,"P",{});var Pe=u(fn);ct=c(Pe,`놀랍게도 Go에는 포인터가 있다. C++ 공부하며 다신 보기 싫었던 친구인데 다시 보게 되니 감회가 새롭다.
다들 알다시피 포인터는 특정 변수가 저장된 메모리의 주소를 가리키는 변수를 의미한다. C/C++의 포인터와 크게 다르지 않다.`),Pe.forEach(s),xs=r(n),mn=o(n,"P",{});var we=u(mn);ut=c(we,"포인터 변수는 가리키고자 하는 메모리 주소의 첫 번째 byte address를 저장한다."),we.forEach(s),Cs=r(n),V=o(n,"PRE",{class:!0});var Ao=u(V);Ao.forEach(s),Bs=r(n),E=o(n,"P",{});var C=u(E);Bn=o(C,"CODE",{});var Re=u(Bn);it=c(Re,"&"),Re.forEach(s),rt=c(C,"는 변수의 주소값을 반환하는 연산자이며, "),Gn=o(C,"CODE",{});var Me=u(Gn);kt=c(Me,"*"),Me.forEach(s),ft=c(C,`는 indirection 연산자로, 해당 포인터가 가리키는 주소에 저장된 값을 반환한다.
`),On=o(C,"CODE",{});var xe=u(On);mt=c(xe,"*"),xe.forEach(s),bt=c(C,"를 통해 메모리 주소에 저장된 값에 접근하는 것을 "),Hn=o(C,"STRONG",{});var Ce=u(Hn);vt=c(Ce,"dereferencing"),Ce.forEach(s),Et=c(C,"이라고 한다."),C.forEach(s),Gs=r(n),bn=o(n,"P",{});var Be=u(bn);_t=c(Be,"위 코드의 출력 결과는 아래와 같다."),Be.forEach(s),Os=r(n),W=o(n,"PRE",{class:!0});var Fo=u(W);Fo.forEach(s),Hs=r(n),m=o(n,"P",{});var y=u(m);dt=c(y,"위의 "),Sn=o(y,"CODE",{});var Ge=u(Sn);yt=c(Ge,"pointerZ"),Ge.forEach(s),Pt=c(y," 변수처럼 포인터 변수를 선언하고 아무런 주소값도 할당하지 않으면 "),Nn=o(y,"CODE",{});var Oe=u(Nn);wt=c(Oe,"nil"),Oe.forEach(s),Rt=c(y,"이 할당된다. 포인터 변수의 Zero value가 "),Dn=o(y,"CODE",{});var He=u(Dn);Mt=c(He,"nil"),He.forEach(s),xt=c(y,"인 셈이다."),Ct=o(y,"BR",{}),Bt=c(y,`
만약 주소가 `),Ln=o(y,"CODE",{});var Se=u(Ln);Gt=c(Se,"nil"),Se.forEach(s),Ot=c(y,"인 접근하려고 하면 panic(런타임 에러)이 발생한다."),y.forEach(s),Ss=r(n),Ns=o(n,"BR",{}),Ds=r(n),K=o(n,"P",{});var re=u(K);Tn=o(re,"CODE",{});var Ne=u(Tn);Ht=c(Ne,"new()"),Ne.forEach(s),St=c(re," 함수는 포인터 변수를 생성하는 built-in 함수이다. 포인터가 가리키는 값은 파라미터로 주어진 타입의 Zero value로 초기화된다."),re.forEach(s),Ls=r(n),Q=o(n,"PRE",{class:!0});var Zo=u(Q);Zo.forEach(s),Ts=r(n),O=o(n,"P",{});var nt=u(O);Nt=c(nt,"근데 "),An=o(nt,"CODE",{});var De=u(An);Dt=c(De,"new()"),De.forEach(s),Lt=c(nt," 함수는 자주 쓰이지는 않는다고 한다."),nt.forEach(s),As=r(n),Fs=o(n,"BR",{}),Zs=r(n),$=o(n,"P",{});var ke=u($);Fn=o(ke,"CODE",{});var Le=u(Fn);Tt=c(Le,"&"),Le.forEach(s),At=c(ke," 연산자를 통해서 상수나 리터럴의 주소값을 얻을 수는 없다. 이런 애들은 메모리 주소가 따로 존재하지 않기 때문이다."),ke.forEach(s),Us=r(n),vn=o(n,"P",{});var Te=u(vn);Ft=c(Te,"따라서 특정 값을 가진 포인터 변수를 생셩하려면, 먼저 일반 변수를 선언해서 값을 할당한 뒤, 해당 변수의 주소값을 넘겨주어야 한다."),Te.forEach(s),Js=r(n),h=o(n,"PRE",{class:!0});var Uo=u(h);Uo.forEach(s),js=r(n),H=o(n,"P",{});var st=u(H);Zt=c(st,`이러한 방식이 직관적이기는 하지만 코드의 길이가 쓸데없이 길어진다는 단점이 있다.
그렇다면 `),Zn=o(st,"EM",{});var Ae=u(Zn);Ut=c(Ae,"helper function"),Ae.forEach(s),Jt=c(st,"이란 것을 만들어서 값을 할당해줄 수 있다."),st.forEach(s),zs=r(n),g=o(n,"PRE",{class:!0});var Jo=u(g);Jo.forEach(s),Is=r(n),Xs=o(n,"BR",{}),Ys=o(n,"BR",{}),qs=r(n),S=o(n,"H2",{id:!0});var fe=u(S);N=o(fe,"A",{"aria-hidden":!0,tabindex:!0,href:!0});var Fe=u(N);Un=o(Fe,"SPAN",{class:!0}),u(Un).forEach(s),Fe.forEach(s),jt=c(fe,"Passing Pointers"),fe.forEach(s),Vs=r(n),Ws=o(n,"HR",{}),Ks=r(n),Qs=o(n,"BR",{}),$s=r(n),D=o(n,"H3",{id:!0});var me=u(D);L=o(me,"A",{"aria-hidden":!0,tabindex:!0,href:!0});var Ze=u(L);Jn=o(Ze,"SPAN",{class:!0}),u(Jn).forEach(s),Ze.forEach(s),zt=c(me,"Pass by Pointer"),me.forEach(s),hs=r(n),T=o(n,"P",{});var at=u(T);It=c(at,`다들 알다시피, struct를 비롯한 원시 타입의 변수를 함수의 파라미터로 넘기면, 함수 안에서 해당 파라미터를 어떻게 수정하든 그 값이 바뀌지 않는다.
Go는 `),jn=o(at,"STRONG",{});var Ue=u(jn);Xt=c(Ue,"Call by Value"),Ue.forEach(s),Yt=c(at," 기반이기 때문."),at.forEach(s),gs=r(n),nn=o(n,"PRE",{class:!0});var jo=u(nn);jo.forEach(s),na=r(n),sa=o(n,"BR",{}),aa=r(n),_=o(n,"P",{});var Y=u(_);qt=c(Y,"다만 이는 파라미터로 넘기는 변수의 타입이 "),zn=o(Y,"EM",{});var Je=u(zn);Vt=c(Je,"slice"),Je.forEach(s),Wt=c(Y,"이거나 "),In=o(Y,"EM",{});var je=u(In);Kt=c(je,"map"),je.forEach(s),Qt=c(Y,"이면 달라지는데, slice와 map은 "),Xn=o(Y,"STRONG",{});var ze=u(Xn);$t=c(ze,"Pass by Pointer"),ze.forEach(s),ht=c(Y,`로 넘겨진다.
따라서 파라미터로 받은 함수에서 값을 변경할 수 있다.`),Y.forEach(s),ta=r(n),sn=o(n,"PRE",{class:!0});var zo=u(sn);zo.forEach(s),pa=r(n),ea=o(n,"BR",{}),oa=r(n),P=o(n,"P",{});var wn=u(P);gt=c(wn,`파라미터로 넘기는 변수를 포인터로 지정해주면 Pass by Pointer가 된다.
이 경우 `),Yn=o(wn,"EM",{});var Ie=u(Yn);np=c(Ie,"dereferencing"),Ie.forEach(s),sp=c(wn,`을 통해 메모리 주소에 직접 접근하여 변수의 값을 변경할 수 있다.
다만 포인터 변수에 새로운 변수의 주소값을 할당한다고 해서 원래의 값이 바뀌지는 않는다(아래 예제의 `),qn=o(wn,"CODE",{});var Xe=u(qn);ap=c(Xe,"failedUpdate()"),Xe.forEach(s),tp=c(wn,"함수 참조)."),wn.forEach(s),la=r(n),an=o(n,"PRE",{class:!0});var Io=u(an);Io.forEach(s),ca=r(n),ua=o(n,"BR",{}),ia=r(n),w=o(n,"P",{});var Rn=u(w);pp=c(Rn,"따라서 위에서 보았던 "),Vn=o(Rn,"CODE",{});var Ye=u(Vn);ep=c(Ye,"modifySlice()"),Ye.forEach(s),op=c(Rn," 함수에서, 파라미터로 넘긴 변수가 "),Wn=o(Rn,"CODE",{});var qe=u(Wn);lp=c(qe,"s = append(s, 10)"),qe.forEach(s),cp=c(Rn," 라인에 의해 변경되지 않으리라는 것을 알 수 있다."),Rn.forEach(s),ra=r(n),tn=o(n,"PRE",{class:!0});var Xo=u(tn);Xo.forEach(s),ka=r(n),R=o(n,"P",{});var Mn=u(R);up=c(Mn,"추가적으로, Go 내부적으로 slice는 원소들이 저장되는 메모리 주소에 대한 포인터, "),Kn=o(Mn,"CODE",{});var Ve=u(Kn);ip=c(Ve,"cap"),Ve.forEach(s),rp=c(Mn,", "),Qn=o(Mn,"CODE",{});var We=u(Qn);kp=c(We,"len"),We.forEach(s),fp=c(Mn,`, 이렇게 세 개의 원소로 구성된 struct 구조체라고 볼 수 있다.
따라서 slice가 파라미터로 넘어오면 원본 slice의 cap, len은 복사된 정수로 변경할 수 없는데 반해, 원소들이 저장된 메모리 공간에 대한 변경은 가능한 것이다.`),Mn.forEach(s),fa=r(n),ma=o(n,"BR",{}),ba=o(n,"BR",{}),va=r(n),A=o(n,"H3",{id:!0});var be=u(A);F=o(be,"A",{"aria-hidden":!0,tabindex:!0,href:!0});var Ke=u(F);$n=o(Ke,"SPAN",{class:!0}),u($n).forEach(s),Ke.forEach(s),mp=c(be,"Avoid Passing by Pointer"),be.forEach(s),Ea=r(n),Z=o(n,"P",{});var tt=u(Z);bp=c(tt,"일반적으로 구조체 등 데이터를 생성하거나 설정하고자 할 때, 이를 "),hn=o(tt,"EM",{});var Qe=u(hn);vp=c(Qe,"Pass by Pointer"),Qe.forEach(s),Ep=c(tt,`로 넘기는 방식은 직관적이지 않다.
경우에 따라 오히려 이를 수행하는데 필요한 자원이 더 많이 소모하게 될 수도 있다.`),tt.forEach(s),_a=r(n),pn=o(n,"PRE",{class:!0});var Yo=u(pn);Yo.forEach(s),da=r(n),U=o(n,"P",{});var pt=u(U);_p=c(pt,"위 예시처럼 "),gn=o(pt,"EM",{});var $e=u(gn);dp=c($e,"Pass by Pointer"),$e.forEach(s),yp=c(pt,"를 사용하기보단, 그냥 그 값을 반환하는 형식이 시각적으로도 더 좋다."),pt.forEach(s),ya=r(n),Pa=o(n,"BR",{}),wa=r(n),J=o(n,"P",{});var et=u(J);Pp=c(et,"다만 예외사항이 좀 있다. 이를테면 JSON을 파싱하는 경우, "),ns=o(et,"CODE",{});var he=u(ns);wp=c(he,"Unmarshal()"),he.forEach(s),Rp=c(et,"과 같은 일부 함수들은 포인터 파라미터를 사용하기도 한다."),et.forEach(s),Ra=r(n),en=o(n,"PRE",{class:!0});var qo=u(en);qo.forEach(s),Ma=r(n),xa=o(n,"BR",{}),Ca=r(n),En=o(n,"P",{});var ge=u(En);Mp=c(ge,"또는, 반환해야 할(또는 파라미터로 넘겨야 할) 데이터가 메가바이트 단위 이상일 경우, Pass by Pointer를 사용하는 것이 훨씬 빠르다고 한다."),ge.forEach(s),Ba=r(n),Ga=o(n,"BR",{}),Oa=o(n,"BR",{}),Ha=r(n),j=o(n,"H2",{id:!0});var ve=u(j);z=o(ve,"A",{"aria-hidden":!0,tabindex:!0,href:!0});var no=u(z);ss=o(no,"SPAN",{class:!0}),u(ss).forEach(s),no.forEach(s),xp=c(ve,"Garbage Collector"),ve.forEach(s),Sa=r(n),Na=o(n,"HR",{}),Da=r(n),_n=o(n,"P",{});var so=u(_n);Cp=c(so,`Go에는 가비지 콜렉터가 존재한다. 이녀석의 역할은 더 이상 사용되지 않는 메모리 공간을 반환하는 것으로, Go는 메모리 관리를 프로그램 레벨에서 해준다.
다만 가비지 콜렉터가 존재한다고 해도 생각없이 코드를 짜면 가비지 콜렉터의 워크로드가 늘어나 프로그램이 느려질 수 있다.`),so.forEach(s),La=r(n),Ta=o(n,"BR",{}),Aa=r(n),on=o(n,"PRE",{class:!0});var Vo=u(on);Vo.forEach(s),Fa=r(n),d=o(n,"P",{});var q=u(d);Bp=c(q,"위 코드는 안좋은 예로, 매 이터레이션마다 "),as=o(q,"CODE",{});var ao=u(as);Gp=c(ao,"r.next_chunk()"),ao.forEach(s),Op=c(q,"의 반환값을 받아들이는 "),ts=o(q,"CODE",{});var to=u(ts);Hp=c(to,"data_chunk"),to.forEach(s),Sp=c(q,` 변수가 생성된다.
이터레이션이 끝날 때마다 `),ps=o(q,"CODE",{});var po=u(ps);Np=c(po,"data_chunk"),po.forEach(s),Dp=c(q,"에 저장된 값은 필요 없는 메모리 공간이 되고, 가비지 콜렉터가 해야 하는 일이 쌓이게 되는 것이다."),q.forEach(s),Za=r(n),v=o(n,"P",{});var M=u(v);Lp=c(M,"아래 예제는 "),es=o(M,"EM",{});var eo=u(es);Tp=c(eo,"Slice"),eo.forEach(s),Ap=c(M,"를 "),os=o(M,"EM",{});var oo=u(os);Fp=c(oo,"Buffer"),oo.forEach(s),Zp=c(M,`처럼 사용하여, 파일의 데이터를 읽어오는 예제이다.
매 이터레이션마다 변수 `),ls=o(M,"CODE",{});var lo=u(ls);Up=c(lo,"data"),lo.forEach(s),Jp=c(M,"에 값을 불러오고, 변수 "),cs=o(M,"CODE",{});var co=u(cs);jp=c(co,"data"),co.forEach(s),zp=c(M,"는 전체 이터레이션에서 재사용되므로, 가비지 콜렉터가 해야 할 일이 줄어든다."),M.forEach(s),Ua=r(n),ln=o(n,"PRE",{class:!0});var Wo=u(ln);Wo.forEach(s),Ja=r(n),ja=o(n,"BR",{}),za=r(n),f=o(n,"P",{});var b=u(f);Ip=c(b,"Go에서는 기본적으로 "),us=o(b,"EM",{});var uo=u(us);Xp=c(uo,"Stack"),uo.forEach(s),Yp=c(b,"에 저장할 수 없는 가변적인 크기의 데이터들은 "),is=o(b,"EM",{});var io=u(is);qp=c(io,"Heap"),io.forEach(s),Vp=c(b,"에 저장되며, "),rs=o(b,"EM",{});var ro=u(rs);Wp=c(ro,"Heap"),ro.forEach(s),Kp=c(b,`은 가비지 콜렉터에 의해 관리된다.
가비지 콜렉터는 어떠한 포인터도 가리키지 않는 데이터(`),ks=o(b,"EM",{});var ko=u(ks);Qp=c(ko,"garbage"),ko.forEach(s),$p=c(b,`)들을 청소하는 알고리즘이다.
사용가능한 데이터를 찾기 위해 한번에 최대한 많은 데이터를, 가능한한 빨리 찾게끔 디자인되어있기 때문에,
우리가 짠 Go 코드가 `),fs=o(b,"EM",{});var fo=u(fs);hp=c(fo,"garbage"),fo.forEach(s),gp=c(b,"를 많이 생성할수록 "),ms=o(b,"EM",{});var mo=u(ms);ne=c(mo,"garbage"),mo.forEach(s),se=c(b,"찾지 못할 확률이 높아지며, "),bs=o(b,"EM",{});var bo=u(bs);ae=c(bo,"garbage"),bo.forEach(s),te=c(b,`를 찾는데 더욱 오래 걸리게 된다.
게다가 보통 포인터가 가리키는 데이터들은 메모리 상에서 흩어져서 저장되기 때문에 찾기가 더 힘들어진다.`),b.forEach(s),Ia=r(n),dn=o(n,"P",{});var vo=u(dn);pe=c(vo,`비록 Go가 Python, Java, Javascript와 같은 여타 언어들에 비해 가비지 콜렉터의 성능이 뛰어난 편이라고는 해도,
가비지 컬렉터가 해야 할 일을 줄여서 코드를 최적화시키는게 당연히 좋을 것이다.`),vo.forEach(s),Xa=r(n),Ya=o(n,"BR",{}),qa=o(n,"BR",{}),Va=r(n),I=o(n,"H2",{id:!0});var Ee=u(I);X=o(Ee,"A",{"aria-hidden":!0,tabindex:!0,href:!0});var Eo=u(X);vs=o(Eo,"SPAN",{class:!0}),u(vs).forEach(s),Eo.forEach(s),ee=c(Ee,"References"),Ee.forEach(s),Wa=r(n),Ka=o(n,"HR",{}),Qa=r(n),yn=o(n,"CENTER",{});var _o=u(yn);x=o(_o,"P",{});var xn=u(x);cn=o(xn,"A",{href:!0,rel:!0});var yo=u(cn);Pn=o(yo,"IMG",{src:!0,alt:!0}),yo.forEach(s),oe=r(xn),le=o(xn,"BR",{}),ce=r(xn),un=o(xn,"A",{href:!0,rel:!0});var Po=u(un);ue=c(Po,"Jon Bodner, 『Learning Go』, O’Reilly Media, Inc."),Po.forEach(s),xn.forEach(s),_o.forEach(s),$a=r(n),ha=o(n,"BR",{}),ga=o(n,"BR",{}),this.h()},h(){k(Cn,"class","icon icon-link"),k(G,"aria-hidden","true"),k(G,"tabindex","-1"),k(G,"href","#pointer"),k(B,"id","pointer"),k(V,"class","language-go"),k(W,"class","language-go"),k(Q,"class","language-go"),k(h,"class","language-go"),k(g,"class","language-go"),k(Un,"class","icon icon-link"),k(N,"aria-hidden","true"),k(N,"tabindex","-1"),k(N,"href","#passing-pointers"),k(S,"id","passing-pointers"),k(Jn,"class","icon icon-link"),k(L,"aria-hidden","true"),k(L,"tabindex","-1"),k(L,"href","#pass-by-pointer"),k(D,"id","pass-by-pointer"),k(nn,"class","language-go"),k(sn,"class","language-go"),k(an,"class","language-go"),k(tn,"class","language-go"),k($n,"class","icon icon-link"),k(F,"aria-hidden","true"),k(F,"tabindex","-1"),k(F,"href","#avoid-passing-by-pointer"),k(A,"id","avoid-passing-by-pointer"),k(pn,"class","language-go"),k(en,"class","language-go"),k(ss,"class","icon icon-link"),k(z,"aria-hidden","true"),k(z,"tabindex","-1"),k(z,"href","#garbage-collector"),k(j,"id","garbage-collector"),k(on,"class","language-go"),k(ln,"class","language-go"),k(vs,"class","icon icon-link"),k(X,"aria-hidden","true"),k(X,"tabindex","-1"),k(X,"href","#references"),k(I,"id","references"),ho(Pn.src,de="https://learning.oreilly.com/covers/urn:orm:book:9781492077206/400w/")||k(Pn,"src",de),k(Pn,"alt","Learning Go Book Cover"),k(cn,"href","https://learning.oreilly.com/library/view/learning-go/9781492077206/"),k(cn,"rel","nofollow"),k(un,"href","https://learning.oreilly.com/library/view/learning-go/9781492077206/"),k(un,"rel","nofollow")},m(n,t){p(n,rn,t),p(n,Es,t),p(n,kn,t),a(kn,ot),p(n,_s,t),p(n,ds,t),p(n,ys,t),p(n,Ps,t),p(n,B,t),a(B,G),a(G,Cn),a(B,lt),p(n,ws,t),p(n,Rs,t),p(n,Ms,t),p(n,fn,t),a(fn,ct),p(n,xs,t),p(n,mn,t),a(mn,ut),p(n,Cs,t),p(n,V,t),V.innerHTML=Ro,p(n,Bs,t),p(n,E,t),a(E,Bn),a(Bn,it),a(E,rt),a(E,Gn),a(Gn,kt),a(E,ft),a(E,On),a(On,mt),a(E,bt),a(E,Hn),a(Hn,vt),a(E,Et),p(n,Gs,t),p(n,bn,t),a(bn,_t),p(n,Os,t),p(n,W,t),W.innerHTML=Mo,p(n,Hs,t),p(n,m,t),a(m,dt),a(m,Sn),a(Sn,yt),a(m,Pt),a(m,Nn),a(Nn,wt),a(m,Rt),a(m,Dn),a(Dn,Mt),a(m,xt),a(m,Ct),a(m,Bt),a(m,Ln),a(Ln,Gt),a(m,Ot),p(n,Ss,t),p(n,Ns,t),p(n,Ds,t),p(n,K,t),a(K,Tn),a(Tn,Ht),a(K,St),p(n,Ls,t),p(n,Q,t),Q.innerHTML=xo,p(n,Ts,t),p(n,O,t),a(O,Nt),a(O,An),a(An,Dt),a(O,Lt),p(n,As,t),p(n,Fs,t),p(n,Zs,t),p(n,$,t),a($,Fn),a(Fn,Tt),a($,At),p(n,Us,t),p(n,vn,t),a(vn,Ft),p(n,Js,t),p(n,h,t),h.innerHTML=Co,p(n,js,t),p(n,H,t),a(H,Zt),a(H,Zn),a(Zn,Ut),a(H,Jt),p(n,zs,t),p(n,g,t),g.innerHTML=Bo,p(n,Is,t),p(n,Xs,t),p(n,Ys,t),p(n,qs,t),p(n,S,t),a(S,N),a(N,Un),a(S,jt),p(n,Vs,t),p(n,Ws,t),p(n,Ks,t),p(n,Qs,t),p(n,$s,t),p(n,D,t),a(D,L),a(L,Jn),a(D,zt),p(n,hs,t),p(n,T,t),a(T,It),a(T,jn),a(jn,Xt),a(T,Yt),p(n,gs,t),p(n,nn,t),nn.innerHTML=Go,p(n,na,t),p(n,sa,t),p(n,aa,t),p(n,_,t),a(_,qt),a(_,zn),a(zn,Vt),a(_,Wt),a(_,In),a(In,Kt),a(_,Qt),a(_,Xn),a(Xn,$t),a(_,ht),p(n,ta,t),p(n,sn,t),sn.innerHTML=Oo,p(n,pa,t),p(n,ea,t),p(n,oa,t),p(n,P,t),a(P,gt),a(P,Yn),a(Yn,np),a(P,sp),a(P,qn),a(qn,ap),a(P,tp),p(n,la,t),p(n,an,t),an.innerHTML=Ho,p(n,ca,t),p(n,ua,t),p(n,ia,t),p(n,w,t),a(w,pp),a(w,Vn),a(Vn,ep),a(w,op),a(w,Wn),a(Wn,lp),a(w,cp),p(n,ra,t),p(n,tn,t),tn.innerHTML=So,p(n,ka,t),p(n,R,t),a(R,up),a(R,Kn),a(Kn,ip),a(R,rp),a(R,Qn),a(Qn,kp),a(R,fp),p(n,fa,t),p(n,ma,t),p(n,ba,t),p(n,va,t),p(n,A,t),a(A,F),a(F,$n),a(A,mp),p(n,Ea,t),p(n,Z,t),a(Z,bp),a(Z,hn),a(hn,vp),a(Z,Ep),p(n,_a,t),p(n,pn,t),pn.innerHTML=No,p(n,da,t),p(n,U,t),a(U,_p),a(U,gn),a(gn,dp),a(U,yp),p(n,ya,t),p(n,Pa,t),p(n,wa,t),p(n,J,t),a(J,Pp),a(J,ns),a(ns,wp),a(J,Rp),p(n,Ra,t),p(n,en,t),en.innerHTML=Do,p(n,Ma,t),p(n,xa,t),p(n,Ca,t),p(n,En,t),a(En,Mp),p(n,Ba,t),p(n,Ga,t),p(n,Oa,t),p(n,Ha,t),p(n,j,t),a(j,z),a(z,ss),a(j,xp),p(n,Sa,t),p(n,Na,t),p(n,Da,t),p(n,_n,t),a(_n,Cp),p(n,La,t),p(n,Ta,t),p(n,Aa,t),p(n,on,t),on.innerHTML=Lo,p(n,Fa,t),p(n,d,t),a(d,Bp),a(d,as),a(as,Gp),a(d,Op),a(d,ts),a(ts,Hp),a(d,Sp),a(d,ps),a(ps,Np),a(d,Dp),p(n,Za,t),p(n,v,t),a(v,Lp),a(v,es),a(es,Tp),a(v,Ap),a(v,os),a(os,Fp),a(v,Zp),a(v,ls),a(ls,Up),a(v,Jp),a(v,cs),a(cs,jp),a(v,zp),p(n,Ua,t),p(n,ln,t),ln.innerHTML=To,p(n,Ja,t),p(n,ja,t),p(n,za,t),p(n,f,t),a(f,Ip),a(f,us),a(us,Xp),a(f,Yp),a(f,is),a(is,qp),a(f,Vp),a(f,rs),a(rs,Wp),a(f,Kp),a(f,ks),a(ks,Qp),a(f,$p),a(f,fs),a(fs,hp),a(f,gp),a(f,ms),a(ms,ne),a(f,se),a(f,bs),a(bs,ae),a(f,te),p(n,Ia,t),p(n,dn,t),a(dn,pe),p(n,Xa,t),p(n,Ya,t),p(n,qa,t),p(n,Va,t),p(n,I,t),a(I,X),a(X,vs),a(I,ee),p(n,Wa,t),p(n,Ka,t),p(n,Qa,t),p(n,yn,t),a(yn,x),a(x,cn),a(cn,Pn),a(x,oe),a(x,le),a(x,ce),a(x,un),a(un,ue),p(n,$a,t),p(n,ha,t),p(n,ga,t)},p:_e,i:_e,o:_e,d(n){n&&s(rn),n&&s(Es),n&&s(kn),n&&s(_s),n&&s(ds),n&&s(ys),n&&s(Ps),n&&s(B),n&&s(ws),n&&s(Rs),n&&s(Ms),n&&s(fn),n&&s(xs),n&&s(mn),n&&s(Cs),n&&s(V),n&&s(Bs),n&&s(E),n&&s(Gs),n&&s(bn),n&&s(Os),n&&s(W),n&&s(Hs),n&&s(m),n&&s(Ss),n&&s(Ns),n&&s(Ds),n&&s(K),n&&s(Ls),n&&s(Q),n&&s(Ts),n&&s(O),n&&s(As),n&&s(Fs),n&&s(Zs),n&&s($),n&&s(Us),n&&s(vn),n&&s(Js),n&&s(h),n&&s(js),n&&s(H),n&&s(zs),n&&s(g),n&&s(Is),n&&s(Xs),n&&s(Ys),n&&s(qs),n&&s(S),n&&s(Vs),n&&s(Ws),n&&s(Ks),n&&s(Qs),n&&s($s),n&&s(D),n&&s(hs),n&&s(T),n&&s(gs),n&&s(nn),n&&s(na),n&&s(sa),n&&s(aa),n&&s(_),n&&s(ta),n&&s(sn),n&&s(pa),n&&s(ea),n&&s(oa),n&&s(P),n&&s(la),n&&s(an),n&&s(ca),n&&s(ua),n&&s(ia),n&&s(w),n&&s(ra),n&&s(tn),n&&s(ka),n&&s(R),n&&s(fa),n&&s(ma),n&&s(ba),n&&s(va),n&&s(A),n&&s(Ea),n&&s(Z),n&&s(_a),n&&s(pn),n&&s(da),n&&s(U),n&&s(ya),n&&s(Pa),n&&s(wa),n&&s(J),n&&s(Ra),n&&s(en),n&&s(Ma),n&&s(xa),n&&s(Ca),n&&s(En),n&&s(Ba),n&&s(Ga),n&&s(Oa),n&&s(Ha),n&&s(j),n&&s(Sa),n&&s(Na),n&&s(Da),n&&s(_n),n&&s(La),n&&s(Ta),n&&s(Aa),n&&s(on),n&&s(Fa),n&&s(d),n&&s(Za),n&&s(v),n&&s(Ua),n&&s(ln),n&&s(Ja),n&&s(ja),n&&s(za),n&&s(f),n&&s(Ia),n&&s(dn),n&&s(Xa),n&&s(Ya),n&&s(qa),n&&s(Va),n&&s(I),n&&s(Wa),n&&s(Ka),n&&s(Qa),n&&s(yn),n&&s($a),n&&s(ha),n&&s(ga)}}}const sl={title:"포인터",date:"2022-08-07T00:00:00.000Z",excerpt:"Pointer",categories:["Golang","Basic Golang"],coverImage:"/post_img/Go/Golang_basics/cover.png",coverWidth:16,coverHeight:9,indexed:!1,exposed:!0};class al extends Ko{constructor(rn){super(),Qo(this,rn,null,go,$o,{})}}export{al as default,sl as metadata};
