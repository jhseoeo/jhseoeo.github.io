import{S as UI,i as jI,s as zI,k as p,a as i,q as t,y as qI,l as o,c as r,m as l,r as e,h as a,z as VI,n as k,p as JI,b as u,E as s,A as XI,M as $I,g as ZI,d as KI,B as QI}from"./index.d78780bf.js";import{I as YI}from"./Image.605b14b5.js";function hI(tM){let At,tr,Gt,T2,er,pr,or,lr,Ps,Os,We,S2,cr,ur,ir,Rs,M2,Ue,I2,L2,rr,Aa,eM=`<code class="language-go"><span class="token keyword">type</span> Person <span class="token keyword">struct</span> <span class="token punctuation">&#123;</span>
    FirstName <span class="token builtin">string</span>
    LastName  <span class="token builtin">string</span>
    Age       <span class="token builtin">int</span>
<span class="token punctuation">&#125;</span>
<span class="token keyword">type</span> Score <span class="token builtin">int</span>
<span class="token keyword">type</span> Converter <span class="token keyword">func</span><span class="token punctuation">(</span><span class="token builtin">string</span><span class="token punctuation">)</span> Score
<span class="token keyword">type</span> TeamScores <span class="token keyword">map</span><span class="token punctuation">[</span><span class="token builtin">string</span><span class="token punctuation">]</span>Score
<span class="token keyword">type</span> Employee Person</code>`,kr,Bt,H2,fr,dr,Er,kn,A2,je,G2,B2,ze,x2,N2,qe,F2,W2,mr,Hn,U2,Ve,j2,z2,Je,q2,V2,vr,Ts,J2,Xe,X2,$2,_r,yr,br,wr,Ss,Ms,$e,Z2,Cr,xt,K2,Dr,Ga,pM=`<code class="language-go"><span class="token keyword">type</span> HighScore Score
<span class="token keyword">type</span> Employee Person</code>`,Pr,Is,Q2,Ze,Y2,h2,Or,q,g2,Ke,nm,sm,Qe,am,tm,Ye,em,pm,he,om,lm,Rr,Ba,oM=`<code class="language-go"><span class="token comment">// assigning untyped constants is valid</span>
<span class="token keyword">var</span> i <span class="token builtin">int</span> <span class="token operator">=</span> <span class="token number">300</span>
<span class="token keyword">var</span> s Score <span class="token operator">=</span> <span class="token number">100</span>
<span class="token keyword">var</span> hs HighScore <span class="token operator">=</span> <span class="token number">200</span>
hs <span class="token operator">=</span> s                  <span class="token comment">// compilation error!</span>
s <span class="token operator">=</span> i                   <span class="token comment">// compilation error!</span>
s <span class="token operator">=</span> <span class="token function">Score</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span>            <span class="token comment">// ok</span>
hs <span class="token operator">=</span> <span class="token function">HighScore</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span>       <span class="token comment">// ok</span></code>`,Tr,Sr,Mr,Ir,Ls,Hs,ge,cm,Lr,An,um,np,im,rm,sp,km,fm,Hr,xa,lM=`<code class="language-go">	<span class="token keyword">type</span> MailCategory <span class="token builtin">int</span>
	<span class="token keyword">const</span> <span class="token punctuation">(</span>
		Uncategorized MailCategory <span class="token operator">=</span> <span class="token boolean">iota</span> <span class="token comment">// 0</span>
		Personal                          <span class="token comment">// 1</span>
		Spam                              <span class="token comment">// 2</span>
		Social                            <span class="token comment">// 3</span>
		Advertisement                     <span class="token comment">// 4</span>
	<span class="token punctuation">)</span>

	fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>Uncategorized<span class="token punctuation">,</span> Personal<span class="token punctuation">,</span> Spam<span class="token punctuation">,</span> Social<span class="token punctuation">,</span> Advertisement<span class="token punctuation">)</span></code>`,Ar,Na,cM='<code class="language-bash"><span class="token number">0</span> <span class="token number">1</span> <span class="token number">2</span> <span class="token number">3</span> <span class="token number">4</span></code>',Gr,V,dm,ap,Em,mm,tp,vm,_m,ep,ym,bm,pp,wm,Cm,Br,xr,Nr,Fa,uM=`<code class="language-go">	<span class="token keyword">type</span> BitField <span class="token builtin">int</span>
	<span class="token keyword">const</span> <span class="token punctuation">(</span>
		Field1 BitField <span class="token operator">=</span> <span class="token number">1</span> <span class="token operator">&lt;&lt;</span> <span class="token boolean">iota</span> <span class="token comment">// assigned 1</span>
		Field2                      <span class="token comment">// assigned 2</span>
		Field3                      <span class="token comment">// assigned 4</span>
		Field4                      <span class="token comment">// assigned 8</span>
		<span class="token boolean">_</span>                           <span class="token comment">// passed 16</span>
		Field6                      <span class="token comment">// assigned 32</span>
	<span class="token punctuation">)</span>

	fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>Field1<span class="token punctuation">,</span> Field2<span class="token punctuation">,</span> Field3<span class="token punctuation">,</span> Field4<span class="token punctuation">,</span> Field6<span class="token punctuation">)</span></code>`,Fr,is,op,Dm,Pm,lp,Om,Rm,Wr,Ur,jr,D,Tm,cp,Sm,Mm,up,Im,Lm,ip,Hm,Am,rp,Gm,Bm,kp,xm,Nm,fp,Fm,Wm,zr,J,Um,dp,jm,zm,Ep,qm,Vm,mp,Jm,Xm,vp,$m,Zm,qr,As,Km,_p,Qm,Ym,Vr,Jr,Xr,$r,Gs,Bs,yp,hm,Zr,Kr,Qr,fn,gm,bp,nv,sv,wp,av,tv,Cp,ev,pv,Yr,Wa,iM=`<code class="language-go"><span class="token keyword">type</span> Person <span class="token keyword">struct</span> <span class="token punctuation">&#123;</span>
	FirstName <span class="token builtin">string</span>
	LastName  <span class="token builtin">string</span>
	Age       <span class="token builtin">int</span>
<span class="token punctuation">&#125;</span>

<span class="token comment">// defining methods for user-defined type</span>
<span class="token keyword">func</span> <span class="token punctuation">(</span>p Person<span class="token punctuation">)</span> <span class="token function">String</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token builtin">string</span> <span class="token punctuation">&#123;</span> <span class="token comment">// The receiver appears between the keyword func and the name of the method</span>
	<span class="token keyword">return</span> fmt<span class="token punctuation">.</span><span class="token function">Sprintf</span><span class="token punctuation">(</span><span class="token string">"%s %s, age %d"</span><span class="token punctuation">,</span> p<span class="token punctuation">.</span>FirstName<span class="token punctuation">,</span> p<span class="token punctuation">.</span>LastName<span class="token punctuation">,</span> p<span class="token punctuation">.</span>Age<span class="token punctuation">)</span>
<span class="token punctuation">&#125;</span>

<span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
	p <span class="token operator">:=</span> Person<span class="token punctuation">&#123;</span>
		FirstName<span class="token punctuation">:</span> <span class="token string">"Fred"</span><span class="token punctuation">,</span>
		LastName<span class="token punctuation">:</span>  <span class="token string">"Fredson"</span><span class="token punctuation">,</span>
		Age<span class="token punctuation">:</span>       <span class="token number">52</span><span class="token punctuation">,</span>
	<span class="token punctuation">&#125;</span>
    <span class="token comment">// method invocations look familiar to those who have used methods in other languages</span>
	output <span class="token operator">:=</span> p<span class="token punctuation">.</span><span class="token function">String</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
	fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>output<span class="token punctuation">)</span>
<span class="token punctuation">&#125;</span></code>`,hr,Nt,ov,gr,Ft,lv,nk,sk,ak,tk,xs,Ns,Dp,cv,ek,dn,uv,Pp,iv,rv,Op,kv,fv,Rp,dv,Ev,pk,Ua,Tp,mv,vv,ok,Gn,rs,_v,Sp,yv,bv,Mp,wv,Cv,Dv,ks,Pv,Ip,Ov,Rv,Lp,Tv,Sv,Mv,fs,Iv,Hp,Lv,Hv,Ap,Av,Gv,lk,Rn,Gp,Bv,xv,Bp,Nv,Fv,xp,Wv,Uv,ck,uk,ik,ja,rM=`<code class="language-go"><span class="token keyword">type</span> Counter <span class="token keyword">struct</span> <span class="token punctuation">&#123;</span>
	total       <span class="token builtin">int</span>
	lastUpdated time<span class="token punctuation">.</span>Time
<span class="token punctuation">&#125;</span>

<span class="token comment">// pointer receiver should be used when the method modifies the receiver or handles nil instances</span>
<span class="token keyword">func</span> <span class="token punctuation">(</span>c <span class="token operator">*</span>Counter<span class="token punctuation">)</span> <span class="token function">Increment</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
	c<span class="token punctuation">.</span>total<span class="token operator">++</span>
	c<span class="token punctuation">.</span>lastUpdated <span class="token operator">=</span> time<span class="token punctuation">.</span><span class="token function">Now</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">&#125;</span>

<span class="token comment">// value receiver can be used when the method doesn't modify the receiver</span>
<span class="token keyword">func</span> <span class="token punctuation">(</span>c Counter<span class="token punctuation">)</span> <span class="token function">String</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token builtin">string</span> <span class="token punctuation">&#123;</span>
	<span class="token keyword">return</span> fmt<span class="token punctuation">.</span><span class="token function">Sprintf</span><span class="token punctuation">(</span><span class="token string">"total: %d, last updated: %v"</span><span class="token punctuation">,</span> c<span class="token punctuation">.</span>total<span class="token punctuation">,</span> c<span class="token punctuation">.</span>lastUpdated<span class="token punctuation">)</span>
<span class="token punctuation">&#125;</span>

<span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
	<span class="token keyword">var</span> c Counter
	fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>c<span class="token punctuation">.</span><span class="token function">String</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
	<span class="token comment">// Go automatically converts it to a pointer type.</span>
	c<span class="token punctuation">.</span><span class="token function">Increment</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">//c.Increment() is converted to (&amp;c).Increment()</span>
	fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>c<span class="token punctuation">.</span><span class="token function">String</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token punctuation">&#125;</span></code>`,rk,En,jv,Np,zv,qv,Fp,Vv,Jv,Wp,Xv,$v,kk,za,kM=`<code class="language-bash">total: <span class="token number">0</span>, last updated: 0001-01-01 00:00:00 +0000 UTC
total: <span class="token number">1</span>, last updated: <span class="token number">2022</span>-08-10 <span class="token number">17</span>:54:27.046864964 +0900 KST <span class="token assign-left variable">m</span><span class="token operator">=</span>+0.000053109</code>`,fk,dk,Ek,Wt,Zv,mk,qa,fM=`<code class="language-go"><span class="token keyword">func</span> <span class="token function">doUpdateWrong</span><span class="token punctuation">(</span>c Counter<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    c<span class="token punctuation">.</span><span class="token function">Increment</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"in doUpdateWrong:"</span><span class="token punctuation">,</span> c<span class="token punctuation">.</span><span class="token function">String</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token punctuation">&#125;</span>

<span class="token keyword">func</span> <span class="token function">doUpdateRight</span><span class="token punctuation">(</span>c <span class="token operator">*</span>Counter<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    c<span class="token punctuation">.</span><span class="token function">Increment</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"in doUpdateRight:"</span><span class="token punctuation">,</span> c<span class="token punctuation">.</span><span class="token function">String</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token punctuation">&#125;</span>

<span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">var</span> c Counter
    <span class="token function">doUpdateWrong</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span>
    fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"in main:"</span><span class="token punctuation">,</span> c<span class="token punctuation">.</span><span class="token function">String</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
    <span class="token function">doUpdateRight</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>c<span class="token punctuation">)</span>
    fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"in main:"</span><span class="token punctuation">,</span> c<span class="token punctuation">.</span><span class="token function">String</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token punctuation">&#125;</span></code>`,vk,E,Up,Kv,Qv,jp,Yv,hv,zp,gv,n3,qp,s3,a3,Vp,t3,e3,Jp,p3,o3,Xp,l3,c3,$p,u3,i3,Zp,r3,k3,_k,Ut,f3,yk,Va,dM=`<code class="language-bash"><span class="token keyword">in</span> doUpdateWrong: total: <span class="token number">1</span>, last updated: <span class="token number">2022</span>-08-11 01:35:23.983808201 +0900 KST <span class="token assign-left variable">m</span><span class="token operator">=</span>+0.000097936
<span class="token keyword">in</span> main: total: <span class="token number">0</span>, last updated: 0001-01-01 00:00:00 +0000 UTC
<span class="token keyword">in</span> doUpdateRight: total: <span class="token number">1</span>, last updated: <span class="token number">2022</span>-08-11 01:35:23.983813841 +0900 KST <span class="token assign-left variable">m</span><span class="token operator">=</span>+0.000103576
<span class="token keyword">in</span> main: total: <span class="token number">1</span>, last updated: <span class="token number">2022</span>-08-11 01:35:23.983813841 +0900 KST <span class="token assign-left variable">m</span><span class="token operator">=</span>+0.000103576</code>`,bk,wk,Ck,mn,d3,Kp,E3,m3,Qp,v3,_3,Yp,y3,b3,Dk,Pk,Ok,Rk,ds,hp,w3,C3,gp,D3,P3,Tk,v,O3,no,R3,T3,so,S3,M3,ao,I3,L3,to,H3,A3,eo,G3,B3,po,x3,N3,oo,F3,W3,Sk,Ja,EM=`<code class="language-go"><span class="token keyword">type</span> IntTree <span class="token keyword">struct</span> <span class="token punctuation">&#123;</span>
	val         <span class="token builtin">int</span>
	left<span class="token punctuation">,</span> right <span class="token operator">*</span>IntTree
<span class="token punctuation">&#125;</span>

<span class="token keyword">func</span> <span class="token punctuation">(</span>it <span class="token operator">*</span>IntTree<span class="token punctuation">)</span> <span class="token function">Insert</span><span class="token punctuation">(</span>val <span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token operator">*</span>IntTree <span class="token punctuation">&#123;</span>
	<span class="token keyword">if</span> it <span class="token operator">==</span> <span class="token boolean">nil</span> <span class="token punctuation">&#123;</span> <span class="token comment">// case that handles when the receiver is a nil instance</span>
		<span class="token keyword">return</span> <span class="token operator">&amp;</span>IntTree<span class="token punctuation">&#123;</span>val<span class="token punctuation">:</span> val<span class="token punctuation">&#125;</span> <span class="token comment">// cannot assign its address into receiver directly</span>
	<span class="token punctuation">&#125;</span>
	<span class="token keyword">if</span> val <span class="token operator">&lt;</span> it<span class="token punctuation">.</span>val <span class="token punctuation">&#123;</span>
		it<span class="token punctuation">.</span>left <span class="token operator">=</span> it<span class="token punctuation">.</span>left<span class="token punctuation">.</span><span class="token function">Insert</span><span class="token punctuation">(</span>val<span class="token punctuation">)</span>
	<span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token keyword">if</span> val <span class="token operator">></span> it<span class="token punctuation">.</span>val <span class="token punctuation">&#123;</span>
		it<span class="token punctuation">.</span>right <span class="token operator">=</span> it<span class="token punctuation">.</span>right<span class="token punctuation">.</span><span class="token function">Insert</span><span class="token punctuation">(</span>val<span class="token punctuation">)</span>
	<span class="token punctuation">&#125;</span>
	<span class="token keyword">return</span> it
<span class="token punctuation">&#125;</span>

<span class="token keyword">func</span> <span class="token punctuation">(</span>it <span class="token operator">*</span>IntTree<span class="token punctuation">)</span> <span class="token function">Contains</span><span class="token punctuation">(</span>val <span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token builtin">bool</span> <span class="token punctuation">&#123;</span>
	<span class="token keyword">switch</span> <span class="token punctuation">&#123;</span>
	<span class="token keyword">case</span> it <span class="token operator">==</span> <span class="token boolean">nil</span><span class="token punctuation">:</span> <span class="token comment">// case that handles when the receiver is a nil instance</span>
		<span class="token keyword">return</span> <span class="token boolean">false</span>
	<span class="token keyword">case</span> val <span class="token operator">&lt;</span> it<span class="token punctuation">.</span>val<span class="token punctuation">:</span>
		<span class="token keyword">return</span> it<span class="token punctuation">.</span>left<span class="token punctuation">.</span><span class="token function">Contains</span><span class="token punctuation">(</span>val<span class="token punctuation">)</span>
	<span class="token keyword">case</span> val <span class="token operator">></span> it<span class="token punctuation">.</span>val<span class="token punctuation">:</span>
		<span class="token keyword">return</span> it<span class="token punctuation">.</span>right<span class="token punctuation">.</span><span class="token function">Contains</span><span class="token punctuation">(</span>val<span class="token punctuation">)</span>
	<span class="token keyword">default</span><span class="token punctuation">:</span>
		<span class="token keyword">return</span> <span class="token boolean">true</span>
	<span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span>

<span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
	<span class="token keyword">var</span> it <span class="token operator">*</span>IntTree
	it <span class="token operator">=</span> it<span class="token punctuation">.</span><span class="token function">Insert</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span>
	it <span class="token operator">=</span> it<span class="token punctuation">.</span><span class="token function">Insert</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span>
	it <span class="token operator">=</span> it<span class="token punctuation">.</span><span class="token function">Insert</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span>
	it <span class="token operator">=</span> it<span class="token punctuation">.</span><span class="token function">Insert</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span>
	fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>it<span class="token punctuation">.</span><span class="token function">Contains</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">)</span>  <span class="token comment">// true</span>
	fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>it<span class="token punctuation">.</span><span class="token function">Contains</span><span class="token punctuation">(</span><span class="token number">12</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment">// false</span>
<span class="token punctuation">&#125;</span></code>`,Mk,Fs,U3,lo,j3,z3,Ik,pn,co,q3,V3,uo,J3,X3,io,$3,Z3,ro,K3,Q3,Lk,Hk,Ak,Gk,Ws,Us,ko,Y3,Bk,jt,h3,xk,Xa,mM=`<code class="language-go"><span class="token keyword">type</span> Adder <span class="token keyword">struct</span> <span class="token punctuation">&#123;</span>
	start <span class="token builtin">int</span>
<span class="token punctuation">&#125;</span>

<span class="token keyword">func</span> <span class="token punctuation">(</span>a Adder<span class="token punctuation">)</span> <span class="token function">AddTo</span><span class="token punctuation">(</span>val <span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token builtin">int</span> <span class="token punctuation">&#123;</span>
	<span class="token keyword">return</span> a<span class="token punctuation">.</span>start <span class="token operator">+</span> val
<span class="token punctuation">&#125;</span>

<span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
	myAdder <span class="token operator">:=</span> Adder<span class="token punctuation">&#123;</span>start<span class="token punctuation">:</span> <span class="token number">10</span><span class="token punctuation">&#125;</span>
	fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>myAdder<span class="token punctuation">.</span><span class="token function">AddTo</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment">// prints 15</span>

	f1 <span class="token operator">:=</span> myAdder<span class="token punctuation">.</span>AddTo           <span class="token comment">// We can also assign the method to a variable or pass it to a parameter of type func(int)int</span>
	fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token function">f1</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">)</span>           <span class="token comment">// prints 20</span>

	f2 <span class="token operator">:=</span> Adder<span class="token punctuation">.</span>AddTo
	fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token function">f2</span><span class="token punctuation">(</span>myAdder<span class="token punctuation">,</span> <span class="token number">15</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment">// prints 25</span>
<span class="token punctuation">&#125;</span></code>`,Nk,vn,g3,fo,n5,s5,Eo,a5,t5,mo,e5,p5,Fk,N,vo,o5,l5,_o,c5,u5,yo,i5,r5,bo,k5,f5,wo,d5,E5,Wk,X,m5,Co,v5,_5,Do,y5,b5,Po,w5,C5,Oo,D5,P5,Uk,js,O5,Ro,R5,T5,jk,zk,qk,Vk,zs,qs,To,S5,Jk,Xk,$k,Bn,M5,So,I5,L5,Mo,H5,A5,Zk,zt,G5,Kk,$a,vM=`<code class="language-go"><span class="token keyword">type</span> Employee <span class="token keyword">struct</span> <span class="token punctuation">&#123;</span>
	Name <span class="token builtin">string</span>
	ID   <span class="token builtin">string</span>
<span class="token punctuation">&#125;</span>

<span class="token keyword">func</span> <span class="token punctuation">(</span>e Employee<span class="token punctuation">)</span> <span class="token function">Description</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token builtin">string</span> <span class="token punctuation">&#123;</span>
	<span class="token keyword">return</span> fmt<span class="token punctuation">.</span><span class="token function">Sprintf</span><span class="token punctuation">(</span><span class="token string">"%s (%s)"</span><span class="token punctuation">,</span> e<span class="token punctuation">.</span>Name<span class="token punctuation">,</span> e<span class="token punctuation">.</span>ID<span class="token punctuation">)</span>
<span class="token punctuation">&#125;</span>

<span class="token keyword">type</span> Manager <span class="token keyword">struct</span> <span class="token punctuation">&#123;</span>
	<span class="token comment">// Employee as an embedded field</span>
	Employee <span class="token comment">// no name assigned to this filed. only type.</span>
	Reports  <span class="token punctuation">[</span><span class="token punctuation">]</span>Employee
<span class="token punctuation">&#125;</span>

<span class="token keyword">func</span> <span class="token punctuation">(</span>m Manager<span class="token punctuation">)</span> <span class="token function">FindNewEmployees</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>Employee <span class="token punctuation">&#123;</span>
	<span class="token comment">// do business logic</span>
	<span class="token keyword">return</span> m<span class="token punctuation">.</span>Reports
<span class="token punctuation">&#125;</span>

<span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
	m <span class="token operator">:=</span> Manager<span class="token punctuation">&#123;</span>
		Employee<span class="token punctuation">:</span> Employee<span class="token punctuation">&#123;</span>
			Name<span class="token punctuation">:</span> <span class="token string">"Bob Bobson"</span><span class="token punctuation">,</span>
			ID<span class="token punctuation">:</span>   <span class="token string">"12345"</span><span class="token punctuation">,</span>
		<span class="token punctuation">&#125;</span><span class="token punctuation">,</span>
		Reports<span class="token punctuation">:</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>Employee<span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token punctuation">,</span>
	<span class="token punctuation">&#125;</span>
	fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>m<span class="token punctuation">.</span>ID<span class="token punctuation">)</span>            <span class="token comment">// prints 12345</span>
	fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>m<span class="token punctuation">.</span><span class="token function">Description</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token comment">// prints Bob Bobson (12345)</span>
<span class="token punctuation">&#125;</span></code>`,Qk,y,Io,B5,x5,Lo,N5,F5,Ho,W5,U5,Ao,j5,z5,Go,q5,V5,Bo,J5,X5,xo,$5,Z5,Yk,hk,gk,Za,_M=`<code class="language-go"><span class="token keyword">type</span> Inner <span class="token keyword">struct</span> <span class="token punctuation">&#123;</span>
    X <span class="token builtin">int</span>
<span class="token punctuation">&#125;</span>

<span class="token keyword">type</span> Outer <span class="token keyword">struct</span> <span class="token punctuation">&#123;</span>
    Inner
    X <span class="token builtin">int</span>
<span class="token punctuation">&#125;</span>

<span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
	o <span class="token operator">:=</span> Outer<span class="token punctuation">&#123;</span>
		Inner<span class="token punctuation">:</span> Inner<span class="token punctuation">&#123;</span>
			X<span class="token punctuation">:</span> <span class="token number">10</span><span class="token punctuation">,</span>
		<span class="token punctuation">&#125;</span><span class="token punctuation">,</span>
		X<span class="token punctuation">:</span> <span class="token number">20</span><span class="token punctuation">,</span>
	<span class="token punctuation">&#125;</span>
	fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>o<span class="token punctuation">.</span>X<span class="token punctuation">)</span>       <span class="token comment">// prints 20</span>
	fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>o<span class="token punctuation">.</span>Inner<span class="token punctuation">.</span>X<span class="token punctuation">)</span> <span class="token comment">// prints 10</span>
<span class="token punctuation">&#125;</span></code>`,nf,Vs,K5,No,Q5,Y5,sf,_n,h5,Fo,g5,n_,Wo,s_,a_,Uo,t_,e_,af,tf,ef,pf,Es,jo,p_,o_,zo,l_,c_,of,lf,cf,xn,u_,qo,i_,r_,Vo,k_,f_,uf,Ka,yM=`<code class="language-go"><span class="token keyword">var</span> m Manager <span class="token operator">:=</span> <span class="token punctuation">&#123;</span><span class="token comment">/*fields*/</span><span class="token punctuation">&#125;</span>
<span class="token keyword">var</span> eFail Employee <span class="token operator">=</span> m			<span class="token comment">// complie error</span>
<span class="token keyword">var</span> eOk Employee <span class="token operator">=</span> m<span class="token punctuation">.</span>Employee   <span class="token comment">// successfully compiled</span></code>`,rf,$,d_,Jo,E_,m_,Xo,v_,__,$o,y_,b_,Zo,w_,C_,kf,ff,df,Js,D_,Ko,P_,O_,Ef,Qa,bM=`<code class="language-go"><span class="token keyword">type</span> Inner <span class="token keyword">struct</span> <span class="token punctuation">&#123;</span>
	A <span class="token builtin">int</span>
<span class="token punctuation">&#125;</span>

<span class="token keyword">func</span> <span class="token punctuation">(</span>i Inner<span class="token punctuation">)</span> <span class="token function">IntPrinter</span><span class="token punctuation">(</span>val <span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token builtin">string</span> <span class="token punctuation">&#123;</span>
	<span class="token keyword">return</span> fmt<span class="token punctuation">.</span><span class="token function">Sprintf</span><span class="token punctuation">(</span><span class="token string">"Inner: %d"</span><span class="token punctuation">,</span> val<span class="token punctuation">)</span> <span class="token comment">// This always call Inner.IntPrinter()</span>
<span class="token punctuation">&#125;</span>

<span class="token keyword">func</span> <span class="token punctuation">(</span>i Inner<span class="token punctuation">)</span> <span class="token function">Double</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token builtin">string</span> <span class="token punctuation">&#123;</span>
	<span class="token keyword">return</span> i<span class="token punctuation">.</span><span class="token function">IntPrinter</span><span class="token punctuation">(</span>i<span class="token punctuation">.</span>A <span class="token operator">*</span> <span class="token number">2</span><span class="token punctuation">)</span>
<span class="token punctuation">&#125;</span>

<span class="token keyword">type</span> Outer <span class="token keyword">struct</span> <span class="token punctuation">&#123;</span>
	Inner
	S <span class="token builtin">string</span>
<span class="token punctuation">&#125;</span>

<span class="token keyword">func</span> <span class="token punctuation">(</span>o Outer<span class="token punctuation">)</span> <span class="token function">IntPrinter</span><span class="token punctuation">(</span>val <span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token builtin">string</span> <span class="token punctuation">&#123;</span>
	<span class="token keyword">return</span> fmt<span class="token punctuation">.</span><span class="token function">Sprintf</span><span class="token punctuation">(</span><span class="token string">"Outer: %d"</span><span class="token punctuation">,</span> val<span class="token punctuation">)</span>
<span class="token punctuation">&#125;</span>

<span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
	o <span class="token operator">:=</span> Outer<span class="token punctuation">&#123;</span>
		Inner<span class="token punctuation">:</span> Inner<span class="token punctuation">&#123;</span>
			A<span class="token punctuation">:</span> <span class="token number">10</span><span class="token punctuation">,</span>
		<span class="token punctuation">&#125;</span><span class="token punctuation">,</span>
		S<span class="token punctuation">:</span> <span class="token string">"Hello"</span><span class="token punctuation">,</span>
	<span class="token punctuation">&#125;</span>

	fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>o<span class="token punctuation">.</span><span class="token function">Double</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token punctuation">&#125;</span></code>`,mf,Ya,wM='<code class="language-bash">Inner: <span class="token number">20</span></code>',vf,I,R_,Qo,T_,S_,Yo,M_,I_,ho,L_,H_,go,A_,G_,nl,B_,x_,_f,yf,bf,wf,Xs,$s,sl,N_,Cf,Df,Pf,Zs,F_,al,W_,U_,Of,qt,j_,Rf,ha,CM=`<code class="language-go"><span class="token keyword">type</span> Stringer <span class="token keyword">interface</span> <span class="token punctuation">&#123;</span>
	<span class="token function">String</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token builtin">string</span>
<span class="token punctuation">&#125;</span></code>`,Tf,b,tl,z_,q_,el,V_,J_,pl,X_,$_,ol,Z_,K_,ll,Q_,Y_,cl,h_,g_,ul,n0,s0,Sf,Mf,If,on,il,a0,t0,rl,e0,p0,kl,o0,l0,fl,c0,u0,Lf,L,i0,Vt,r0,k0,dl,f0,d0,El,E0,m0,ml,v0,_0,vl,y0,b0,Hf,ga,_l,w0,C0,Af,Nn,D0,yl,P0,O0,bl,R0,T0,Gf,Jt,S0,Bf,Xt,M0,xf,Nf,Ff,$t,I0,Wf,Zt,L0,Uf,nt,DM=`<code class="language-go"><span class="token keyword">type</span> LogicProvider <span class="token keyword">struct</span><span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span>

<span class="token keyword">func</span> <span class="token punctuation">(</span>lp LogicProvider<span class="token punctuation">)</span> <span class="token function">Process</span><span class="token punctuation">(</span>data <span class="token builtin">string</span><span class="token punctuation">)</span> <span class="token builtin">string</span> <span class="token punctuation">&#123;</span>
	<span class="token comment">// do some business logic</span>
	<span class="token keyword">return</span> data <span class="token operator">+</span> <span class="token string">"!"</span>
<span class="token punctuation">&#125;</span>

<span class="token keyword">type</span> Logic <span class="token keyword">interface</span> <span class="token punctuation">&#123;</span>
	<span class="token function">Process</span><span class="token punctuation">(</span>data <span class="token builtin">string</span><span class="token punctuation">)</span> <span class="token builtin">string</span>
<span class="token punctuation">&#125;</span>

<span class="token keyword">type</span> Client <span class="token keyword">struct</span> <span class="token punctuation">&#123;</span>
	L Logic
<span class="token punctuation">&#125;</span>

<span class="token keyword">func</span> <span class="token punctuation">(</span>c Client<span class="token punctuation">)</span> <span class="token function">Program</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
	<span class="token comment">// get data from somewhere</span>
	data <span class="token operator">:=</span> <span class="token string">"hello world"</span>
	refinedData <span class="token operator">:=</span> c<span class="token punctuation">.</span>L<span class="token punctuation">.</span><span class="token function">Process</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span>
	fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>refinedData<span class="token punctuation">)</span>
<span class="token punctuation">&#125;</span>

<span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
	c <span class="token operator">:=</span> Client<span class="token punctuation">&#123;</span>
		L<span class="token punctuation">:</span> LogicProvider<span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token punctuation">,</span> <span class="token comment">// concrete type assigned into Client's interface</span>
	<span class="token punctuation">&#125;</span>
	c<span class="token punctuation">.</span><span class="token function">Program</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">&#125;</span></code>`,jf,f,wl,H0,A0,Cl,G0,B0,Dl,x0,N0,Pl,F0,W0,Ol,U0,j0,Rl,z0,q0,Tl,V0,J0,Sl,X0,$0,Ml,Z0,K0,Il,Q0,Y0,Ll,h0,g0,Hl,n4,s4,Al,a4,t4,zf,qf,Vf,Z,e4,Gl,p4,o4,Bl,l4,c4,xl,u4,i4,Nl,r4,k4,Jf,Kt,f4,Xf,st,PM=`<code class="language-go">
<span class="token keyword">func</span> <span class="token function">process</span><span class="token punctuation">(</span>r io<span class="token punctuation">.</span>Reader<span class="token punctuation">)</span> <span class="token builtin">error</span> <span class="token punctuation">&#123;</span>
	<span class="token comment">// do something</span>
<span class="token punctuation">&#125;</span>

<span class="token keyword">func</span> <span class="token function">openfile</span><span class="token punctuation">(</span>fileName <span class="token builtin">string</span><span class="token punctuation">)</span> <span class="token builtin">error</span> <span class="token punctuation">&#123;</span>
	r<span class="token punctuation">,</span> err <span class="token operator">:=</span> os<span class="token punctuation">.</span><span class="token function">Open</span><span class="token punctuation">(</span>fileName<span class="token punctuation">)</span>
	<span class="token keyword">if</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">&#123;</span>
		<span class="token keyword">return</span> err
	<span class="token punctuation">&#125;</span>
	<span class="token keyword">defer</span> r<span class="token punctuation">.</span><span class="token function">CLose</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
	<span class="token keyword">return</span> <span class="token function">process</span><span class="token punctuation">(</span>r<span class="token punctuation">)</span>
<span class="token punctuation">&#125;</span></code>`,$f,K,d4,Fl,E4,m4,Wl,v4,_4,Ul,y4,b4,jl,w4,C4,Zf,Fn,D4,zl,P4,O4,ql,R4,T4,Kf,at,OM=`<code class="language-go"><span class="token keyword">func</span> <span class="token function">openfile</span><span class="token punctuation">(</span>fileName <span class="token builtin">string</span><span class="token punctuation">)</span> <span class="token builtin">error</span> <span class="token punctuation">&#123;</span>
	r<span class="token punctuation">,</span> err <span class="token operator">:=</span> os<span class="token punctuation">.</span><span class="token function">Open</span><span class="token punctuation">(</span>fileName<span class="token punctuation">)</span>
	<span class="token keyword">if</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">&#123;</span>
	r	eturn err
	<span class="token punctuation">&#125;</span>
	<span class="token keyword">defer</span> r<span class="token punctuation">.</span><span class="token function">Close</span><span class="token punctuation">(</span><span class="token punctuation">)</span>

	gz<span class="token punctuation">,</span> err <span class="token operator">=</span> gzip<span class="token punctuation">.</span><span class="token function">NewReader</span><span class="token punctuation">(</span>r<span class="token punctuation">)</span>
	<span class="token keyword">if</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">&#123;</span>
		<span class="token keyword">return</span> err
	<span class="token punctuation">&#125;</span>
	<span class="token keyword">defer</span> gz<span class="token punctuation">.</span><span class="token function">Close</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
	<span class="token keyword">return</span> <span class="token function">process</span><span class="token punctuation">(</span>gz<span class="token punctuation">)</span>
<span class="token punctuation">&#125;</span></code>`,Qf,Qt,S4,Yf,P,M4,Vl,I4,L4,Jl,H4,A4,Xl,G4,B4,$l,x4,N4,Zl,F4,W4,Kl,U4,j4,hf,Q,z4,Ql,q4,V4,Yl,J4,X4,hl,$4,Z4,gl,K4,Q4,gf,n1,s1,a1,Ks,Qs,nc,Y4,t1,ln,sc,h4,g4,ac,ny,sy,tc,ay,ty,ec,ey,py,e1,tt,RM=`<code class="language-go"><span class="token keyword">type</span> Reader <span class="token keyword">interface</span> <span class="token punctuation">&#123;</span>
	<span class="token function">Read</span><span class="token punctuation">(</span>p <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">byte</span><span class="token punctuation">)</span> <span class="token punctuation">(</span>n <span class="token builtin">int</span><span class="token punctuation">,</span> err <span class="token builtin">error</span><span class="token punctuation">)</span>
<span class="token punctuation">&#125;</span>

<span class="token keyword">type</span> Closer <span class="token keyword">interface</span> <span class="token punctuation">&#123;</span>
	<span class="token function">Close</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token builtin">error</span>
<span class="token punctuation">&#125;</span>

<span class="token keyword">type</span> ReadCloser <span class="token keyword">interface</span> <span class="token punctuation">&#123;</span>
	Reader
	Closer
<span class="token punctuation">&#125;</span></code>`,p1,o1,l1,c1,Ys,hs,pc,oy,u1,gs,ly,oc,cy,uy,i1,Yt,iy,r1,ht,ry,k1,gt,ky,f1,Wn,fy,lc,dy,Ey,cc,my,vy,d1,ne,_y,E1,se,yy,m1,v1,_1,y1,na,sa,uc,by,b1,Un,wy,ic,Cy,Dy,rc,Py,Oy,w1,et,TM=`<code class="language-go">	<span class="token keyword">var</span> s <span class="token operator">*</span><span class="token builtin">string</span>
	fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>s <span class="token operator">==</span> <span class="token boolean">nil</span><span class="token punctuation">)</span>
	<span class="token keyword">var</span> i <span class="token keyword">interface</span><span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span>
	fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>i <span class="token operator">==</span> <span class="token boolean">nil</span><span class="token punctuation">)</span>
	i <span class="token operator">=</span> s
	fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>i<span class="token punctuation">,</span> i <span class="token operator">==</span> <span class="token boolean">nil</span><span class="token punctuation">)</span></code>`,C1,pt,SM=`<code class="language-bash"><span class="token operator">&lt;</span>nil<span class="token operator">></span> <span class="token boolean">true</span>
<span class="token operator">&lt;</span>nil<span class="token operator">></span> <span class="token boolean">true</span>
<span class="token operator">&lt;</span>nil<span class="token operator">></span> <span class="token boolean">false</span></code>`,D1,jn,Ry,kc,Ty,Sy,fc,My,Iy,P1,O,Ly,dc,Hy,Ay,Ec,Gy,By,mc,xy,Ny,vc,Fy,Wy,_c,Uy,jy,yc,zy,qy,O1,Y,Vy,bc,Jy,Xy,wc,$y,Zy,Cc,Ky,Qy,Dc,Yy,hy,R1,T1,S1,M1,aa,ta,Pc,gy,I1,ea,n6,Oc,s6,a6,L1,ot,MM=`<code class="language-go"><span class="token keyword">var</span> i <span class="token keyword">interface</span><span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span> <span class="token comment">// empty interfece variable can store a value of any type</span>

i <span class="token operator">=</span> <span class="token number">20</span>
fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span>

i <span class="token operator">=</span> <span class="token string">"hello"</span>
fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span>

i <span class="token operator">=</span> <span class="token keyword">struct</span> <span class="token punctuation">&#123;</span>
	FirstName <span class="token builtin">string</span>
	LastName  <span class="token builtin">string</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">&#123;</span><span class="token string">"Fred"</span><span class="token punctuation">,</span> <span class="token string">"Fredson"</span><span class="token punctuation">&#125;</span>
fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span></code>`,H1,zn,t6,Rc,e6,p6,Tc,o6,l6,A1,G1,B1,ae,c6,x1,lt,IM=`<code class="language-go">data <span class="token operator">:=</span> <span class="token keyword">map</span><span class="token punctuation">[</span><span class="token builtin">string</span><span class="token punctuation">]</span><span class="token keyword">interface</span><span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span>

contents<span class="token punctuation">,</span> err <span class="token operator">:=</span> ioutil<span class="token punctuation">.</span><span class="token function">ReadFile</span><span class="token punctuation">(</span><span class="token string">"testdata/sample.json"</span><span class="token punctuation">)</span>
<span class="token keyword">if</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">return</span> err
<span class="token punctuation">&#125;</span>
<span class="token keyword">defer</span> contents<span class="token punctuation">.</span><span class="token function">Close</span><span class="token punctuation">(</span><span class="token punctuation">)</span>

json<span class="token punctuation">.</span><span class="token function">Unmarshal</span><span class="token punctuation">(</span>contents<span class="token punctuation">,</span> <span class="token operator">&amp;</span>data<span class="token punctuation">)</span></code>`,N1,pa,u6,Sc,i6,r6,F1,W1,U1,yn,k6,Mc,f6,d6,Ic,E6,m6,Lc,v6,_6,j1,ct,LM=`<code class="language-go"><span class="token keyword">type</span> LinkedList <span class="token keyword">struct</span> <span class="token punctuation">&#123;</span>
    Value <span class="token keyword">interface</span><span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span>
    Next    <span class="token operator">*</span>LinkedList
<span class="token punctuation">&#125;</span>

<span class="token keyword">func</span> <span class="token punctuation">(</span>ll <span class="token operator">*</span>LinkedList<span class="token punctuation">)</span> <span class="token function">Insert</span><span class="token punctuation">(</span>pos <span class="token builtin">int</span><span class="token punctuation">,</span> val <span class="token keyword">interface</span><span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span> <span class="token operator">*</span>LinkedList <span class="token punctuation">&#123;</span>
    <span class="token keyword">if</span> ll <span class="token operator">==</span> <span class="token boolean">nil</span> <span class="token operator">||</span> pos <span class="token operator">==</span> <span class="token number">0</span> <span class="token punctuation">&#123;</span>
        <span class="token keyword">return</span> <span class="token operator">&amp;</span>LinkedList<span class="token punctuation">&#123;</span>
            Value<span class="token punctuation">:</span> val<span class="token punctuation">,</span>
            Next<span class="token punctuation">:</span>    ll<span class="token punctuation">,</span>
        <span class="token punctuation">&#125;</span>
    <span class="token punctuation">&#125;</span>
    ll<span class="token punctuation">.</span>Next <span class="token operator">=</span> ll<span class="token punctuation">.</span>Next<span class="token punctuation">.</span><span class="token function">Insert</span><span class="token punctuation">(</span>pos<span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span> val<span class="token punctuation">)</span>
    <span class="token keyword">return</span> ll
<span class="token punctuation">&#125;</span></code>`,z1,te,y6,q1,bn,b6,Hc,w6,C6,Ac,D6,P6,Gc,O6,R6,V1,J1,X1,H,T6,Bc,S6,M6,xc,I6,L6,Nc,H6,A6,Fc,G6,B6,Wc,x6,N6,$1,Z1,K1,Q1,oa,la,Uc,F6,Y1,ee,W6,h1,ca,U6,jc,j6,z6,g1,ut,HM=`<code class="language-go"><span class="token keyword">type</span> MyInt <span class="token builtin">int</span>

<span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">var</span> i <span class="token keyword">interface</span><span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span>
    <span class="token keyword">var</span> mine MyInt <span class="token operator">=</span> <span class="token number">20</span>
    i <span class="token operator">=</span> mine
    i2 <span class="token operator">:=</span> i<span class="token punctuation">.</span><span class="token punctuation">(</span>MyInt<span class="token punctuation">)</span> <span class="token comment">// using type assertion, we can confine the type of concrete type that the interface indicates</span>
    fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>i2 <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span>
<span class="token punctuation">&#125;</span></code>`,nd,A,q6,zc,V6,J6,qc,X6,$6,Vc,Z6,K6,Jc,Q6,Y6,Xc,h6,g6,sd,ad,td,qn,n7,$c,s7,a7,Zc,t7,e7,ed,it,AM=`<code class="language-go">i3 <span class="token operator">:=</span> i<span class="token punctuation">.</span><span class="token punctuation">(</span><span class="token builtin">string</span><span class="token punctuation">)</span> <span class="token comment">// this line occurs a panic</span>
fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>i3<span class="token punctuation">)</span></code>`,pd,od,ld,cn,Kc,p7,o7,Qc,l7,c7,Yc,u7,i7,hc,r7,k7,cd,rt,GM=`<code class="language-go">i4 <span class="token operator">:=</span> i<span class="token punctuation">.</span><span class="token punctuation">(</span><span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token comment">// this line also occurs a panic</span>
fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>i4<span class="token punctuation">)</span></code>`,ud,id,rd,ms,gc,f7,d7,nu,E7,m7,kd,kt,BM=`<code class="language-go"><span class="token comment">// ok is set to true if the type conversion was successful.</span>
<span class="token comment">// if it was not, ok is set to false and the other value is set to its zero value</span>
i5<span class="token punctuation">,</span> ok <span class="token operator">:=</span> i<span class="token punctuation">.</span><span class="token punctuation">(</span><span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token comment">// i5 is set to 0, ok is set to false</span>
<span class="token keyword">if</span> <span class="token operator">!</span>ok <span class="token punctuation">&#123;</span>
	msg <span class="token operator">:=</span> fmt<span class="token punctuation">.</span><span class="token function">Errorf</span><span class="token punctuation">(</span><span class="token string">"unexpected type for %v"</span><span class="token punctuation">,</span> i5<span class="token punctuation">)</span>
	fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>msg<span class="token punctuation">)</span>
<span class="token punctuation">&#125;</span>

i6<span class="token punctuation">,</span> ok <span class="token operator">:=</span> i<span class="token punctuation">.</span><span class="token punctuation">(</span>MyInt<span class="token punctuation">)</span>
<span class="token keyword">if</span> <span class="token operator">!</span>ok <span class="token punctuation">&#123;</span> <span class="token comment">// i6 is set to 20, ok is set to true</span>
	<span class="token comment">// this block is not reached</span>
	msg <span class="token operator">:=</span> fmt<span class="token punctuation">.</span><span class="token function">Errorf</span><span class="token punctuation">(</span><span class="token string">"unexpected type for %v"</span><span class="token punctuation">,</span> i6<span class="token punctuation">)</span>
	fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>msg<span class="token punctuation">)</span>
<span class="token punctuation">&#125;</span></code>`,fd,w,su,v7,_7,au,y7,b7,tu,w7,C7,eu,D7,P7,O7,R7,pu,T7,S7,ou,M7,I7,dd,Vn,L7,lu,H7,A7,cu,G7,B7,Ed,ua,x7,uu,N7,F7,md,vd,_d,yd,ia,W7,iu,U7,j7,bd,ft,xM=`<code class="language-go"><span class="token keyword">func</span> <span class="token function">typeSwitch</span><span class="token punctuation">(</span>i <span class="token keyword">interface</span><span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
	<span class="token keyword">switch</span> i<span class="token punctuation">.</span><span class="token punctuation">(</span><span class="token keyword">type</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
	<span class="token keyword">case</span> <span class="token boolean">nil</span><span class="token punctuation">:</span>
		fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"nil"</span><span class="token punctuation">)</span>
	<span class="token keyword">case</span> <span class="token builtin">int</span><span class="token punctuation">:</span>
		fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"int"</span><span class="token punctuation">)</span>
	<span class="token keyword">case</span> MyInt<span class="token punctuation">:</span>
		fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"MyInt"</span><span class="token punctuation">)</span>
	<span class="token keyword">case</span> <span class="token builtin">string</span><span class="token punctuation">:</span>
		fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"string"</span><span class="token punctuation">)</span>
	<span class="token keyword">case</span> <span class="token builtin">bool</span><span class="token punctuation">,</span> <span class="token builtin">rune</span><span class="token punctuation">:</span>
		fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"bool or rune"</span><span class="token punctuation">)</span>
	<span class="token keyword">default</span><span class="token punctuation">:</span>
		fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"what is this"</span><span class="token punctuation">)</span>
	<span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span>

<span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
	<span class="token keyword">var</span> a <span class="token builtin">int</span> <span class="token operator">=</span> <span class="token number">12</span>
	<span class="token keyword">var</span> b MyInt <span class="token operator">=</span> <span class="token number">23</span>
	<span class="token keyword">var</span> c <span class="token operator">*</span><span class="token builtin">string</span>
	d <span class="token operator">:=</span> <span class="token string">"asdasd"</span>
	e <span class="token operator">:=</span> <span class="token keyword">map</span><span class="token punctuation">[</span><span class="token builtin">string</span><span class="token punctuation">]</span><span class="token builtin">string</span><span class="token punctuation">&#123;</span>
		<span class="token string">"hi"</span><span class="token punctuation">:</span> <span class="token string">"there"</span><span class="token punctuation">,</span>
	<span class="token punctuation">&#125;</span>
	<span class="token keyword">var</span> f <span class="token keyword">interface</span><span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span>

	<span class="token function">typeSwitch</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span>
	<span class="token function">typeSwitch</span><span class="token punctuation">(</span>b<span class="token punctuation">)</span>
	<span class="token function">typeSwitch</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span>
	<span class="token function">typeSwitch</span><span class="token punctuation">(</span>d<span class="token punctuation">)</span>
	<span class="token function">typeSwitch</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span>
	<span class="token function">typeSwitch</span><span class="token punctuation">(</span>f<span class="token punctuation">)</span>
<span class="token punctuation">&#125;</span></code>`,wd,dt,NM=`<code class="language-bash">int
MyInt
what is this
string
what is this
nil</code>`,Cd,Jn,z7,ru,q7,V7,ku,J7,X7,Dd,_,$7,fu,Z7,K7,du,Q7,Y7,Eu,h7,g7,mu,n8,s8,vu,a8,t8,_u,e8,p8,yu,o8,l8,Pd,ra,c8,bu,u8,i8,Od,un,wu,r8,k8,Cu,f8,d8,Du,E8,m8,Pu,v8,_8,Rd,Td,Sd,vs,Ou,y8,b8,Ru,w8,C8,Md,G,D8,Tu,P8,O8,Su,R8,T8,Mu,S8,M8,Iu,I8,L8,Lu,H8,A8,Id,m,Hu,G8,B8,Au,x8,N8,Gu,F8,W8,Bu,U8,j8,xu,z8,q8,Nu,V8,J8,Fu,X8,$8,Wu,Z8,K8,Ld,Et,FM=`<code class="language-go"><span class="token comment">// copyBuffer is the actual implementation of Copy and CopyBuffer.</span>
<span class="token comment">// if buf is nil, one is allocated.</span>
<span class="token keyword">func</span> <span class="token function">copyBuffer</span><span class="token punctuation">(</span>dst Writer<span class="token punctuation">,</span> src Reader<span class="token punctuation">,</span> buf <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">byte</span><span class="token punctuation">)</span> <span class="token punctuation">(</span>written <span class="token builtin">int64</span><span class="token punctuation">,</span> err <span class="token builtin">error</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token comment">// If the reader has a WriteTo method, use it to do the copy.</span>
    <span class="token comment">// Avoids an allocation and a copy.</span>
    <span class="token keyword">if</span> wt<span class="token punctuation">,</span> ok <span class="token operator">:=</span> src<span class="token punctuation">.</span><span class="token punctuation">(</span>WriterTo<span class="token punctuation">)</span><span class="token punctuation">;</span> ok <span class="token punctuation">&#123;</span>
        <span class="token keyword">return</span> wt<span class="token punctuation">.</span><span class="token function">WriteTo</span><span class="token punctuation">(</span>dst<span class="token punctuation">)</span>
    <span class="token punctuation">&#125;</span>
    <span class="token comment">// Similarly, if the writer has a ReadFrom method, use it to do the copy.</span>
    <span class="token keyword">if</span> rt<span class="token punctuation">,</span> ok <span class="token operator">:=</span> dst<span class="token punctuation">.</span><span class="token punctuation">(</span>ReaderFrom<span class="token punctuation">)</span><span class="token punctuation">;</span> ok <span class="token punctuation">&#123;</span>
        <span class="token keyword">return</span> rt<span class="token punctuation">.</span><span class="token function">ReadFrom</span><span class="token punctuation">(</span>src<span class="token punctuation">)</span>
    <span class="token punctuation">&#125;</span>
    <span class="token comment">// function continues...</span>
<span class="token punctuation">&#125;</span></code>`,Hd,Ad,Gd,Xn,Q8,Uu,Y8,h8,ju,g8,n9,Bd,R,s9,zu,a9,t9,qu,e9,p9,Vu,o9,l9,Ju,c9,u9,Xu,i9,r9,$u,k9,f9,xd,mt,WM=`<code class="language-go"><span class="token keyword">func</span> <span class="token function">ctxDriverStmtExec</span><span class="token punctuation">(</span>ctx context<span class="token punctuation">.</span>Context<span class="token punctuation">,</span> si driver<span class="token punctuation">.</span>Stmt<span class="token punctuation">,</span>
                       nvdargs <span class="token punctuation">[</span><span class="token punctuation">]</span>driver<span class="token punctuation">.</span>NamedValue<span class="token punctuation">)</span> <span class="token punctuation">(</span>driver<span class="token punctuation">.</span>Result<span class="token punctuation">,</span> <span class="token builtin">error</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">if</span> siCtx<span class="token punctuation">,</span> is <span class="token operator">:=</span> si<span class="token punctuation">.</span><span class="token punctuation">(</span>driver<span class="token punctuation">.</span>StmtExecContext<span class="token punctuation">)</span><span class="token punctuation">;</span> is <span class="token punctuation">&#123;</span>
        <span class="token keyword">return</span> siCtx<span class="token punctuation">.</span><span class="token function">ExecContext</span><span class="token punctuation">(</span>ctx<span class="token punctuation">,</span> nvdargs<span class="token punctuation">)</span>
    <span class="token punctuation">&#125;</span>
    <span class="token comment">// fallback code is here</span>
<span class="token punctuation">&#125;</span></code>`,Nd,Fd,Wd,$n,d9,Zu,E9,m9,Ku,v9,_9,Ud,T,y9,Qu,b9,w9,Yu,C9,D9,hu,P9,O9,gu,R9,T9,ni,S9,M9,si,I9,L9,jd,h,H9,ai,A9,G9,ti,B9,x9,ei,N9,F9,pi,W9,U9,zd,qd,Vd,vt,oi,j9,z9,Jd,g,q9,li,V9,J9,ci,X9,$9,ui,Z9,K9,ii,Q9,Y9,Xd,$d,Zd,Kd,ka,fa,ri,h9,Qd,pe,g9,Yd,oe,nb,hd,_t,UM=`<code class="language-go"><span class="token keyword">type</span> Handler <span class="token keyword">interface</span> <span class="token punctuation">&#123;</span>
    <span class="token function">ServeHTTP</span><span class="token punctuation">(</span>http<span class="token punctuation">.</span>ResponseWriter<span class="token punctuation">,</span> <span class="token operator">*</span>http<span class="token punctuation">.</span>Request<span class="token punctuation">)</span>
<span class="token punctuation">&#125;</span></code>`,gd,F,ki,sb,ab,fi,tb,eb,di,pb,ob,Ei,lb,cb,mi,ub,ib,nE,yt,jM=`<code class="language-go"><span class="token keyword">type</span> HandlerFunc <span class="token keyword">func</span><span class="token punctuation">(</span>http<span class="token punctuation">.</span>ResponseWriter<span class="token punctuation">,</span> <span class="token operator">*</span>http<span class="token punctuation">.</span>Request<span class="token punctuation">)</span>

<span class="token keyword">func</span> <span class="token punctuation">(</span>f HandlerFunc<span class="token punctuation">)</span> <span class="token function">ServeHTTP</span><span class="token punctuation">(</span>w http<span class="token punctuation">.</span>ResponseWriter<span class="token punctuation">,</span> r <span class="token operator">*</span>http<span class="token punctuation">.</span>Request<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    <span class="token function">f</span><span class="token punctuation">(</span>w<span class="token punctuation">,</span> r<span class="token punctuation">)</span>
<span class="token punctuation">&#125;</span></code>`,sE,da,rb,vi,kb,fb,aE,tE,eE,le,db,pE,Zn,Eb,_i,mb,vb,yi,_b,yb,oE,lE,cE,uE,Ea,ma,bi,bb,iE,bt,wi,wb,Cb,rE,ce,Db,kE,wt,zM=`<code class="language-go"><span class="token keyword">func</span> <span class="token function">LogOutput</span><span class="token punctuation">(</span>message <span class="token builtin">string</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>message<span class="token punctuation">)</span>
<span class="token punctuation">&#125;</span>

<span class="token keyword">type</span> SimpleDataStore <span class="token keyword">struct</span> <span class="token punctuation">&#123;</span>
    userData <span class="token keyword">map</span><span class="token punctuation">[</span><span class="token builtin">string</span><span class="token punctuation">]</span><span class="token builtin">string</span>
<span class="token punctuation">&#125;</span>

<span class="token keyword">func</span> <span class="token punctuation">(</span>sds SimpleDataStore<span class="token punctuation">)</span> <span class="token function">UserNameForID</span><span class="token punctuation">(</span>userID <span class="token builtin">string</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token builtin">string</span><span class="token punctuation">,</span> <span class="token builtin">bool</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    name<span class="token punctuation">,</span> ok <span class="token operator">:=</span> sds<span class="token punctuation">.</span>userData<span class="token punctuation">[</span>userID<span class="token punctuation">]</span>
    <span class="token keyword">return</span> name<span class="token punctuation">,</span> ok
<span class="token punctuation">&#125;</span></code>`,fE,va,Pb,Ci,Ob,Rb,dE,Ct,qM=`<code class="language-go"><span class="token keyword">func</span> <span class="token function">NewSimpleDataStore</span><span class="token punctuation">(</span><span class="token punctuation">)</span> SimpleDataStore <span class="token punctuation">&#123;</span>
	<span class="token keyword">return</span> SimpleDataStore<span class="token punctuation">&#123;</span>
		userData<span class="token punctuation">:</span> <span class="token keyword">map</span><span class="token punctuation">[</span><span class="token builtin">string</span><span class="token punctuation">]</span><span class="token builtin">string</span><span class="token punctuation">&#123;</span>
			<span class="token string">"1"</span><span class="token punctuation">:</span> <span class="token string">"Fred"</span><span class="token punctuation">,</span>
			<span class="token string">"2"</span><span class="token punctuation">:</span> <span class="token string">"Mary"</span><span class="token punctuation">,</span>
			<span class="token string">"3"</span><span class="token punctuation">:</span> <span class="token string">"Pat"</span><span class="token punctuation">,</span>
		<span class="token punctuation">&#125;</span><span class="token punctuation">,</span>
	<span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span></code>`,EE,mE,vE,Kn,Tb,Di,Sb,Mb,Pi,Ib,Lb,_E,ue,Hb,yE,Dt,VM=`<code class="language-go"><span class="token keyword">type</span> DataStore <span class="token keyword">interface</span> <span class="token punctuation">&#123;</span>
	<span class="token function">UserNameForID</span><span class="token punctuation">(</span>userID <span class="token builtin">string</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token builtin">string</span><span class="token punctuation">,</span> <span class="token builtin">bool</span><span class="token punctuation">)</span>
<span class="token punctuation">&#125;</span>

<span class="token keyword">type</span> Logger <span class="token keyword">interface</span> <span class="token punctuation">&#123;</span>
	<span class="token function">Log</span><span class="token punctuation">(</span>message <span class="token builtin">string</span><span class="token punctuation">)</span>
<span class="token punctuation">&#125;</span>

<span class="token keyword">type</span> LoggerAdapter <span class="token keyword">func</span><span class="token punctuation">(</span>message <span class="token builtin">string</span><span class="token punctuation">)</span>

<span class="token keyword">func</span> <span class="token punctuation">(</span>lg LoggerAdapter<span class="token punctuation">)</span> <span class="token function">Log</span><span class="token punctuation">(</span>message <span class="token builtin">string</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
	<span class="token function">lg</span><span class="token punctuation">(</span>message<span class="token punctuation">)</span>
<span class="token punctuation">&#125;</span></code>`,bE,Tn,Oi,Ab,Gb,Ri,Bb,xb,Ti,Nb,Fb,wE,ie,Wb,CE,Pt,JM=`<code class="language-go"><span class="token keyword">type</span> SimpleLogic <span class="token keyword">struct</span> <span class="token punctuation">&#123;</span>
	l  Logger
	ds DataStore
<span class="token punctuation">&#125;</span>

<span class="token keyword">func</span> <span class="token punctuation">(</span>sl SimpleLogic<span class="token punctuation">)</span> <span class="token function">SayHello</span><span class="token punctuation">(</span>userID <span class="token builtin">string</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token builtin">string</span><span class="token punctuation">,</span> <span class="token builtin">error</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
	sl<span class="token punctuation">.</span>l<span class="token punctuation">.</span><span class="token function">Log</span><span class="token punctuation">(</span><span class="token string">"in say hello for "</span> <span class="token operator">+</span> userID<span class="token punctuation">)</span>
	name<span class="token punctuation">,</span> ok <span class="token operator">:=</span> sl<span class="token punctuation">.</span>ds<span class="token punctuation">.</span><span class="token function">UserNameForID</span><span class="token punctuation">(</span>userID<span class="token punctuation">)</span>
	<span class="token keyword">if</span> <span class="token operator">!</span>ok <span class="token punctuation">&#123;</span>
		<span class="token keyword">return</span> <span class="token string">""</span><span class="token punctuation">,</span> errors<span class="token punctuation">.</span><span class="token function">New</span><span class="token punctuation">(</span><span class="token string">"unknown user"</span><span class="token punctuation">)</span>
	<span class="token punctuation">&#125;</span>
	<span class="token keyword">return</span> <span class="token string">"Hello, "</span> <span class="token operator">+</span> name<span class="token punctuation">,</span> <span class="token boolean">nil</span>
<span class="token punctuation">&#125;</span>

<span class="token keyword">func</span> <span class="token punctuation">(</span>sl SimpleLogic<span class="token punctuation">)</span> <span class="token function">SayGoodbye</span><span class="token punctuation">(</span>userID <span class="token builtin">string</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token builtin">string</span><span class="token punctuation">,</span> <span class="token builtin">error</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
	sl<span class="token punctuation">.</span>l<span class="token punctuation">.</span><span class="token function">Log</span><span class="token punctuation">(</span><span class="token string">"in say goodbye for "</span> <span class="token operator">+</span> userID<span class="token punctuation">)</span>
	name<span class="token punctuation">,</span> ok <span class="token operator">:=</span> sl<span class="token punctuation">.</span>ds<span class="token punctuation">.</span><span class="token function">UserNameForID</span><span class="token punctuation">(</span>userID<span class="token punctuation">)</span>
	<span class="token keyword">if</span> <span class="token operator">!</span>ok <span class="token punctuation">&#123;</span>
		<span class="token keyword">return</span> <span class="token string">""</span><span class="token punctuation">,</span> errors<span class="token punctuation">.</span><span class="token function">New</span><span class="token punctuation">(</span><span class="token string">"unknown user"</span><span class="token punctuation">)</span>
	<span class="token punctuation">&#125;</span>
	<span class="token keyword">return</span> <span class="token string">"Goodbye, "</span> <span class="token operator">+</span> name<span class="token punctuation">,</span> <span class="token boolean">nil</span>
<span class="token punctuation">&#125;</span>

<span class="token keyword">func</span> <span class="token function">NewSimpleLogic</span><span class="token punctuation">(</span>l Logger<span class="token punctuation">,</span> ds DataStore<span class="token punctuation">)</span> SimpleLogic <span class="token punctuation">&#123;</span>
    <span class="token keyword">return</span> SimpleLogic<span class="token punctuation">&#123;</span>
        l<span class="token punctuation">:</span>    l<span class="token punctuation">,</span>
        ds<span class="token punctuation">:</span> ds<span class="token punctuation">,</span>
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span>

<span class="token keyword">func</span> <span class="token function">NewSimpleLogic</span><span class="token punctuation">(</span>l Logger<span class="token punctuation">,</span> ds DataStore<span class="token punctuation">)</span> SimpleLogic <span class="token punctuation">&#123;</span>
	<span class="token keyword">return</span> SimpleLogic<span class="token punctuation">&#123;</span>
		l<span class="token punctuation">:</span>  l<span class="token punctuation">,</span>
		ds<span class="token punctuation">:</span> ds<span class="token punctuation">,</span>
	<span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span></code>`,DE,W,Si,Ub,jb,Mi,zb,qb,Ii,Vb,Jb,Li,Xb,$b,Hi,Zb,Kb,PE,OE,RE,Qn,Qb,Ai,Yb,hb,Gi,gb,nw,TE,Ot,XM=`<code class="language-go"><span class="token keyword">type</span> Logic <span class="token keyword">interface</span> <span class="token punctuation">&#123;</span>
    <span class="token function">SayHello</span><span class="token punctuation">(</span>userID <span class="token builtin">string</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token builtin">string</span><span class="token punctuation">,</span> <span class="token builtin">error</span><span class="token punctuation">)</span>
<span class="token punctuation">&#125;</span></code>`,SE,Yn,sw,Bi,aw,tw,xi,ew,pw,ME,Rt,$M=`<code class="language-go"><span class="token keyword">type</span> Controller <span class="token keyword">struct</span> <span class="token punctuation">&#123;</span>
	l     Logger
	logic Logic
<span class="token punctuation">&#125;</span>

<span class="token keyword">func</span> <span class="token punctuation">(</span>c Controller<span class="token punctuation">)</span> <span class="token function">SayHello</span><span class="token punctuation">(</span>w http<span class="token punctuation">.</span>ResponseWriter<span class="token punctuation">,</span> r <span class="token operator">*</span>http<span class="token punctuation">.</span>Request<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
	c<span class="token punctuation">.</span>l<span class="token punctuation">.</span><span class="token function">Log</span><span class="token punctuation">(</span><span class="token string">"In sayhello"</span><span class="token punctuation">)</span>
	userID <span class="token operator">:=</span> r<span class="token punctuation">.</span>URL<span class="token punctuation">.</span><span class="token function">Query</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token string">"user_id"</span><span class="token punctuation">)</span>
	message<span class="token punctuation">,</span> err <span class="token operator">:=</span> c<span class="token punctuation">.</span>logic<span class="token punctuation">.</span><span class="token function">SayHello</span><span class="token punctuation">(</span>userID<span class="token punctuation">)</span>
	<span class="token keyword">if</span> err <span class="token operator">!=</span> <span class="token boolean">nil</span> <span class="token punctuation">&#123;</span>
		w<span class="token punctuation">.</span><span class="token function">WriteHeader</span><span class="token punctuation">(</span>http<span class="token punctuation">.</span>StatusBadRequest<span class="token punctuation">)</span>
		w<span class="token punctuation">.</span><span class="token function">Write</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token function">byte</span><span class="token punctuation">(</span>err<span class="token punctuation">.</span><span class="token function">Error</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
		<span class="token keyword">return</span>
	<span class="token punctuation">&#125;</span>
	w<span class="token punctuation">.</span><span class="token function">Write</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token function">byte</span><span class="token punctuation">(</span>message<span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token punctuation">&#125;</span>

<span class="token keyword">func</span> <span class="token function">NewController</span><span class="token punctuation">(</span>l Logger<span class="token punctuation">,</span> logic Logic<span class="token punctuation">)</span> Controller <span class="token punctuation">&#123;</span>
	<span class="token keyword">return</span> Controller<span class="token punctuation">&#123;</span>
		l<span class="token punctuation">:</span>     l<span class="token punctuation">,</span>
		logic<span class="token punctuation">:</span> logic<span class="token punctuation">,</span>
	<span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span></code>`,IE,LE,HE,_a,ow,Ni,lw,cw,AE,Tt,ZM=`<code class="language-go"><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
	l <span class="token operator">:=</span> <span class="token function">LoggerAdapter</span><span class="token punctuation">(</span>LogOutput<span class="token punctuation">)</span>
	ds <span class="token operator">:=</span> <span class="token function">NewSimpleDataStore</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
	logic <span class="token operator">:=</span> <span class="token function">NewSimpleLogic</span><span class="token punctuation">(</span>l<span class="token punctuation">,</span> ds<span class="token punctuation">)</span>
	c <span class="token operator">:=</span> <span class="token function">NewController</span><span class="token punctuation">(</span>l<span class="token punctuation">,</span> logic<span class="token punctuation">)</span>
	http<span class="token punctuation">.</span><span class="token function">HandleFunc</span><span class="token punctuation">(</span><span class="token string">"/hello"</span><span class="token punctuation">,</span> c<span class="token punctuation">.</span>SayHello<span class="token punctuation">)</span>
	http<span class="token punctuation">.</span><span class="token function">ListenAndServe</span><span class="token punctuation">(</span><span class="token string">":8080"</span><span class="token punctuation">,</span> <span class="token boolean">nil</span><span class="token punctuation">)</span>
<span class="token punctuation">&#125;</span></code>`,GE,hn,uw,Fi,iw,rw,Wi,kw,fw,BE,S,Ui,dw,Ew,ji,mw,vw,zi,_w,yw,qi,bw,ww,Vi,Cw,Dw,Ji,Pw,Ow,xE,_s,Xi,Rw,Tw,$i,Sw,Mw,NE,re,Iw,FE,WE,UE,ya,Lw,St,Hw,Aw,jE,zE,qE,VE,ba,wa,Zi,Gw,JE,ke,Bw,XE,$E,ZE,KE,Ca,Da,Ki,xw,QE,YE,hE,Sn,Qi,Nw,Fw,Mt,Ww,Uw,jw,gE,n2,s2,fe,zw,a2,de,qw,t2,e2,p2,o2;return Mt=new YI({props:{alt:"Learning Go Book Cover",src:"https://learning.oreilly.com/covers/urn:orm:book:9781492077206/400w/"}}),{c(){At=p("br"),tr=i(),Gt=p("p"),T2=t("본 글은 Golang을 공부하며 주요 내용이라 생각되는 것들을 기록해둔 자료이며, Ubuntu 20.04 LTS 기준으로 작성되었습니다."),er=i(),pr=p("br"),or=p("br"),lr=i(),Ps=p("h2"),Os=p("a"),We=p("span"),S2=t("Types"),cr=i(),ur=p("hr"),ir=i(),Rs=p("p"),M2=t("Go에는 Class나 상속과 같은 개념이 개념이 존재하지 않는다. 대신 타입을 정의하고자 하는 경우, "),Ue=p("code"),I2=t("type"),L2=t(" 키워드를 사용하여 정의한다."),rr=i(),Aa=p("pre"),kr=i(),Bt=p("p"),H2=t("위처럼 정의된 타입들은 이들이 정의된 스코프 내에서만 정의 가능하다."),fr=i(),dr=p("br"),Er=i(),kn=p("p"),A2=t("한 가지 짚고 넘어가야 할 점은, 위 예제의 "),je=p("code"),G2=t("Score"),B2=t(" 타입의 경우 사실상 "),ze=p("code"),x2=t("int"),N2=t(`와 동일한 타입이다.
그럼에도 위와 같이 타입명을 지정해준 것은 타입명 자체를 일종의 `),qe=p("strong"),F2=t("documentation"),W2=t("으로 볼 수 있기 때문이다."),mr=i(),Hn=p("p"),U2=t(`이러한 타입 지정은 해당 타입의 변수 또는 인스턴스가 코드 내에서 어떠한 역할을 하며,
어떠한 데이터를 저장할 지에 대한 정보를 제공할 수 있다.
위 예제에서 `),Ve=p("code"),j2=t("Score"),z2=t("는 "),Je=p("code"),q2=t("int"),V2=t("와 똑같은 정수 타입이기는 해도, 무식하게 큰 정수나 음수인 값에 대해서는 유효하지 않은 값임을 파악할 수 있을 것이다."),vr=i(),Ts=p("p"),J2=t("위 예제의 "),Xe=p("code"),X2=t("Employee"),$2=t(`은 유저가 정의한 타입을 다시 정의한 경우인데, 이 또한 같은 맥락에서 바라볼 수 있다.
저장하고 있는 데이터의 종류는 같을지라도, 이들이 사용되어야 할 적합한 맥락에 대해서 정보를 제공할 수 있다.`),_r=i(),yr=p("br"),br=p("br"),wr=i(),Ss=p("h3"),Ms=p("a"),$e=p("span"),Z2=t("Inheritance in Go?"),Cr=i(),xt=p("p"),K2=t("Go에는 객체지향과 상속 개념이 없다. type을 선언할 수 있지만, 이는 말 그대로 어디까지나 선언만 할 수 있는 것이다."),Dr=i(),Ga=p("pre"),Pr=i(),Is=p("p"),Q2=t("위와 같은 "),Ze=p("code"),Y2=t("type"),h2=t(` 선언은 상속처럼 보일 수는 있지만, 엄연히 다르다. 실질적으로는 이름만 다른 동일한 타입이 두 개 선언되는 것.
이들 사이에는 어떠한 계층 구조도 존재하지 않는다.`),Or=i(),q=p("p"),g2=t("객체지향에서 "),Ke=p("em"),nm=t("child class"),sm=t("는 "),Qe=p("em"),am=t("parent class"),tm=t(`가 가진 모든 메소드와 값들을 사용할 수 있어야 하며, parent class가 사용되는 곳 어디에든 사용될 수 있어야 한다.
반면 Go에서는, 위 예제의 `),Ye=p("code"),em=t("Score"),pm=t(" 인스턴스가 사용되는 상황에서 "),he=p("code"),om=t("HighScore"),lm=t(" 인스턴스를 사용하려면 타입 변환을 해주어야 한다."),Rr=i(),Ba=p("pre"),Tr=i(),Sr=p("br"),Mr=p("br"),Ir=i(),Ls=p("h3"),Hs=p("a"),ge=p("span"),cm=t("Enumeration in Go - iota"),Lr=i(),An=p("p"),um=t("여러 프로그래밍 언어에 존재하는 "),np=p("em"),im=t("Enumeration"),rm=t("에 대한 개념 대신, Go에는 "),sp=p("code"),km=t("iota"),fm=t("가 존재한다. 바로 예제를 확인해보자."),Hr=i(),xa=p("pre"),Ar=i(),Na=p("pre"),Gr=i(),V=p("p"),dm=t(`위 예제의 실행 결과를 확인해보면, 0부터 4까지의 수가 순서대로 할당되었음을 알 수 있다.
이는 `),ap=p("code"),Em=t("iota"),mm=t("가 첫 번째 상수인 "),tp=p("code"),vm=t("Uncategorized"),_m=t("에 0, 두 번째 상수인 "),ep=p("code"),ym=t("Personal"),bm=t(`에 1, 이런 식으로 점점 증가되게끔 값을 할당하였기 때문이다.
또한, 만일 새로운 `),pp=p("code"),wm=t("const"),Cm=t(" 선언 블록이 존재할 경우, iota는 0이 될 것이다."),Br=i(),xr=p("br"),Nr=i(),Fa=p("pre"),Fr=i(),is=p("p"),op=p("code"),Dm=t("_"),Pm=t(`를 이용하면 iota로 할당되는 값을 건너뛸 수 있다.
또한 `),lp=p("code"),Om=t("iota"),Rm=t(`를 사용할 때 위와 같은 표현식을 사용하여 값들을 할당할 수도 있다.
다만 이런 경우, 무슨 목적으로 이런 코드를 짰는지 잘 명시해주는 것이 좋겠다.`),Wr=i(),Ur=p("br"),jr=i(),D=p("p"),Tm=t("단 "),cp=p("code"),Sm=t("iota"),Mm=t("를 사용하려면 "),up=p("code"),Im=t("iota"),Lm=t(`에 의해서 할당되는 값이 큰 의미가 없는 경우여야 한다.
0, 1, 2, … 등 `),ip=p("code"),Hm=t("iota"),Am=t(`에 의해 할당되는 값들은 단순히 서로를 구분하기 위해서 사용되는 값일 뿐이며, 이 값을 직접적으로 사용해선 안된다.
만일 `),rp=p("code"),Gm=t("iota"),Bm=t("를 사용하는 "),kp=p("code"),xm=t("const"),Nm=t(` 블록 중간에 새로운 상수를 추가하면 값들이 전체적으로 바뀔 것이다.
이 때 `),fp=p("code"),Fm=t("iota"),Wm=t("에 의해 할당되는 값을 직접적으로 사용한다면 이에 영향을 받을 것이다."),zr=i(),J=p("p"),Um=t(`특정 인터페이스와 직접적으로 관련되어있지 않은 내부적인 로직에서 사용하는 것이 좋다.
만약 어느 `),dp=p("code"),jm=t("struct"),zm=t(" 타입에 "),Ep=p("code"),qm=t("iota"),Vm=t(`를 사용하는 Enumeration 필드가 존재하고, 해당 인스턴스들이 DB에 저장되어있다고 가정해보자.
그런데 `),mp=p("code"),Jm=t("iota"),Xm=t("를 사용하는 "),vp=p("code"),$m=t("const"),Zm=t(" 블록 중간에 새로운 상수를 추가하면 DB에 저장된 값들이 완전히 다른 값을 가리키게 될 것이다."),qr=i(),As=p("p"),Km=t("따라서 상수의 값이 중요한 경우이거나 내부적인 로직에서 사용하는 것이 아니라면 "),_p=p("code"),Qm=t("iota"),Ym=t(`를 쓰지 말고 그냥 값을 직접 할당해주는 편이 좋다.
그게 아니라면 문서를 잘 써놓자.`),Vr=i(),Jr=p("br"),Xr=p("br"),$r=i(),Gs=p("h2"),Bs=p("a"),yp=p("span"),hm=t("Methods"),Zr=i(),Kr=p("hr"),Qr=i(),fn=p("p"),gm=t("Go에서는 "),bp=p("em"),nv=t("User-defined type"),sv=t(`에 대해 메소드를 생성할 수 있다.
일반적인 함수 선언과 유사하지만, `),wp=p("code"),av=t("func"),tv=t("와 메소드명 사이에 "),Cp=p("strong"),ev=t("receiver"),pv=t(`를 명시해준다.
보통의 변수 선언처럼 변수명을 먼저 적고 타입을 뒤에 적는다.
일반적으로는 타입명의 맨 앞글자를 소문자로 적는다고 한다.`),Yr=i(),Wa=p("pre"),hr=i(),Nt=p("p"),ov=t(`Go에서는 함수 오버로딩을 지원하지 않으며, 메소드도 동일하다.
동일한 타입에서 두개 이상의 동일한 이름을 가진 메소드를 선언할 수 없다.`),gr=i(),Ft=p("p"),lv=t("또한 타입과 이에 대한 메소드가 선언된 파일을 서로 분리할 수는 있지만, 같은 파일 에서 함께 선언하는 것이 권장된다고 한다."),nk=i(),sk=p("br"),ak=p("br"),tk=i(),xs=p("h3"),Ns=p("a"),Dp=p("span"),cv=t("Pointer Receivers"),ek=i(),dn=p("p"),uv=t("함수에서 포인터 파라미터를 사용할 때처럼, "),Pp=p("em"),iv=t("Receiver"),rv=t(`에도 포인터를 사용할 수 있다.
이 때 `),Op=p("em"),kv=t("Value Receiver"),fv=t("를 사용할 때와의 차이점은 "),Rp=p("em"),dv=t("Receiver"),Ev=t("로 패스한 값이 변경될 수 있다는 것이다."),pk=i(),Ua=p("p"),Tp=p("em"),mv=t("Pointer Reciver"),vv=t("에 대한 몇 가지 규칙이 존재한다."),ok=i(),Gn=p("ol"),rs=p("li"),_v=t("메소드가 "),Sp=p("em"),yv=t("Reciver"),bv=t(" 값을 변경한다면, 반드시 "),Mp=p("em"),wv=t("Pointer Reciver"),Cv=t("를 사용한다."),Dv=i(),ks=p("li"),Pv=t("메소드가 "),Ip=p("code"),Ov=t("nil"),Rv=t(" 인스턴스를 다뤄야 한다면, 반드시 "),Lp=p("em"),Tv=t("Pointer Reciver"),Sv=t("를 사용한다."),Mv=i(),fs=p("li"),Iv=t("메소드가 "),Hp=p("em"),Lv=t("Reciver"),Hv=t(" 값을 변경하지 않는다면, "),Ap=p("em"),Av=t("Value Reciver"),Gv=t("를 사용할 수 있다."),lk=i(),Rn=p("p"),Gp=p("em"),Bv=t("Reciver"),xv=t(" 값을 변경하지 않는 메소드에 대해서도 "),Bp=p("em"),Nv=t("Pointer Reciver"),Fv=t(`를 사용하는 것이 국룰이라고 한다.
다만 난 잘 모르겠다. 개인적으로는 값을 변경하지 않는다면 명시적으로 `),xp=p("em"),Wv=t("Value Reciver"),Uv=t("를 써도 되는 거 아닌가 싶다."),ck=i(),uk=p("br"),ik=i(),ja=p("pre"),rk=i(),En=p("p"),jv=t("함수에 포인터 파라미터를 넘길 때와는 달리, Receiver에 "),Np=p("code"),zv=t("&"),qv=t(`를 붙이지 않아도 된다.
위 `),Fp=p("code"),Vv=t("c.Increment()"),Jv=t(" 부분은 자동으로 "),Wp=p("code"),Xv=t("(&c).Increment()"),$v=t(`로 변환된다.
아래 코드는 예제의 실행 결과이다.`),kk=i(),za=p("pre"),fk=i(),dk=p("br"),Ek=i(),Wt=p("p"),Zv=t("이러한 규칙들에 대해 잘 이해하면, 아래 예제의 실행 결과도 알 수 있을 것이다."),mk=i(),qa=p("pre"),vk=i(),E=p("p"),Up=p("code"),Kv=t("doUpdateWrong()"),Qv=t(" 함수의 스코프 내에서 "),jp=p("code"),Yv=t("c.Increment()"),hv=t("를 호출시 "),zp=p("code"),gv=t("c"),n3=t(`가 변경되고, 그 결과가 이후 출력에서 반영된다.
하지만 `),qp=p("code"),s3=t("doUpdateWrong()"),a3=t(" 함수는 파라미터인 "),Vp=p("code"),t3=t("Counter"),e3=t("를 "),Jp=p("em"),p3=t("pass by value"),o3=t("로 받았기 때문에 "),Xp=p("code"),l3=t("main()"),c3=t(` 함수로 되돌아왔을 때 변경사항이 유지되지 않는다.
반면 `),$p=p("code"),u3=t("doUpdateWrong()"),i3=t(" 함수는 파라미터를 "),Zp=p("em"),r3=t("pass by pointer"),k3=t("로 받았기에, 변경사항이 유지된다."),_k=i(),Ut=p("p"),f3=t("위 예제의 실행 결과는 아래와 같다."),yk=i(),Va=p("pre"),bk=i(),wk=p("br"),Ck=i(),mn=p("p"),d3=t("이렇게 유저가 정의한 타입에 Method를 통해 "),Kp=p("em"),E3=t("Getter"),m3=t("나, "),Qp=p("em"),v3=t("Pointer Reciver"),_3=t("를 이용하여 "),Yp=p("em"),y3=t("Setter"),b3=t(`를 정의할 수는 있다.
다만 필드에 직접 값을 할당하는 경우가 아니거나, 여러 필드를 한 번의 오퍼레이션으로 처리해야 하는 경우가 아니라면,
Go에서는 되도록이면 필드값에 직접 접근하는 것을 권장한다.`),Dk=i(),Pk=p("br"),Ok=p("br"),Rk=i(),ds=p("p"),hp=p("em"),w3=t("Pointer Reciver"),C3=t("는 "),gp=p("code"),D3=t("nil"),P3=t(" 인스턴스를 다뤄야 할 때 사용할 수 있다."),Tk=i(),v=p("p"),O3=t("다른 언어들의 경우 "),no=p("code"),R3=t("null"),T3=t("이나 "),so=p("code"),S3=t("None"),M3=t(` 인스턴스에서 메소드를 호출하면 에러가 발생한다.
Go에서도 `),ao=p("code"),I3=t("nil"),L3=t(" 인스턴스에서 메소드를 호출할 때 "),to=p("em"),H3=t("Value Reciver"),A3=t("인 경우에는 "),eo=p("em"),G3=t("panic"),B3=t("이 발생하지만, "),po=p("em"),x3=t("Pointer Reciver"),N3=t(`인 경우 메소드가 정상적으로 호출된다.
이 경우, 메소드가 `),oo=p("code"),F3=t("nil"),W3=t(" 인스턴스를 처리할 수 있게끔 작성되어 있어야 한다."),Sk=i(),Ja=p("pre"),Mk=i(),Fs=p("p"),U3=t("위 예제는 "),lo=p("code"),j3=t("nil"),z3=t(" 인스턴스를 핸들링할 수 있는 정수형 바이너리 트리의 예제이다."),Ik=i(),pn=p("p"),co=p("code"),q3=t("IntTree.Contains()"),V3=t(" 메소드는 현재 receiver가 "),uo=p("code"),J3=t("nil"),X3=t(`인지에 따라 해당 값이 포함되어 있는가의 여부를 판단하며
`),io=p("code"),$3=t("IntTree.Insert()"),Z3=t(" 메소드는 현재 receiver가 "),ro=p("code"),K3=t("nil"),Q3=t(`일 경우 현 위치에 값을 추가한 값을 반환한다.
단, 이때는 포인터 파라미터를 사용할 때처럼 receiver에 특정 주소값을 할당하여도, 원본 포인터가 변경되지는 않는다.`),Lk=i(),Hk=p("br"),Ak=p("br"),Gk=i(),Ws=p("h3"),Us=p("a"),ko=p("span"),Y3=t("Methods and Functions"),Bk=i(),jt=p("p"),h3=t("Go에서 메소드는 함수와 유사한 점이 많다."),xk=i(),Xa=p("pre"),Nk=i(),vn=p("p"),g3=t("함수를 변수에 할당하여 사용할 수 있듯, 위 예제의 "),fo=p("code"),n5=t("f1"),s5=t(`처럼 메소드도 변수에 할당하여 사용할 수 있다.
이 때 이 메소드의 타입은 `),Eo=p("code"),a5=t("func(int)int"),t5=t("가 되며, 이를 "),mo=p("em"),e5=t("method value"),p5=t("라 한다."),Fk=i(),N=p("p"),vo=p("em"),o5=t("method value"),l5=t("는 "),_o=p("em"),c5=t("closure"),u5=t(`처럼 파라미터로 넘기거나 할 수도 있다.
`),yo=p("em"),i5=t("method value"),r5=t("를 선언할 때 붙어있던 "),bo=p("em"),k5=t("receiver"),f5=t("가 고정되어 있기 때문에, 이를 호출할 경우 해당 "),wo=p("em"),d5=t("receiver"),E5=t("가 영향을 받는다."),Wk=i(),X=p("p"),m5=t("위 예제의 "),Co=p("code"),v5=t("f2"),_5=t(`처럼 그냥 타입명에 메소드를 붙인 것을 변수에 할당할 수도 있다.
이를 `),Do=p("em"),y5=t("method expression"),b5=t("이라 한다. 이 때 이 메소드의 타입은 "),Po=p("code"),w5=t("func(Adder, int) int"),C5=t("가 되며, 첫 번째 파라미터가 "),Oo=p("em"),D5=t("receiver"),P5=t("가 된다."),Uk=i(),js=p("p"),O5=t(`이렇게 Go에서는 메소드를 함수처럼 사용할 수 있기에 큰 차이가 없기에 어느 것을 사용해야 할지 혼동이 올 수 있다.
만약 작성하고자 하는 로직이 입력 파라미터에 의해서만 영향을 받는다면 함수를 사용하는 것이 옳다.
반면 프로그램이 실행되며 설정되고, 실행 중 계속 바뀌는 어떤 값에 의해 로직이 영향을 받을 수 있다.
그러한 경우 이 값들은 `),Ro=p("code"),R5=t("struct"),T5=t("에 저장되어야 하고 메소드를 사용하는 것이 좋다."),jk=i(),zk=p("br"),qk=p("br"),Vk=i(),zs=p("h2"),qs=p("a"),To=p("span"),S5=t("Embedding"),Jk=i(),Xk=p("hr"),$k=i(),Bn=p("p"),M5=t("Go에는 상속이 없지만 "),So=p("strong"),I5=t("Embedding"),L5=t("을 통해 구조화된 "),Mo=p("code"),H5=t("struct"),A5=t(" 타입을 구성할 수 있다."),Zk=i(),zt=p("p"),G5=t("기본적인 예제는 다음과 같다."),Kk=i(),$a=p("pre"),Qk=i(),y=p("p"),Io=p("code"),B5=t("Manager"),x5=t("를 정의할 때 "),Lo=p("code"),N5=t("Employee"),F5=t("를 필드명 없이 선언해줌으로써, "),Ho=p("code"),W5=t("Employee"),U5=t("는 "),Ao=p("code"),j5=t("Manager"),z5=t("의 "),Go=p("strong"),q5=t("Embedded Field"),V5=t(`가 된다.
`),Bo=p("code"),J5=t("Manager"),X5=t("에서는 "),xo=p("code"),$5=t("Employee"),Z5=t("의 필드에 접근할 수 있다."),Yk=i(),hk=p("br"),gk=i(),Za=p("pre"),nf=i(),Vs=p("p"),K5=t("위 예제처럼 "),No=p("em"),Q5=t("Embedding"),Y5=t("된 구조체의 내부와 외부 양쪽에 동일한 필드명을 가진 상황이 생길 수 있다."),sf=i(),_n=p("p"),h5=t("이러한 경우, "),Fo=p("code"),g5=t("Outer"),n_=t("에 있는 "),Wo=p("code"),s_=t("Inner"),a_=t(" 내부에 위치한 X에 접근하려고 할 때는 "),Uo=p("code"),t_=t("Inner"),e_=t("를 명시해줘야 한다."),af=i(),tf=p("br"),ef=p("br"),pf=i(),Es=p("p"),jo=p("em"),p_=t("Embedding"),o_=t("은 다른 언어에서 찾기 힘든, 흔치 않은 개념이다. 그래서 구조적으로 비슷한 상속과 연관지어서 생각하곤 하는데, "),zo=p("em"),l_=t("Embedding"),c_=t("은 상속과는 명백하게 다르다."),of=i(),lf=p("br"),cf=i(),xn=p("p"),u_=t("위 "),qo=p("code"),i_=t("Manager"),r_=t("와 "),Vo=p("code"),k_=t("Employee"),f_=t(" 예제에 이어서, 아래 예제도 살펴보자."),uf=i(),Ka=p("pre"),rf=i(),$=p("p"),d_=t("만약 상속이었다면 위 "),Jo=p("code"),E_=t("var eFail Employee = m"),m_=t(` 라인이 정상적으로 컴파일되었을 것이다.
`),Xo=p("code"),v_=t("Manager"),__=t("를 "),$o=p("code"),y_=t("Employee"),b_=t(`의 하위 개념으로 보기 때문.
하지만 `),Zo=p("em"),w_=t("Embedding"),C_=t("은 상속과는 차이가 있기 때문에 에러가 발생한다."),kf=i(),ff=p("br"),df=i(),Js=p("p"),D_=t("Go는 상속을 지원하지 않기 때문에 폴리모피즘과는 거리가 있고, "),Ko=p("strong"),P_=t("Dynamic Dispatch"),O_=t("(동적 디스패치)도 존재하지 않는다."),Ef=i(),Qa=p("pre"),mf=i(),Ya=p("pre"),vf=i(),I=p("p"),R_=t("위 예제에서 "),Qo=p("code"),T_=t("o.Double()"),S_=t("를 호출하면 겹치는 메소드명이 없기 때문에 "),Yo=p("code"),M_=t("o.Inner.Double()"),I_=t(`가 자동 호출된다.
이 때 `),ho=p("code"),L_=t("o.Inner.Double()"),H_=t(" 내부에서는 "),go=p("code"),A_=t("o.Inner.IntPrinter()"),G_=t("를 호출하기 때문에, "),nl=p("code"),B_=t("Inner: 20"),x_=t(`가 출력된 것이다.
이렇듯 Go에서 메소드는 전혀 오버라이딩되지 않는다.`),_f=i(),yf=p("br"),bf=p("br"),wf=i(),Xs=p("h2"),$s=p("a"),sl=p("span"),N_=t("Interface"),Cf=i(),Df=p("hr"),Pf=i(),Zs=p("p"),F_=t("책에서는 Go의 진정한 꽃이 Goroutine을 위시한 Concurrency가 아니라, 이 "),al=p("em"),W_=t("Interface"),U_=t("라고 하는데, 대체 얼마나 맛집이기에.."),Of=i(),qt=p("p"),j_=t("설명에 앞서 인터페이스는 아래와 같이 정의할 수 있다."),Rf=i(),ha=p("pre"),Tf=i(),b=p("p"),tl=p("code"),z_=t("struct"),q_=t(`를 정의하는 것과 큰 차이는 없는 것 같다.
암묵적인 룰이 하나 있는데, 인터페이스의 이름은 대개 “er”로 끝난다.
그 예로 `),el=p("code"),V_=t("fmt.Stringer"),J_=t(", "),pl=p("code"),X_=t("io.Reader"),$_=t(", "),ol=p("code"),Z_=t("io.Closer"),K_=t(", "),ll=p("code"),Q_=t("io.ReadCloser"),Y_=t(", "),cl=p("code"),h_=t("json.Marshaler"),g_=t(", "),ul=p("code"),n0=t("http.Handler"),s0=t(" 등등이 있다."),Sf=i(),Mf=p("br"),If=i(),on=p("p"),il=p("em"),a0=t("Interface"),t0=t("는 객체지향의 "),rl=p("em"),e0=t("Abstract Class"),p0=t(`와 유사하지만, 차이점이 있다.
다른 객체지향 언어에서는 `),kl=p("em"),o0=t("Abstract Class"),l0=t("에서 선언된 메소드 등을 "),fl=p("em"),c0=t("Concrete Class"),u0=t("에서 구현한다."),Lf=i(),L=p("p"),i0=t("반면 Go의 인터페이스는 "),Vt=p("span"),r0=t("암묵적"),k0=t(`인 개념이다.
`),dl=p("em"),f0=t("Concrete Type"),d0=t(`에서는 인터페이스를 구현한다고 선언하지 않는다.
만약 `),El=p("em"),E0=t("Concrete Type"),m0=t(`에서 구현하는 메소드들이 인터페이스에서 선언된 모든 메소드들을 포함한다면,
그 때 `),ml=p("em"),v0=t("Concrete Type"),_0=t(`가 인터페이스를 구현한다고 할 수 있으며, 이래서 암묵적이라는 표현을 사용하는 듯 하다.
그래서 Go에서는 `),vl=p("em"),y0=t("Concrete Type"),b0=t("을 인터페이스에 할당한다는 느낌으로 받아들여야 하는 것 같다."),Hf=i(),ga=p("p"),_l=p("em"),w0=t("Interface"),C0=t(" 덕에 Type-Safe, 디커플링, 정적/동적 언어에서 기능을 연결하는 것이 가능해진다고 하는데, 이건 좀 더 해봐야 알 듯 하다."),Af=i(),Nn=p("p"),D0=t("Javascript, Python 등의 동적 타입 언어에서는 인터페이스가 없는 대신 "),yl=p("em"),P0=t("Duck Typing"),O0=t(`이란 것을 사용한다.
`),bl=p("em"),R0=t("Duck Typing"),T0=t(`은 어떤 인스턴스가 원하는 메소드(또는 필드)들을 가지고 있다면, 내가 원하는 타입으로 간주한다는 뜻이다.
프로젝트의 규모가 너무 크거나, 프로젝트가 너무 오래되어서 의존성을 추적하기 어려운 경우 이런 방식을 사용한다.`),Gf=i(),Jt=p("p"),S0=t(`주로 정적 타입 언어를 사용하는 개발자라면 이런 방식에 대해 회의적이다.
인스턴스의 타입을 명시하지 않으면 어떤 타입인지 확인하기도 어려울 것이며, 어떤 기능을 할 수 있을지 예측할 수 없으리라 생각한다.`),Bf=i(),Xt=p("p"),M0=t(`반면 Java에서는 다소 패턴이 다르다. 인터페이스의 정의와 구현이 각각 존재하지만, 인터페이스의 정의만 참조된다.
주로 동적 타입 언어를 사용하는 개발자들은 이 방식에 대해, 인터페이스가 바뀔 때마다 코드를 다시 짜야 하는 불편한 방식이라고 생각한다.`),xf=i(),Nf=p("br"),Ff=i(),$t=p("p"),I0=t(`만약 어플리케이션이 잠정적으로 개선될 여지가 있다면 코드에 유연성이 필요하다.
하지만 코드가 하고 있는 일이 무엇인지에 대해 사람들이 이해할 수 있도록 하는 것도 중요하기에, 코드의 역할과 의존성 등을 명시할 필요도 있다.
Go의 인터페이스는 양쪽 모두의 입장을 받아들인다.`),Wf=i(),Zt=p("p"),L0=t("아래 예제에서 Interface가 사용된 예시를 확인할 수 있다."),Uf=i(),nt=p("pre"),jf=i(),f=p("p"),wl=p("em"),H0=t("Concrete Type"),A0=t(" 역할을 하는 "),Cl=p("code"),G0=t("LogicProvider"),B0=t("가 정의될 때, 이것이 "),Dl=p("code"),x0=t("Logic"),N0=t(`이라는 인터페이스에 관련된 것이라고 선언된 것은 없다.
`),Pl=p("code"),F0=t("Logic"),W0=t("과 "),Ol=p("code"),U0=t("LogicProvider"),j0=t("이 연결되는 것은, "),Rl=p("code"),z0=t("Client"),q0=t(" 인스턴스인 "),Tl=p("code"),V0=t("c"),J0=t(`가 생성될 때이며,
`),Sl=p("code"),X0=t("LogicProvider"),$0=t("에는 "),Ml=p("code"),Z0=t("Logic"),K0=t("에서 정의된 것과 동일한 이름의 메소드인 "),Il=p("code"),Q0=t("Process()"),Y0=t(`가 존재할 뿐이다.
따라서 `),Ll=p("code"),h0=t("LogicProvider"),g0=t("가 "),Hl=p("code"),n4=t("Logic"),s4=t("이라는 인터페이스를 위한 "),Al=p("em"),a4=t("Concrete Type"),t4=t("임을 알 수 있도록, 잘 문서화할 필요가 있다."),zf=i(),qf=p("br"),Vf=i(),Z=p("p"),e4=t("Go에서는 "),Gl=p("code"),p4=t("io.Reader"),o4=t("나 "),Bl=p("code"),l4=t("io.Writer"),c4=t(` 등, 스탠다드 인터페이스도 존재한다.
스탠다드 인터페이스를 사용하는 것은 `),xl=p("em"),u4=t("decorator"),i4=t(` 패턴과 유사한데,
특정 인터페이스의 인스턴스를 받아서 동일한 인터페이스의 다른 인스턴스를 반환하는 `),Nl=p("em"),r4=t("Factory Function"),k4=t("(객체를 반환하는 함수)를 자주 사용하기 때문."),Jf=i(),Kt=p("p"),f4=t("아래 예제를 확인하자."),Xf=i(),st=p("pre"),$f=i(),K=p("p"),d4=t("위 코드에서 "),Fl=p("code"),E4=t("os.Open()"),m4=t("에 의해 반환된 "),Wl=p("code"),v4=t("os.File"),_4=t(" 인스턴스는 "),Ul=p("code"),y4=t("io.Reader"),b4=t(` 인터페이스를 충족시킨다.
따라서 `),jl=p("code"),w4=t("process()"),C4=t(" 함수 내에서 파일의 데이터를 읽을 수 있다."),Zf=i(),Fn=p("p"),D4=t("아래 예제는 "),zl=p("code"),P4=t("gzip"),O4=t("을 통해 파일을 압축 해제할 수 있는 경우에, "),ql=p("code"),R4=t("gzip"),T4=t(" 라이브러리를 사용하여 압축 해제하는 예제이다."),Kf=i(),at=p("pre"),Qf=i(),Qt=p("p"),S4=t("위처럼 스탠다드 라이브러리의 인터페이스가 코드에 잘 어울릴 것 같으면, 사용하는 것이 좋다."),Yf=i(),P=p("p"),M4=t("예제에서는 "),Vl=p("code"),I4=t("gzip"),L4=t("으로 압축 해제된 "),Jl=p("code"),H4=t("io.Reader"),A4=t(" 인터페이스의 인스턴스가 "),Xl=p("code"),G4=t("gz"),B4=t(`에 할당되고,
그 `),$l=p("code"),x4=t("gz"),N4=t("가 다시 한번 "),Zl=p("code"),F4=t("process()"),W4=t("함수에서 "),Kl=p("code"),U4=t("io.Reader"),j4=t("의 인스턴스가 된다."),hf=i(),Q=p("p"),z4=t(`어느 타입의 메소드들이 특정 인터페이스를 충족시키고도 남는 경우,
즉 인터페이스에 명시된 것 외의 메소드들이 존재한다고 해도 그 타입은 인터페이스를 충족시킨다.
이 때문에 한 타입이 두 개 이상의 인터페이스를 동시에 충족시킬 수 있다. 이 때 명시된 것 외의 메소드들은 무시한다.
이를테면 `),Ql=p("code"),q4=t("io.File"),V4=t(" 타입은 "),Yl=p("code"),J4=t("io.Reader"),X4=t("와 "),hl=p("code"),$4=t("io.Writer"),Z4=t(`를 동시에 충족시킨다.
즉, `),gl=p("code"),K4=t("io.File"),Q4=t(" 한 가지 타입으로 읽고 쓰기가 동시에, 각각 지원되는 것이다."),gf=i(),n1=p("br"),s1=p("br"),a1=i(),Ks=p("h3"),Qs=p("a"),nc=p("span"),Y4=t("Embedding and Interfaces"),t1=i(),ln=p("p"),sc=p("code"),h4=t("struct"),g4=t(` 타입을 Embedding하는 것처럼, 인터페이스도 인터페이스 안에 Embedding할 수 있다.
스탠다드 라이브러리의 `),ac=p("code"),ny=t("io.ReadCloser"),sy=t("도 "),tc=p("code"),ay=t("io.Reader"),ty=t("와 "),ec=p("code"),ey=t("io.Closer"),py=t(`가 임베딩된 것이다.
아래의 예제와 유사하다.`),e1=i(),tt=p("pre"),p1=i(),o1=p("br"),l1=p("br"),c1=i(),Ys=p("h3"),hs=p("a"),pc=p("span"),oy=t("Accept Interfaces, Return Structs"),u1=i(),gs=p("p"),ly=t("Go의 빡고수들이 버릇처럼 읊는 말이 "),oc=p("strong"),cy=t("Accept Interfaces, Return Structs"),uy=t(`라고 한다.
이는 함수에 의해 호출되는 로직은 반드시 인터페이스를 통해 호출되어야 하며,
함수의 결과값은 반드시 concrete type(struct)이어야 한다는 것이다.
함수의 파라미터로 인터페이스를 받으면 어떤 기능을 사용할 것인지 명시적으로 선언하면서도, flexible함을 동시에 챙길 수 있다.`),i1=i(),Yt=p("p"),iy=t(`만약 API가 (암묵적이어야 할) 인터페이스를 리턴한다면, 디커플링이라는 인터페이스의 장점을 잃는다.
만약 그렇게 된다면 서드 파티 모듈의 인터페이스에 코드가 종속되는 결과를 낳게 된다.
대개 서드 파티 인터페이스에 대한 클라이언트의 의존성을 줄이고자 하기 마련이다.
이를 위해 또다른 인터페이스를 작성한 뒤, 타입 변환을 하는데(의존성 주입, Dependency Injection),
이는 어플리케이션의 기능을 제약할 수도 있기에 좋은 방법은 아니다.`),r1=i(),ht=p("p"),ry=t(`인터페이스를 리턴하지 말아야 하는 또 다른 이유는 버전에 관련된 것이다.
Concrete Type을 리턴하는 경우에는 기존 코드에 새로운 메소드나 필드가 별 문제 없이 추가될 수 있다.
반면 인터페이스의 경우에는 새로운 메소드를 추가하려면 기존에 존재하는 모든 메소드들의 구현을 업데이트해야 한다.
따라서 API를 롤백해야 하는 경우에도, major version number를 증가시켜야 한다.`),k1=i(),gt=p("p"),ky=t(`인터페이스가 정해져 있고 파라미터에 따라서 다른 인스턴스가 나오는 factory function을 짜는 것보다는,
타입들을 분리하여 concrete type이 반환되는 각각의 함수를 작성하는 것이 좋다.`),f1=i(),Wn=p("p"),fy=t(`웬만하면 인터페이스를 반환하지 않는 것이 좋긴 한데, 가끔 어쩔 수 없이 하는 경우가 있다. 대표적인 예시가 바로 에러이다.
Go에서는 `),lc=p("code"),dy=t("error"),Ey=t(` 인터페이스를 반환하도록 선언되는 경우가 많다.
이는 인터페이스가 Go에서 유일하게 사용할 수 있는 추상 유형이며. `),cc=p("code"),my=t("error"),vy=t(` 인터페이스의 다른 구현을 사용해야 하는 경우가 많기 때문이다.
따라서 가능한 모든 옵션을 처리하기 위해 인터페이스를 사용해야 한다.`),d1=i(),ne=p("p"),_y=t(`다만 이러한 패턴의 잠재적인 문제점이 존재한다.
concrete type을 반환하는 경우 Heap 할당이 줄어들기에 가비지 콜렉터의 워크로드가 줄어든다.
반면 인터페이스를 파라미터로 사용하는 함수의 경우, 각 인터페이스마다 Heap 할당되므로, 가비지 콜렉터가 힘들어한다.
결국은 더 좋은 성능과 더 좋은 추상화 사이에 trade-off가 존재하는 셈이다.`),E1=i(),se=p("p"),yy=t(`그렇기 때문에 되도록이면 코드를 예쁘게, 고치기 편하게 작성하는 것이 좋다.
그래야 인터페이스로 인한 잠재적인 성능 문제가 발생하여도, 이를 concrete type으로 변경하는 등의 작업을 하기가 쉬워진다.`),m1=i(),v1=p("br"),_1=p("br"),y1=i(),na=p("h3"),sa=p("a"),uc=p("span"),by=t("Interfaces and nil"),b1=i(),Un=p("p"),wy=t("많이 봐왔듯, "),ic=p("code"),Cy=t("nil"),Dy=t(`은 포인터의 Zero value이다.
마찬가지로 `),rc=p("code"),Py=t("nil"),Oy=t("은 인터페이스의 Zero value이긴 하지만, Concrete Type들에 비해 간단하지만은 않다."),w1=i(),et=p("pre"),C1=i(),pt=p("pre"),D1=i(),jn=p("p"),Ry=t(`Go의 인터페이스는 내부적으로 두 쌍의 포인터로 구성되며, 각각 타입, 값을 가리킨다.
만약 타입을 가리키는 포인터가 `),kc=p("code"),Ty=t("nil"),Sy=t("이 아니라면, 인터페이스는 "),fc=p("code"),My=t("nil"),Iy=t("이 아닌 것이다. 출력 결과의 세 번째 라인이 저 모양인 것이 이 때문."),P1=i(),O=p("p"),Ly=t("인터페이스에 할당된 concrete type에 따라 호출되는 메소드가 달라지듯, 인터페이스에서 "),dc=p("code"),Hy=t("nil"),Ay=t(`은 메소드를 호출할 수 있는지 여부를 나타낸다.
만약 인터페이스가 `),Ec=p("code"),Gy=t("nil"),By=t("임에도 메소드를 호출하였다면, "),mc=p("em"),xy=t("panic"),Ny=t(`이 발생한다.
만약 인터페이스가 `),vc=p("code"),Fy=t("nil"),Wy=t(`이 아닌데 메소드를 호출하였다면, 메소드를 호출하려고 시도할 것이다.
(다만 위 예제와 같은 경우 인터페이스에 연결된 값이 `),_c=p("code"),Uy=t("nil"),jy=t("이기 때문에, 곧바로 "),yc=p("em"),zy=t("panic"),qy=t("이 발생할 것이다.)"),O1=i(),Y=p("p"),Vy=t("인터페이스 인스턴스의 타입을 나타내는 포인터가 "),bc=p("code"),Jy=t("nil"),Xy=t("이 아니라면, 이는 "),wc=p("code"),$y=t("nil"),Zy=t(`이 아닌 것이다.
그렇다고 해서 이 인터페이스의 값이 `),Cc=p("code"),Ky=t("nil"),Qy=t("인지는 확실하게 알 수 없기 때문에, 나중에 나올 "),Dc=p("em"),Yy=t("Reflection"),hy=t("을 사용해야 한다."),R1=i(),T1=p("br"),S1=p("br"),M1=i(),aa=p("h3"),ta=p("a"),Pc=p("span"),gy=t("The Empty Interface Says Nothing"),I1=i(),ea=p("p"),n6=t(`정적 타입 언어에서도 아무 타입이나 다 집어넣을 수 있는 변수가 필요할 때가 있다.
그러한 경우, Go에서는 `),Oc=p("code"),s6=t("interface{}"),a6=t("를 사용할 수 있다."),L1=i(),ot=p("pre"),H1=i(),zn=p("p"),t6=t(`비어 있는 인터페이스는 말 그대로 아무 값이나 다 저장할 수 있다.
인터페이스가 비어 있다는 말은 0개 이상의 메소드가 있는 타입들을 가리킬 수 있다는 뜻이며,
그래서 메소드가 없는 `),Rc=p("code"),e6=t("int"),p6=t(", "),Tc=p("code"),o6=t("string"),l6=t(" 등의 Primitive Type들도 저장이 가능해진다."),A1=i(),G1=p("br"),B1=i(),ae=p("p"),c6=t("비어 있는 인터페이스가 사용되는 예 중 하나는, JSON처럼 외부 소스에서 읽어온 불분명한 스키마의 placeholder로 사용하는 것이다."),x1=i(),lt=p("pre"),N1=i(),pa=p("p"),u6=t("위 코드를 실행하면 JSON 데이터가 "),Sc=p("code"),i6=t("data"),r6=t(" 변수에 저장된다."),F1=i(),W1=p("br"),U1=i(),yn=p("p"),k6=t(`또 다른 경우에는, 유저가 만든 자료구조에서 다양한 타입의 값을 저장하기 위해 사용된다.
Go의 `),Mc=p("code"),f6=t("slice"),d6=t(", "),Ic=p("code"),E6=t("map"),m6=t(" 등 타입들은 한 가지 타입밖에 저장하지 못하는데 비해, "),Lc=p("code"),v6=t("interface{}"),_6=t("는 여러 타입을 가리킬 수 있기 때문."),j1=i(),ct=p("pre"),z1=i(),te=p("p"),y6=t("위 코드는 러프한 예시니까 실제로 사용하지는 말자."),q1=i(),bn=p("p"),b6=t("또 다른 사용예로는 함수의 파라미터로 "),Hc=p("code"),w6=t("interface{}"),C6=t("를 받는 경우인데, "),Ac=p("em"),D6=t("reflection"),P6=t(`을 하기 위해 사용한다고 하는 것 같다.
`),Gc=p("em"),O6=t("reflection"),R6=t("은 나중에 나온다!"),V1=i(),J1=p("br"),X1=i(),H=p("p"),T6=t("근데 "),Bc=p("code"),S6=t("interface{}"),M6=t(`를 되도록이면 사용하지 않는 게 좋다.
Go는 기본적으로 정적 타입 언어로 디자인된 언어인 만큼, `),xc=p("code"),I6=t("interface{}"),L6=t(`로 여러 타입들을 쑤시고 다니는 건 좋지 않다.
`),Nc=p("code"),H6=t("interface{}"),A6=t(`를 사용하여 값들을 저장해야 할 상황에서, 값을 다시 읽어오려면 어떻게 해야 할까?
그럴 때 바로 아래에서 설명할 `),Fc=p("em"),G6=t("Type Assertions"),B6=t(" 및 "),Wc=p("em"),x6=t("Type Switches"),N6=t("를 사용해 보자."),$1=i(),Z1=p("br"),K1=p("br"),Q1=i(),oa=p("h3"),la=p("a"),Uc=p("span"),F6=t("Type Assertions and Type Switches"),Y1=i(),ee=p("p"),W6=t(`Go에는 어떤 변수의 인터페이스가 가리키는 타입이 특정한 Concrete Type인지,
혹은 Concrete Type이 또 다른 인터페이스를 구현하는지 확인할 수 있는 두 가지 방법이 있다.`),h1=i(),ca=p("p"),U6=t("한 가지가 바로 "),jc=p("strong"),j6=t("Type Assertion"),z6=t(`이다.
이는 어떤 인터페이스를 구현하는 Concrete Type에 이름을 붙이거나,
또는 이 인터페이스를 구현하고 있는 Concrete Type이 구현하는 또 다른 인터페이스에 이름을 붙인다.`),g1=i(),ut=p("pre"),nd=i(),A=p("p"),q6=t("이렇게 "),zc=p("em"),V6=t("Type Assertion"),J6=t("을 사용하여 "),qc=p("code"),X6=t("i"),$6=t("가 가리키고 있는 타입을 "),Vc=p("code"),Z6=t("MyInt"),K6=t(`로 한정할 수 있다.
위 예제에서 변수 `),Jc=p("code"),Q6=t("i2"),Y6=t("의 타입은 "),Xc=p("code"),h6=t("MyInt"),g6=t("가 된다."),sd=i(),ad=p("br"),td=i(),qn=p("p"),n7=t("만약 잘못된 타입으로 "),$c=p("em"),s7=t("Type Assertion"),a7=t("을 하면 "),Zc=p("em"),t7=t("panic"),e7=t("이 발생한다."),ed=i(),it=p("pre"),pd=i(),od=p("br"),ld=i(),cn=p("p"),Kc=p("code"),p7=t("int"),o7=t("와 "),Qc=p("code"),l7=t("MyInt"),c7=t("는 본질적으론 같은 타입이지만, Go는 타입에 엄격하기 때문에 "),Yc=p("em"),u7=t("Type Assertion"),i7=t(`을 사용할 때 Concrete Type끼리 일치시켜주어야 한다.
따라서 아래와 같은 예제는 `),hc=p("em"),r7=t("panic"),k7=t("이 발생한다."),cd=i(),rt=p("pre"),ud=i(),id=p("br"),rd=i(),ms=p("p"),gc=p("code"),f7=t("map"),d7=t("을 사용할 때 보았던 "),nu=p("em"),E7=t("comma ok idiom"),m7=t("을 사용하여 panic을 회피할 수 있다."),kd=i(),kt=p("pre"),fd=i(),w=p("p"),su=p("code"),v7=t("map"),_7=t(`에서 봤던 패턴과 유사하다.
`),au=p("em"),y7=t("Type Assertion"),b7=t("에 성공하면 변수 "),tu=p("code"),w7=t("ok"),C7=t("는 "),eu=p("code"),D7=t("true"),P7=t("가 되며, 나머지 변수는 인터페이스가 가리키는 값으로 초기화된다."),O7=p("br"),R7=t(`
반면 실패하면 `),pu=p("code"),T7=t("ok"),S7=t("는 "),ou=p("code"),M7=t("false"),I7=t("가 되며, 나머지 변수는 해당 타입의 Zero value로 초기화된다."),dd=i(),Vn=p("p"),L7=t("그렇게 얻은 "),lu=p("code"),H7=t("ok"),A7=t(" 변수값을 통해 이를 "),cu=p("code"),G7=t("if"),B7=t(`문으로 처리할 수는 있지만
Go에서는 에러 핸들링을 통해 처리하는 것을 더 지향한다는 것 같다. 에러 핸들링은 다음 챕터에서 나온다!`),Ed=i(),ua=p("p"),x7=t("어찌 됐든, 인터페이스가 가리키고 있는 데이터의 타입이 확실하다고 생각해도 되도록이면 "),uu=p("em"),N7=t("comma ok idiom"),F7=t(`를 쓰는 것이 좋다.
다른 사람이나 미래의 내가 언제 이 코드를 다시 사용할 지도 모르는 일이며, 코드를 조금 수정했는데 런타임 에러가 날 수도 있으니 말이다.`),md=i(),vd=p("br"),_d=p("br"),yd=i(),ia=p("p"),W7=t("어느 인터페이스의 타입에 여러 개의 후보군이 있다면, "),iu=p("em"),U7=t("Type Switch"),j7=t("를 써보도록 하자."),bd=i(),ft=p("pre"),wd=i(),dt=p("pre"),Cd=i(),Jn=p("p"),z7=t("기본적으로 형태는 boolean 표현식이 사용되지 않는 일반적인 "),ru=p("code"),q7=t("switch"),V7=t(`문의 형태와 유사하다.
다만 switch문 이후에 `),ku=p("code"),J7=t("i.(type)"),X7=t(`로, 인터페이스의 타입을 나타내어 주면 된다.
이렇게 각 case문에 타입을 할당함으로써, 인터페이스의 타입에 따라 처리할 수 있다.`),Dd=i(),_=p("p"),$7=t(`실행 결과를 보면 대충 알 수 있겠지만, 3번째 줄의 경우 주의해야 할 것 같다.
변수 `),fu=p("code"),Z7=t("c"),K7=t("는 값이 "),du=p("code"),Q7=t("nil"),Y7=t("인 것이지, 타입은 "),Eu=p("code"),h7=t("nil"),g7=t("이 아니라 "),mu=p("code"),n8=t("*string"),s8=t(`이다.
실제로 `),vu=p("code"),a8=t("switch"),t8=t("문에서 "),_u=p("code"),e8=t("case nil"),p8=t("에 걸리는 경우는, 변수 "),yu=p("code"),o8=t("f"),l8=t("처럼 인터페이스가 가리키는 대상이 아무 것도 없을 때이다."),Pd=i(),ra=p("p"),c8=t("인터페이스가 가리키는 타입에 대해 전혀 모를 경우, "),bu=p("em"),u8=t("reflection"),i8=t(`을 사용하면 된다고 한다.
나중에 나온다. 나중에…`),Od=i(),un=p("p"),wu=p("em"),r8=t("Type Assertion"),k8=t("과 "),Cu=p("em"),f8=t("Type Switch"),d8=t(`가 꽤나 유용한 기술처럼 보이는데, 자주 사용하면 안된다고 한다.
웬만하면 함수의 파라미터나 리턴값은 특정한 몇 가지의 타입으로만 지정하는 것이 좋으며, 나머지 다른 타입들은 가능은 하더라도 안되게 해야 한다.
그렇지 않으면 우리가 짜는 함수가 어떤 타입들을 지원하는지에 대해 정확히 명시하지 못할 수 있다.
대충 `),Du=p("code"),E8=t("interface{}"),m8=t("를 사용하는 걸 지양하라는 말과 일맥상통하는 것 같다. "),Pu=p("code"),v8=t("interface{}"),_8=t("를 안 쓰면 특정한 타입을 명시할 수밖에 없을 테니 말이다."),Rd=i(),Td=p("br"),Sd=i(),vs=p("p"),Ou=p("em"),y8=t("Type Assertion"),b8=t("과 "),Ru=p("em"),w8=t("Type Switch"),C8=t("가 유용하게 사용되는 예제에 대해 알아보자."),Md=i(),G=p("p"),D8=t(`가장 일반적인 경우, 한 인터페이스가 가리키고 있는 concrete type을 보기 위해 사용되는데,
이 concrete type은 다른 인터페이스에서도 가리킬 수 있는 경우이다.
이를테면 `),Tu=p("code"),P8=t("io"),O8=t(" 라이브러리의 "),Su=p("code"),R8=t("io.File"),T8=t(" 등 여러 타입들은 "),Mu=p("code"),S8=t("io.Reader"),M8=t("와 "),Iu=p("code"),I8=t("io.Writer"),L8=t(` 두 가지 인터페이스를 모두 만족시킨다.
그 때 `),Lu=p("code"),H8=t("io.Reader"),A8=t("가 가리키고 있는 타입이 어떤 타입인지 확인하기 위해 사용할 수 있을 것이다."),Id=i(),m=p("p"),Hu=p("code"),G8=t("io.Copy()"),B8=t(" 함수는 "),Au=p("code"),x8=t("io.Reader"),N8=t("와 "),Gu=p("code"),F8=t("io.Writer"),W8=t(" 인터페이스들을 파라미터로 받아, "),Bu=p("code"),U8=t("io.copyBuffer()"),j8=t(`함수를 실행한다.
다만 이때 `),xu=p("code"),z8=t("io.Reader"),q8=t("의 파라미터가 "),Nu=p("code"),V8=t("io.ReaderFrom"),J8=t("에서도 사용할 수 있거나, "),Fu=p("code"),X8=t("io.Writer"),$8=t("의 파라미터가 "),Wu=p("code"),Z8=t("io.WriterTo"),K8=t(`에서도 사용할 수 있다면,
함수 내용 대부분이 생략될 수 있다.`),Ld=i(),Et=p("pre"),Hd=i(),Ad=p("br"),Gd=i(),Xn=p("p"),Q8=t(`인터페이스는 API를 업그레이드할때도 사용된다고 한다.
챕터 12에서 `),Uu=p("em"),Y8=t("context"),h8=t("에 대해 알아볼 텐데, "),ju=p("em"),g8=t("context"),n9=t(`란 취소를 관리하는 표준적인 방법을 제시하는 파라미터이다.
Go 버전 1.7부터 생긴 기능인지라, 이전 버전의 데이터베이스 드라이버 등에서는 지원하지 않는다.`),Bd=i(),R=p("p"),s9=t("Go 1.8부터는 "),zu=p("code"),a9=t("database/sql/driver"),t9=t(` 패키지에 기존에 존재하는 인터페이스에 대한 새로운 컨텍스트 인식 유사체가 정의되었다.
이를테면 `),qu=p("code"),e9=t("StmtExecContext"),p9=t(" 인터페이스에는 "),Vu=p("code"),o9=t("ExecContext"),l9=t(`라는 메소드가 있다.
스탠다드 라이브러리 데이터베이스 코드에 `),Ju=p("code"),c9=t("Stmt"),u9=t(` 인터페이스의 타입이 통과될 경우,
이 타입이 `),Xu=p("code"),i9=t("StmtExecContext"),r9=t("에도 사용할 수 있는지 확인한다. 만약 그렇다면 "),$u=p("code"),k9=t("ExecContext"),f9=t(`를 호출한다.
만약 그렇지 않다면, fallback code를 실행한다.`),xd=i(),mt=p("pre"),Nd=i(),Fd=p("br"),Wd=i(),$n=p("p"),d9=t(`이런 optional interface 기능에는 한 가지 단점이 존재한다.
한 인터페이스로 여러 가지 타입을 사용하여 계층적 구조를 만드는 decorator 패턴을 사용하기 위해 인터페이스가 많이들 사용된다.
이 때, 어느 optional interface가 이 타입들 중 한 가지라도 사용할 수 있다면, `),Zu=p("em"),E9=t("Type Assertion"),m9=t("과 "),Ku=p("em"),v9=t("Type Switch"),_9=t("으로 이를 감지할 수 없다."),Ud=i(),T=p("p"),y9=t("그 예로 "),Qu=p("code"),b9=t("bufio"),w9=t(`라는 표준 라이브러리는 buffered reader를 제공한다.
이 때 `),Yu=p("code"),C9=t("bufio.NewReader()"),D9=t(" 함수에 "),hu=p("code"),P9=t("io.Reader"),O9=t("를 지원하는 타입을 파라미터로 통과시키면, "),gu=p("code"),R9=t("*bufio.Reader"),T9=t(`를 리턴받는다.
만약 파라미터로 넘겨진 `),ni=p("code"),S9=t("io.Reader"),M9=t("의 타입이 "),si=p("code"),I9=t("io.ReaderFrom"),L9=t("도 지원하는 경우, 이를 buffered reader로 감싸게 되면 최적화가 되지 않는다."),jd=i(),h=p("p"),H9=t(`에러 핸들링 할때도 본 현상인데, 에러는 다른 에러를 감싸는 것을 통해 추가적인 정보를 포함할 수 있다.
`),ai=p("em"),A9=t("Type Assertion"),G9=t("과 "),ti=p("em"),B9=t("Type Switch"),x9=t(`로는 감싸진 에러를 확인할 수 없기 때문에,
제대로 핸들링하기 위해 감싸진 에러에 접근하려면 `),ei=p("code"),N9=t("errors.Is()"),F9=t("나 "),pi=p("code"),W9=t("errors.As()"),U9=t("같은 함수를 사용해야 한다."),zd=i(),qd=p("br"),Vd=i(),vt=p("p"),oi=p("em"),j9=t("Type Switch"),z9=t(`는 인터페이스를 지원하는 타입들이 여러 개 있고, 각 타입마다 다르게 처리해줘야 하는 경우 유용하다.
그중 가장 유용한 경우는, 유효한 타입이 딱 한 개만 존재하는 경우이다.`),Jd=i(),g=p("p"),q9=t("웬만하면 "),li=p("code"),V9=t("switch"),J9=t("문에 "),ci=p("code"),X9=t("default"),$9=t(`를 반드시 넣어주는 게 좋다.
인터페이스를 지원하는 타입을 추가했는데 `),ui=p("code"),Z9=t("switch"),K9=t("문을 업데이트하는 것을 까먹은 경우 "),ii=p("code"),Q9=t("default"),Y9=t(" 블록에 걸리므로, 문제를 추적하기 쉬워질 것이다."),Xd=i(),$d=p("br"),Zd=p("br"),Kd=i(),ka=p("h3"),fa=p("a"),ri=p("span"),h9=t("Function Types Are a Bridge to Interfaces"),Qd=i(),pe=p("p"),g9=t("Go에서는 함수를 비롯하여 유저가 정의한 타입이라면 어떠한 타입이든 메소드를 추가할 수 있으며, 이는 굉장히 유용하다."),Yd=i(),oe=p("p"),nb=t("가장 일반적인 사례는 HTTP 요청을 처리하는 HTTP 핸들러이다. 이는 아래와 같이 인터페이스로 정의되어 있다."),hd=i(),_t=p("pre"),gd=i(),F=p("p"),ki=p("code"),sb=t("http.ResponseWriter"),ab=t(", "),fi=p("code"),tb=t("*http.Request"),eb=t("를 파라미터로 받는 함수들은 "),di=p("code"),pb=t("HandlerFunc"),ob=t(`로 타입 변환을 할 수 있다.
그러면 `),Ei=p("code"),lb=t("ServeHTTP()"),cb=t("를 호출할 수 있게 되며, "),mi=p("code"),ub=t("http.Handler"),ib=t(" 인터페이스를 사용할 수 있게 된다."),nE=i(),yt=p("pre"),sE=i(),da=p("p"),rb=t("이러한 방식을 통해 "),vi=p("code"),kb=t("http.Handler"),fb=t("의 인터페이스를 충족시키기만 하면 함수, 메소드, Closure를 HTTP 핸들러로 사용할 수 있다."),aE=i(),tE=p("br"),eE=i(),le=p("p"),db=t(`Go에서 함수는 가장 중요한 개념인 만큼, 또 다른 함수의 파라미터로 전달된다.
한편으로, Go에서는 작은 인터페이스를 권장하며, 메소드가 하나 뿐인 인터페이스는 함수의 파라미터로 전달되는 함수를 대체할 수 있다.
그렇다면 이런 질문이 생길 수 있다. 파라미터인 함수의 타입을 언제 명시해줘야 하며, 언제 인터페이스를 써야 할까?`),pE=i(),Zn=p("p"),Eb=t(`만약 함수가 다른 함수들이나, 파라미터가 아닌 state에 의존한다면,
인터페이스 파라미터를 사용하고 인터페이스에 대한 bridge로써 함수 타입을 정의하는 것이 좋다고 한다.
이를테면 이는 `),_i=p("code"),mb=t("http"),vb=t(` 패키지에서 사용하는 방식이다. http 핸들러는 설정해주어야 하는 연쇄적인 함수 호출의 진입점일 가능성이 높다.
반면 함수가 `),yi=p("code"),_b=t("sort.Slice()"),yb=t("처럼 간단한 함수일 경우, 인터페이스보단 그냥 함수를 넘기는 게 좋다고 한다."),oE=i(),lE=p("br"),cE=p("br"),uE=i(),Ea=p("h3"),ma=p("a"),bi=p("span"),bb=t("Implicit Interfaces Make Dependency Injection Easier"),iE=i(),bt=p("p"),wi=p("strong"),wb=t("Dependency Injection"),Cb=t(`이란 코드가 수행하는 기능과 작업을 분명하게 명시해야 한다는 개념이다.
Go의 인터페이스는 디커플링을 맛깔나게 잘 해줘서 Dependency Injection이 엄청 잘 된다고 한다.
그래서 다른 언어에서 Dependency Injection를 위해 복잡한 프레임워크를 사용하는 반면,
Go는 어떠한 외부 라이브러리도 사용하지 않는다.`),rE=i(),ce=p("p"),Db=t("Dependency Injection이 어떻게 이루어지는지 보기 위해, 간단한 웹 서버 예제를 만들어보자."),kE=i(),wt=p("pre"),fE=i(),va=p("p"),Pb=t(`간단한 로깅 함수와 저장을 위한 데이터 타입, 및 데이터 탐색 메소드를 정의하였다.
`),Ci=p("code"),Ob=t("SimpleDataStore"),Rb=t(" 인스턴스를 생성하는 factory function을 정의해보자."),dE=i(),Ct=p("pre"),EE=i(),mE=p("br"),vE=i(),Kn=p("p"),Tb=t(`이제 유저에게 “hello” 또는 “good bye”라고 날리는 로직을 작성해 볼 것이다.
이 로직은 유저에게 접근해야 하므로 접근 대상이 되는 자료구조와, 로깅을 하는 함수에 대한 의존성이 존재한다.
하지만 우리는 `),Di=p("code"),Sb=t("LogOutput()"),Mb=t("이나 "),Pi=p("code"),Ib=t("SimpleDataStore"),Lb=t(`에 대한 직접적인 의존성을 만들고 싶지 않다.
미래에 다른 자료구조나 로깅 함수를 사용할 수도 있기 때문이다.`),_E=i(),ue=p("p"),Hb=t("바로 이러한 경우, 인터페이스가 적절한 해법이 된다."),yE=i(),Dt=p("pre"),bE=i(),Tn=p("p"),Oi=p("code"),Ab=t("LoggerAdapter"),Gb=t("를 선언해 "),Ri=p("code"),Bb=t("LogOutput()"),xb=t("함수를 "),Ti=p("code"),Nb=t("Logger"),Fb=t(`에 연결해 주었다.
이제 우리의 비즈니스 로직은 인터페이스들을 사용하여 자료구조에 접근하고, 로깅을 할 수 있다.`),wE=i(),ie=p("p"),Wb=t("의존성이 정의되었으니, 비즈니스 로직을 완성해보자."),CE=i(),Pt=p("pre"),DE=i(),W=p("p"),Si=p("code"),Ub=t("Logger"),jb=t("와 "),Mi=p("code"),zb=t("DataStore"),qb=t("를 필드로 갖는 "),Ii=p("code"),Vb=t("SimpleLogic"),Jb=t("이라는 "),Li=p("code"),Xb=t("struct"),$b=t(`와, factory function을 정의해주었다.
이 `),Hi=p("code"),Zb=t("SimpleLogic"),Kb=t(` 내의 메소드는 다른 concrete type을 레퍼런스하지 않기 때문에, 의존성이 없다.
그래서 차후 라이브러리를 교체하더라도 인터페이스는 라이브러리와 관련이 없기 때문에 문제가 발생하지 않는다.`),PE=i(),OE=p("br"),RE=i(),Qn=p("p"),Qb=t("이제 "),Ai=p("code"),Yb=t("/hello"),hb=t(`라는 엔드포인트를 정의해볼 것이다. 이 엔드포인트에서는 유저의 ID가 같이 오면 인사를 할 것이다.
`),Gi=p("em"),gb=t("Controller"),nw=t("에게 인사를 할 로직을 쥐어주기 위해 인터페이스를 만들어주자."),TE=i(),Ot=p("pre"),SE=i(),Yn=p("p"),sw=t("이 인터페이스는 "),Bi=p("code"),aw=t("SimpleLogic"),tw=t(`을 가리킬 수 있다.
인터페이스는 클라이언트 코드에서 정의되기 때문에, 수정이 필요하다면 클라이언트 코드에서 수정하면 그만이다.
따라서 `),xi=p("code"),ew=t("SimpleLogic"),pw=t("이 나중에 변경되거나, 혹은 새로운 로직이 추가되더라도 별다른 문제 없이 사용할 수 있다."),ME=i(),Rt=p("pre"),IE=i(),LE=p("br"),HE=i(),_a=p("p"),ow=t("마지막으로, "),Ni=p("code"),lw=t("main"),cw=t(" 함수에서 모든 컴포넌트를 연결하고 서버를 열어보자."),AE=i(),Tt=p("pre"),GE=i(),hn=p("p"),uw=t("파일을 실행하여 서버를 연 뒤, 브라우저에서 "),Fi=p("code"),iw=t("http://localhost:8080/hello?user_id=1"),rw=t(" 및 "),Wi=p("code"),kw=t("http://localhost:8080/hello?user_id=5"),fw=t(" 등으로 접속해보자."),BE=i(),S=p("p"),Ui=p("code"),dw=t('http.HandleFunc("/hello", c.SayHello)'),Ew=t(" 라인을 잘 살펴보면, 두 번째 "),ji=p("code"),mw=t("http.HandleFunc()"),vw=t("의 두 번째 파라미터로 "),zi=p("code"),_w=t("c.SayHello()"),yw=t(` 메소드를 보냈다.
이때 보내진 메소드는 `),qi=p("code"),bw=t("http.Handler"),ww=t(" 인터페이스를 충족시키는 "),Vi=p("code"),Cw=t("http.HandlerFunc"),Dw=t(` 타입으로 변환이 된다.
`),Ji=p("code"),Pw=t("NewController"),Ow=t("의 메소드임을 유지한 채로 말이다."),xE=i(),_s=p("p"),Xi=p("code"),Rw=t("main"),Tw=t(` 함수는 concrete type들이 실제로 선언되는 유일한 영역이다.
어느 타입 하나를 다른 타입으로 변경하고 싶다면, `),$i=p("code"),Sw=t("main"),Mw=t(`에서만 변경해주면 된다.
이렇게 Dependency Injection을 통해 의존성을 Externalizing함으로써, 코드를 업데이트 할 때 변경해야 할 내용을 최소화할 수 있다.`),NE=i(),re=p("p"),Iw=t(`Dependency Injection은 테스트를 더 쉽게 할 수 있도록 해주기도 한다.
환경이 다르더라도, 입출력이 제한된 상황에서 unit test를 하는 것은 코드를 효과적으로 재사용한다.
이를테면 위 예제에서 logger의 출력을 테스트하려고 한다면, logger의 출력을 capture하는 타입을 주입하고 인터페이스를 충족시켜주기만 하면 된다.`),FE=i(),WE=p("br"),UE=i(),ya=p("p"),Lw=t(`개인적으로는 Dependency Injection이 일단 짜놓으면 편하긴 한데, 직접 짜기에는 너무 복잡하고 양이 많아 보였다.
그럴 때에는 구글님들이 `),St=p("a"),Hw=t("Wire"),Aw=t(`라는, Dependency Injection을 도와주는 유틸리티가 있는데,
자동적으로 concrete type 선언 코드를 만들어준다고 하니 필요하다면 잘 사용해보도록 하자.`),jE=i(),zE=p("br"),qE=p("br"),VE=i(),ba=p("h3"),wa=p("a"),Zi=p("span"),Gw=t("Go Isn’t Particularly Object-Oriented"),JE=i(),ke=p("p"),Bw=t(`Go라는 언어를 특정 스타일로 구분짓기는 어렵다.
일단 절차지향은 아닌 듯 한데, 메소드 오버라이딩이나 상속도 없어서 객체지향이라기에도 애매하다.
함수 타입과 closure가 있지만 함수형 언어도 아니다.
만약 이러한 방법론에 맞춰서 Go 코드를 짜면, 아마 그게 이상적인 Go 코드는 아닐 것이다.`),XE=i(),$E=p("br"),ZE=p("br"),KE=i(),Ca=p("h2"),Da=p("a"),Ki=p("span"),xw=t("Refereces"),QE=i(),YE=p("hr"),hE=i(),Sn=p("center"),Qi=p("p"),Nw=t("["),Fw=i(),qI(Mt.$$.fragment),Ww=t(`
](https://learning.oreilly.com/library/view/learning-go/9781492077206/) `),Uw=p("br"),jw=t(`
[Jon Bodner, 『Learning Go』, O'Reilly Media, Inc.](https://learning.oreilly.com/library/view/learning-go/9781492077206/)`),gE=i(),n2=p("br"),s2=i(),fe=p("p"),zw=t("이번 포스트는 의역이 너무 많아용"),a2=i(),de=p("p"),qw=t("원문 참조하시는 게 좋을듯함"),t2=i(),e2=p("br"),p2=p("br"),this.h()},l(n){At=o(n,"BR",{}),tr=r(n),Gt=o(n,"P",{});var c=l(Gt);T2=e(c,"본 글은 Golang을 공부하며 주요 내용이라 생각되는 것들을 기록해둔 자료이며, Ubuntu 20.04 LTS 기준으로 작성되었습니다."),c.forEach(a),er=r(n),pr=o(n,"BR",{}),or=o(n,"BR",{}),lr=r(n),Ps=o(n,"H2",{id:!0});var Vw=l(Ps);Os=o(Vw,"A",{"aria-hidden":!0,tabindex:!0,href:!0});var rC=l(Os);We=o(rC,"SPAN",{class:!0}),l(We).forEach(a),rC.forEach(a),S2=e(Vw,"Types"),Vw.forEach(a),cr=r(n),ur=o(n,"HR",{}),ir=r(n),Rs=o(n,"P",{});var l2=l(Rs);M2=e(l2,"Go에는 Class나 상속과 같은 개념이 개념이 존재하지 않는다. 대신 타입을 정의하고자 하는 경우, "),Ue=o(l2,"CODE",{});var kC=l(Ue);I2=e(kC,"type"),kC.forEach(a),L2=e(l2," 키워드를 사용하여 정의한다."),l2.forEach(a),rr=r(n),Aa=o(n,"PRE",{class:!0});var KM=l(Aa);KM.forEach(a),kr=r(n),Bt=o(n,"P",{});var fC=l(Bt);H2=e(fC,"위처럼 정의된 타입들은 이들이 정의된 스코프 내에서만 정의 가능하다."),fC.forEach(a),fr=r(n),dr=o(n,"BR",{}),Er=r(n),kn=o(n,"P",{});var Pa=l(kn);A2=e(Pa,"한 가지 짚고 넘어가야 할 점은, 위 예제의 "),je=o(Pa,"CODE",{});var dC=l(je);G2=e(dC,"Score"),dC.forEach(a),B2=e(Pa," 타입의 경우 사실상 "),ze=o(Pa,"CODE",{});var EC=l(ze);x2=e(EC,"int"),EC.forEach(a),N2=e(Pa,`와 동일한 타입이다.
그럼에도 위와 같이 타입명을 지정해준 것은 타입명 자체를 일종의 `),qe=o(Pa,"STRONG",{});var mC=l(qe);F2=e(mC,"documentation"),mC.forEach(a),W2=e(Pa,"으로 볼 수 있기 때문이다."),Pa.forEach(a),mr=r(n),Hn=o(n,"P",{});var Ee=l(Hn);U2=e(Ee,`이러한 타입 지정은 해당 타입의 변수 또는 인스턴스가 코드 내에서 어떠한 역할을 하며,
어떠한 데이터를 저장할 지에 대한 정보를 제공할 수 있다.
위 예제에서 `),Ve=o(Ee,"CODE",{});var vC=l(Ve);j2=e(vC,"Score"),vC.forEach(a),z2=e(Ee,"는 "),Je=o(Ee,"CODE",{});var _C=l(Je);q2=e(_C,"int"),_C.forEach(a),V2=e(Ee,"와 똑같은 정수 타입이기는 해도, 무식하게 큰 정수나 음수인 값에 대해서는 유효하지 않은 값임을 파악할 수 있을 것이다."),Ee.forEach(a),vr=r(n),Ts=o(n,"P",{});var c2=l(Ts);J2=e(c2,"위 예제의 "),Xe=o(c2,"CODE",{});var yC=l(Xe);X2=e(yC,"Employee"),yC.forEach(a),$2=e(c2,`은 유저가 정의한 타입을 다시 정의한 경우인데, 이 또한 같은 맥락에서 바라볼 수 있다.
저장하고 있는 데이터의 종류는 같을지라도, 이들이 사용되어야 할 적합한 맥락에 대해서 정보를 제공할 수 있다.`),c2.forEach(a),_r=r(n),yr=o(n,"BR",{}),br=o(n,"BR",{}),wr=r(n),Ss=o(n,"H3",{id:!0});var Jw=l(Ss);Ms=o(Jw,"A",{"aria-hidden":!0,tabindex:!0,href:!0});var bC=l(Ms);$e=o(bC,"SPAN",{class:!0}),l($e).forEach(a),bC.forEach(a),Z2=e(Jw,"Inheritance in Go?"),Jw.forEach(a),Cr=r(n),xt=o(n,"P",{});var wC=l(xt);K2=e(wC,"Go에는 객체지향과 상속 개념이 없다. type을 선언할 수 있지만, 이는 말 그대로 어디까지나 선언만 할 수 있는 것이다."),wC.forEach(a),Dr=r(n),Ga=o(n,"PRE",{class:!0});var QM=l(Ga);QM.forEach(a),Pr=r(n),Is=o(n,"P",{});var u2=l(Is);Q2=e(u2,"위와 같은 "),Ze=o(u2,"CODE",{});var CC=l(Ze);Y2=e(CC,"type"),CC.forEach(a),h2=e(u2,` 선언은 상속처럼 보일 수는 있지만, 엄연히 다르다. 실질적으로는 이름만 다른 동일한 타입이 두 개 선언되는 것.
이들 사이에는 어떠한 계층 구조도 존재하지 않는다.`),u2.forEach(a),Or=r(n),q=o(n,"P",{});var gn=l(q);g2=e(gn,"객체지향에서 "),Ke=o(gn,"EM",{});var DC=l(Ke);nm=e(DC,"child class"),DC.forEach(a),sm=e(gn,"는 "),Qe=o(gn,"EM",{});var PC=l(Qe);am=e(PC,"parent class"),PC.forEach(a),tm=e(gn,`가 가진 모든 메소드와 값들을 사용할 수 있어야 하며, parent class가 사용되는 곳 어디에든 사용될 수 있어야 한다.
반면 Go에서는, 위 예제의 `),Ye=o(gn,"CODE",{});var OC=l(Ye);em=e(OC,"Score"),OC.forEach(a),pm=e(gn," 인스턴스가 사용되는 상황에서 "),he=o(gn,"CODE",{});var RC=l(he);om=e(RC,"HighScore"),RC.forEach(a),lm=e(gn," 인스턴스를 사용하려면 타입 변환을 해주어야 한다."),gn.forEach(a),Rr=r(n),Ba=o(n,"PRE",{class:!0});var YM=l(Ba);YM.forEach(a),Tr=r(n),Sr=o(n,"BR",{}),Mr=o(n,"BR",{}),Ir=r(n),Ls=o(n,"H3",{id:!0});var Xw=l(Ls);Hs=o(Xw,"A",{"aria-hidden":!0,tabindex:!0,href:!0});var TC=l(Hs);ge=o(TC,"SPAN",{class:!0}),l(ge).forEach(a),TC.forEach(a),cm=e(Xw,"Enumeration in Go - iota"),Xw.forEach(a),Lr=r(n),An=o(n,"P",{});var me=l(An);um=e(me,"여러 프로그래밍 언어에 존재하는 "),np=o(me,"EM",{});var SC=l(np);im=e(SC,"Enumeration"),SC.forEach(a),rm=e(me,"에 대한 개념 대신, Go에는 "),sp=o(me,"CODE",{});var MC=l(sp);km=e(MC,"iota"),MC.forEach(a),fm=e(me,"가 존재한다. 바로 예제를 확인해보자."),me.forEach(a),Hr=r(n),xa=o(n,"PRE",{class:!0});var hM=l(xa);hM.forEach(a),Ar=r(n),Na=o(n,"PRE",{class:!0});var gM=l(Na);gM.forEach(a),Gr=r(n),V=o(n,"P",{});var ns=l(V);dm=e(ns,`위 예제의 실행 결과를 확인해보면, 0부터 4까지의 수가 순서대로 할당되었음을 알 수 있다.
이는 `),ap=o(ns,"CODE",{});var IC=l(ap);Em=e(IC,"iota"),IC.forEach(a),mm=e(ns,"가 첫 번째 상수인 "),tp=o(ns,"CODE",{});var LC=l(tp);vm=e(LC,"Uncategorized"),LC.forEach(a),_m=e(ns,"에 0, 두 번째 상수인 "),ep=o(ns,"CODE",{});var HC=l(ep);ym=e(HC,"Personal"),HC.forEach(a),bm=e(ns,`에 1, 이런 식으로 점점 증가되게끔 값을 할당하였기 때문이다.
또한, 만일 새로운 `),pp=o(ns,"CODE",{});var AC=l(pp);wm=e(AC,"const"),AC.forEach(a),Cm=e(ns," 선언 블록이 존재할 경우, iota는 0이 될 것이다."),ns.forEach(a),Br=r(n),xr=o(n,"BR",{}),Nr=r(n),Fa=o(n,"PRE",{class:!0});var nI=l(Fa);nI.forEach(a),Fr=r(n),is=o(n,"P",{});var Yi=l(is);op=o(Yi,"CODE",{});var GC=l(op);Dm=e(GC,"_"),GC.forEach(a),Pm=e(Yi,`를 이용하면 iota로 할당되는 값을 건너뛸 수 있다.
또한 `),lp=o(Yi,"CODE",{});var BC=l(lp);Om=e(BC,"iota"),BC.forEach(a),Rm=e(Yi,`를 사용할 때 위와 같은 표현식을 사용하여 값들을 할당할 수도 있다.
다만 이런 경우, 무슨 목적으로 이런 코드를 짰는지 잘 명시해주는 것이 좋겠다.`),Yi.forEach(a),Wr=r(n),Ur=o(n,"BR",{}),jr=r(n),D=o(n,"P",{});var nn=l(D);Tm=e(nn,"단 "),cp=o(nn,"CODE",{});var xC=l(cp);Sm=e(xC,"iota"),xC.forEach(a),Mm=e(nn,"를 사용하려면 "),up=o(nn,"CODE",{});var NC=l(up);Im=e(NC,"iota"),NC.forEach(a),Lm=e(nn,`에 의해서 할당되는 값이 큰 의미가 없는 경우여야 한다.
0, 1, 2, … 등 `),ip=o(nn,"CODE",{});var FC=l(ip);Hm=e(FC,"iota"),FC.forEach(a),Am=e(nn,`에 의해 할당되는 값들은 단순히 서로를 구분하기 위해서 사용되는 값일 뿐이며, 이 값을 직접적으로 사용해선 안된다.
만일 `),rp=o(nn,"CODE",{});var WC=l(rp);Gm=e(WC,"iota"),WC.forEach(a),Bm=e(nn,"를 사용하는 "),kp=o(nn,"CODE",{});var UC=l(kp);xm=e(UC,"const"),UC.forEach(a),Nm=e(nn,` 블록 중간에 새로운 상수를 추가하면 값들이 전체적으로 바뀔 것이다.
이 때 `),fp=o(nn,"CODE",{});var jC=l(fp);Fm=e(jC,"iota"),jC.forEach(a),Wm=e(nn,"에 의해 할당되는 값을 직접적으로 사용한다면 이에 영향을 받을 것이다."),nn.forEach(a),zr=r(n),J=o(n,"P",{});var ss=l(J);Um=e(ss,`특정 인터페이스와 직접적으로 관련되어있지 않은 내부적인 로직에서 사용하는 것이 좋다.
만약 어느 `),dp=o(ss,"CODE",{});var zC=l(dp);jm=e(zC,"struct"),zC.forEach(a),zm=e(ss," 타입에 "),Ep=o(ss,"CODE",{});var qC=l(Ep);qm=e(qC,"iota"),qC.forEach(a),Vm=e(ss,`를 사용하는 Enumeration 필드가 존재하고, 해당 인스턴스들이 DB에 저장되어있다고 가정해보자.
그런데 `),mp=o(ss,"CODE",{});var VC=l(mp);Jm=e(VC,"iota"),VC.forEach(a),Xm=e(ss,"를 사용하는 "),vp=o(ss,"CODE",{});var JC=l(vp);$m=e(JC,"const"),JC.forEach(a),Zm=e(ss," 블록 중간에 새로운 상수를 추가하면 DB에 저장된 값들이 완전히 다른 값을 가리키게 될 것이다."),ss.forEach(a),qr=r(n),As=o(n,"P",{});var i2=l(As);Km=e(i2,"따라서 상수의 값이 중요한 경우이거나 내부적인 로직에서 사용하는 것이 아니라면 "),_p=o(i2,"CODE",{});var XC=l(_p);Qm=e(XC,"iota"),XC.forEach(a),Ym=e(i2,`를 쓰지 말고 그냥 값을 직접 할당해주는 편이 좋다.
그게 아니라면 문서를 잘 써놓자.`),i2.forEach(a),Vr=r(n),Jr=o(n,"BR",{}),Xr=o(n,"BR",{}),$r=r(n),Gs=o(n,"H2",{id:!0});var $w=l(Gs);Bs=o($w,"A",{"aria-hidden":!0,tabindex:!0,href:!0});var $C=l(Bs);yp=o($C,"SPAN",{class:!0}),l(yp).forEach(a),$C.forEach(a),hm=e($w,"Methods"),$w.forEach(a),Zr=r(n),Kr=o(n,"HR",{}),Qr=r(n),fn=o(n,"P",{});var Oa=l(fn);gm=e(Oa,"Go에서는 "),bp=o(Oa,"EM",{});var ZC=l(bp);nv=e(ZC,"User-defined type"),ZC.forEach(a),sv=e(Oa,`에 대해 메소드를 생성할 수 있다.
일반적인 함수 선언과 유사하지만, `),wp=o(Oa,"CODE",{});var KC=l(wp);av=e(KC,"func"),KC.forEach(a),tv=e(Oa,"와 메소드명 사이에 "),Cp=o(Oa,"STRONG",{});var QC=l(Cp);ev=e(QC,"receiver"),QC.forEach(a),pv=e(Oa,`를 명시해준다.
보통의 변수 선언처럼 변수명을 먼저 적고 타입을 뒤에 적는다.
일반적으로는 타입명의 맨 앞글자를 소문자로 적는다고 한다.`),Oa.forEach(a),Yr=r(n),Wa=o(n,"PRE",{class:!0});var sI=l(Wa);sI.forEach(a),hr=r(n),Nt=o(n,"P",{});var YC=l(Nt);ov=e(YC,`Go에서는 함수 오버로딩을 지원하지 않으며, 메소드도 동일하다.
동일한 타입에서 두개 이상의 동일한 이름을 가진 메소드를 선언할 수 없다.`),YC.forEach(a),gr=r(n),Ft=o(n,"P",{});var hC=l(Ft);lv=e(hC,"또한 타입과 이에 대한 메소드가 선언된 파일을 서로 분리할 수는 있지만, 같은 파일 에서 함께 선언하는 것이 권장된다고 한다."),hC.forEach(a),nk=r(n),sk=o(n,"BR",{}),ak=o(n,"BR",{}),tk=r(n),xs=o(n,"H3",{id:!0});var Zw=l(xs);Ns=o(Zw,"A",{"aria-hidden":!0,tabindex:!0,href:!0});var gC=l(Ns);Dp=o(gC,"SPAN",{class:!0}),l(Dp).forEach(a),gC.forEach(a),cv=e(Zw,"Pointer Receivers"),Zw.forEach(a),ek=r(n),dn=o(n,"P",{});var Ra=l(dn);uv=e(Ra,"함수에서 포인터 파라미터를 사용할 때처럼, "),Pp=o(Ra,"EM",{});var nD=l(Pp);iv=e(nD,"Receiver"),nD.forEach(a),rv=e(Ra,`에도 포인터를 사용할 수 있다.
이 때 `),Op=o(Ra,"EM",{});var sD=l(Op);kv=e(sD,"Value Receiver"),sD.forEach(a),fv=e(Ra,"를 사용할 때와의 차이점은 "),Rp=o(Ra,"EM",{});var aD=l(Rp);dv=e(aD,"Receiver"),aD.forEach(a),Ev=e(Ra,"로 패스한 값이 변경될 수 있다는 것이다."),Ra.forEach(a),pk=r(n),Ua=o(n,"P",{});var Kw=l(Ua);Tp=o(Kw,"EM",{});var tD=l(Tp);mv=e(tD,"Pointer Reciver"),tD.forEach(a),vv=e(Kw,"에 대한 몇 가지 규칙이 존재한다."),Kw.forEach(a),ok=r(n),Gn=o(n,"OL",{});var ve=l(Gn);rs=o(ve,"LI",{});var _e=l(rs);_v=e(_e,"메소드가 "),Sp=o(_e,"EM",{});var eD=l(Sp);yv=e(eD,"Reciver"),eD.forEach(a),bv=e(_e," 값을 변경한다면, 반드시 "),Mp=o(_e,"EM",{});var pD=l(Mp);wv=e(pD,"Pointer Reciver"),pD.forEach(a),Cv=e(_e,"를 사용한다."),_e.forEach(a),Dv=r(ve),ks=o(ve,"LI",{});var ye=l(ks);Pv=e(ye,"메소드가 "),Ip=o(ye,"CODE",{});var oD=l(Ip);Ov=e(oD,"nil"),oD.forEach(a),Rv=e(ye," 인스턴스를 다뤄야 한다면, 반드시 "),Lp=o(ye,"EM",{});var lD=l(Lp);Tv=e(lD,"Pointer Reciver"),lD.forEach(a),Sv=e(ye,"를 사용한다."),ye.forEach(a),Mv=r(ve),fs=o(ve,"LI",{});var be=l(fs);Iv=e(be,"메소드가 "),Hp=o(be,"EM",{});var cD=l(Hp);Lv=e(cD,"Reciver"),cD.forEach(a),Hv=e(be," 값을 변경하지 않는다면, "),Ap=o(be,"EM",{});var uD=l(Ap);Av=e(uD,"Value Reciver"),uD.forEach(a),Gv=e(be,"를 사용할 수 있다."),be.forEach(a),ve.forEach(a),lk=r(n),Rn=o(n,"P",{});var It=l(Rn);Gp=o(It,"EM",{});var iD=l(Gp);Bv=e(iD,"Reciver"),iD.forEach(a),xv=e(It," 값을 변경하지 않는 메소드에 대해서도 "),Bp=o(It,"EM",{});var rD=l(Bp);Nv=e(rD,"Pointer Reciver"),rD.forEach(a),Fv=e(It,`를 사용하는 것이 국룰이라고 한다.
다만 난 잘 모르겠다. 개인적으로는 값을 변경하지 않는다면 명시적으로 `),xp=o(It,"EM",{});var kD=l(xp);Wv=e(kD,"Value Reciver"),kD.forEach(a),Uv=e(It,"를 써도 되는 거 아닌가 싶다."),It.forEach(a),ck=r(n),uk=o(n,"BR",{}),ik=r(n),ja=o(n,"PRE",{class:!0});var aI=l(ja);aI.forEach(a),rk=r(n),En=o(n,"P",{});var Ta=l(En);jv=e(Ta,"함수에 포인터 파라미터를 넘길 때와는 달리, Receiver에 "),Np=o(Ta,"CODE",{});var fD=l(Np);zv=e(fD,"&"),fD.forEach(a),qv=e(Ta,`를 붙이지 않아도 된다.
위 `),Fp=o(Ta,"CODE",{});var dD=l(Fp);Vv=e(dD,"c.Increment()"),dD.forEach(a),Jv=e(Ta," 부분은 자동으로 "),Wp=o(Ta,"CODE",{});var ED=l(Wp);Xv=e(ED,"(&c).Increment()"),ED.forEach(a),$v=e(Ta,`로 변환된다.
아래 코드는 예제의 실행 결과이다.`),Ta.forEach(a),kk=r(n),za=o(n,"PRE",{class:!0});var tI=l(za);tI.forEach(a),fk=r(n),dk=o(n,"BR",{}),Ek=r(n),Wt=o(n,"P",{});var mD=l(Wt);Zv=e(mD,"이러한 규칙들에 대해 잘 이해하면, 아래 예제의 실행 결과도 알 수 있을 것이다."),mD.forEach(a),mk=r(n),qa=o(n,"PRE",{class:!0});var eI=l(qa);eI.forEach(a),vk=r(n),E=o(n,"P",{});var C=l(E);Up=o(C,"CODE",{});var vD=l(Up);Kv=e(vD,"doUpdateWrong()"),vD.forEach(a),Qv=e(C," 함수의 스코프 내에서 "),jp=o(C,"CODE",{});var _D=l(jp);Yv=e(_D,"c.Increment()"),_D.forEach(a),hv=e(C,"를 호출시 "),zp=o(C,"CODE",{});var yD=l(zp);gv=e(yD,"c"),yD.forEach(a),n3=e(C,`가 변경되고, 그 결과가 이후 출력에서 반영된다.
하지만 `),qp=o(C,"CODE",{});var bD=l(qp);s3=e(bD,"doUpdateWrong()"),bD.forEach(a),a3=e(C," 함수는 파라미터인 "),Vp=o(C,"CODE",{});var wD=l(Vp);t3=e(wD,"Counter"),wD.forEach(a),e3=e(C,"를 "),Jp=o(C,"EM",{});var CD=l(Jp);p3=e(CD,"pass by value"),CD.forEach(a),o3=e(C,"로 받았기 때문에 "),Xp=o(C,"CODE",{});var DD=l(Xp);l3=e(DD,"main()"),DD.forEach(a),c3=e(C,` 함수로 되돌아왔을 때 변경사항이 유지되지 않는다.
반면 `),$p=o(C,"CODE",{});var PD=l($p);u3=e(PD,"doUpdateWrong()"),PD.forEach(a),i3=e(C," 함수는 파라미터를 "),Zp=o(C,"EM",{});var OD=l(Zp);r3=e(OD,"pass by pointer"),OD.forEach(a),k3=e(C,"로 받았기에, 변경사항이 유지된다."),C.forEach(a),_k=r(n),Ut=o(n,"P",{});var RD=l(Ut);f3=e(RD,"위 예제의 실행 결과는 아래와 같다."),RD.forEach(a),yk=r(n),Va=o(n,"PRE",{class:!0});var pI=l(Va);pI.forEach(a),bk=r(n),wk=o(n,"BR",{}),Ck=r(n),mn=o(n,"P",{});var Sa=l(mn);d3=e(Sa,"이렇게 유저가 정의한 타입에 Method를 통해 "),Kp=o(Sa,"EM",{});var TD=l(Kp);E3=e(TD,"Getter"),TD.forEach(a),m3=e(Sa,"나, "),Qp=o(Sa,"EM",{});var SD=l(Qp);v3=e(SD,"Pointer Reciver"),SD.forEach(a),_3=e(Sa,"를 이용하여 "),Yp=o(Sa,"EM",{});var MD=l(Yp);y3=e(MD,"Setter"),MD.forEach(a),b3=e(Sa,`를 정의할 수는 있다.
다만 필드에 직접 값을 할당하는 경우가 아니거나, 여러 필드를 한 번의 오퍼레이션으로 처리해야 하는 경우가 아니라면,
Go에서는 되도록이면 필드값에 직접 접근하는 것을 권장한다.`),Sa.forEach(a),Dk=r(n),Pk=o(n,"BR",{}),Ok=o(n,"BR",{}),Rk=r(n),ds=o(n,"P",{});var hi=l(ds);hp=o(hi,"EM",{});var ID=l(hp);w3=e(ID,"Pointer Reciver"),ID.forEach(a),C3=e(hi,"는 "),gp=o(hi,"CODE",{});var LD=l(gp);D3=e(LD,"nil"),LD.forEach(a),P3=e(hi," 인스턴스를 다뤄야 할 때 사용할 수 있다."),hi.forEach(a),Tk=r(n),v=o(n,"P",{});var B=l(v);O3=e(B,"다른 언어들의 경우 "),no=o(B,"CODE",{});var HD=l(no);R3=e(HD,"null"),HD.forEach(a),T3=e(B,"이나 "),so=o(B,"CODE",{});var AD=l(so);S3=e(AD,"None"),AD.forEach(a),M3=e(B,` 인스턴스에서 메소드를 호출하면 에러가 발생한다.
Go에서도 `),ao=o(B,"CODE",{});var GD=l(ao);I3=e(GD,"nil"),GD.forEach(a),L3=e(B," 인스턴스에서 메소드를 호출할 때 "),to=o(B,"EM",{});var BD=l(to);H3=e(BD,"Value Reciver"),BD.forEach(a),A3=e(B,"인 경우에는 "),eo=o(B,"EM",{});var xD=l(eo);G3=e(xD,"panic"),xD.forEach(a),B3=e(B,"이 발생하지만, "),po=o(B,"EM",{});var ND=l(po);x3=e(ND,"Pointer Reciver"),ND.forEach(a),N3=e(B,`인 경우 메소드가 정상적으로 호출된다.
이 경우, 메소드가 `),oo=o(B,"CODE",{});var FD=l(oo);F3=e(FD,"nil"),FD.forEach(a),W3=e(B," 인스턴스를 처리할 수 있게끔 작성되어 있어야 한다."),B.forEach(a),Sk=r(n),Ja=o(n,"PRE",{class:!0});var oI=l(Ja);oI.forEach(a),Mk=r(n),Fs=o(n,"P",{});var r2=l(Fs);U3=e(r2,"위 예제는 "),lo=o(r2,"CODE",{});var WD=l(lo);j3=e(WD,"nil"),WD.forEach(a),z3=e(r2," 인스턴스를 핸들링할 수 있는 정수형 바이너리 트리의 예제이다."),r2.forEach(a),Ik=r(n),pn=o(n,"P",{});var ys=l(pn);co=o(ys,"CODE",{});var UD=l(co);q3=e(UD,"IntTree.Contains()"),UD.forEach(a),V3=e(ys," 메소드는 현재 receiver가 "),uo=o(ys,"CODE",{});var jD=l(uo);J3=e(jD,"nil"),jD.forEach(a),X3=e(ys,`인지에 따라 해당 값이 포함되어 있는가의 여부를 판단하며
`),io=o(ys,"CODE",{});var zD=l(io);$3=e(zD,"IntTree.Insert()"),zD.forEach(a),Z3=e(ys," 메소드는 현재 receiver가 "),ro=o(ys,"CODE",{});var qD=l(ro);K3=e(qD,"nil"),qD.forEach(a),Q3=e(ys,`일 경우 현 위치에 값을 추가한 값을 반환한다.
단, 이때는 포인터 파라미터를 사용할 때처럼 receiver에 특정 주소값을 할당하여도, 원본 포인터가 변경되지는 않는다.`),ys.forEach(a),Lk=r(n),Hk=o(n,"BR",{}),Ak=o(n,"BR",{}),Gk=r(n),Ws=o(n,"H3",{id:!0});var Qw=l(Ws);Us=o(Qw,"A",{"aria-hidden":!0,tabindex:!0,href:!0});var VD=l(Us);ko=o(VD,"SPAN",{class:!0}),l(ko).forEach(a),VD.forEach(a),Y3=e(Qw,"Methods and Functions"),Qw.forEach(a),Bk=r(n),jt=o(n,"P",{});var JD=l(jt);h3=e(JD,"Go에서 메소드는 함수와 유사한 점이 많다."),JD.forEach(a),xk=r(n),Xa=o(n,"PRE",{class:!0});var lI=l(Xa);lI.forEach(a),Nk=r(n),vn=o(n,"P",{});var Ma=l(vn);g3=e(Ma,"함수를 변수에 할당하여 사용할 수 있듯, 위 예제의 "),fo=o(Ma,"CODE",{});var XD=l(fo);n5=e(XD,"f1"),XD.forEach(a),s5=e(Ma,`처럼 메소드도 변수에 할당하여 사용할 수 있다.
이 때 이 메소드의 타입은 `),Eo=o(Ma,"CODE",{});var $D=l(Eo);a5=e($D,"func(int)int"),$D.forEach(a),t5=e(Ma,"가 되며, 이를 "),mo=o(Ma,"EM",{});var ZD=l(mo);e5=e(ZD,"method value"),ZD.forEach(a),p5=e(Ma,"라 한다."),Ma.forEach(a),Fk=r(n),N=o(n,"P",{});var Mn=l(N);vo=o(Mn,"EM",{});var KD=l(vo);o5=e(KD,"method value"),KD.forEach(a),l5=e(Mn,"는 "),_o=o(Mn,"EM",{});var QD=l(_o);c5=e(QD,"closure"),QD.forEach(a),u5=e(Mn,`처럼 파라미터로 넘기거나 할 수도 있다.
`),yo=o(Mn,"EM",{});var YD=l(yo);i5=e(YD,"method value"),YD.forEach(a),r5=e(Mn,"를 선언할 때 붙어있던 "),bo=o(Mn,"EM",{});var hD=l(bo);k5=e(hD,"receiver"),hD.forEach(a),f5=e(Mn,"가 고정되어 있기 때문에, 이를 호출할 경우 해당 "),wo=o(Mn,"EM",{});var gD=l(wo);d5=e(gD,"receiver"),gD.forEach(a),E5=e(Mn,"가 영향을 받는다."),Mn.forEach(a),Wk=r(n),X=o(n,"P",{});var as=l(X);m5=e(as,"위 예제의 "),Co=o(as,"CODE",{});var nP=l(Co);v5=e(nP,"f2"),nP.forEach(a),_5=e(as,`처럼 그냥 타입명에 메소드를 붙인 것을 변수에 할당할 수도 있다.
이를 `),Do=o(as,"EM",{});var sP=l(Do);y5=e(sP,"method expression"),sP.forEach(a),b5=e(as,"이라 한다. 이 때 이 메소드의 타입은 "),Po=o(as,"CODE",{});var aP=l(Po);w5=e(aP,"func(Adder, int) int"),aP.forEach(a),C5=e(as,"가 되며, 첫 번째 파라미터가 "),Oo=o(as,"EM",{});var tP=l(Oo);D5=e(tP,"receiver"),tP.forEach(a),P5=e(as,"가 된다."),as.forEach(a),Uk=r(n),js=o(n,"P",{});var k2=l(js);O5=e(k2,`이렇게 Go에서는 메소드를 함수처럼 사용할 수 있기에 큰 차이가 없기에 어느 것을 사용해야 할지 혼동이 올 수 있다.
만약 작성하고자 하는 로직이 입력 파라미터에 의해서만 영향을 받는다면 함수를 사용하는 것이 옳다.
반면 프로그램이 실행되며 설정되고, 실행 중 계속 바뀌는 어떤 값에 의해 로직이 영향을 받을 수 있다.
그러한 경우 이 값들은 `),Ro=o(k2,"CODE",{});var eP=l(Ro);R5=e(eP,"struct"),eP.forEach(a),T5=e(k2,"에 저장되어야 하고 메소드를 사용하는 것이 좋다."),k2.forEach(a),jk=r(n),zk=o(n,"BR",{}),qk=o(n,"BR",{}),Vk=r(n),zs=o(n,"H2",{id:!0});var Yw=l(zs);qs=o(Yw,"A",{"aria-hidden":!0,tabindex:!0,href:!0});var pP=l(qs);To=o(pP,"SPAN",{class:!0}),l(To).forEach(a),pP.forEach(a),S5=e(Yw,"Embedding"),Yw.forEach(a),Jk=r(n),Xk=o(n,"HR",{}),$k=r(n),Bn=o(n,"P",{});var we=l(Bn);M5=e(we,"Go에는 상속이 없지만 "),So=o(we,"STRONG",{});var oP=l(So);I5=e(oP,"Embedding"),oP.forEach(a),L5=e(we,"을 통해 구조화된 "),Mo=o(we,"CODE",{});var lP=l(Mo);H5=e(lP,"struct"),lP.forEach(a),A5=e(we," 타입을 구성할 수 있다."),we.forEach(a),Zk=r(n),zt=o(n,"P",{});var cP=l(zt);G5=e(cP,"기본적인 예제는 다음과 같다."),cP.forEach(a),Kk=r(n),$a=o(n,"PRE",{class:!0});var cI=l($a);cI.forEach(a),Qk=r(n),y=o(n,"P",{});var U=l(y);Io=o(U,"CODE",{});var uP=l(Io);B5=e(uP,"Manager"),uP.forEach(a),x5=e(U,"를 정의할 때 "),Lo=o(U,"CODE",{});var iP=l(Lo);N5=e(iP,"Employee"),iP.forEach(a),F5=e(U,"를 필드명 없이 선언해줌으로써, "),Ho=o(U,"CODE",{});var rP=l(Ho);W5=e(rP,"Employee"),rP.forEach(a),U5=e(U,"는 "),Ao=o(U,"CODE",{});var kP=l(Ao);j5=e(kP,"Manager"),kP.forEach(a),z5=e(U,"의 "),Go=o(U,"STRONG",{});var fP=l(Go);q5=e(fP,"Embedded Field"),fP.forEach(a),V5=e(U,`가 된다.
`),Bo=o(U,"CODE",{});var dP=l(Bo);J5=e(dP,"Manager"),dP.forEach(a),X5=e(U,"에서는 "),xo=o(U,"CODE",{});var EP=l(xo);$5=e(EP,"Employee"),EP.forEach(a),Z5=e(U,"의 필드에 접근할 수 있다."),U.forEach(a),Yk=r(n),hk=o(n,"BR",{}),gk=r(n),Za=o(n,"PRE",{class:!0});var uI=l(Za);uI.forEach(a),nf=r(n),Vs=o(n,"P",{});var f2=l(Vs);K5=e(f2,"위 예제처럼 "),No=o(f2,"EM",{});var mP=l(No);Q5=e(mP,"Embedding"),mP.forEach(a),Y5=e(f2,"된 구조체의 내부와 외부 양쪽에 동일한 필드명을 가진 상황이 생길 수 있다."),f2.forEach(a),sf=r(n),_n=o(n,"P",{});var Ia=l(_n);h5=e(Ia,"이러한 경우, "),Fo=o(Ia,"CODE",{});var vP=l(Fo);g5=e(vP,"Outer"),vP.forEach(a),n_=e(Ia,"에 있는 "),Wo=o(Ia,"CODE",{});var _P=l(Wo);s_=e(_P,"Inner"),_P.forEach(a),a_=e(Ia," 내부에 위치한 X에 접근하려고 할 때는 "),Uo=o(Ia,"CODE",{});var yP=l(Uo);t_=e(yP,"Inner"),yP.forEach(a),e_=e(Ia,"를 명시해줘야 한다."),Ia.forEach(a),af=r(n),tf=o(n,"BR",{}),ef=o(n,"BR",{}),pf=r(n),Es=o(n,"P",{});var gi=l(Es);jo=o(gi,"EM",{});var bP=l(jo);p_=e(bP,"Embedding"),bP.forEach(a),o_=e(gi,"은 다른 언어에서 찾기 힘든, 흔치 않은 개념이다. 그래서 구조적으로 비슷한 상속과 연관지어서 생각하곤 하는데, "),zo=o(gi,"EM",{});var wP=l(zo);l_=e(wP,"Embedding"),wP.forEach(a),c_=e(gi,"은 상속과는 명백하게 다르다."),gi.forEach(a),of=r(n),lf=o(n,"BR",{}),cf=r(n),xn=o(n,"P",{});var Ce=l(xn);u_=e(Ce,"위 "),qo=o(Ce,"CODE",{});var CP=l(qo);i_=e(CP,"Manager"),CP.forEach(a),r_=e(Ce,"와 "),Vo=o(Ce,"CODE",{});var DP=l(Vo);k_=e(DP,"Employee"),DP.forEach(a),f_=e(Ce," 예제에 이어서, 아래 예제도 살펴보자."),Ce.forEach(a),uf=r(n),Ka=o(n,"PRE",{class:!0});var iI=l(Ka);iI.forEach(a),rf=r(n),$=o(n,"P",{});var ts=l($);d_=e(ts,"만약 상속이었다면 위 "),Jo=o(ts,"CODE",{});var PP=l(Jo);E_=e(PP,"var eFail Employee = m"),PP.forEach(a),m_=e(ts,` 라인이 정상적으로 컴파일되었을 것이다.
`),Xo=o(ts,"CODE",{});var OP=l(Xo);v_=e(OP,"Manager"),OP.forEach(a),__=e(ts,"를 "),$o=o(ts,"CODE",{});var RP=l($o);y_=e(RP,"Employee"),RP.forEach(a),b_=e(ts,`의 하위 개념으로 보기 때문.
하지만 `),Zo=o(ts,"EM",{});var TP=l(Zo);w_=e(TP,"Embedding"),TP.forEach(a),C_=e(ts,"은 상속과는 차이가 있기 때문에 에러가 발생한다."),ts.forEach(a),kf=r(n),ff=o(n,"BR",{}),df=r(n),Js=o(n,"P",{});var d2=l(Js);D_=e(d2,"Go는 상속을 지원하지 않기 때문에 폴리모피즘과는 거리가 있고, "),Ko=o(d2,"STRONG",{});var SP=l(Ko);P_=e(SP,"Dynamic Dispatch"),SP.forEach(a),O_=e(d2,"(동적 디스패치)도 존재하지 않는다."),d2.forEach(a),Ef=r(n),Qa=o(n,"PRE",{class:!0});var rI=l(Qa);rI.forEach(a),mf=r(n),Ya=o(n,"PRE",{class:!0});var kI=l(Ya);kI.forEach(a),vf=r(n),I=o(n,"P",{});var wn=l(I);R_=e(wn,"위 예제에서 "),Qo=o(wn,"CODE",{});var MP=l(Qo);T_=e(MP,"o.Double()"),MP.forEach(a),S_=e(wn,"를 호출하면 겹치는 메소드명이 없기 때문에 "),Yo=o(wn,"CODE",{});var IP=l(Yo);M_=e(IP,"o.Inner.Double()"),IP.forEach(a),I_=e(wn,`가 자동 호출된다.
이 때 `),ho=o(wn,"CODE",{});var LP=l(ho);L_=e(LP,"o.Inner.Double()"),LP.forEach(a),H_=e(wn," 내부에서는 "),go=o(wn,"CODE",{});var HP=l(go);A_=e(HP,"o.Inner.IntPrinter()"),HP.forEach(a),G_=e(wn,"를 호출하기 때문에, "),nl=o(wn,"CODE",{});var AP=l(nl);B_=e(AP,"Inner: 20"),AP.forEach(a),x_=e(wn,`가 출력된 것이다.
이렇듯 Go에서 메소드는 전혀 오버라이딩되지 않는다.`),wn.forEach(a),_f=r(n),yf=o(n,"BR",{}),bf=o(n,"BR",{}),wf=r(n),Xs=o(n,"H2",{id:!0});var hw=l(Xs);$s=o(hw,"A",{"aria-hidden":!0,tabindex:!0,href:!0});var GP=l($s);sl=o(GP,"SPAN",{class:!0}),l(sl).forEach(a),GP.forEach(a),N_=e(hw,"Interface"),hw.forEach(a),Cf=r(n),Df=o(n,"HR",{}),Pf=r(n),Zs=o(n,"P",{});var E2=l(Zs);F_=e(E2,"책에서는 Go의 진정한 꽃이 Goroutine을 위시한 Concurrency가 아니라, 이 "),al=o(E2,"EM",{});var BP=l(al);W_=e(BP,"Interface"),BP.forEach(a),U_=e(E2,"라고 하는데, 대체 얼마나 맛집이기에.."),E2.forEach(a),Of=r(n),qt=o(n,"P",{});var xP=l(qt);j_=e(xP,"설명에 앞서 인터페이스는 아래와 같이 정의할 수 있다."),xP.forEach(a),Rf=r(n),ha=o(n,"PRE",{class:!0});var fI=l(ha);fI.forEach(a),Tf=r(n),b=o(n,"P",{});var j=l(b);tl=o(j,"CODE",{});var NP=l(tl);z_=e(NP,"struct"),NP.forEach(a),q_=e(j,`를 정의하는 것과 큰 차이는 없는 것 같다.
암묵적인 룰이 하나 있는데, 인터페이스의 이름은 대개 “er”로 끝난다.
그 예로 `),el=o(j,"CODE",{});var FP=l(el);V_=e(FP,"fmt.Stringer"),FP.forEach(a),J_=e(j,", "),pl=o(j,"CODE",{});var WP=l(pl);X_=e(WP,"io.Reader"),WP.forEach(a),$_=e(j,", "),ol=o(j,"CODE",{});var UP=l(ol);Z_=e(UP,"io.Closer"),UP.forEach(a),K_=e(j,", "),ll=o(j,"CODE",{});var jP=l(ll);Q_=e(jP,"io.ReadCloser"),jP.forEach(a),Y_=e(j,", "),cl=o(j,"CODE",{});var zP=l(cl);h_=e(zP,"json.Marshaler"),zP.forEach(a),g_=e(j,", "),ul=o(j,"CODE",{});var qP=l(ul);n0=e(qP,"http.Handler"),qP.forEach(a),s0=e(j," 등등이 있다."),j.forEach(a),Sf=r(n),Mf=o(n,"BR",{}),If=r(n),on=o(n,"P",{});var bs=l(on);il=o(bs,"EM",{});var VP=l(il);a0=e(VP,"Interface"),VP.forEach(a),t0=e(bs,"는 객체지향의 "),rl=o(bs,"EM",{});var JP=l(rl);e0=e(JP,"Abstract Class"),JP.forEach(a),p0=e(bs,`와 유사하지만, 차이점이 있다.
다른 객체지향 언어에서는 `),kl=o(bs,"EM",{});var XP=l(kl);o0=e(XP,"Abstract Class"),XP.forEach(a),l0=e(bs,"에서 선언된 메소드 등을 "),fl=o(bs,"EM",{});var $P=l(fl);c0=e($P,"Concrete Class"),$P.forEach(a),u0=e(bs,"에서 구현한다."),bs.forEach(a),Lf=r(n),L=o(n,"P",{});var Cn=l(L);i0=e(Cn,"반면 Go의 인터페이스는 "),Vt=o(Cn,"SPAN",{style:!0});var ZP=l(Vt);r0=e(ZP,"암묵적"),ZP.forEach(a),k0=e(Cn,`인 개념이다.
`),dl=o(Cn,"EM",{});var KP=l(dl);f0=e(KP,"Concrete Type"),KP.forEach(a),d0=e(Cn,`에서는 인터페이스를 구현한다고 선언하지 않는다.
만약 `),El=o(Cn,"EM",{});var QP=l(El);E0=e(QP,"Concrete Type"),QP.forEach(a),m0=e(Cn,`에서 구현하는 메소드들이 인터페이스에서 선언된 모든 메소드들을 포함한다면,
그 때 `),ml=o(Cn,"EM",{});var YP=l(ml);v0=e(YP,"Concrete Type"),YP.forEach(a),_0=e(Cn,`가 인터페이스를 구현한다고 할 수 있으며, 이래서 암묵적이라는 표현을 사용하는 듯 하다.
그래서 Go에서는 `),vl=o(Cn,"EM",{});var hP=l(vl);y0=e(hP,"Concrete Type"),hP.forEach(a),b0=e(Cn,"을 인터페이스에 할당한다는 느낌으로 받아들여야 하는 것 같다."),Cn.forEach(a),Hf=r(n),ga=o(n,"P",{});var gw=l(ga);_l=o(gw,"EM",{});var gP=l(_l);w0=e(gP,"Interface"),gP.forEach(a),C0=e(gw," 덕에 Type-Safe, 디커플링, 정적/동적 언어에서 기능을 연결하는 것이 가능해진다고 하는데, 이건 좀 더 해봐야 알 듯 하다."),gw.forEach(a),Af=r(n),Nn=o(n,"P",{});var De=l(Nn);D0=e(De,"Javascript, Python 등의 동적 타입 언어에서는 인터페이스가 없는 대신 "),yl=o(De,"EM",{});var nO=l(yl);P0=e(nO,"Duck Typing"),nO.forEach(a),O0=e(De,`이란 것을 사용한다.
`),bl=o(De,"EM",{});var sO=l(bl);R0=e(sO,"Duck Typing"),sO.forEach(a),T0=e(De,`은 어떤 인스턴스가 원하는 메소드(또는 필드)들을 가지고 있다면, 내가 원하는 타입으로 간주한다는 뜻이다.
프로젝트의 규모가 너무 크거나, 프로젝트가 너무 오래되어서 의존성을 추적하기 어려운 경우 이런 방식을 사용한다.`),De.forEach(a),Gf=r(n),Jt=o(n,"P",{});var aO=l(Jt);S0=e(aO,`주로 정적 타입 언어를 사용하는 개발자라면 이런 방식에 대해 회의적이다.
인스턴스의 타입을 명시하지 않으면 어떤 타입인지 확인하기도 어려울 것이며, 어떤 기능을 할 수 있을지 예측할 수 없으리라 생각한다.`),aO.forEach(a),Bf=r(n),Xt=o(n,"P",{});var tO=l(Xt);M0=e(tO,`반면 Java에서는 다소 패턴이 다르다. 인터페이스의 정의와 구현이 각각 존재하지만, 인터페이스의 정의만 참조된다.
주로 동적 타입 언어를 사용하는 개발자들은 이 방식에 대해, 인터페이스가 바뀔 때마다 코드를 다시 짜야 하는 불편한 방식이라고 생각한다.`),tO.forEach(a),xf=r(n),Nf=o(n,"BR",{}),Ff=r(n),$t=o(n,"P",{});var eO=l($t);I0=e(eO,`만약 어플리케이션이 잠정적으로 개선될 여지가 있다면 코드에 유연성이 필요하다.
하지만 코드가 하고 있는 일이 무엇인지에 대해 사람들이 이해할 수 있도록 하는 것도 중요하기에, 코드의 역할과 의존성 등을 명시할 필요도 있다.
Go의 인터페이스는 양쪽 모두의 입장을 받아들인다.`),eO.forEach(a),Wf=r(n),Zt=o(n,"P",{});var pO=l(Zt);L0=e(pO,"아래 예제에서 Interface가 사용된 예시를 확인할 수 있다."),pO.forEach(a),Uf=r(n),nt=o(n,"PRE",{class:!0});var dI=l(nt);dI.forEach(a),jf=r(n),f=o(n,"P",{});var d=l(f);wl=o(d,"EM",{});var oO=l(wl);H0=e(oO,"Concrete Type"),oO.forEach(a),A0=e(d," 역할을 하는 "),Cl=o(d,"CODE",{});var lO=l(Cl);G0=e(lO,"LogicProvider"),lO.forEach(a),B0=e(d,"가 정의될 때, 이것이 "),Dl=o(d,"CODE",{});var cO=l(Dl);x0=e(cO,"Logic"),cO.forEach(a),N0=e(d,`이라는 인터페이스에 관련된 것이라고 선언된 것은 없다.
`),Pl=o(d,"CODE",{});var uO=l(Pl);F0=e(uO,"Logic"),uO.forEach(a),W0=e(d,"과 "),Ol=o(d,"CODE",{});var iO=l(Ol);U0=e(iO,"LogicProvider"),iO.forEach(a),j0=e(d,"이 연결되는 것은, "),Rl=o(d,"CODE",{});var rO=l(Rl);z0=e(rO,"Client"),rO.forEach(a),q0=e(d," 인스턴스인 "),Tl=o(d,"CODE",{});var kO=l(Tl);V0=e(kO,"c"),kO.forEach(a),J0=e(d,`가 생성될 때이며,
`),Sl=o(d,"CODE",{});var fO=l(Sl);X0=e(fO,"LogicProvider"),fO.forEach(a),$0=e(d,"에는 "),Ml=o(d,"CODE",{});var dO=l(Ml);Z0=e(dO,"Logic"),dO.forEach(a),K0=e(d,"에서 정의된 것과 동일한 이름의 메소드인 "),Il=o(d,"CODE",{});var EO=l(Il);Q0=e(EO,"Process()"),EO.forEach(a),Y0=e(d,`가 존재할 뿐이다.
따라서 `),Ll=o(d,"CODE",{});var mO=l(Ll);h0=e(mO,"LogicProvider"),mO.forEach(a),g0=e(d,"가 "),Hl=o(d,"CODE",{});var vO=l(Hl);n4=e(vO,"Logic"),vO.forEach(a),s4=e(d,"이라는 인터페이스를 위한 "),Al=o(d,"EM",{});var _O=l(Al);a4=e(_O,"Concrete Type"),_O.forEach(a),t4=e(d,"임을 알 수 있도록, 잘 문서화할 필요가 있다."),d.forEach(a),zf=r(n),qf=o(n,"BR",{}),Vf=r(n),Z=o(n,"P",{});var es=l(Z);e4=e(es,"Go에서는 "),Gl=o(es,"CODE",{});var yO=l(Gl);p4=e(yO,"io.Reader"),yO.forEach(a),o4=e(es,"나 "),Bl=o(es,"CODE",{});var bO=l(Bl);l4=e(bO,"io.Writer"),bO.forEach(a),c4=e(es,` 등, 스탠다드 인터페이스도 존재한다.
스탠다드 인터페이스를 사용하는 것은 `),xl=o(es,"EM",{});var wO=l(xl);u4=e(wO,"decorator"),wO.forEach(a),i4=e(es,` 패턴과 유사한데,
특정 인터페이스의 인스턴스를 받아서 동일한 인터페이스의 다른 인스턴스를 반환하는 `),Nl=o(es,"EM",{});var CO=l(Nl);r4=e(CO,"Factory Function"),CO.forEach(a),k4=e(es,"(객체를 반환하는 함수)를 자주 사용하기 때문."),es.forEach(a),Jf=r(n),Kt=o(n,"P",{});var DO=l(Kt);f4=e(DO,"아래 예제를 확인하자."),DO.forEach(a),Xf=r(n),st=o(n,"PRE",{class:!0});var EI=l(st);EI.forEach(a),$f=r(n),K=o(n,"P",{});var ps=l(K);d4=e(ps,"위 코드에서 "),Fl=o(ps,"CODE",{});var PO=l(Fl);E4=e(PO,"os.Open()"),PO.forEach(a),m4=e(ps,"에 의해 반환된 "),Wl=o(ps,"CODE",{});var OO=l(Wl);v4=e(OO,"os.File"),OO.forEach(a),_4=e(ps," 인스턴스는 "),Ul=o(ps,"CODE",{});var RO=l(Ul);y4=e(RO,"io.Reader"),RO.forEach(a),b4=e(ps,` 인터페이스를 충족시킨다.
따라서 `),jl=o(ps,"CODE",{});var TO=l(jl);w4=e(TO,"process()"),TO.forEach(a),C4=e(ps," 함수 내에서 파일의 데이터를 읽을 수 있다."),ps.forEach(a),Zf=r(n),Fn=o(n,"P",{});var Pe=l(Fn);D4=e(Pe,"아래 예제는 "),zl=o(Pe,"CODE",{});var SO=l(zl);P4=e(SO,"gzip"),SO.forEach(a),O4=e(Pe,"을 통해 파일을 압축 해제할 수 있는 경우에, "),ql=o(Pe,"CODE",{});var MO=l(ql);R4=e(MO,"gzip"),MO.forEach(a),T4=e(Pe," 라이브러리를 사용하여 압축 해제하는 예제이다."),Pe.forEach(a),Kf=r(n),at=o(n,"PRE",{class:!0});var mI=l(at);mI.forEach(a),Qf=r(n),Qt=o(n,"P",{});var IO=l(Qt);S4=e(IO,"위처럼 스탠다드 라이브러리의 인터페이스가 코드에 잘 어울릴 것 같으면, 사용하는 것이 좋다."),IO.forEach(a),Yf=r(n),P=o(n,"P",{});var sn=l(P);M4=e(sn,"예제에서는 "),Vl=o(sn,"CODE",{});var LO=l(Vl);I4=e(LO,"gzip"),LO.forEach(a),L4=e(sn,"으로 압축 해제된 "),Jl=o(sn,"CODE",{});var HO=l(Jl);H4=e(HO,"io.Reader"),HO.forEach(a),A4=e(sn," 인터페이스의 인스턴스가 "),Xl=o(sn,"CODE",{});var AO=l(Xl);G4=e(AO,"gz"),AO.forEach(a),B4=e(sn,`에 할당되고,
그 `),$l=o(sn,"CODE",{});var GO=l($l);x4=e(GO,"gz"),GO.forEach(a),N4=e(sn,"가 다시 한번 "),Zl=o(sn,"CODE",{});var BO=l(Zl);F4=e(BO,"process()"),BO.forEach(a),W4=e(sn,"함수에서 "),Kl=o(sn,"CODE",{});var xO=l(Kl);U4=e(xO,"io.Reader"),xO.forEach(a),j4=e(sn,"의 인스턴스가 된다."),sn.forEach(a),hf=r(n),Q=o(n,"P",{});var os=l(Q);z4=e(os,`어느 타입의 메소드들이 특정 인터페이스를 충족시키고도 남는 경우,
즉 인터페이스에 명시된 것 외의 메소드들이 존재한다고 해도 그 타입은 인터페이스를 충족시킨다.
이 때문에 한 타입이 두 개 이상의 인터페이스를 동시에 충족시킬 수 있다. 이 때 명시된 것 외의 메소드들은 무시한다.
이를테면 `),Ql=o(os,"CODE",{});var NO=l(Ql);q4=e(NO,"io.File"),NO.forEach(a),V4=e(os," 타입은 "),Yl=o(os,"CODE",{});var FO=l(Yl);J4=e(FO,"io.Reader"),FO.forEach(a),X4=e(os,"와 "),hl=o(os,"CODE",{});var WO=l(hl);$4=e(WO,"io.Writer"),WO.forEach(a),Z4=e(os,`를 동시에 충족시킨다.
즉, `),gl=o(os,"CODE",{});var UO=l(gl);K4=e(UO,"io.File"),UO.forEach(a),Q4=e(os," 한 가지 타입으로 읽고 쓰기가 동시에, 각각 지원되는 것이다."),os.forEach(a),gf=r(n),n1=o(n,"BR",{}),s1=o(n,"BR",{}),a1=r(n),Ks=o(n,"H3",{id:!0});var nC=l(Ks);Qs=o(nC,"A",{"aria-hidden":!0,tabindex:!0,href:!0});var jO=l(Qs);nc=o(jO,"SPAN",{class:!0}),l(nc).forEach(a),jO.forEach(a),Y4=e(nC,"Embedding and Interfaces"),nC.forEach(a),t1=r(n),ln=o(n,"P",{});var ws=l(ln);sc=o(ws,"CODE",{});var zO=l(sc);h4=e(zO,"struct"),zO.forEach(a),g4=e(ws,` 타입을 Embedding하는 것처럼, 인터페이스도 인터페이스 안에 Embedding할 수 있다.
스탠다드 라이브러리의 `),ac=o(ws,"CODE",{});var qO=l(ac);ny=e(qO,"io.ReadCloser"),qO.forEach(a),sy=e(ws,"도 "),tc=o(ws,"CODE",{});var VO=l(tc);ay=e(VO,"io.Reader"),VO.forEach(a),ty=e(ws,"와 "),ec=o(ws,"CODE",{});var JO=l(ec);ey=e(JO,"io.Closer"),JO.forEach(a),py=e(ws,`가 임베딩된 것이다.
아래의 예제와 유사하다.`),ws.forEach(a),e1=r(n),tt=o(n,"PRE",{class:!0});var vI=l(tt);vI.forEach(a),p1=r(n),o1=o(n,"BR",{}),l1=o(n,"BR",{}),c1=r(n),Ys=o(n,"H3",{id:!0});var sC=l(Ys);hs=o(sC,"A",{"aria-hidden":!0,tabindex:!0,href:!0});var XO=l(hs);pc=o(XO,"SPAN",{class:!0}),l(pc).forEach(a),XO.forEach(a),oy=e(sC,"Accept Interfaces, Return Structs"),sC.forEach(a),u1=r(n),gs=o(n,"P",{});var m2=l(gs);ly=e(m2,"Go의 빡고수들이 버릇처럼 읊는 말이 "),oc=o(m2,"STRONG",{});var $O=l(oc);cy=e($O,"Accept Interfaces, Return Structs"),$O.forEach(a),uy=e(m2,`라고 한다.
이는 함수에 의해 호출되는 로직은 반드시 인터페이스를 통해 호출되어야 하며,
함수의 결과값은 반드시 concrete type(struct)이어야 한다는 것이다.
함수의 파라미터로 인터페이스를 받으면 어떤 기능을 사용할 것인지 명시적으로 선언하면서도, flexible함을 동시에 챙길 수 있다.`),m2.forEach(a),i1=r(n),Yt=o(n,"P",{});var ZO=l(Yt);iy=e(ZO,`만약 API가 (암묵적이어야 할) 인터페이스를 리턴한다면, 디커플링이라는 인터페이스의 장점을 잃는다.
만약 그렇게 된다면 서드 파티 모듈의 인터페이스에 코드가 종속되는 결과를 낳게 된다.
대개 서드 파티 인터페이스에 대한 클라이언트의 의존성을 줄이고자 하기 마련이다.
이를 위해 또다른 인터페이스를 작성한 뒤, 타입 변환을 하는데(의존성 주입, Dependency Injection),
이는 어플리케이션의 기능을 제약할 수도 있기에 좋은 방법은 아니다.`),ZO.forEach(a),r1=r(n),ht=o(n,"P",{});var KO=l(ht);ry=e(KO,`인터페이스를 리턴하지 말아야 하는 또 다른 이유는 버전에 관련된 것이다.
Concrete Type을 리턴하는 경우에는 기존 코드에 새로운 메소드나 필드가 별 문제 없이 추가될 수 있다.
반면 인터페이스의 경우에는 새로운 메소드를 추가하려면 기존에 존재하는 모든 메소드들의 구현을 업데이트해야 한다.
따라서 API를 롤백해야 하는 경우에도, major version number를 증가시켜야 한다.`),KO.forEach(a),k1=r(n),gt=o(n,"P",{});var QO=l(gt);ky=e(QO,`인터페이스가 정해져 있고 파라미터에 따라서 다른 인스턴스가 나오는 factory function을 짜는 것보다는,
타입들을 분리하여 concrete type이 반환되는 각각의 함수를 작성하는 것이 좋다.`),QO.forEach(a),f1=r(n),Wn=o(n,"P",{});var Oe=l(Wn);fy=e(Oe,`웬만하면 인터페이스를 반환하지 않는 것이 좋긴 한데, 가끔 어쩔 수 없이 하는 경우가 있다. 대표적인 예시가 바로 에러이다.
Go에서는 `),lc=o(Oe,"CODE",{});var YO=l(lc);dy=e(YO,"error"),YO.forEach(a),Ey=e(Oe,` 인터페이스를 반환하도록 선언되는 경우가 많다.
이는 인터페이스가 Go에서 유일하게 사용할 수 있는 추상 유형이며. `),cc=o(Oe,"CODE",{});var hO=l(cc);my=e(hO,"error"),hO.forEach(a),vy=e(Oe,` 인터페이스의 다른 구현을 사용해야 하는 경우가 많기 때문이다.
따라서 가능한 모든 옵션을 처리하기 위해 인터페이스를 사용해야 한다.`),Oe.forEach(a),d1=r(n),ne=o(n,"P",{});var gO=l(ne);_y=e(gO,`다만 이러한 패턴의 잠재적인 문제점이 존재한다.
concrete type을 반환하는 경우 Heap 할당이 줄어들기에 가비지 콜렉터의 워크로드가 줄어든다.
반면 인터페이스를 파라미터로 사용하는 함수의 경우, 각 인터페이스마다 Heap 할당되므로, 가비지 콜렉터가 힘들어한다.
결국은 더 좋은 성능과 더 좋은 추상화 사이에 trade-off가 존재하는 셈이다.`),gO.forEach(a),E1=r(n),se=o(n,"P",{});var nR=l(se);yy=e(nR,`그렇기 때문에 되도록이면 코드를 예쁘게, 고치기 편하게 작성하는 것이 좋다.
그래야 인터페이스로 인한 잠재적인 성능 문제가 발생하여도, 이를 concrete type으로 변경하는 등의 작업을 하기가 쉬워진다.`),nR.forEach(a),m1=r(n),v1=o(n,"BR",{}),_1=o(n,"BR",{}),y1=r(n),na=o(n,"H3",{id:!0});var aC=l(na);sa=o(aC,"A",{"aria-hidden":!0,tabindex:!0,href:!0});var sR=l(sa);uc=o(sR,"SPAN",{class:!0}),l(uc).forEach(a),sR.forEach(a),by=e(aC,"Interfaces and nil"),aC.forEach(a),b1=r(n),Un=o(n,"P",{});var Re=l(Un);wy=e(Re,"많이 봐왔듯, "),ic=o(Re,"CODE",{});var aR=l(ic);Cy=e(aR,"nil"),aR.forEach(a),Dy=e(Re,`은 포인터의 Zero value이다.
마찬가지로 `),rc=o(Re,"CODE",{});var tR=l(rc);Py=e(tR,"nil"),tR.forEach(a),Oy=e(Re,"은 인터페이스의 Zero value이긴 하지만, Concrete Type들에 비해 간단하지만은 않다."),Re.forEach(a),w1=r(n),et=o(n,"PRE",{class:!0});var _I=l(et);_I.forEach(a),C1=r(n),pt=o(n,"PRE",{class:!0});var yI=l(pt);yI.forEach(a),D1=r(n),jn=o(n,"P",{});var Te=l(jn);Ry=e(Te,`Go의 인터페이스는 내부적으로 두 쌍의 포인터로 구성되며, 각각 타입, 값을 가리킨다.
만약 타입을 가리키는 포인터가 `),kc=o(Te,"CODE",{});var eR=l(kc);Ty=e(eR,"nil"),eR.forEach(a),Sy=e(Te,"이 아니라면, 인터페이스는 "),fc=o(Te,"CODE",{});var pR=l(fc);My=e(pR,"nil"),pR.forEach(a),Iy=e(Te,"이 아닌 것이다. 출력 결과의 세 번째 라인이 저 모양인 것이 이 때문."),Te.forEach(a),P1=r(n),O=o(n,"P",{});var an=l(O);Ly=e(an,"인터페이스에 할당된 concrete type에 따라 호출되는 메소드가 달라지듯, 인터페이스에서 "),dc=o(an,"CODE",{});var oR=l(dc);Hy=e(oR,"nil"),oR.forEach(a),Ay=e(an,`은 메소드를 호출할 수 있는지 여부를 나타낸다.
만약 인터페이스가 `),Ec=o(an,"CODE",{});var lR=l(Ec);Gy=e(lR,"nil"),lR.forEach(a),By=e(an,"임에도 메소드를 호출하였다면, "),mc=o(an,"EM",{});var cR=l(mc);xy=e(cR,"panic"),cR.forEach(a),Ny=e(an,`이 발생한다.
만약 인터페이스가 `),vc=o(an,"CODE",{});var uR=l(vc);Fy=e(uR,"nil"),uR.forEach(a),Wy=e(an,`이 아닌데 메소드를 호출하였다면, 메소드를 호출하려고 시도할 것이다.
(다만 위 예제와 같은 경우 인터페이스에 연결된 값이 `),_c=o(an,"CODE",{});var iR=l(_c);Uy=e(iR,"nil"),iR.forEach(a),jy=e(an,"이기 때문에, 곧바로 "),yc=o(an,"EM",{});var rR=l(yc);zy=e(rR,"panic"),rR.forEach(a),qy=e(an,"이 발생할 것이다.)"),an.forEach(a),O1=r(n),Y=o(n,"P",{});var ls=l(Y);Vy=e(ls,"인터페이스 인스턴스의 타입을 나타내는 포인터가 "),bc=o(ls,"CODE",{});var kR=l(bc);Jy=e(kR,"nil"),kR.forEach(a),Xy=e(ls,"이 아니라면, 이는 "),wc=o(ls,"CODE",{});var fR=l(wc);$y=e(fR,"nil"),fR.forEach(a),Zy=e(ls,`이 아닌 것이다.
그렇다고 해서 이 인터페이스의 값이 `),Cc=o(ls,"CODE",{});var dR=l(Cc);Ky=e(dR,"nil"),dR.forEach(a),Qy=e(ls,"인지는 확실하게 알 수 없기 때문에, 나중에 나올 "),Dc=o(ls,"EM",{});var ER=l(Dc);Yy=e(ER,"Reflection"),ER.forEach(a),hy=e(ls,"을 사용해야 한다."),ls.forEach(a),R1=r(n),T1=o(n,"BR",{}),S1=o(n,"BR",{}),M1=r(n),aa=o(n,"H3",{id:!0});var tC=l(aa);ta=o(tC,"A",{"aria-hidden":!0,tabindex:!0,href:!0});var mR=l(ta);Pc=o(mR,"SPAN",{class:!0}),l(Pc).forEach(a),mR.forEach(a),gy=e(tC,"The Empty Interface Says Nothing"),tC.forEach(a),I1=r(n),ea=o(n,"P",{});var v2=l(ea);n6=e(v2,`정적 타입 언어에서도 아무 타입이나 다 집어넣을 수 있는 변수가 필요할 때가 있다.
그러한 경우, Go에서는 `),Oc=o(v2,"CODE",{});var vR=l(Oc);s6=e(vR,"interface{}"),vR.forEach(a),a6=e(v2,"를 사용할 수 있다."),v2.forEach(a),L1=r(n),ot=o(n,"PRE",{class:!0});var bI=l(ot);bI.forEach(a),H1=r(n),zn=o(n,"P",{});var Se=l(zn);t6=e(Se,`비어 있는 인터페이스는 말 그대로 아무 값이나 다 저장할 수 있다.
인터페이스가 비어 있다는 말은 0개 이상의 메소드가 있는 타입들을 가리킬 수 있다는 뜻이며,
그래서 메소드가 없는 `),Rc=o(Se,"CODE",{});var _R=l(Rc);e6=e(_R,"int"),_R.forEach(a),p6=e(Se,", "),Tc=o(Se,"CODE",{});var yR=l(Tc);o6=e(yR,"string"),yR.forEach(a),l6=e(Se," 등의 Primitive Type들도 저장이 가능해진다."),Se.forEach(a),A1=r(n),G1=o(n,"BR",{}),B1=r(n),ae=o(n,"P",{});var bR=l(ae);c6=e(bR,"비어 있는 인터페이스가 사용되는 예 중 하나는, JSON처럼 외부 소스에서 읽어온 불분명한 스키마의 placeholder로 사용하는 것이다."),bR.forEach(a),x1=r(n),lt=o(n,"PRE",{class:!0});var wI=l(lt);wI.forEach(a),N1=r(n),pa=o(n,"P",{});var _2=l(pa);u6=e(_2,"위 코드를 실행하면 JSON 데이터가 "),Sc=o(_2,"CODE",{});var wR=l(Sc);i6=e(wR,"data"),wR.forEach(a),r6=e(_2," 변수에 저장된다."),_2.forEach(a),F1=r(n),W1=o(n,"BR",{}),U1=r(n),yn=o(n,"P",{});var La=l(yn);k6=e(La,`또 다른 경우에는, 유저가 만든 자료구조에서 다양한 타입의 값을 저장하기 위해 사용된다.
Go의 `),Mc=o(La,"CODE",{});var CR=l(Mc);f6=e(CR,"slice"),CR.forEach(a),d6=e(La,", "),Ic=o(La,"CODE",{});var DR=l(Ic);E6=e(DR,"map"),DR.forEach(a),m6=e(La," 등 타입들은 한 가지 타입밖에 저장하지 못하는데 비해, "),Lc=o(La,"CODE",{});var PR=l(Lc);v6=e(PR,"interface{}"),PR.forEach(a),_6=e(La,"는 여러 타입을 가리킬 수 있기 때문."),La.forEach(a),j1=r(n),ct=o(n,"PRE",{class:!0});var CI=l(ct);CI.forEach(a),z1=r(n),te=o(n,"P",{});var OR=l(te);y6=e(OR,"위 코드는 러프한 예시니까 실제로 사용하지는 말자."),OR.forEach(a),q1=r(n),bn=o(n,"P",{});var Ha=l(bn);b6=e(Ha,"또 다른 사용예로는 함수의 파라미터로 "),Hc=o(Ha,"CODE",{});var RR=l(Hc);w6=e(RR,"interface{}"),RR.forEach(a),C6=e(Ha,"를 받는 경우인데, "),Ac=o(Ha,"EM",{});var TR=l(Ac);D6=e(TR,"reflection"),TR.forEach(a),P6=e(Ha,`을 하기 위해 사용한다고 하는 것 같다.
`),Gc=o(Ha,"EM",{});var SR=l(Gc);O6=e(SR,"reflection"),SR.forEach(a),R6=e(Ha,"은 나중에 나온다!"),Ha.forEach(a),V1=r(n),J1=o(n,"BR",{}),X1=r(n),H=o(n,"P",{});var Dn=l(H);T6=e(Dn,"근데 "),Bc=o(Dn,"CODE",{});var MR=l(Bc);S6=e(MR,"interface{}"),MR.forEach(a),M6=e(Dn,`를 되도록이면 사용하지 않는 게 좋다.
Go는 기본적으로 정적 타입 언어로 디자인된 언어인 만큼, `),xc=o(Dn,"CODE",{});var IR=l(xc);I6=e(IR,"interface{}"),IR.forEach(a),L6=e(Dn,`로 여러 타입들을 쑤시고 다니는 건 좋지 않다.
`),Nc=o(Dn,"CODE",{});var LR=l(Nc);H6=e(LR,"interface{}"),LR.forEach(a),A6=e(Dn,`를 사용하여 값들을 저장해야 할 상황에서, 값을 다시 읽어오려면 어떻게 해야 할까?
그럴 때 바로 아래에서 설명할 `),Fc=o(Dn,"EM",{});var HR=l(Fc);G6=e(HR,"Type Assertions"),HR.forEach(a),B6=e(Dn," 및 "),Wc=o(Dn,"EM",{});var AR=l(Wc);x6=e(AR,"Type Switches"),AR.forEach(a),N6=e(Dn,"를 사용해 보자."),Dn.forEach(a),$1=r(n),Z1=o(n,"BR",{}),K1=o(n,"BR",{}),Q1=r(n),oa=o(n,"H3",{id:!0});var eC=l(oa);la=o(eC,"A",{"aria-hidden":!0,tabindex:!0,href:!0});var GR=l(la);Uc=o(GR,"SPAN",{class:!0}),l(Uc).forEach(a),GR.forEach(a),F6=e(eC,"Type Assertions and Type Switches"),eC.forEach(a),Y1=r(n),ee=o(n,"P",{});var BR=l(ee);W6=e(BR,`Go에는 어떤 변수의 인터페이스가 가리키는 타입이 특정한 Concrete Type인지,
혹은 Concrete Type이 또 다른 인터페이스를 구현하는지 확인할 수 있는 두 가지 방법이 있다.`),BR.forEach(a),h1=r(n),ca=o(n,"P",{});var y2=l(ca);U6=e(y2,"한 가지가 바로 "),jc=o(y2,"STRONG",{});var xR=l(jc);j6=e(xR,"Type Assertion"),xR.forEach(a),z6=e(y2,`이다.
이는 어떤 인터페이스를 구현하는 Concrete Type에 이름을 붙이거나,
또는 이 인터페이스를 구현하고 있는 Concrete Type이 구현하는 또 다른 인터페이스에 이름을 붙인다.`),y2.forEach(a),g1=r(n),ut=o(n,"PRE",{class:!0});var DI=l(ut);DI.forEach(a),nd=r(n),A=o(n,"P",{});var Pn=l(A);q6=e(Pn,"이렇게 "),zc=o(Pn,"EM",{});var NR=l(zc);V6=e(NR,"Type Assertion"),NR.forEach(a),J6=e(Pn,"을 사용하여 "),qc=o(Pn,"CODE",{});var FR=l(qc);X6=e(FR,"i"),FR.forEach(a),$6=e(Pn,"가 가리키고 있는 타입을 "),Vc=o(Pn,"CODE",{});var WR=l(Vc);Z6=e(WR,"MyInt"),WR.forEach(a),K6=e(Pn,`로 한정할 수 있다.
위 예제에서 변수 `),Jc=o(Pn,"CODE",{});var UR=l(Jc);Q6=e(UR,"i2"),UR.forEach(a),Y6=e(Pn,"의 타입은 "),Xc=o(Pn,"CODE",{});var jR=l(Xc);h6=e(jR,"MyInt"),jR.forEach(a),g6=e(Pn,"가 된다."),Pn.forEach(a),sd=r(n),ad=o(n,"BR",{}),td=r(n),qn=o(n,"P",{});var Me=l(qn);n7=e(Me,"만약 잘못된 타입으로 "),$c=o(Me,"EM",{});var zR=l($c);s7=e(zR,"Type Assertion"),zR.forEach(a),a7=e(Me,"을 하면 "),Zc=o(Me,"EM",{});var qR=l(Zc);t7=e(qR,"panic"),qR.forEach(a),e7=e(Me,"이 발생한다."),Me.forEach(a),ed=r(n),it=o(n,"PRE",{class:!0});var PI=l(it);PI.forEach(a),pd=r(n),od=o(n,"BR",{}),ld=r(n),cn=o(n,"P",{});var Cs=l(cn);Kc=o(Cs,"CODE",{});var VR=l(Kc);p7=e(VR,"int"),VR.forEach(a),o7=e(Cs,"와 "),Qc=o(Cs,"CODE",{});var JR=l(Qc);l7=e(JR,"MyInt"),JR.forEach(a),c7=e(Cs,"는 본질적으론 같은 타입이지만, Go는 타입에 엄격하기 때문에 "),Yc=o(Cs,"EM",{});var XR=l(Yc);u7=e(XR,"Type Assertion"),XR.forEach(a),i7=e(Cs,`을 사용할 때 Concrete Type끼리 일치시켜주어야 한다.
따라서 아래와 같은 예제는 `),hc=o(Cs,"EM",{});var $R=l(hc);r7=e($R,"panic"),$R.forEach(a),k7=e(Cs,"이 발생한다."),Cs.forEach(a),cd=r(n),rt=o(n,"PRE",{class:!0});var OI=l(rt);OI.forEach(a),ud=r(n),id=o(n,"BR",{}),rd=r(n),ms=o(n,"P",{});var nr=l(ms);gc=o(nr,"CODE",{});var ZR=l(gc);f7=e(ZR,"map"),ZR.forEach(a),d7=e(nr,"을 사용할 때 보았던 "),nu=o(nr,"EM",{});var KR=l(nu);E7=e(KR,"comma ok idiom"),KR.forEach(a),m7=e(nr,"을 사용하여 panic을 회피할 수 있다."),nr.forEach(a),kd=r(n),kt=o(n,"PRE",{class:!0});var RI=l(kt);RI.forEach(a),fd=r(n),w=o(n,"P",{});var z=l(w);su=o(z,"CODE",{});var QR=l(su);v7=e(QR,"map"),QR.forEach(a),_7=e(z,`에서 봤던 패턴과 유사하다.
`),au=o(z,"EM",{});var YR=l(au);y7=e(YR,"Type Assertion"),YR.forEach(a),b7=e(z,"에 성공하면 변수 "),tu=o(z,"CODE",{});var hR=l(tu);w7=e(hR,"ok"),hR.forEach(a),C7=e(z,"는 "),eu=o(z,"CODE",{});var gR=l(eu);D7=e(gR,"true"),gR.forEach(a),P7=e(z,"가 되며, 나머지 변수는 인터페이스가 가리키는 값으로 초기화된다."),O7=o(z,"BR",{}),R7=e(z,`
반면 실패하면 `),pu=o(z,"CODE",{});var nT=l(pu);T7=e(nT,"ok"),nT.forEach(a),S7=e(z,"는 "),ou=o(z,"CODE",{});var sT=l(ou);M7=e(sT,"false"),sT.forEach(a),I7=e(z,"가 되며, 나머지 변수는 해당 타입의 Zero value로 초기화된다."),z.forEach(a),dd=r(n),Vn=o(n,"P",{});var Ie=l(Vn);L7=e(Ie,"그렇게 얻은 "),lu=o(Ie,"CODE",{});var aT=l(lu);H7=e(aT,"ok"),aT.forEach(a),A7=e(Ie," 변수값을 통해 이를 "),cu=o(Ie,"CODE",{});var tT=l(cu);G7=e(tT,"if"),tT.forEach(a),B7=e(Ie,`문으로 처리할 수는 있지만
Go에서는 에러 핸들링을 통해 처리하는 것을 더 지향한다는 것 같다. 에러 핸들링은 다음 챕터에서 나온다!`),Ie.forEach(a),Ed=r(n),ua=o(n,"P",{});var b2=l(ua);x7=e(b2,"어찌 됐든, 인터페이스가 가리키고 있는 데이터의 타입이 확실하다고 생각해도 되도록이면 "),uu=o(b2,"EM",{});var eT=l(uu);N7=e(eT,"comma ok idiom"),eT.forEach(a),F7=e(b2,`를 쓰는 것이 좋다.
다른 사람이나 미래의 내가 언제 이 코드를 다시 사용할 지도 모르는 일이며, 코드를 조금 수정했는데 런타임 에러가 날 수도 있으니 말이다.`),b2.forEach(a),md=r(n),vd=o(n,"BR",{}),_d=o(n,"BR",{}),yd=r(n),ia=o(n,"P",{});var w2=l(ia);W7=e(w2,"어느 인터페이스의 타입에 여러 개의 후보군이 있다면, "),iu=o(w2,"EM",{});var pT=l(iu);U7=e(pT,"Type Switch"),pT.forEach(a),j7=e(w2,"를 써보도록 하자."),w2.forEach(a),bd=r(n),ft=o(n,"PRE",{class:!0});var TI=l(ft);TI.forEach(a),wd=r(n),dt=o(n,"PRE",{class:!0});var SI=l(dt);SI.forEach(a),Cd=r(n),Jn=o(n,"P",{});var Le=l(Jn);z7=e(Le,"기본적으로 형태는 boolean 표현식이 사용되지 않는 일반적인 "),ru=o(Le,"CODE",{});var oT=l(ru);q7=e(oT,"switch"),oT.forEach(a),V7=e(Le,`문의 형태와 유사하다.
다만 switch문 이후에 `),ku=o(Le,"CODE",{});var lT=l(ku);J7=e(lT,"i.(type)"),lT.forEach(a),X7=e(Le,`로, 인터페이스의 타입을 나타내어 주면 된다.
이렇게 각 case문에 타입을 할당함으로써, 인터페이스의 타입에 따라 처리할 수 있다.`),Le.forEach(a),Dd=r(n),_=o(n,"P",{});var x=l(_);$7=e(x,`실행 결과를 보면 대충 알 수 있겠지만, 3번째 줄의 경우 주의해야 할 것 같다.
변수 `),fu=o(x,"CODE",{});var cT=l(fu);Z7=e(cT,"c"),cT.forEach(a),K7=e(x,"는 값이 "),du=o(x,"CODE",{});var uT=l(du);Q7=e(uT,"nil"),uT.forEach(a),Y7=e(x,"인 것이지, 타입은 "),Eu=o(x,"CODE",{});var iT=l(Eu);h7=e(iT,"nil"),iT.forEach(a),g7=e(x,"이 아니라 "),mu=o(x,"CODE",{});var rT=l(mu);n8=e(rT,"*string"),rT.forEach(a),s8=e(x,`이다.
실제로 `),vu=o(x,"CODE",{});var kT=l(vu);a8=e(kT,"switch"),kT.forEach(a),t8=e(x,"문에서 "),_u=o(x,"CODE",{});var fT=l(_u);e8=e(fT,"case nil"),fT.forEach(a),p8=e(x,"에 걸리는 경우는, 변수 "),yu=o(x,"CODE",{});var dT=l(yu);o8=e(dT,"f"),dT.forEach(a),l8=e(x,"처럼 인터페이스가 가리키는 대상이 아무 것도 없을 때이다."),x.forEach(a),Pd=r(n),ra=o(n,"P",{});var C2=l(ra);c8=e(C2,"인터페이스가 가리키는 타입에 대해 전혀 모를 경우, "),bu=o(C2,"EM",{});var ET=l(bu);u8=e(ET,"reflection"),ET.forEach(a),i8=e(C2,`을 사용하면 된다고 한다.
나중에 나온다. 나중에…`),C2.forEach(a),Od=r(n),un=o(n,"P",{});var Ds=l(un);wu=o(Ds,"EM",{});var mT=l(wu);r8=e(mT,"Type Assertion"),mT.forEach(a),k8=e(Ds,"과 "),Cu=o(Ds,"EM",{});var vT=l(Cu);f8=e(vT,"Type Switch"),vT.forEach(a),d8=e(Ds,`가 꽤나 유용한 기술처럼 보이는데, 자주 사용하면 안된다고 한다.
웬만하면 함수의 파라미터나 리턴값은 특정한 몇 가지의 타입으로만 지정하는 것이 좋으며, 나머지 다른 타입들은 가능은 하더라도 안되게 해야 한다.
그렇지 않으면 우리가 짜는 함수가 어떤 타입들을 지원하는지에 대해 정확히 명시하지 못할 수 있다.
대충 `),Du=o(Ds,"CODE",{});var _T=l(Du);E8=e(_T,"interface{}"),_T.forEach(a),m8=e(Ds,"를 사용하는 걸 지양하라는 말과 일맥상통하는 것 같다. "),Pu=o(Ds,"CODE",{});var yT=l(Pu);v8=e(yT,"interface{}"),yT.forEach(a),_8=e(Ds,"를 안 쓰면 특정한 타입을 명시할 수밖에 없을 테니 말이다."),Ds.forEach(a),Rd=r(n),Td=o(n,"BR",{}),Sd=r(n),vs=o(n,"P",{});var sr=l(vs);Ou=o(sr,"EM",{});var bT=l(Ou);y8=e(bT,"Type Assertion"),bT.forEach(a),b8=e(sr,"과 "),Ru=o(sr,"EM",{});var wT=l(Ru);w8=e(wT,"Type Switch"),wT.forEach(a),C8=e(sr,"가 유용하게 사용되는 예제에 대해 알아보자."),sr.forEach(a),Md=r(n),G=o(n,"P",{});var On=l(G);D8=e(On,`가장 일반적인 경우, 한 인터페이스가 가리키고 있는 concrete type을 보기 위해 사용되는데,
이 concrete type은 다른 인터페이스에서도 가리킬 수 있는 경우이다.
이를테면 `),Tu=o(On,"CODE",{});var CT=l(Tu);P8=e(CT,"io"),CT.forEach(a),O8=e(On," 라이브러리의 "),Su=o(On,"CODE",{});var DT=l(Su);R8=e(DT,"io.File"),DT.forEach(a),T8=e(On," 등 여러 타입들은 "),Mu=o(On,"CODE",{});var PT=l(Mu);S8=e(PT,"io.Reader"),PT.forEach(a),M8=e(On,"와 "),Iu=o(On,"CODE",{});var OT=l(Iu);I8=e(OT,"io.Writer"),OT.forEach(a),L8=e(On,` 두 가지 인터페이스를 모두 만족시킨다.
그 때 `),Lu=o(On,"CODE",{});var RT=l(Lu);H8=e(RT,"io.Reader"),RT.forEach(a),A8=e(On,"가 가리키고 있는 타입이 어떤 타입인지 확인하기 위해 사용할 수 있을 것이다."),On.forEach(a),Id=r(n),m=o(n,"P",{});var M=l(m);Hu=o(M,"CODE",{});var TT=l(Hu);G8=e(TT,"io.Copy()"),TT.forEach(a),B8=e(M," 함수는 "),Au=o(M,"CODE",{});var ST=l(Au);x8=e(ST,"io.Reader"),ST.forEach(a),N8=e(M,"와 "),Gu=o(M,"CODE",{});var MT=l(Gu);F8=e(MT,"io.Writer"),MT.forEach(a),W8=e(M," 인터페이스들을 파라미터로 받아, "),Bu=o(M,"CODE",{});var IT=l(Bu);U8=e(IT,"io.copyBuffer()"),IT.forEach(a),j8=e(M,`함수를 실행한다.
다만 이때 `),xu=o(M,"CODE",{});var LT=l(xu);z8=e(LT,"io.Reader"),LT.forEach(a),q8=e(M,"의 파라미터가 "),Nu=o(M,"CODE",{});var HT=l(Nu);V8=e(HT,"io.ReaderFrom"),HT.forEach(a),J8=e(M,"에서도 사용할 수 있거나, "),Fu=o(M,"CODE",{});var AT=l(Fu);X8=e(AT,"io.Writer"),AT.forEach(a),$8=e(M,"의 파라미터가 "),Wu=o(M,"CODE",{});var GT=l(Wu);Z8=e(GT,"io.WriterTo"),GT.forEach(a),K8=e(M,`에서도 사용할 수 있다면,
함수 내용 대부분이 생략될 수 있다.`),M.forEach(a),Ld=r(n),Et=o(n,"PRE",{class:!0});var MI=l(Et);MI.forEach(a),Hd=r(n),Ad=o(n,"BR",{}),Gd=r(n),Xn=o(n,"P",{});var He=l(Xn);Q8=e(He,`인터페이스는 API를 업그레이드할때도 사용된다고 한다.
챕터 12에서 `),Uu=o(He,"EM",{});var BT=l(Uu);Y8=e(BT,"context"),BT.forEach(a),h8=e(He,"에 대해 알아볼 텐데, "),ju=o(He,"EM",{});var xT=l(ju);g8=e(xT,"context"),xT.forEach(a),n9=e(He,`란 취소를 관리하는 표준적인 방법을 제시하는 파라미터이다.
Go 버전 1.7부터 생긴 기능인지라, 이전 버전의 데이터베이스 드라이버 등에서는 지원하지 않는다.`),He.forEach(a),Bd=r(n),R=o(n,"P",{});var tn=l(R);s9=e(tn,"Go 1.8부터는 "),zu=o(tn,"CODE",{});var NT=l(zu);a9=e(NT,"database/sql/driver"),NT.forEach(a),t9=e(tn,` 패키지에 기존에 존재하는 인터페이스에 대한 새로운 컨텍스트 인식 유사체가 정의되었다.
이를테면 `),qu=o(tn,"CODE",{});var FT=l(qu);e9=e(FT,"StmtExecContext"),FT.forEach(a),p9=e(tn," 인터페이스에는 "),Vu=o(tn,"CODE",{});var WT=l(Vu);o9=e(WT,"ExecContext"),WT.forEach(a),l9=e(tn,`라는 메소드가 있다.
스탠다드 라이브러리 데이터베이스 코드에 `),Ju=o(tn,"CODE",{});var UT=l(Ju);c9=e(UT,"Stmt"),UT.forEach(a),u9=e(tn,` 인터페이스의 타입이 통과될 경우,
이 타입이 `),Xu=o(tn,"CODE",{});var jT=l(Xu);i9=e(jT,"StmtExecContext"),jT.forEach(a),r9=e(tn,"에도 사용할 수 있는지 확인한다. 만약 그렇다면 "),$u=o(tn,"CODE",{});var zT=l($u);k9=e(zT,"ExecContext"),zT.forEach(a),f9=e(tn,`를 호출한다.
만약 그렇지 않다면, fallback code를 실행한다.`),tn.forEach(a),xd=r(n),mt=o(n,"PRE",{class:!0});var II=l(mt);II.forEach(a),Nd=r(n),Fd=o(n,"BR",{}),Wd=r(n),$n=o(n,"P",{});var Ae=l($n);d9=e(Ae,`이런 optional interface 기능에는 한 가지 단점이 존재한다.
한 인터페이스로 여러 가지 타입을 사용하여 계층적 구조를 만드는 decorator 패턴을 사용하기 위해 인터페이스가 많이들 사용된다.
이 때, 어느 optional interface가 이 타입들 중 한 가지라도 사용할 수 있다면, `),Zu=o(Ae,"EM",{});var qT=l(Zu);E9=e(qT,"Type Assertion"),qT.forEach(a),m9=e(Ae,"과 "),Ku=o(Ae,"EM",{});var VT=l(Ku);v9=e(VT,"Type Switch"),VT.forEach(a),_9=e(Ae,"으로 이를 감지할 수 없다."),Ae.forEach(a),Ud=r(n),T=o(n,"P",{});var en=l(T);y9=e(en,"그 예로 "),Qu=o(en,"CODE",{});var JT=l(Qu);b9=e(JT,"bufio"),JT.forEach(a),w9=e(en,`라는 표준 라이브러리는 buffered reader를 제공한다.
이 때 `),Yu=o(en,"CODE",{});var XT=l(Yu);C9=e(XT,"bufio.NewReader()"),XT.forEach(a),D9=e(en," 함수에 "),hu=o(en,"CODE",{});var $T=l(hu);P9=e($T,"io.Reader"),$T.forEach(a),O9=e(en,"를 지원하는 타입을 파라미터로 통과시키면, "),gu=o(en,"CODE",{});var ZT=l(gu);R9=e(ZT,"*bufio.Reader"),ZT.forEach(a),T9=e(en,`를 리턴받는다.
만약 파라미터로 넘겨진 `),ni=o(en,"CODE",{});var KT=l(ni);S9=e(KT,"io.Reader"),KT.forEach(a),M9=e(en,"의 타입이 "),si=o(en,"CODE",{});var QT=l(si);I9=e(QT,"io.ReaderFrom"),QT.forEach(a),L9=e(en,"도 지원하는 경우, 이를 buffered reader로 감싸게 되면 최적화가 되지 않는다."),en.forEach(a),jd=r(n),h=o(n,"P",{});var cs=l(h);H9=e(cs,`에러 핸들링 할때도 본 현상인데, 에러는 다른 에러를 감싸는 것을 통해 추가적인 정보를 포함할 수 있다.
`),ai=o(cs,"EM",{});var YT=l(ai);A9=e(YT,"Type Assertion"),YT.forEach(a),G9=e(cs,"과 "),ti=o(cs,"EM",{});var hT=l(ti);B9=e(hT,"Type Switch"),hT.forEach(a),x9=e(cs,`로는 감싸진 에러를 확인할 수 없기 때문에,
제대로 핸들링하기 위해 감싸진 에러에 접근하려면 `),ei=o(cs,"CODE",{});var gT=l(ei);N9=e(gT,"errors.Is()"),gT.forEach(a),F9=e(cs,"나 "),pi=o(cs,"CODE",{});var nS=l(pi);W9=e(nS,"errors.As()"),nS.forEach(a),U9=e(cs,"같은 함수를 사용해야 한다."),cs.forEach(a),zd=r(n),qd=o(n,"BR",{}),Vd=r(n),vt=o(n,"P",{});var pC=l(vt);oi=o(pC,"EM",{});var sS=l(oi);j9=e(sS,"Type Switch"),sS.forEach(a),z9=e(pC,`는 인터페이스를 지원하는 타입들이 여러 개 있고, 각 타입마다 다르게 처리해줘야 하는 경우 유용하다.
그중 가장 유용한 경우는, 유효한 타입이 딱 한 개만 존재하는 경우이다.`),pC.forEach(a),Jd=r(n),g=o(n,"P",{});var us=l(g);q9=e(us,"웬만하면 "),li=o(us,"CODE",{});var aS=l(li);V9=e(aS,"switch"),aS.forEach(a),J9=e(us,"문에 "),ci=o(us,"CODE",{});var tS=l(ci);X9=e(tS,"default"),tS.forEach(a),$9=e(us,`를 반드시 넣어주는 게 좋다.
인터페이스를 지원하는 타입을 추가했는데 `),ui=o(us,"CODE",{});var eS=l(ui);Z9=e(eS,"switch"),eS.forEach(a),K9=e(us,"문을 업데이트하는 것을 까먹은 경우 "),ii=o(us,"CODE",{});var pS=l(ii);Q9=e(pS,"default"),pS.forEach(a),Y9=e(us," 블록에 걸리므로, 문제를 추적하기 쉬워질 것이다."),us.forEach(a),Xd=r(n),$d=o(n,"BR",{}),Zd=o(n,"BR",{}),Kd=r(n),ka=o(n,"H3",{id:!0});var oC=l(ka);fa=o(oC,"A",{"aria-hidden":!0,tabindex:!0,href:!0});var oS=l(fa);ri=o(oS,"SPAN",{class:!0}),l(ri).forEach(a),oS.forEach(a),h9=e(oC,"Function Types Are a Bridge to Interfaces"),oC.forEach(a),Qd=r(n),pe=o(n,"P",{});var lS=l(pe);g9=e(lS,"Go에서는 함수를 비롯하여 유저가 정의한 타입이라면 어떠한 타입이든 메소드를 추가할 수 있으며, 이는 굉장히 유용하다."),lS.forEach(a),Yd=r(n),oe=o(n,"P",{});var cS=l(oe);nb=e(cS,"가장 일반적인 사례는 HTTP 요청을 처리하는 HTTP 핸들러이다. 이는 아래와 같이 인터페이스로 정의되어 있다."),cS.forEach(a),hd=r(n),_t=o(n,"PRE",{class:!0});var LI=l(_t);LI.forEach(a),gd=r(n),F=o(n,"P",{});var In=l(F);ki=o(In,"CODE",{});var uS=l(ki);sb=e(uS,"http.ResponseWriter"),uS.forEach(a),ab=e(In,", "),fi=o(In,"CODE",{});var iS=l(fi);tb=e(iS,"*http.Request"),iS.forEach(a),eb=e(In,"를 파라미터로 받는 함수들은 "),di=o(In,"CODE",{});var rS=l(di);pb=e(rS,"HandlerFunc"),rS.forEach(a),ob=e(In,`로 타입 변환을 할 수 있다.
그러면 `),Ei=o(In,"CODE",{});var kS=l(Ei);lb=e(kS,"ServeHTTP()"),kS.forEach(a),cb=e(In,"를 호출할 수 있게 되며, "),mi=o(In,"CODE",{});var fS=l(mi);ub=e(fS,"http.Handler"),fS.forEach(a),ib=e(In," 인터페이스를 사용할 수 있게 된다."),In.forEach(a),nE=r(n),yt=o(n,"PRE",{class:!0});var HI=l(yt);HI.forEach(a),sE=r(n),da=o(n,"P",{});var D2=l(da);rb=e(D2,"이러한 방식을 통해 "),vi=o(D2,"CODE",{});var dS=l(vi);kb=e(dS,"http.Handler"),dS.forEach(a),fb=e(D2,"의 인터페이스를 충족시키기만 하면 함수, 메소드, Closure를 HTTP 핸들러로 사용할 수 있다."),D2.forEach(a),aE=r(n),tE=o(n,"BR",{}),eE=r(n),le=o(n,"P",{});var ES=l(le);db=e(ES,`Go에서 함수는 가장 중요한 개념인 만큼, 또 다른 함수의 파라미터로 전달된다.
한편으로, Go에서는 작은 인터페이스를 권장하며, 메소드가 하나 뿐인 인터페이스는 함수의 파라미터로 전달되는 함수를 대체할 수 있다.
그렇다면 이런 질문이 생길 수 있다. 파라미터인 함수의 타입을 언제 명시해줘야 하며, 언제 인터페이스를 써야 할까?`),ES.forEach(a),pE=r(n),Zn=o(n,"P",{});var Ge=l(Zn);Eb=e(Ge,`만약 함수가 다른 함수들이나, 파라미터가 아닌 state에 의존한다면,
인터페이스 파라미터를 사용하고 인터페이스에 대한 bridge로써 함수 타입을 정의하는 것이 좋다고 한다.
이를테면 이는 `),_i=o(Ge,"CODE",{});var mS=l(_i);mb=e(mS,"http"),mS.forEach(a),vb=e(Ge,` 패키지에서 사용하는 방식이다. http 핸들러는 설정해주어야 하는 연쇄적인 함수 호출의 진입점일 가능성이 높다.
반면 함수가 `),yi=o(Ge,"CODE",{});var vS=l(yi);_b=e(vS,"sort.Slice()"),vS.forEach(a),yb=e(Ge,"처럼 간단한 함수일 경우, 인터페이스보단 그냥 함수를 넘기는 게 좋다고 한다."),Ge.forEach(a),oE=r(n),lE=o(n,"BR",{}),cE=o(n,"BR",{}),uE=r(n),Ea=o(n,"H3",{id:!0});var lC=l(Ea);ma=o(lC,"A",{"aria-hidden":!0,tabindex:!0,href:!0});var _S=l(ma);bi=o(_S,"SPAN",{class:!0}),l(bi).forEach(a),_S.forEach(a),bb=e(lC,"Implicit Interfaces Make Dependency Injection Easier"),lC.forEach(a),iE=r(n),bt=o(n,"P",{});var cC=l(bt);wi=o(cC,"STRONG",{});var yS=l(wi);wb=e(yS,"Dependency Injection"),yS.forEach(a),Cb=e(cC,`이란 코드가 수행하는 기능과 작업을 분명하게 명시해야 한다는 개념이다.
Go의 인터페이스는 디커플링을 맛깔나게 잘 해줘서 Dependency Injection이 엄청 잘 된다고 한다.
그래서 다른 언어에서 Dependency Injection를 위해 복잡한 프레임워크를 사용하는 반면,
Go는 어떠한 외부 라이브러리도 사용하지 않는다.`),cC.forEach(a),rE=r(n),ce=o(n,"P",{});var bS=l(ce);Db=e(bS,"Dependency Injection이 어떻게 이루어지는지 보기 위해, 간단한 웹 서버 예제를 만들어보자."),bS.forEach(a),kE=r(n),wt=o(n,"PRE",{class:!0});var AI=l(wt);AI.forEach(a),fE=r(n),va=o(n,"P",{});var P2=l(va);Pb=e(P2,`간단한 로깅 함수와 저장을 위한 데이터 타입, 및 데이터 탐색 메소드를 정의하였다.
`),Ci=o(P2,"CODE",{});var wS=l(Ci);Ob=e(wS,"SimpleDataStore"),wS.forEach(a),Rb=e(P2," 인스턴스를 생성하는 factory function을 정의해보자."),P2.forEach(a),dE=r(n),Ct=o(n,"PRE",{class:!0});var GI=l(Ct);GI.forEach(a),EE=r(n),mE=o(n,"BR",{}),vE=r(n),Kn=o(n,"P",{});var Be=l(Kn);Tb=e(Be,`이제 유저에게 “hello” 또는 “good bye”라고 날리는 로직을 작성해 볼 것이다.
이 로직은 유저에게 접근해야 하므로 접근 대상이 되는 자료구조와, 로깅을 하는 함수에 대한 의존성이 존재한다.
하지만 우리는 `),Di=o(Be,"CODE",{});var CS=l(Di);Sb=e(CS,"LogOutput()"),CS.forEach(a),Mb=e(Be,"이나 "),Pi=o(Be,"CODE",{});var DS=l(Pi);Ib=e(DS,"SimpleDataStore"),DS.forEach(a),Lb=e(Be,`에 대한 직접적인 의존성을 만들고 싶지 않다.
미래에 다른 자료구조나 로깅 함수를 사용할 수도 있기 때문이다.`),Be.forEach(a),_E=r(n),ue=o(n,"P",{});var PS=l(ue);Hb=e(PS,"바로 이러한 경우, 인터페이스가 적절한 해법이 된다."),PS.forEach(a),yE=r(n),Dt=o(n,"PRE",{class:!0});var BI=l(Dt);BI.forEach(a),bE=r(n),Tn=o(n,"P",{});var Lt=l(Tn);Oi=o(Lt,"CODE",{});var OS=l(Oi);Ab=e(OS,"LoggerAdapter"),OS.forEach(a),Gb=e(Lt,"를 선언해 "),Ri=o(Lt,"CODE",{});var RS=l(Ri);Bb=e(RS,"LogOutput()"),RS.forEach(a),xb=e(Lt,"함수를 "),Ti=o(Lt,"CODE",{});var TS=l(Ti);Nb=e(TS,"Logger"),TS.forEach(a),Fb=e(Lt,`에 연결해 주었다.
이제 우리의 비즈니스 로직은 인터페이스들을 사용하여 자료구조에 접근하고, 로깅을 할 수 있다.`),Lt.forEach(a),wE=r(n),ie=o(n,"P",{});var SS=l(ie);Wb=e(SS,"의존성이 정의되었으니, 비즈니스 로직을 완성해보자."),SS.forEach(a),CE=r(n),Pt=o(n,"PRE",{class:!0});var xI=l(Pt);xI.forEach(a),DE=r(n),W=o(n,"P",{});var Ln=l(W);Si=o(Ln,"CODE",{});var MS=l(Si);Ub=e(MS,"Logger"),MS.forEach(a),jb=e(Ln,"와 "),Mi=o(Ln,"CODE",{});var IS=l(Mi);zb=e(IS,"DataStore"),IS.forEach(a),qb=e(Ln,"를 필드로 갖는 "),Ii=o(Ln,"CODE",{});var LS=l(Ii);Vb=e(LS,"SimpleLogic"),LS.forEach(a),Jb=e(Ln,"이라는 "),Li=o(Ln,"CODE",{});var HS=l(Li);Xb=e(HS,"struct"),HS.forEach(a),$b=e(Ln,`와, factory function을 정의해주었다.
이 `),Hi=o(Ln,"CODE",{});var AS=l(Hi);Zb=e(AS,"SimpleLogic"),AS.forEach(a),Kb=e(Ln,` 내의 메소드는 다른 concrete type을 레퍼런스하지 않기 때문에, 의존성이 없다.
그래서 차후 라이브러리를 교체하더라도 인터페이스는 라이브러리와 관련이 없기 때문에 문제가 발생하지 않는다.`),Ln.forEach(a),PE=r(n),OE=o(n,"BR",{}),RE=r(n),Qn=o(n,"P",{});var xe=l(Qn);Qb=e(xe,"이제 "),Ai=o(xe,"CODE",{});var GS=l(Ai);Yb=e(GS,"/hello"),GS.forEach(a),hb=e(xe,`라는 엔드포인트를 정의해볼 것이다. 이 엔드포인트에서는 유저의 ID가 같이 오면 인사를 할 것이다.
`),Gi=o(xe,"EM",{});var BS=l(Gi);gb=e(BS,"Controller"),BS.forEach(a),nw=e(xe,"에게 인사를 할 로직을 쥐어주기 위해 인터페이스를 만들어주자."),xe.forEach(a),TE=r(n),Ot=o(n,"PRE",{class:!0});var NI=l(Ot);NI.forEach(a),SE=r(n),Yn=o(n,"P",{});var Ne=l(Yn);sw=e(Ne,"이 인터페이스는 "),Bi=o(Ne,"CODE",{});var xS=l(Bi);aw=e(xS,"SimpleLogic"),xS.forEach(a),tw=e(Ne,`을 가리킬 수 있다.
인터페이스는 클라이언트 코드에서 정의되기 때문에, 수정이 필요하다면 클라이언트 코드에서 수정하면 그만이다.
따라서 `),xi=o(Ne,"CODE",{});var NS=l(xi);ew=e(NS,"SimpleLogic"),NS.forEach(a),pw=e(Ne,"이 나중에 변경되거나, 혹은 새로운 로직이 추가되더라도 별다른 문제 없이 사용할 수 있다."),Ne.forEach(a),ME=r(n),Rt=o(n,"PRE",{class:!0});var FI=l(Rt);FI.forEach(a),IE=r(n),LE=o(n,"BR",{}),HE=r(n),_a=o(n,"P",{});var O2=l(_a);ow=e(O2,"마지막으로, "),Ni=o(O2,"CODE",{});var FS=l(Ni);lw=e(FS,"main"),FS.forEach(a),cw=e(O2," 함수에서 모든 컴포넌트를 연결하고 서버를 열어보자."),O2.forEach(a),AE=r(n),Tt=o(n,"PRE",{class:!0});var WI=l(Tt);WI.forEach(a),GE=r(n),hn=o(n,"P",{});var Fe=l(hn);uw=e(Fe,"파일을 실행하여 서버를 연 뒤, 브라우저에서 "),Fi=o(Fe,"CODE",{});var WS=l(Fi);iw=e(WS,"http://localhost:8080/hello?user_id=1"),WS.forEach(a),rw=e(Fe," 및 "),Wi=o(Fe,"CODE",{});var US=l(Wi);kw=e(US,"http://localhost:8080/hello?user_id=5"),US.forEach(a),fw=e(Fe," 등으로 접속해보자."),Fe.forEach(a),BE=r(n),S=o(n,"P",{});var rn=l(S);Ui=o(rn,"CODE",{});var jS=l(Ui);dw=e(jS,'http.HandleFunc("/hello", c.SayHello)'),jS.forEach(a),Ew=e(rn," 라인을 잘 살펴보면, 두 번째 "),ji=o(rn,"CODE",{});var zS=l(ji);mw=e(zS,"http.HandleFunc()"),zS.forEach(a),vw=e(rn,"의 두 번째 파라미터로 "),zi=o(rn,"CODE",{});var qS=l(zi);_w=e(qS,"c.SayHello()"),qS.forEach(a),yw=e(rn,` 메소드를 보냈다.
이때 보내진 메소드는 `),qi=o(rn,"CODE",{});var VS=l(qi);bw=e(VS,"http.Handler"),VS.forEach(a),ww=e(rn," 인터페이스를 충족시키는 "),Vi=o(rn,"CODE",{});var JS=l(Vi);Cw=e(JS,"http.HandlerFunc"),JS.forEach(a),Dw=e(rn,` 타입으로 변환이 된다.
`),Ji=o(rn,"CODE",{});var XS=l(Ji);Pw=e(XS,"NewController"),XS.forEach(a),Ow=e(rn,"의 메소드임을 유지한 채로 말이다."),rn.forEach(a),xE=r(n),_s=o(n,"P",{});var ar=l(_s);Xi=o(ar,"CODE",{});var $S=l(Xi);Rw=e($S,"main"),$S.forEach(a),Tw=e(ar,` 함수는 concrete type들이 실제로 선언되는 유일한 영역이다.
어느 타입 하나를 다른 타입으로 변경하고 싶다면, `),$i=o(ar,"CODE",{});var ZS=l($i);Sw=e(ZS,"main"),ZS.forEach(a),Mw=e(ar,`에서만 변경해주면 된다.
이렇게 Dependency Injection을 통해 의존성을 Externalizing함으로써, 코드를 업데이트 할 때 변경해야 할 내용을 최소화할 수 있다.`),ar.forEach(a),NE=r(n),re=o(n,"P",{});var KS=l(re);Iw=e(KS,`Dependency Injection은 테스트를 더 쉽게 할 수 있도록 해주기도 한다.
환경이 다르더라도, 입출력이 제한된 상황에서 unit test를 하는 것은 코드를 효과적으로 재사용한다.
이를테면 위 예제에서 logger의 출력을 테스트하려고 한다면, logger의 출력을 capture하는 타입을 주입하고 인터페이스를 충족시켜주기만 하면 된다.`),KS.forEach(a),FE=r(n),WE=o(n,"BR",{}),UE=r(n),ya=o(n,"P",{});var R2=l(ya);Lw=e(R2,`개인적으로는 Dependency Injection이 일단 짜놓으면 편하긴 한데, 직접 짜기에는 너무 복잡하고 양이 많아 보였다.
그럴 때에는 구글님들이 `),St=o(R2,"A",{href:!0,rel:!0});var QS=l(St);Hw=e(QS,"Wire"),QS.forEach(a),Aw=e(R2,`라는, Dependency Injection을 도와주는 유틸리티가 있는데,
자동적으로 concrete type 선언 코드를 만들어준다고 하니 필요하다면 잘 사용해보도록 하자.`),R2.forEach(a),jE=r(n),zE=o(n,"BR",{}),qE=o(n,"BR",{}),VE=r(n),ba=o(n,"H3",{id:!0});var uC=l(ba);wa=o(uC,"A",{"aria-hidden":!0,tabindex:!0,href:!0});var YS=l(wa);Zi=o(YS,"SPAN",{class:!0}),l(Zi).forEach(a),YS.forEach(a),Gw=e(uC,"Go Isn’t Particularly Object-Oriented"),uC.forEach(a),JE=r(n),ke=o(n,"P",{});var hS=l(ke);Bw=e(hS,`Go라는 언어를 특정 스타일로 구분짓기는 어렵다.
일단 절차지향은 아닌 듯 한데, 메소드 오버라이딩이나 상속도 없어서 객체지향이라기에도 애매하다.
함수 타입과 closure가 있지만 함수형 언어도 아니다.
만약 이러한 방법론에 맞춰서 Go 코드를 짜면, 아마 그게 이상적인 Go 코드는 아닐 것이다.`),hS.forEach(a),XE=r(n),$E=o(n,"BR",{}),ZE=o(n,"BR",{}),KE=r(n),Ca=o(n,"H2",{id:!0});var iC=l(Ca);Da=o(iC,"A",{"aria-hidden":!0,tabindex:!0,href:!0});var gS=l(Da);Ki=o(gS,"SPAN",{class:!0}),l(Ki).forEach(a),gS.forEach(a),xw=e(iC,"Refereces"),iC.forEach(a),QE=r(n),YE=o(n,"HR",{}),hE=r(n),Sn=o(n,"CENTER",{});var Ht=l(Sn);Qi=o(Ht,"P",{});var nM=l(Qi);Nw=e(nM,"["),nM.forEach(a),Fw=r(Ht),VI(Mt.$$.fragment,Ht),Ww=e(Ht,`
](https://learning.oreilly.com/library/view/learning-go/9781492077206/) `),Uw=o(Ht,"BR",{}),jw=e(Ht,`
[Jon Bodner, 『Learning Go』, O'Reilly Media, Inc.](https://learning.oreilly.com/library/view/learning-go/9781492077206/)`),Ht.forEach(a),gE=r(n),n2=o(n,"BR",{}),s2=r(n),fe=o(n,"P",{});var sM=l(fe);zw=e(sM,"이번 포스트는 의역이 너무 많아용"),sM.forEach(a),a2=r(n),de=o(n,"P",{});var aM=l(de);qw=e(aM,"원문 참조하시는 게 좋을듯함"),aM.forEach(a),t2=r(n),e2=o(n,"BR",{}),p2=o(n,"BR",{}),this.h()},h(){k(We,"class","icon icon-link"),k(Os,"aria-hidden","true"),k(Os,"tabindex","-1"),k(Os,"href","#types"),k(Ps,"id","types"),k(Aa,"class","language-go"),k($e,"class","icon icon-link"),k(Ms,"aria-hidden","true"),k(Ms,"tabindex","-1"),k(Ms,"href","#inheritance-in-go"),k(Ss,"id","inheritance-in-go"),k(Ga,"class","language-go"),k(Ba,"class","language-go"),k(ge,"class","icon icon-link"),k(Hs,"aria-hidden","true"),k(Hs,"tabindex","-1"),k(Hs,"href","#enumeration-in-go---iota"),k(Ls,"id","enumeration-in-go---iota"),k(xa,"class","language-go"),k(Na,"class","language-bash"),k(Fa,"class","language-go"),k(yp,"class","icon icon-link"),k(Bs,"aria-hidden","true"),k(Bs,"tabindex","-1"),k(Bs,"href","#methods"),k(Gs,"id","methods"),k(Wa,"class","language-go"),k(Dp,"class","icon icon-link"),k(Ns,"aria-hidden","true"),k(Ns,"tabindex","-1"),k(Ns,"href","#pointer-receivers"),k(xs,"id","pointer-receivers"),k(ja,"class","language-go"),k(za,"class","language-bash"),k(qa,"class","language-go"),k(Va,"class","language-bash"),k(Ja,"class","language-go"),k(ko,"class","icon icon-link"),k(Us,"aria-hidden","true"),k(Us,"tabindex","-1"),k(Us,"href","#methods-and-functions"),k(Ws,"id","methods-and-functions"),k(Xa,"class","language-go"),k(To,"class","icon icon-link"),k(qs,"aria-hidden","true"),k(qs,"tabindex","-1"),k(qs,"href","#embedding"),k(zs,"id","embedding"),k($a,"class","language-go"),k(Za,"class","language-go"),k(Ka,"class","language-go"),k(Qa,"class","language-go"),k(Ya,"class","language-bash"),k(sl,"class","icon icon-link"),k($s,"aria-hidden","true"),k($s,"tabindex","-1"),k($s,"href","#interface"),k(Xs,"id","interface"),k(ha,"class","language-go"),JI(Vt,"background-color","#FFF5B1"),k(nt,"class","language-go"),k(st,"class","language-go"),k(at,"class","language-go"),k(nc,"class","icon icon-link"),k(Qs,"aria-hidden","true"),k(Qs,"tabindex","-1"),k(Qs,"href","#embedding-and-interfaces"),k(Ks,"id","embedding-and-interfaces"),k(tt,"class","language-go"),k(pc,"class","icon icon-link"),k(hs,"aria-hidden","true"),k(hs,"tabindex","-1"),k(hs,"href","#accept-interfaces-return-structs"),k(Ys,"id","accept-interfaces-return-structs"),k(uc,"class","icon icon-link"),k(sa,"aria-hidden","true"),k(sa,"tabindex","-1"),k(sa,"href","#interfaces-and-nil"),k(na,"id","interfaces-and-nil"),k(et,"class","language-go"),k(pt,"class","language-bash"),k(Pc,"class","icon icon-link"),k(ta,"aria-hidden","true"),k(ta,"tabindex","-1"),k(ta,"href","#the-empty-interface-says-nothing"),k(aa,"id","the-empty-interface-says-nothing"),k(ot,"class","language-go"),k(lt,"class","language-go"),k(ct,"class","language-go"),k(Uc,"class","icon icon-link"),k(la,"aria-hidden","true"),k(la,"tabindex","-1"),k(la,"href","#type-assertions-and-type-switches"),k(oa,"id","type-assertions-and-type-switches"),k(ut,"class","language-go"),k(it,"class","language-go"),k(rt,"class","language-go"),k(kt,"class","language-go"),k(ft,"class","language-go"),k(dt,"class","language-bash"),k(Et,"class","language-go"),k(mt,"class","language-go"),k(ri,"class","icon icon-link"),k(fa,"aria-hidden","true"),k(fa,"tabindex","-1"),k(fa,"href","#function-types-are-a-bridge-to-interfaces"),k(ka,"id","function-types-are-a-bridge-to-interfaces"),k(_t,"class","language-go"),k(yt,"class","language-go"),k(bi,"class","icon icon-link"),k(ma,"aria-hidden","true"),k(ma,"tabindex","-1"),k(ma,"href","#implicit-interfaces-make-dependency-injection-easier"),k(Ea,"id","implicit-interfaces-make-dependency-injection-easier"),k(wt,"class","language-go"),k(Ct,"class","language-go"),k(Dt,"class","language-go"),k(Pt,"class","language-go"),k(Ot,"class","language-go"),k(Rt,"class","language-go"),k(Tt,"class","language-go"),k(St,"href","https://github.com/google/wire"),k(St,"rel","nofollow"),k(Zi,"class","icon icon-link"),k(wa,"aria-hidden","true"),k(wa,"tabindex","-1"),k(wa,"href","#go-isnt-particularly-object-oriented"),k(ba,"id","go-isnt-particularly-object-oriented"),k(Ki,"class","icon icon-link"),k(Da,"aria-hidden","true"),k(Da,"tabindex","-1"),k(Da,"href","#refereces"),k(Ca,"id","refereces")},m(n,c){u(n,At,c),u(n,tr,c),u(n,Gt,c),s(Gt,T2),u(n,er,c),u(n,pr,c),u(n,or,c),u(n,lr,c),u(n,Ps,c),s(Ps,Os),s(Os,We),s(Ps,S2),u(n,cr,c),u(n,ur,c),u(n,ir,c),u(n,Rs,c),s(Rs,M2),s(Rs,Ue),s(Ue,I2),s(Rs,L2),u(n,rr,c),u(n,Aa,c),Aa.innerHTML=eM,u(n,kr,c),u(n,Bt,c),s(Bt,H2),u(n,fr,c),u(n,dr,c),u(n,Er,c),u(n,kn,c),s(kn,A2),s(kn,je),s(je,G2),s(kn,B2),s(kn,ze),s(ze,x2),s(kn,N2),s(kn,qe),s(qe,F2),s(kn,W2),u(n,mr,c),u(n,Hn,c),s(Hn,U2),s(Hn,Ve),s(Ve,j2),s(Hn,z2),s(Hn,Je),s(Je,q2),s(Hn,V2),u(n,vr,c),u(n,Ts,c),s(Ts,J2),s(Ts,Xe),s(Xe,X2),s(Ts,$2),u(n,_r,c),u(n,yr,c),u(n,br,c),u(n,wr,c),u(n,Ss,c),s(Ss,Ms),s(Ms,$e),s(Ss,Z2),u(n,Cr,c),u(n,xt,c),s(xt,K2),u(n,Dr,c),u(n,Ga,c),Ga.innerHTML=pM,u(n,Pr,c),u(n,Is,c),s(Is,Q2),s(Is,Ze),s(Ze,Y2),s(Is,h2),u(n,Or,c),u(n,q,c),s(q,g2),s(q,Ke),s(Ke,nm),s(q,sm),s(q,Qe),s(Qe,am),s(q,tm),s(q,Ye),s(Ye,em),s(q,pm),s(q,he),s(he,om),s(q,lm),u(n,Rr,c),u(n,Ba,c),Ba.innerHTML=oM,u(n,Tr,c),u(n,Sr,c),u(n,Mr,c),u(n,Ir,c),u(n,Ls,c),s(Ls,Hs),s(Hs,ge),s(Ls,cm),u(n,Lr,c),u(n,An,c),s(An,um),s(An,np),s(np,im),s(An,rm),s(An,sp),s(sp,km),s(An,fm),u(n,Hr,c),u(n,xa,c),xa.innerHTML=lM,u(n,Ar,c),u(n,Na,c),Na.innerHTML=cM,u(n,Gr,c),u(n,V,c),s(V,dm),s(V,ap),s(ap,Em),s(V,mm),s(V,tp),s(tp,vm),s(V,_m),s(V,ep),s(ep,ym),s(V,bm),s(V,pp),s(pp,wm),s(V,Cm),u(n,Br,c),u(n,xr,c),u(n,Nr,c),u(n,Fa,c),Fa.innerHTML=uM,u(n,Fr,c),u(n,is,c),s(is,op),s(op,Dm),s(is,Pm),s(is,lp),s(lp,Om),s(is,Rm),u(n,Wr,c),u(n,Ur,c),u(n,jr,c),u(n,D,c),s(D,Tm),s(D,cp),s(cp,Sm),s(D,Mm),s(D,up),s(up,Im),s(D,Lm),s(D,ip),s(ip,Hm),s(D,Am),s(D,rp),s(rp,Gm),s(D,Bm),s(D,kp),s(kp,xm),s(D,Nm),s(D,fp),s(fp,Fm),s(D,Wm),u(n,zr,c),u(n,J,c),s(J,Um),s(J,dp),s(dp,jm),s(J,zm),s(J,Ep),s(Ep,qm),s(J,Vm),s(J,mp),s(mp,Jm),s(J,Xm),s(J,vp),s(vp,$m),s(J,Zm),u(n,qr,c),u(n,As,c),s(As,Km),s(As,_p),s(_p,Qm),s(As,Ym),u(n,Vr,c),u(n,Jr,c),u(n,Xr,c),u(n,$r,c),u(n,Gs,c),s(Gs,Bs),s(Bs,yp),s(Gs,hm),u(n,Zr,c),u(n,Kr,c),u(n,Qr,c),u(n,fn,c),s(fn,gm),s(fn,bp),s(bp,nv),s(fn,sv),s(fn,wp),s(wp,av),s(fn,tv),s(fn,Cp),s(Cp,ev),s(fn,pv),u(n,Yr,c),u(n,Wa,c),Wa.innerHTML=iM,u(n,hr,c),u(n,Nt,c),s(Nt,ov),u(n,gr,c),u(n,Ft,c),s(Ft,lv),u(n,nk,c),u(n,sk,c),u(n,ak,c),u(n,tk,c),u(n,xs,c),s(xs,Ns),s(Ns,Dp),s(xs,cv),u(n,ek,c),u(n,dn,c),s(dn,uv),s(dn,Pp),s(Pp,iv),s(dn,rv),s(dn,Op),s(Op,kv),s(dn,fv),s(dn,Rp),s(Rp,dv),s(dn,Ev),u(n,pk,c),u(n,Ua,c),s(Ua,Tp),s(Tp,mv),s(Ua,vv),u(n,ok,c),u(n,Gn,c),s(Gn,rs),s(rs,_v),s(rs,Sp),s(Sp,yv),s(rs,bv),s(rs,Mp),s(Mp,wv),s(rs,Cv),s(Gn,Dv),s(Gn,ks),s(ks,Pv),s(ks,Ip),s(Ip,Ov),s(ks,Rv),s(ks,Lp),s(Lp,Tv),s(ks,Sv),s(Gn,Mv),s(Gn,fs),s(fs,Iv),s(fs,Hp),s(Hp,Lv),s(fs,Hv),s(fs,Ap),s(Ap,Av),s(fs,Gv),u(n,lk,c),u(n,Rn,c),s(Rn,Gp),s(Gp,Bv),s(Rn,xv),s(Rn,Bp),s(Bp,Nv),s(Rn,Fv),s(Rn,xp),s(xp,Wv),s(Rn,Uv),u(n,ck,c),u(n,uk,c),u(n,ik,c),u(n,ja,c),ja.innerHTML=rM,u(n,rk,c),u(n,En,c),s(En,jv),s(En,Np),s(Np,zv),s(En,qv),s(En,Fp),s(Fp,Vv),s(En,Jv),s(En,Wp),s(Wp,Xv),s(En,$v),u(n,kk,c),u(n,za,c),za.innerHTML=kM,u(n,fk,c),u(n,dk,c),u(n,Ek,c),u(n,Wt,c),s(Wt,Zv),u(n,mk,c),u(n,qa,c),qa.innerHTML=fM,u(n,vk,c),u(n,E,c),s(E,Up),s(Up,Kv),s(E,Qv),s(E,jp),s(jp,Yv),s(E,hv),s(E,zp),s(zp,gv),s(E,n3),s(E,qp),s(qp,s3),s(E,a3),s(E,Vp),s(Vp,t3),s(E,e3),s(E,Jp),s(Jp,p3),s(E,o3),s(E,Xp),s(Xp,l3),s(E,c3),s(E,$p),s($p,u3),s(E,i3),s(E,Zp),s(Zp,r3),s(E,k3),u(n,_k,c),u(n,Ut,c),s(Ut,f3),u(n,yk,c),u(n,Va,c),Va.innerHTML=dM,u(n,bk,c),u(n,wk,c),u(n,Ck,c),u(n,mn,c),s(mn,d3),s(mn,Kp),s(Kp,E3),s(mn,m3),s(mn,Qp),s(Qp,v3),s(mn,_3),s(mn,Yp),s(Yp,y3),s(mn,b3),u(n,Dk,c),u(n,Pk,c),u(n,Ok,c),u(n,Rk,c),u(n,ds,c),s(ds,hp),s(hp,w3),s(ds,C3),s(ds,gp),s(gp,D3),s(ds,P3),u(n,Tk,c),u(n,v,c),s(v,O3),s(v,no),s(no,R3),s(v,T3),s(v,so),s(so,S3),s(v,M3),s(v,ao),s(ao,I3),s(v,L3),s(v,to),s(to,H3),s(v,A3),s(v,eo),s(eo,G3),s(v,B3),s(v,po),s(po,x3),s(v,N3),s(v,oo),s(oo,F3),s(v,W3),u(n,Sk,c),u(n,Ja,c),Ja.innerHTML=EM,u(n,Mk,c),u(n,Fs,c),s(Fs,U3),s(Fs,lo),s(lo,j3),s(Fs,z3),u(n,Ik,c),u(n,pn,c),s(pn,co),s(co,q3),s(pn,V3),s(pn,uo),s(uo,J3),s(pn,X3),s(pn,io),s(io,$3),s(pn,Z3),s(pn,ro),s(ro,K3),s(pn,Q3),u(n,Lk,c),u(n,Hk,c),u(n,Ak,c),u(n,Gk,c),u(n,Ws,c),s(Ws,Us),s(Us,ko),s(Ws,Y3),u(n,Bk,c),u(n,jt,c),s(jt,h3),u(n,xk,c),u(n,Xa,c),Xa.innerHTML=mM,u(n,Nk,c),u(n,vn,c),s(vn,g3),s(vn,fo),s(fo,n5),s(vn,s5),s(vn,Eo),s(Eo,a5),s(vn,t5),s(vn,mo),s(mo,e5),s(vn,p5),u(n,Fk,c),u(n,N,c),s(N,vo),s(vo,o5),s(N,l5),s(N,_o),s(_o,c5),s(N,u5),s(N,yo),s(yo,i5),s(N,r5),s(N,bo),s(bo,k5),s(N,f5),s(N,wo),s(wo,d5),s(N,E5),u(n,Wk,c),u(n,X,c),s(X,m5),s(X,Co),s(Co,v5),s(X,_5),s(X,Do),s(Do,y5),s(X,b5),s(X,Po),s(Po,w5),s(X,C5),s(X,Oo),s(Oo,D5),s(X,P5),u(n,Uk,c),u(n,js,c),s(js,O5),s(js,Ro),s(Ro,R5),s(js,T5),u(n,jk,c),u(n,zk,c),u(n,qk,c),u(n,Vk,c),u(n,zs,c),s(zs,qs),s(qs,To),s(zs,S5),u(n,Jk,c),u(n,Xk,c),u(n,$k,c),u(n,Bn,c),s(Bn,M5),s(Bn,So),s(So,I5),s(Bn,L5),s(Bn,Mo),s(Mo,H5),s(Bn,A5),u(n,Zk,c),u(n,zt,c),s(zt,G5),u(n,Kk,c),u(n,$a,c),$a.innerHTML=vM,u(n,Qk,c),u(n,y,c),s(y,Io),s(Io,B5),s(y,x5),s(y,Lo),s(Lo,N5),s(y,F5),s(y,Ho),s(Ho,W5),s(y,U5),s(y,Ao),s(Ao,j5),s(y,z5),s(y,Go),s(Go,q5),s(y,V5),s(y,Bo),s(Bo,J5),s(y,X5),s(y,xo),s(xo,$5),s(y,Z5),u(n,Yk,c),u(n,hk,c),u(n,gk,c),u(n,Za,c),Za.innerHTML=_M,u(n,nf,c),u(n,Vs,c),s(Vs,K5),s(Vs,No),s(No,Q5),s(Vs,Y5),u(n,sf,c),u(n,_n,c),s(_n,h5),s(_n,Fo),s(Fo,g5),s(_n,n_),s(_n,Wo),s(Wo,s_),s(_n,a_),s(_n,Uo),s(Uo,t_),s(_n,e_),u(n,af,c),u(n,tf,c),u(n,ef,c),u(n,pf,c),u(n,Es,c),s(Es,jo),s(jo,p_),s(Es,o_),s(Es,zo),s(zo,l_),s(Es,c_),u(n,of,c),u(n,lf,c),u(n,cf,c),u(n,xn,c),s(xn,u_),s(xn,qo),s(qo,i_),s(xn,r_),s(xn,Vo),s(Vo,k_),s(xn,f_),u(n,uf,c),u(n,Ka,c),Ka.innerHTML=yM,u(n,rf,c),u(n,$,c),s($,d_),s($,Jo),s(Jo,E_),s($,m_),s($,Xo),s(Xo,v_),s($,__),s($,$o),s($o,y_),s($,b_),s($,Zo),s(Zo,w_),s($,C_),u(n,kf,c),u(n,ff,c),u(n,df,c),u(n,Js,c),s(Js,D_),s(Js,Ko),s(Ko,P_),s(Js,O_),u(n,Ef,c),u(n,Qa,c),Qa.innerHTML=bM,u(n,mf,c),u(n,Ya,c),Ya.innerHTML=wM,u(n,vf,c),u(n,I,c),s(I,R_),s(I,Qo),s(Qo,T_),s(I,S_),s(I,Yo),s(Yo,M_),s(I,I_),s(I,ho),s(ho,L_),s(I,H_),s(I,go),s(go,A_),s(I,G_),s(I,nl),s(nl,B_),s(I,x_),u(n,_f,c),u(n,yf,c),u(n,bf,c),u(n,wf,c),u(n,Xs,c),s(Xs,$s),s($s,sl),s(Xs,N_),u(n,Cf,c),u(n,Df,c),u(n,Pf,c),u(n,Zs,c),s(Zs,F_),s(Zs,al),s(al,W_),s(Zs,U_),u(n,Of,c),u(n,qt,c),s(qt,j_),u(n,Rf,c),u(n,ha,c),ha.innerHTML=CM,u(n,Tf,c),u(n,b,c),s(b,tl),s(tl,z_),s(b,q_),s(b,el),s(el,V_),s(b,J_),s(b,pl),s(pl,X_),s(b,$_),s(b,ol),s(ol,Z_),s(b,K_),s(b,ll),s(ll,Q_),s(b,Y_),s(b,cl),s(cl,h_),s(b,g_),s(b,ul),s(ul,n0),s(b,s0),u(n,Sf,c),u(n,Mf,c),u(n,If,c),u(n,on,c),s(on,il),s(il,a0),s(on,t0),s(on,rl),s(rl,e0),s(on,p0),s(on,kl),s(kl,o0),s(on,l0),s(on,fl),s(fl,c0),s(on,u0),u(n,Lf,c),u(n,L,c),s(L,i0),s(L,Vt),s(Vt,r0),s(L,k0),s(L,dl),s(dl,f0),s(L,d0),s(L,El),s(El,E0),s(L,m0),s(L,ml),s(ml,v0),s(L,_0),s(L,vl),s(vl,y0),s(L,b0),u(n,Hf,c),u(n,ga,c),s(ga,_l),s(_l,w0),s(ga,C0),u(n,Af,c),u(n,Nn,c),s(Nn,D0),s(Nn,yl),s(yl,P0),s(Nn,O0),s(Nn,bl),s(bl,R0),s(Nn,T0),u(n,Gf,c),u(n,Jt,c),s(Jt,S0),u(n,Bf,c),u(n,Xt,c),s(Xt,M0),u(n,xf,c),u(n,Nf,c),u(n,Ff,c),u(n,$t,c),s($t,I0),u(n,Wf,c),u(n,Zt,c),s(Zt,L0),u(n,Uf,c),u(n,nt,c),nt.innerHTML=DM,u(n,jf,c),u(n,f,c),s(f,wl),s(wl,H0),s(f,A0),s(f,Cl),s(Cl,G0),s(f,B0),s(f,Dl),s(Dl,x0),s(f,N0),s(f,Pl),s(Pl,F0),s(f,W0),s(f,Ol),s(Ol,U0),s(f,j0),s(f,Rl),s(Rl,z0),s(f,q0),s(f,Tl),s(Tl,V0),s(f,J0),s(f,Sl),s(Sl,X0),s(f,$0),s(f,Ml),s(Ml,Z0),s(f,K0),s(f,Il),s(Il,Q0),s(f,Y0),s(f,Ll),s(Ll,h0),s(f,g0),s(f,Hl),s(Hl,n4),s(f,s4),s(f,Al),s(Al,a4),s(f,t4),u(n,zf,c),u(n,qf,c),u(n,Vf,c),u(n,Z,c),s(Z,e4),s(Z,Gl),s(Gl,p4),s(Z,o4),s(Z,Bl),s(Bl,l4),s(Z,c4),s(Z,xl),s(xl,u4),s(Z,i4),s(Z,Nl),s(Nl,r4),s(Z,k4),u(n,Jf,c),u(n,Kt,c),s(Kt,f4),u(n,Xf,c),u(n,st,c),st.innerHTML=PM,u(n,$f,c),u(n,K,c),s(K,d4),s(K,Fl),s(Fl,E4),s(K,m4),s(K,Wl),s(Wl,v4),s(K,_4),s(K,Ul),s(Ul,y4),s(K,b4),s(K,jl),s(jl,w4),s(K,C4),u(n,Zf,c),u(n,Fn,c),s(Fn,D4),s(Fn,zl),s(zl,P4),s(Fn,O4),s(Fn,ql),s(ql,R4),s(Fn,T4),u(n,Kf,c),u(n,at,c),at.innerHTML=OM,u(n,Qf,c),u(n,Qt,c),s(Qt,S4),u(n,Yf,c),u(n,P,c),s(P,M4),s(P,Vl),s(Vl,I4),s(P,L4),s(P,Jl),s(Jl,H4),s(P,A4),s(P,Xl),s(Xl,G4),s(P,B4),s(P,$l),s($l,x4),s(P,N4),s(P,Zl),s(Zl,F4),s(P,W4),s(P,Kl),s(Kl,U4),s(P,j4),u(n,hf,c),u(n,Q,c),s(Q,z4),s(Q,Ql),s(Ql,q4),s(Q,V4),s(Q,Yl),s(Yl,J4),s(Q,X4),s(Q,hl),s(hl,$4),s(Q,Z4),s(Q,gl),s(gl,K4),s(Q,Q4),u(n,gf,c),u(n,n1,c),u(n,s1,c),u(n,a1,c),u(n,Ks,c),s(Ks,Qs),s(Qs,nc),s(Ks,Y4),u(n,t1,c),u(n,ln,c),s(ln,sc),s(sc,h4),s(ln,g4),s(ln,ac),s(ac,ny),s(ln,sy),s(ln,tc),s(tc,ay),s(ln,ty),s(ln,ec),s(ec,ey),s(ln,py),u(n,e1,c),u(n,tt,c),tt.innerHTML=RM,u(n,p1,c),u(n,o1,c),u(n,l1,c),u(n,c1,c),u(n,Ys,c),s(Ys,hs),s(hs,pc),s(Ys,oy),u(n,u1,c),u(n,gs,c),s(gs,ly),s(gs,oc),s(oc,cy),s(gs,uy),u(n,i1,c),u(n,Yt,c),s(Yt,iy),u(n,r1,c),u(n,ht,c),s(ht,ry),u(n,k1,c),u(n,gt,c),s(gt,ky),u(n,f1,c),u(n,Wn,c),s(Wn,fy),s(Wn,lc),s(lc,dy),s(Wn,Ey),s(Wn,cc),s(cc,my),s(Wn,vy),u(n,d1,c),u(n,ne,c),s(ne,_y),u(n,E1,c),u(n,se,c),s(se,yy),u(n,m1,c),u(n,v1,c),u(n,_1,c),u(n,y1,c),u(n,na,c),s(na,sa),s(sa,uc),s(na,by),u(n,b1,c),u(n,Un,c),s(Un,wy),s(Un,ic),s(ic,Cy),s(Un,Dy),s(Un,rc),s(rc,Py),s(Un,Oy),u(n,w1,c),u(n,et,c),et.innerHTML=TM,u(n,C1,c),u(n,pt,c),pt.innerHTML=SM,u(n,D1,c),u(n,jn,c),s(jn,Ry),s(jn,kc),s(kc,Ty),s(jn,Sy),s(jn,fc),s(fc,My),s(jn,Iy),u(n,P1,c),u(n,O,c),s(O,Ly),s(O,dc),s(dc,Hy),s(O,Ay),s(O,Ec),s(Ec,Gy),s(O,By),s(O,mc),s(mc,xy),s(O,Ny),s(O,vc),s(vc,Fy),s(O,Wy),s(O,_c),s(_c,Uy),s(O,jy),s(O,yc),s(yc,zy),s(O,qy),u(n,O1,c),u(n,Y,c),s(Y,Vy),s(Y,bc),s(bc,Jy),s(Y,Xy),s(Y,wc),s(wc,$y),s(Y,Zy),s(Y,Cc),s(Cc,Ky),s(Y,Qy),s(Y,Dc),s(Dc,Yy),s(Y,hy),u(n,R1,c),u(n,T1,c),u(n,S1,c),u(n,M1,c),u(n,aa,c),s(aa,ta),s(ta,Pc),s(aa,gy),u(n,I1,c),u(n,ea,c),s(ea,n6),s(ea,Oc),s(Oc,s6),s(ea,a6),u(n,L1,c),u(n,ot,c),ot.innerHTML=MM,u(n,H1,c),u(n,zn,c),s(zn,t6),s(zn,Rc),s(Rc,e6),s(zn,p6),s(zn,Tc),s(Tc,o6),s(zn,l6),u(n,A1,c),u(n,G1,c),u(n,B1,c),u(n,ae,c),s(ae,c6),u(n,x1,c),u(n,lt,c),lt.innerHTML=IM,u(n,N1,c),u(n,pa,c),s(pa,u6),s(pa,Sc),s(Sc,i6),s(pa,r6),u(n,F1,c),u(n,W1,c),u(n,U1,c),u(n,yn,c),s(yn,k6),s(yn,Mc),s(Mc,f6),s(yn,d6),s(yn,Ic),s(Ic,E6),s(yn,m6),s(yn,Lc),s(Lc,v6),s(yn,_6),u(n,j1,c),u(n,ct,c),ct.innerHTML=LM,u(n,z1,c),u(n,te,c),s(te,y6),u(n,q1,c),u(n,bn,c),s(bn,b6),s(bn,Hc),s(Hc,w6),s(bn,C6),s(bn,Ac),s(Ac,D6),s(bn,P6),s(bn,Gc),s(Gc,O6),s(bn,R6),u(n,V1,c),u(n,J1,c),u(n,X1,c),u(n,H,c),s(H,T6),s(H,Bc),s(Bc,S6),s(H,M6),s(H,xc),s(xc,I6),s(H,L6),s(H,Nc),s(Nc,H6),s(H,A6),s(H,Fc),s(Fc,G6),s(H,B6),s(H,Wc),s(Wc,x6),s(H,N6),u(n,$1,c),u(n,Z1,c),u(n,K1,c),u(n,Q1,c),u(n,oa,c),s(oa,la),s(la,Uc),s(oa,F6),u(n,Y1,c),u(n,ee,c),s(ee,W6),u(n,h1,c),u(n,ca,c),s(ca,U6),s(ca,jc),s(jc,j6),s(ca,z6),u(n,g1,c),u(n,ut,c),ut.innerHTML=HM,u(n,nd,c),u(n,A,c),s(A,q6),s(A,zc),s(zc,V6),s(A,J6),s(A,qc),s(qc,X6),s(A,$6),s(A,Vc),s(Vc,Z6),s(A,K6),s(A,Jc),s(Jc,Q6),s(A,Y6),s(A,Xc),s(Xc,h6),s(A,g6),u(n,sd,c),u(n,ad,c),u(n,td,c),u(n,qn,c),s(qn,n7),s(qn,$c),s($c,s7),s(qn,a7),s(qn,Zc),s(Zc,t7),s(qn,e7),u(n,ed,c),u(n,it,c),it.innerHTML=AM,u(n,pd,c),u(n,od,c),u(n,ld,c),u(n,cn,c),s(cn,Kc),s(Kc,p7),s(cn,o7),s(cn,Qc),s(Qc,l7),s(cn,c7),s(cn,Yc),s(Yc,u7),s(cn,i7),s(cn,hc),s(hc,r7),s(cn,k7),u(n,cd,c),u(n,rt,c),rt.innerHTML=GM,u(n,ud,c),u(n,id,c),u(n,rd,c),u(n,ms,c),s(ms,gc),s(gc,f7),s(ms,d7),s(ms,nu),s(nu,E7),s(ms,m7),u(n,kd,c),u(n,kt,c),kt.innerHTML=BM,u(n,fd,c),u(n,w,c),s(w,su),s(su,v7),s(w,_7),s(w,au),s(au,y7),s(w,b7),s(w,tu),s(tu,w7),s(w,C7),s(w,eu),s(eu,D7),s(w,P7),s(w,O7),s(w,R7),s(w,pu),s(pu,T7),s(w,S7),s(w,ou),s(ou,M7),s(w,I7),u(n,dd,c),u(n,Vn,c),s(Vn,L7),s(Vn,lu),s(lu,H7),s(Vn,A7),s(Vn,cu),s(cu,G7),s(Vn,B7),u(n,Ed,c),u(n,ua,c),s(ua,x7),s(ua,uu),s(uu,N7),s(ua,F7),u(n,md,c),u(n,vd,c),u(n,_d,c),u(n,yd,c),u(n,ia,c),s(ia,W7),s(ia,iu),s(iu,U7),s(ia,j7),u(n,bd,c),u(n,ft,c),ft.innerHTML=xM,u(n,wd,c),u(n,dt,c),dt.innerHTML=NM,u(n,Cd,c),u(n,Jn,c),s(Jn,z7),s(Jn,ru),s(ru,q7),s(Jn,V7),s(Jn,ku),s(ku,J7),s(Jn,X7),u(n,Dd,c),u(n,_,c),s(_,$7),s(_,fu),s(fu,Z7),s(_,K7),s(_,du),s(du,Q7),s(_,Y7),s(_,Eu),s(Eu,h7),s(_,g7),s(_,mu),s(mu,n8),s(_,s8),s(_,vu),s(vu,a8),s(_,t8),s(_,_u),s(_u,e8),s(_,p8),s(_,yu),s(yu,o8),s(_,l8),u(n,Pd,c),u(n,ra,c),s(ra,c8),s(ra,bu),s(bu,u8),s(ra,i8),u(n,Od,c),u(n,un,c),s(un,wu),s(wu,r8),s(un,k8),s(un,Cu),s(Cu,f8),s(un,d8),s(un,Du),s(Du,E8),s(un,m8),s(un,Pu),s(Pu,v8),s(un,_8),u(n,Rd,c),u(n,Td,c),u(n,Sd,c),u(n,vs,c),s(vs,Ou),s(Ou,y8),s(vs,b8),s(vs,Ru),s(Ru,w8),s(vs,C8),u(n,Md,c),u(n,G,c),s(G,D8),s(G,Tu),s(Tu,P8),s(G,O8),s(G,Su),s(Su,R8),s(G,T8),s(G,Mu),s(Mu,S8),s(G,M8),s(G,Iu),s(Iu,I8),s(G,L8),s(G,Lu),s(Lu,H8),s(G,A8),u(n,Id,c),u(n,m,c),s(m,Hu),s(Hu,G8),s(m,B8),s(m,Au),s(Au,x8),s(m,N8),s(m,Gu),s(Gu,F8),s(m,W8),s(m,Bu),s(Bu,U8),s(m,j8),s(m,xu),s(xu,z8),s(m,q8),s(m,Nu),s(Nu,V8),s(m,J8),s(m,Fu),s(Fu,X8),s(m,$8),s(m,Wu),s(Wu,Z8),s(m,K8),u(n,Ld,c),u(n,Et,c),Et.innerHTML=FM,u(n,Hd,c),u(n,Ad,c),u(n,Gd,c),u(n,Xn,c),s(Xn,Q8),s(Xn,Uu),s(Uu,Y8),s(Xn,h8),s(Xn,ju),s(ju,g8),s(Xn,n9),u(n,Bd,c),u(n,R,c),s(R,s9),s(R,zu),s(zu,a9),s(R,t9),s(R,qu),s(qu,e9),s(R,p9),s(R,Vu),s(Vu,o9),s(R,l9),s(R,Ju),s(Ju,c9),s(R,u9),s(R,Xu),s(Xu,i9),s(R,r9),s(R,$u),s($u,k9),s(R,f9),u(n,xd,c),u(n,mt,c),mt.innerHTML=WM,u(n,Nd,c),u(n,Fd,c),u(n,Wd,c),u(n,$n,c),s($n,d9),s($n,Zu),s(Zu,E9),s($n,m9),s($n,Ku),s(Ku,v9),s($n,_9),u(n,Ud,c),u(n,T,c),s(T,y9),s(T,Qu),s(Qu,b9),s(T,w9),s(T,Yu),s(Yu,C9),s(T,D9),s(T,hu),s(hu,P9),s(T,O9),s(T,gu),s(gu,R9),s(T,T9),s(T,ni),s(ni,S9),s(T,M9),s(T,si),s(si,I9),s(T,L9),u(n,jd,c),u(n,h,c),s(h,H9),s(h,ai),s(ai,A9),s(h,G9),s(h,ti),s(ti,B9),s(h,x9),s(h,ei),s(ei,N9),s(h,F9),s(h,pi),s(pi,W9),s(h,U9),u(n,zd,c),u(n,qd,c),u(n,Vd,c),u(n,vt,c),s(vt,oi),s(oi,j9),s(vt,z9),u(n,Jd,c),u(n,g,c),s(g,q9),s(g,li),s(li,V9),s(g,J9),s(g,ci),s(ci,X9),s(g,$9),s(g,ui),s(ui,Z9),s(g,K9),s(g,ii),s(ii,Q9),s(g,Y9),u(n,Xd,c),u(n,$d,c),u(n,Zd,c),u(n,Kd,c),u(n,ka,c),s(ka,fa),s(fa,ri),s(ka,h9),u(n,Qd,c),u(n,pe,c),s(pe,g9),u(n,Yd,c),u(n,oe,c),s(oe,nb),u(n,hd,c),u(n,_t,c),_t.innerHTML=UM,u(n,gd,c),u(n,F,c),s(F,ki),s(ki,sb),s(F,ab),s(F,fi),s(fi,tb),s(F,eb),s(F,di),s(di,pb),s(F,ob),s(F,Ei),s(Ei,lb),s(F,cb),s(F,mi),s(mi,ub),s(F,ib),u(n,nE,c),u(n,yt,c),yt.innerHTML=jM,u(n,sE,c),u(n,da,c),s(da,rb),s(da,vi),s(vi,kb),s(da,fb),u(n,aE,c),u(n,tE,c),u(n,eE,c),u(n,le,c),s(le,db),u(n,pE,c),u(n,Zn,c),s(Zn,Eb),s(Zn,_i),s(_i,mb),s(Zn,vb),s(Zn,yi),s(yi,_b),s(Zn,yb),u(n,oE,c),u(n,lE,c),u(n,cE,c),u(n,uE,c),u(n,Ea,c),s(Ea,ma),s(ma,bi),s(Ea,bb),u(n,iE,c),u(n,bt,c),s(bt,wi),s(wi,wb),s(bt,Cb),u(n,rE,c),u(n,ce,c),s(ce,Db),u(n,kE,c),u(n,wt,c),wt.innerHTML=zM,u(n,fE,c),u(n,va,c),s(va,Pb),s(va,Ci),s(Ci,Ob),s(va,Rb),u(n,dE,c),u(n,Ct,c),Ct.innerHTML=qM,u(n,EE,c),u(n,mE,c),u(n,vE,c),u(n,Kn,c),s(Kn,Tb),s(Kn,Di),s(Di,Sb),s(Kn,Mb),s(Kn,Pi),s(Pi,Ib),s(Kn,Lb),u(n,_E,c),u(n,ue,c),s(ue,Hb),u(n,yE,c),u(n,Dt,c),Dt.innerHTML=VM,u(n,bE,c),u(n,Tn,c),s(Tn,Oi),s(Oi,Ab),s(Tn,Gb),s(Tn,Ri),s(Ri,Bb),s(Tn,xb),s(Tn,Ti),s(Ti,Nb),s(Tn,Fb),u(n,wE,c),u(n,ie,c),s(ie,Wb),u(n,CE,c),u(n,Pt,c),Pt.innerHTML=JM,u(n,DE,c),u(n,W,c),s(W,Si),s(Si,Ub),s(W,jb),s(W,Mi),s(Mi,zb),s(W,qb),s(W,Ii),s(Ii,Vb),s(W,Jb),s(W,Li),s(Li,Xb),s(W,$b),s(W,Hi),s(Hi,Zb),s(W,Kb),u(n,PE,c),u(n,OE,c),u(n,RE,c),u(n,Qn,c),s(Qn,Qb),s(Qn,Ai),s(Ai,Yb),s(Qn,hb),s(Qn,Gi),s(Gi,gb),s(Qn,nw),u(n,TE,c),u(n,Ot,c),Ot.innerHTML=XM,u(n,SE,c),u(n,Yn,c),s(Yn,sw),s(Yn,Bi),s(Bi,aw),s(Yn,tw),s(Yn,xi),s(xi,ew),s(Yn,pw),u(n,ME,c),u(n,Rt,c),Rt.innerHTML=$M,u(n,IE,c),u(n,LE,c),u(n,HE,c),u(n,_a,c),s(_a,ow),s(_a,Ni),s(Ni,lw),s(_a,cw),u(n,AE,c),u(n,Tt,c),Tt.innerHTML=ZM,u(n,GE,c),u(n,hn,c),s(hn,uw),s(hn,Fi),s(Fi,iw),s(hn,rw),s(hn,Wi),s(Wi,kw),s(hn,fw),u(n,BE,c),u(n,S,c),s(S,Ui),s(Ui,dw),s(S,Ew),s(S,ji),s(ji,mw),s(S,vw),s(S,zi),s(zi,_w),s(S,yw),s(S,qi),s(qi,bw),s(S,ww),s(S,Vi),s(Vi,Cw),s(S,Dw),s(S,Ji),s(Ji,Pw),s(S,Ow),u(n,xE,c),u(n,_s,c),s(_s,Xi),s(Xi,Rw),s(_s,Tw),s(_s,$i),s($i,Sw),s(_s,Mw),u(n,NE,c),u(n,re,c),s(re,Iw),u(n,FE,c),u(n,WE,c),u(n,UE,c),u(n,ya,c),s(ya,Lw),s(ya,St),s(St,Hw),s(ya,Aw),u(n,jE,c),u(n,zE,c),u(n,qE,c),u(n,VE,c),u(n,ba,c),s(ba,wa),s(wa,Zi),s(ba,Gw),u(n,JE,c),u(n,ke,c),s(ke,Bw),u(n,XE,c),u(n,$E,c),u(n,ZE,c),u(n,KE,c),u(n,Ca,c),s(Ca,Da),s(Da,Ki),s(Ca,xw),u(n,QE,c),u(n,YE,c),u(n,hE,c),u(n,Sn,c),s(Sn,Qi),s(Qi,Nw),s(Sn,Fw),XI(Mt,Sn,null),s(Sn,Ww),s(Sn,Uw),s(Sn,jw),u(n,gE,c),u(n,n2,c),u(n,s2,c),u(n,fe,c),s(fe,zw),u(n,a2,c),u(n,de,c),s(de,qw),u(n,t2,c),u(n,e2,c),u(n,p2,c),o2=!0},p:$I,i(n){o2||(ZI(Mt.$$.fragment,n),o2=!0)},o(n){KI(Mt.$$.fragment,n),o2=!1},d(n){n&&a(At),n&&a(tr),n&&a(Gt),n&&a(er),n&&a(pr),n&&a(or),n&&a(lr),n&&a(Ps),n&&a(cr),n&&a(ur),n&&a(ir),n&&a(Rs),n&&a(rr),n&&a(Aa),n&&a(kr),n&&a(Bt),n&&a(fr),n&&a(dr),n&&a(Er),n&&a(kn),n&&a(mr),n&&a(Hn),n&&a(vr),n&&a(Ts),n&&a(_r),n&&a(yr),n&&a(br),n&&a(wr),n&&a(Ss),n&&a(Cr),n&&a(xt),n&&a(Dr),n&&a(Ga),n&&a(Pr),n&&a(Is),n&&a(Or),n&&a(q),n&&a(Rr),n&&a(Ba),n&&a(Tr),n&&a(Sr),n&&a(Mr),n&&a(Ir),n&&a(Ls),n&&a(Lr),n&&a(An),n&&a(Hr),n&&a(xa),n&&a(Ar),n&&a(Na),n&&a(Gr),n&&a(V),n&&a(Br),n&&a(xr),n&&a(Nr),n&&a(Fa),n&&a(Fr),n&&a(is),n&&a(Wr),n&&a(Ur),n&&a(jr),n&&a(D),n&&a(zr),n&&a(J),n&&a(qr),n&&a(As),n&&a(Vr),n&&a(Jr),n&&a(Xr),n&&a($r),n&&a(Gs),n&&a(Zr),n&&a(Kr),n&&a(Qr),n&&a(fn),n&&a(Yr),n&&a(Wa),n&&a(hr),n&&a(Nt),n&&a(gr),n&&a(Ft),n&&a(nk),n&&a(sk),n&&a(ak),n&&a(tk),n&&a(xs),n&&a(ek),n&&a(dn),n&&a(pk),n&&a(Ua),n&&a(ok),n&&a(Gn),n&&a(lk),n&&a(Rn),n&&a(ck),n&&a(uk),n&&a(ik),n&&a(ja),n&&a(rk),n&&a(En),n&&a(kk),n&&a(za),n&&a(fk),n&&a(dk),n&&a(Ek),n&&a(Wt),n&&a(mk),n&&a(qa),n&&a(vk),n&&a(E),n&&a(_k),n&&a(Ut),n&&a(yk),n&&a(Va),n&&a(bk),n&&a(wk),n&&a(Ck),n&&a(mn),n&&a(Dk),n&&a(Pk),n&&a(Ok),n&&a(Rk),n&&a(ds),n&&a(Tk),n&&a(v),n&&a(Sk),n&&a(Ja),n&&a(Mk),n&&a(Fs),n&&a(Ik),n&&a(pn),n&&a(Lk),n&&a(Hk),n&&a(Ak),n&&a(Gk),n&&a(Ws),n&&a(Bk),n&&a(jt),n&&a(xk),n&&a(Xa),n&&a(Nk),n&&a(vn),n&&a(Fk),n&&a(N),n&&a(Wk),n&&a(X),n&&a(Uk),n&&a(js),n&&a(jk),n&&a(zk),n&&a(qk),n&&a(Vk),n&&a(zs),n&&a(Jk),n&&a(Xk),n&&a($k),n&&a(Bn),n&&a(Zk),n&&a(zt),n&&a(Kk),n&&a($a),n&&a(Qk),n&&a(y),n&&a(Yk),n&&a(hk),n&&a(gk),n&&a(Za),n&&a(nf),n&&a(Vs),n&&a(sf),n&&a(_n),n&&a(af),n&&a(tf),n&&a(ef),n&&a(pf),n&&a(Es),n&&a(of),n&&a(lf),n&&a(cf),n&&a(xn),n&&a(uf),n&&a(Ka),n&&a(rf),n&&a($),n&&a(kf),n&&a(ff),n&&a(df),n&&a(Js),n&&a(Ef),n&&a(Qa),n&&a(mf),n&&a(Ya),n&&a(vf),n&&a(I),n&&a(_f),n&&a(yf),n&&a(bf),n&&a(wf),n&&a(Xs),n&&a(Cf),n&&a(Df),n&&a(Pf),n&&a(Zs),n&&a(Of),n&&a(qt),n&&a(Rf),n&&a(ha),n&&a(Tf),n&&a(b),n&&a(Sf),n&&a(Mf),n&&a(If),n&&a(on),n&&a(Lf),n&&a(L),n&&a(Hf),n&&a(ga),n&&a(Af),n&&a(Nn),n&&a(Gf),n&&a(Jt),n&&a(Bf),n&&a(Xt),n&&a(xf),n&&a(Nf),n&&a(Ff),n&&a($t),n&&a(Wf),n&&a(Zt),n&&a(Uf),n&&a(nt),n&&a(jf),n&&a(f),n&&a(zf),n&&a(qf),n&&a(Vf),n&&a(Z),n&&a(Jf),n&&a(Kt),n&&a(Xf),n&&a(st),n&&a($f),n&&a(K),n&&a(Zf),n&&a(Fn),n&&a(Kf),n&&a(at),n&&a(Qf),n&&a(Qt),n&&a(Yf),n&&a(P),n&&a(hf),n&&a(Q),n&&a(gf),n&&a(n1),n&&a(s1),n&&a(a1),n&&a(Ks),n&&a(t1),n&&a(ln),n&&a(e1),n&&a(tt),n&&a(p1),n&&a(o1),n&&a(l1),n&&a(c1),n&&a(Ys),n&&a(u1),n&&a(gs),n&&a(i1),n&&a(Yt),n&&a(r1),n&&a(ht),n&&a(k1),n&&a(gt),n&&a(f1),n&&a(Wn),n&&a(d1),n&&a(ne),n&&a(E1),n&&a(se),n&&a(m1),n&&a(v1),n&&a(_1),n&&a(y1),n&&a(na),n&&a(b1),n&&a(Un),n&&a(w1),n&&a(et),n&&a(C1),n&&a(pt),n&&a(D1),n&&a(jn),n&&a(P1),n&&a(O),n&&a(O1),n&&a(Y),n&&a(R1),n&&a(T1),n&&a(S1),n&&a(M1),n&&a(aa),n&&a(I1),n&&a(ea),n&&a(L1),n&&a(ot),n&&a(H1),n&&a(zn),n&&a(A1),n&&a(G1),n&&a(B1),n&&a(ae),n&&a(x1),n&&a(lt),n&&a(N1),n&&a(pa),n&&a(F1),n&&a(W1),n&&a(U1),n&&a(yn),n&&a(j1),n&&a(ct),n&&a(z1),n&&a(te),n&&a(q1),n&&a(bn),n&&a(V1),n&&a(J1),n&&a(X1),n&&a(H),n&&a($1),n&&a(Z1),n&&a(K1),n&&a(Q1),n&&a(oa),n&&a(Y1),n&&a(ee),n&&a(h1),n&&a(ca),n&&a(g1),n&&a(ut),n&&a(nd),n&&a(A),n&&a(sd),n&&a(ad),n&&a(td),n&&a(qn),n&&a(ed),n&&a(it),n&&a(pd),n&&a(od),n&&a(ld),n&&a(cn),n&&a(cd),n&&a(rt),n&&a(ud),n&&a(id),n&&a(rd),n&&a(ms),n&&a(kd),n&&a(kt),n&&a(fd),n&&a(w),n&&a(dd),n&&a(Vn),n&&a(Ed),n&&a(ua),n&&a(md),n&&a(vd),n&&a(_d),n&&a(yd),n&&a(ia),n&&a(bd),n&&a(ft),n&&a(wd),n&&a(dt),n&&a(Cd),n&&a(Jn),n&&a(Dd),n&&a(_),n&&a(Pd),n&&a(ra),n&&a(Od),n&&a(un),n&&a(Rd),n&&a(Td),n&&a(Sd),n&&a(vs),n&&a(Md),n&&a(G),n&&a(Id),n&&a(m),n&&a(Ld),n&&a(Et),n&&a(Hd),n&&a(Ad),n&&a(Gd),n&&a(Xn),n&&a(Bd),n&&a(R),n&&a(xd),n&&a(mt),n&&a(Nd),n&&a(Fd),n&&a(Wd),n&&a($n),n&&a(Ud),n&&a(T),n&&a(jd),n&&a(h),n&&a(zd),n&&a(qd),n&&a(Vd),n&&a(vt),n&&a(Jd),n&&a(g),n&&a(Xd),n&&a($d),n&&a(Zd),n&&a(Kd),n&&a(ka),n&&a(Qd),n&&a(pe),n&&a(Yd),n&&a(oe),n&&a(hd),n&&a(_t),n&&a(gd),n&&a(F),n&&a(nE),n&&a(yt),n&&a(sE),n&&a(da),n&&a(aE),n&&a(tE),n&&a(eE),n&&a(le),n&&a(pE),n&&a(Zn),n&&a(oE),n&&a(lE),n&&a(cE),n&&a(uE),n&&a(Ea),n&&a(iE),n&&a(bt),n&&a(rE),n&&a(ce),n&&a(kE),n&&a(wt),n&&a(fE),n&&a(va),n&&a(dE),n&&a(Ct),n&&a(EE),n&&a(mE),n&&a(vE),n&&a(Kn),n&&a(_E),n&&a(ue),n&&a(yE),n&&a(Dt),n&&a(bE),n&&a(Tn),n&&a(wE),n&&a(ie),n&&a(CE),n&&a(Pt),n&&a(DE),n&&a(W),n&&a(PE),n&&a(OE),n&&a(RE),n&&a(Qn),n&&a(TE),n&&a(Ot),n&&a(SE),n&&a(Yn),n&&a(ME),n&&a(Rt),n&&a(IE),n&&a(LE),n&&a(HE),n&&a(_a),n&&a(AE),n&&a(Tt),n&&a(GE),n&&a(hn),n&&a(BE),n&&a(S),n&&a(xE),n&&a(_s),n&&a(NE),n&&a(re),n&&a(FE),n&&a(WE),n&&a(UE),n&&a(ya),n&&a(jE),n&&a(zE),n&&a(qE),n&&a(VE),n&&a(ba),n&&a(JE),n&&a(ke),n&&a(XE),n&&a($E),n&&a(ZE),n&&a(KE),n&&a(Ca),n&&a(QE),n&&a(YE),n&&a(hE),n&&a(Sn),QI(Mt),n&&a(gE),n&&a(n2),n&&a(s2),n&&a(fe),n&&a(a2),n&&a(de),n&&a(t2),n&&a(e2),n&&a(p2)}}}const sL={title:"타입, 메소드, 인터페이스",date:"2022-08-11T00:00:00.000Z",excerpt:"Types, Methods, Interfaces",categories:["Golang","Basic Golang"],coverImage:"/post_img/Go/Golang_basics/cover.png",coverWidth:16,coverHeight:9,indexed:!1,exposed:!0};class aL extends UI{constructor(At){super(),jI(this,At,null,hI,zI,{})}}export{aL as default,sL as metadata};
