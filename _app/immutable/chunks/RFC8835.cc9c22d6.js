import{S as er,i as tr,s as ir,k as i,q as a,a as s,l as o,m as r,r as f,h as t,c as v,n as E,b as T,E as l,M as Ki}from"./index.d78780bf.js";function or(lr){let n,ge,pe,h,W,pl,lt,Te,V,et,Ee,X,tt,_e,N,Tl,it,ot,El,rt,de,Re,ce,Pe,m,D,_l,at,ue,Y,ft,be,_,w,dl,st,vt,Rl,cl,pt,Tt,Pl,ul,Et,_t,bl,Il,dt,Rt,Cl,Ll,ct,Ie,$,Pt,Ce,d,F,Ul,ut,bt,u,nl,It,Ct,hl,Lt,Ut,Wl,nt,ht,M,Nl,Wt,Nt,b,ml,mt,Dt,Dl,St,xt,Sl,Ht,At,q,xl,Ot,kt,I,Hl,Bt,wt,Al,Ft,Mt,Ol,qt,yt,y,kl,Zt,jt,C,Bl,zt,Gt,wl,Jt,Kt,Fl,Qt,Le,Ue,ne,S,Vt,Ml,Xt,Yt,he,R,ql,$t,gt,yl,li,ei,Zl,ti,We,Ne,me,g,ii,De,x,jl,oi,ri,zl,ai,Se,xe,He,Ae,H,A,Gl,fi,Oe,ll,si,ke,c,Z,Jl,vi,pi,Kl,O,Ti,Ql,Ei,_i,Vl,Xl,di,Ri,j,Yl,ci,Pi,L,el,ui,z,$l,bi,Ii,gl,Ci,Li,le,Ui,ni,P,hi,ee,Wi,Ni,te,mi,Di,G,ie,Si,xi,J,Hi,oe,Ai,Oi,ki,U,re,Bi,wi,ae,Fi,Mi,K,fe,qi,yi,se,Zi,Be,we,Fe;return{c(){n=i("p"),ge=a(`학교 프로젝트 진행 중 정리한 RFC8835의 내용을 블로그에 포스팅해봅니다.
필요한 내용만 정리하였기 때문에 일부 내용은 생략되었을 수 있습니다.`),pe=s(),h=i("h2"),W=i("a"),pl=i("span"),lt=a("개요"),Te=s(),V=i("p"),et=a(`인터넷에서 오가는 모든 데이터는 Congestion Control이 필요하다.
그런데 WebRTC와 같이 상호 작용, 낮은 딜레이, 약간의 신뢰성을 필요로 하는 실시간 p2p 미디어 전송 프로토콜의 경우, FTP나 웹 페이지에서 필요로 하는 것과는 다소 다른 요구사항을 가진다. 따라서 이런 프로토콜의 트래픽을 처리하기 위한 Congestion control 방법이 필요하다.`),Ee=s(),X=i("p"),tt=a("스트리밍되는 실시간 데이터는 다음과 같은 요구사항을 가진다."),_e=s(),N=i("ul"),Tl=i("li"),it=a("제한된 Time window 안에 데이터를 끊임없이 전송해야 함."),ot=s(),El=i("li"),rt=a("일부 packet의 loss가 일어나더라도 데이터를 실시간으로 보내는 게 더 높은 우선순위"),de=s(),Re=i("br"),ce=i("br"),Pe=s(),m=i("h2"),D=i("a"),_l=i("span"),at=a("원리"),ue=s(),Y=i("p"),ft=a("WebRTC IP 처리의 중요 원리는 다음과 같다."),be=s(),_=i("ol"),w=i("li"),dl=i("p"),st=a("기본적으로 WebRTC 트래픽은 전통적인 IP 라우팅 방식을 따르며(HTTP 트래픽과 동일한 인터페이스를 사용함), application이 시스템의 public 주소를 볼 수 있어야 함."),vt=s(),Rl=i("ul"),cl=i("li"),pt=a("하지만 최적의 미디어 퀄리티를 위해 WebRTC는 모든 네트워크 인터페이스에서 최적의 경로를 찾을 수 있어야 함."),Tt=s(),Pl=i("li"),ul=i("p"),Et=a("WebRTC는 NAT 순회 또는 TURN을 사용하지 않고 엔드포인트간의 직접적인 p2p 연결이 가능한 경우, 그렇게 해야 함. 이로써 p2p 라우팅을 필요로하는 애플리케이션이 성공적으로 동작할 수 있음."),_t=s(),bl=i("li"),Il=i("p"),dt=a("WebRTC가 private IP를 공개하지 않기를 원한다면, 이를 설정할 수 있어야 함. 단 이게 기본 설정은 아님."),Rt=s(),Cl=i("li"),Ll=i("p"),ct=a("기본 설정으로 WebRTC 트래픽은 프록시 서버를 통해 전송되지는 않아야 함. 이는 프록시를 사용하여 통신하는 경우 WebRTC 트래픽이 TCP를 통해 전송되기 때문에 성능 문제가 발생하기 때문임. 또한 WebRTC의 long-lived, high bandwidth인 연결이 프록시를 통하면 성능 문제가 생김. 하지만 클라이언트가 원할 경우 프록시를 통하여 WebRTC 연결을 보내도록 설정할 수 있어야 함."),Ie=s(),$=i("p"),Pt=a("이러한 원리에 기반하여, WebRTC 동작에 대한 4개의 모드를 정의할 수 있음."),Ce=s(),d=i("ol"),F=i("li"),Ul=i("p"),ut=a("모든 주소를 열거함"),bt=s(),u=i("ul"),nl=i("li"),It=a("WebRTC는 모든 네트워크 인터페이스를 사용하여 STUN, TURN, 피어와 통신을 시도함."),Ct=s(),hl=i("li"),Lt=a("이를 통해 최선의 미디어 경로를 찾음."),Ut=s(),Wl=i("li"),nt=a("미디어 성능이 최우선적으로 중요할 때 사용하지만 많은 정보가 공개됨."),ht=s(),M=i("li"),Nl=i("p"),Wt=a("기본 경로 + 연관된 로컬 주소"),Nt=s(),b=i("ul"),ml=i("li"),mt=a("WebRTC는 커널의 라우팅 테이블을 따라야 하며, 이 경우 일반적으로 미디어 패킷이 HTTP 트래픽과 같은 경로를 타게 됨."),Dt=s(),Dl=i("li"),St=a("만약 TURN 서버가 존재하는 경우, TRUN 서버를 통과하는 경로를 선호함."),xt=s(),Sl=i("li"),Ht=a("인터페이스가 선택되면, 이 인터페이스와 연관된 private ipv4 및 ipv6 주소를 찾아 호스트 후보로 어플리케이션에 전달됨. 이로써 이 모드에서 직접적인 연결이 생성될 수 있음."),At=s(),q=i("li"),xl=i("p"),Ot=a("기본 경로만 사용"),kt=s(),I=i("ul"),Hl=i("li"),Bt=a("이 모드는 (2)의 모드와 비슷하지만, 연관된 private 주소가 제공되지 않음."),wt=s(),Al=i("li"),Ft=a("수집된 IP주소는 기본 경로에서 STUN 및 TURN과 같은 매커니즘을 통해 검색된 IP주소 이외엔 없음."),Mt=s(),Ol=i("li"),qt=a("하지만 트래픽이 NAT를 통과하거나, TURN 서버를 통하거나, 모두 실패하여 품질에 영향을 미칠 수 있음."),yt=s(),y=i("li"),kl=i("p"),Zt=a("프록시 강제"),jt=s(),C=i("ul"),Bl=i("li"),zt=a("(3)의 모드와 동일하지만 HTTP 트래픽이 프록시를 통하는 경우, WebRTC의 트래픽도 프록시를 통하게 됨."),Gt=s(),wl=i("li"),Jt=a("만약 프록시가 UDP를 지원하지 않거나 WebRTC 구현이 UDP 프록시를 지원하지 않는경우, WebRTC는 UDP를 사용하지 않고 TCP를 사용하여 프록시를 통해 전송 및 수신함."),Kt=s(),Fl=i("li"),Qt=a("TCP를 사용하면 미디어 품질 및 전송시 성능이 감소함."),Le=s(),Ue=i("br"),ne=s(),S=i("p"),Vt=a("이때 사용자 동의가 없는 한 모드 1을 사용하지 않는다. 사용자 정의에 관련된 부분은 "),Ml=i("code"),Xt=a("getUserMedia"),Yt=a(" 등에서 얻을 수 있는 듯 함. 동의가 없는 경우 모드 2를 사용한다."),he=s(),R=i("ul"),ql=i("li"),$t=a("즉, 모드 2는 별다른 동의 없이 최적의 네트워크 성능을 달성할 수 있게끔 하는 합리적인 절충안이라고 볼 수 있음"),gt=s(),yl=i("li"),li=a("직접 연결을 달성하는데 필요한 최소 정보만 동의 없이 어플리케이션에 제공"),ei=s(),Zl=i("li"),ti=a("하지만 사용자 요구에 따라, 필요하다면 더 엄격한 모드를 선택함."),We=s(),Ne=i("br"),me=s(),g=i("p"),ii=a("제안된 기본값음 모든 외부 WebRTC 트래픽이 프록시나 TURN 서버를 통과하게끔 원하는 조직도 사용 가능함"),De=s(),x=i("ul"),jl=i("li"),oi=a("WebRTC 트래픽이 프록시나 TURN 서버를 통해서만 나가도록 조직의 방화벽 정책을 설정하면 됨"),ri=s(),zl=i("li"),ai=a("프록시나 TURN 서버가 외부 트래픽에 사용되지만, 조직 내 트래픽에 직접 연결될 수 있으며, 프록시의 경우 성능 문제를 방지할 수 있음"),Se=s(),xe=i("br"),He=i("br"),Ae=s(),H=i("h2"),A=i("a"),Gl=i("span"),fi=a("구현 가이드"),Oe=s(),ll=i("p"),si=a("위 정책을 구현하는 방법에 대한 WebRTC 구현 지침"),ke=s(),c=i("ol"),Z=i("li"),Jl=i("p"),vi=a("정상 라우팅 보장"),pi=s(),Kl=i("ul"),O=i("li"),Ti=a("모드 2 또는 모드 3과 같은 전통적인 IP 라우팅을 시도하는 경우, 가장 간단한 방법은 와일드카드 주소(IPv4의 0.0.0.0 및 IPv6의 ::)로 소켓을 "),Ql=i("code"),Ei=a("bind()"),_i=a("하는 것임."),Vl=i("ul"),Xl=i("li"),di=a("이렇게 하면 OS는 HTTP 트래픽과 동일한 방식으로 WebRTC 트래픽을 라우팅할 것이며, STUN과 TURN도 평소대로 사용되고, 호스트 후보는 아래 언급된 것처럼 여전히 결정될 수 있음."),Ri=s(),j=i("li"),Yl=i("p"),ci=a("연관된 로컬 주소 결정"),Pi=s(),L=i("ul"),el=i("li"),ui=a("와일드카드 주소를 바인딩할 때, 모드 2에 필요한 연관된 로컬 주소를 결정하려면 추가적인 작업이 필요함."),z=i("ul"),$l=i("li"),bi=a("로컬 주소는 웹 애플리케이션 호스트로 전송되는 모든 패킷의 source address로 정의됨."),Ii=s(),gl=i("li"),Ci=a("웹 애플리케이션 호스트를 destination으로 사용하면 애플리케이션의 위치에 관계 없이 올바른 source address가 선택됨."),Li=s(),le=i("li"),Ui=a("웹 애플리케이션 URI의 호스트 컴포넌트를 resolve하여 적절한 remote IPv4/IPv6 주소를 얻음. 클라이언트가 프록시 뒤에 있고 DNS를 통해 IP를 resolve할 수 없는 경우, 프록시의 주소를 대신 사용함."),ni=s(),P=i("li"),hi=a("일단 적절한 원격 IP가 결정되면, UDP 소켓을 적절한 와일드카드 주소에 "),ee=i("code"),Wi=a("bind()"),Ni=a("하고 원격 IP에 "),te=i("code"),mi=a("connect()"),Di=a("함."),G=i("ul"),ie=i("li"),Si=a("일반적으로 이 소켓은 네트워크를 통해 패킷을 보내지 않고 커널의 라우팅 테이블을 바탕으로 로컬 주소를 할당받음."),xi=s(),J=i("li"),Hi=a("결과적으로 이 소켓으로 "),oe=i("code"),Ai=a("getsocketname()"),Oi=a(" 등을 호출하여 적절한 로컬 주소를 확인할 수 있음."),ki=s(),U=i("li"),re=i("p"),Bi=a("어플리케이션 동작"),wi=s(),ae=i("p"),Fi=a("WebRTC를 사용하는 애플리케이션이 잘못 동작하지 않게끔, 다음과 같은 가이드라인을 제공함."),Mi=s(),K=i("ul"),fe=i("li"),qi=a("모드 3 및 4를 지원하기 위해서는 UDP 및 TCP 연결을 모두 지원하는 TURN 서버를 배포해야 함."),yi=s(),se=i("li"),Zi=a("어플리케이션은 host candidate의 존재 유무를 확인하여 모든 ICE candidates에 접근할 수 없는 경우를 감지할 수 있어야 함. host candidate가 없다면 모드 3 및 4를 사용중인 경우임."),Be=s(),we=i("br"),Fe=i("br"),this.h()},l(e){n=o(e,"P",{});var p=r(n);ge=f(p,`학교 프로젝트 진행 중 정리한 RFC8835의 내용을 블로그에 포스팅해봅니다.
필요한 내용만 정리하였기 때문에 일부 내용은 생략되었을 수 있습니다.`),p.forEach(t),pe=v(e),h=o(e,"H2",{id:!0});var ji=r(h);W=o(ji,"A",{"aria-hidden":!0,tabindex:!0,href:!0});var Qi=r(W);pl=o(Qi,"SPAN",{class:!0}),r(pl).forEach(t),Qi.forEach(t),lt=f(ji,"개요"),ji.forEach(t),Te=v(e),V=o(e,"P",{});var Vi=r(V);et=f(Vi,`인터넷에서 오가는 모든 데이터는 Congestion Control이 필요하다.
그런데 WebRTC와 같이 상호 작용, 낮은 딜레이, 약간의 신뢰성을 필요로 하는 실시간 p2p 미디어 전송 프로토콜의 경우, FTP나 웹 페이지에서 필요로 하는 것과는 다소 다른 요구사항을 가진다. 따라서 이런 프로토콜의 트래픽을 처리하기 위한 Congestion control 방법이 필요하다.`),Vi.forEach(t),Ee=v(e),X=o(e,"P",{});var Xi=r(X);tt=f(Xi,"스트리밍되는 실시간 데이터는 다음과 같은 요구사항을 가진다."),Xi.forEach(t),_e=v(e),N=o(e,"UL",{});var Me=r(N);Tl=o(Me,"LI",{});var Yi=r(Tl);it=f(Yi,"제한된 Time window 안에 데이터를 끊임없이 전송해야 함."),Yi.forEach(t),ot=v(Me),El=o(Me,"LI",{});var $i=r(El);rt=f($i,"일부 packet의 loss가 일어나더라도 데이터를 실시간으로 보내는 게 더 높은 우선순위"),$i.forEach(t),Me.forEach(t),de=v(e),Re=o(e,"BR",{}),ce=o(e,"BR",{}),Pe=v(e),m=o(e,"H2",{id:!0});var zi=r(m);D=o(zi,"A",{"aria-hidden":!0,tabindex:!0,href:!0});var gi=r(D);_l=o(gi,"SPAN",{class:!0}),r(_l).forEach(t),gi.forEach(t),at=f(zi,"원리"),zi.forEach(t),ue=v(e),Y=o(e,"P",{});var lo=r(Y);ft=f(lo,"WebRTC IP 처리의 중요 원리는 다음과 같다."),lo.forEach(t),be=v(e),_=o(e,"OL",{});var k=r(_);w=o(k,"LI",{});var qe=r(w);dl=o(qe,"P",{});var eo=r(dl);st=f(eo,"기본적으로 WebRTC 트래픽은 전통적인 IP 라우팅 방식을 따르며(HTTP 트래픽과 동일한 인터페이스를 사용함), application이 시스템의 public 주소를 볼 수 있어야 함."),eo.forEach(t),vt=v(qe),Rl=o(qe,"UL",{});var to=r(Rl);cl=o(to,"LI",{});var io=r(cl);pt=f(io,"하지만 최적의 미디어 퀄리티를 위해 WebRTC는 모든 네트워크 인터페이스에서 최적의 경로를 찾을 수 있어야 함."),io.forEach(t),to.forEach(t),qe.forEach(t),Tt=v(k),Pl=o(k,"LI",{});var oo=r(Pl);ul=o(oo,"P",{});var ro=r(ul);Et=f(ro,"WebRTC는 NAT 순회 또는 TURN을 사용하지 않고 엔드포인트간의 직접적인 p2p 연결이 가능한 경우, 그렇게 해야 함. 이로써 p2p 라우팅을 필요로하는 애플리케이션이 성공적으로 동작할 수 있음."),ro.forEach(t),oo.forEach(t),_t=v(k),bl=o(k,"LI",{});var ao=r(bl);Il=o(ao,"P",{});var fo=r(Il);dt=f(fo,"WebRTC가 private IP를 공개하지 않기를 원한다면, 이를 설정할 수 있어야 함. 단 이게 기본 설정은 아님."),fo.forEach(t),ao.forEach(t),Rt=v(k),Cl=o(k,"LI",{});var so=r(Cl);Ll=o(so,"P",{});var vo=r(Ll);ct=f(vo,"기본 설정으로 WebRTC 트래픽은 프록시 서버를 통해 전송되지는 않아야 함. 이는 프록시를 사용하여 통신하는 경우 WebRTC 트래픽이 TCP를 통해 전송되기 때문에 성능 문제가 발생하기 때문임. 또한 WebRTC의 long-lived, high bandwidth인 연결이 프록시를 통하면 성능 문제가 생김. 하지만 클라이언트가 원할 경우 프록시를 통하여 WebRTC 연결을 보내도록 설정할 수 있어야 함."),vo.forEach(t),so.forEach(t),k.forEach(t),Ie=v(e),$=o(e,"P",{});var po=r($);Pt=f(po,"이러한 원리에 기반하여, WebRTC 동작에 대한 4개의 모드를 정의할 수 있음."),po.forEach(t),Ce=v(e),d=o(e,"OL",{});var B=r(d);F=o(B,"LI",{});var ye=r(F);Ul=o(ye,"P",{});var To=r(Ul);ut=f(To,"모든 주소를 열거함"),To.forEach(t),bt=v(ye),u=o(ye,"UL",{});var tl=r(u);nl=o(tl,"LI",{});var Eo=r(nl);It=f(Eo,"WebRTC는 모든 네트워크 인터페이스를 사용하여 STUN, TURN, 피어와 통신을 시도함."),Eo.forEach(t),Ct=v(tl),hl=o(tl,"LI",{});var _o=r(hl);Lt=f(_o,"이를 통해 최선의 미디어 경로를 찾음."),_o.forEach(t),Ut=v(tl),Wl=o(tl,"LI",{});var Ro=r(Wl);nt=f(Ro,"미디어 성능이 최우선적으로 중요할 때 사용하지만 많은 정보가 공개됨."),Ro.forEach(t),tl.forEach(t),ye.forEach(t),ht=v(B),M=o(B,"LI",{});var Ze=r(M);Nl=o(Ze,"P",{});var co=r(Nl);Wt=f(co,"기본 경로 + 연관된 로컬 주소"),co.forEach(t),Nt=v(Ze),b=o(Ze,"UL",{});var il=r(b);ml=o(il,"LI",{});var Po=r(ml);mt=f(Po,"WebRTC는 커널의 라우팅 테이블을 따라야 하며, 이 경우 일반적으로 미디어 패킷이 HTTP 트래픽과 같은 경로를 타게 됨."),Po.forEach(t),Dt=v(il),Dl=o(il,"LI",{});var uo=r(Dl);St=f(uo,"만약 TURN 서버가 존재하는 경우, TRUN 서버를 통과하는 경로를 선호함."),uo.forEach(t),xt=v(il),Sl=o(il,"LI",{});var bo=r(Sl);Ht=f(bo,"인터페이스가 선택되면, 이 인터페이스와 연관된 private ipv4 및 ipv6 주소를 찾아 호스트 후보로 어플리케이션에 전달됨. 이로써 이 모드에서 직접적인 연결이 생성될 수 있음."),bo.forEach(t),il.forEach(t),Ze.forEach(t),At=v(B),q=o(B,"LI",{});var je=r(q);xl=o(je,"P",{});var Io=r(xl);Ot=f(Io,"기본 경로만 사용"),Io.forEach(t),kt=v(je),I=o(je,"UL",{});var ol=r(I);Hl=o(ol,"LI",{});var Co=r(Hl);Bt=f(Co,"이 모드는 (2)의 모드와 비슷하지만, 연관된 private 주소가 제공되지 않음."),Co.forEach(t),wt=v(ol),Al=o(ol,"LI",{});var Lo=r(Al);Ft=f(Lo,"수집된 IP주소는 기본 경로에서 STUN 및 TURN과 같은 매커니즘을 통해 검색된 IP주소 이외엔 없음."),Lo.forEach(t),Mt=v(ol),Ol=o(ol,"LI",{});var Uo=r(Ol);qt=f(Uo,"하지만 트래픽이 NAT를 통과하거나, TURN 서버를 통하거나, 모두 실패하여 품질에 영향을 미칠 수 있음."),Uo.forEach(t),ol.forEach(t),je.forEach(t),yt=v(B),y=o(B,"LI",{});var ze=r(y);kl=o(ze,"P",{});var no=r(kl);Zt=f(no,"프록시 강제"),no.forEach(t),jt=v(ze),C=o(ze,"UL",{});var rl=r(C);Bl=o(rl,"LI",{});var ho=r(Bl);zt=f(ho,"(3)의 모드와 동일하지만 HTTP 트래픽이 프록시를 통하는 경우, WebRTC의 트래픽도 프록시를 통하게 됨."),ho.forEach(t),Gt=v(rl),wl=o(rl,"LI",{});var Wo=r(wl);Jt=f(Wo,"만약 프록시가 UDP를 지원하지 않거나 WebRTC 구현이 UDP 프록시를 지원하지 않는경우, WebRTC는 UDP를 사용하지 않고 TCP를 사용하여 프록시를 통해 전송 및 수신함."),Wo.forEach(t),Kt=v(rl),Fl=o(rl,"LI",{});var No=r(Fl);Qt=f(No,"TCP를 사용하면 미디어 품질 및 전송시 성능이 감소함."),No.forEach(t),rl.forEach(t),ze.forEach(t),B.forEach(t),Le=v(e),Ue=o(e,"BR",{}),ne=v(e),S=o(e,"P",{});var Ge=r(S);Vt=f(Ge,"이때 사용자 동의가 없는 한 모드 1을 사용하지 않는다. 사용자 정의에 관련된 부분은 "),Ml=o(Ge,"CODE",{});var mo=r(Ml);Xt=f(mo,"getUserMedia"),mo.forEach(t),Yt=f(Ge," 등에서 얻을 수 있는 듯 함. 동의가 없는 경우 모드 2를 사용한다."),Ge.forEach(t),he=v(e),R=o(e,"UL",{});var al=r(R);ql=o(al,"LI",{});var Do=r(ql);$t=f(Do,"즉, 모드 2는 별다른 동의 없이 최적의 네트워크 성능을 달성할 수 있게끔 하는 합리적인 절충안이라고 볼 수 있음"),Do.forEach(t),gt=v(al),yl=o(al,"LI",{});var So=r(yl);li=f(So,"직접 연결을 달성하는데 필요한 최소 정보만 동의 없이 어플리케이션에 제공"),So.forEach(t),ei=v(al),Zl=o(al,"LI",{});var xo=r(Zl);ti=f(xo,"하지만 사용자 요구에 따라, 필요하다면 더 엄격한 모드를 선택함."),xo.forEach(t),al.forEach(t),We=v(e),Ne=o(e,"BR",{}),me=v(e),g=o(e,"P",{});var Ho=r(g);ii=f(Ho,"제안된 기본값음 모든 외부 WebRTC 트래픽이 프록시나 TURN 서버를 통과하게끔 원하는 조직도 사용 가능함"),Ho.forEach(t),De=v(e),x=o(e,"UL",{});var Je=r(x);jl=o(Je,"LI",{});var Ao=r(jl);oi=f(Ao,"WebRTC 트래픽이 프록시나 TURN 서버를 통해서만 나가도록 조직의 방화벽 정책을 설정하면 됨"),Ao.forEach(t),ri=v(Je),zl=o(Je,"LI",{});var Oo=r(zl);ai=f(Oo,"프록시나 TURN 서버가 외부 트래픽에 사용되지만, 조직 내 트래픽에 직접 연결될 수 있으며, 프록시의 경우 성능 문제를 방지할 수 있음"),Oo.forEach(t),Je.forEach(t),Se=v(e),xe=o(e,"BR",{}),He=o(e,"BR",{}),Ae=v(e),H=o(e,"H2",{id:!0});var Gi=r(H);A=o(Gi,"A",{"aria-hidden":!0,tabindex:!0,href:!0});var ko=r(A);Gl=o(ko,"SPAN",{class:!0}),r(Gl).forEach(t),ko.forEach(t),fi=f(Gi,"구현 가이드"),Gi.forEach(t),Oe=v(e),ll=o(e,"P",{});var Bo=r(ll);si=f(Bo,"위 정책을 구현하는 방법에 대한 WebRTC 구현 지침"),Bo.forEach(t),ke=v(e),c=o(e,"OL",{});var fl=r(c);Z=o(fl,"LI",{});var Ke=r(Z);Jl=o(Ke,"P",{});var wo=r(Jl);vi=f(wo,"정상 라우팅 보장"),wo.forEach(t),pi=v(Ke),Kl=o(Ke,"UL",{});var Fo=r(Kl);O=o(Fo,"LI",{});var ve=r(O);Ti=f(ve,"모드 2 또는 모드 3과 같은 전통적인 IP 라우팅을 시도하는 경우, 가장 간단한 방법은 와일드카드 주소(IPv4의 0.0.0.0 및 IPv6의 ::)로 소켓을 "),Ql=o(ve,"CODE",{});var Mo=r(Ql);Ei=f(Mo,"bind()"),Mo.forEach(t),_i=f(ve,"하는 것임."),Vl=o(ve,"UL",{});var qo=r(Vl);Xl=o(qo,"LI",{});var yo=r(Xl);di=f(yo,"이렇게 하면 OS는 HTTP 트래픽과 동일한 방식으로 WebRTC 트래픽을 라우팅할 것이며, STUN과 TURN도 평소대로 사용되고, 호스트 후보는 아래 언급된 것처럼 여전히 결정될 수 있음."),yo.forEach(t),qo.forEach(t),ve.forEach(t),Fo.forEach(t),Ke.forEach(t),Ri=v(fl),j=o(fl,"LI",{});var Qe=r(j);Yl=o(Qe,"P",{});var Zo=r(Yl);ci=f(Zo,"연관된 로컬 주소 결정"),Zo.forEach(t),Pi=v(Qe),L=o(Qe,"UL",{});var sl=r(L);el=o(sl,"LI",{});var Ji=r(el);ui=f(Ji,"와일드카드 주소를 바인딩할 때, 모드 2에 필요한 연관된 로컬 주소를 결정하려면 추가적인 작업이 필요함."),z=o(Ji,"UL",{});var Ve=r(z);$l=o(Ve,"LI",{});var jo=r($l);bi=f(jo,"로컬 주소는 웹 애플리케이션 호스트로 전송되는 모든 패킷의 source address로 정의됨."),jo.forEach(t),Ii=v(Ve),gl=o(Ve,"LI",{});var zo=r(gl);Ci=f(zo,"웹 애플리케이션 호스트를 destination으로 사용하면 애플리케이션의 위치에 관계 없이 올바른 source address가 선택됨."),zo.forEach(t),Ve.forEach(t),Ji.forEach(t),Li=v(sl),le=o(sl,"LI",{});var Go=r(le);Ui=f(Go,"웹 애플리케이션 URI의 호스트 컴포넌트를 resolve하여 적절한 remote IPv4/IPv6 주소를 얻음. 클라이언트가 프록시 뒤에 있고 DNS를 통해 IP를 resolve할 수 없는 경우, 프록시의 주소를 대신 사용함."),Go.forEach(t),ni=v(sl),P=o(sl,"LI",{});var Q=r(P);hi=f(Q,"일단 적절한 원격 IP가 결정되면, UDP 소켓을 적절한 와일드카드 주소에 "),ee=o(Q,"CODE",{});var Jo=r(ee);Wi=f(Jo,"bind()"),Jo.forEach(t),Ni=f(Q,"하고 원격 IP에 "),te=o(Q,"CODE",{});var Ko=r(te);mi=f(Ko,"connect()"),Ko.forEach(t),Di=f(Q,"함."),G=o(Q,"UL",{});var Xe=r(G);ie=o(Xe,"LI",{});var Qo=r(ie);Si=f(Qo,"일반적으로 이 소켓은 네트워크를 통해 패킷을 보내지 않고 커널의 라우팅 테이블을 바탕으로 로컬 주소를 할당받음."),Qo.forEach(t),xi=v(Xe),J=o(Xe,"LI",{});var Ye=r(J);Hi=f(Ye,"결과적으로 이 소켓으로 "),oe=o(Ye,"CODE",{});var Vo=r(oe);Ai=f(Vo,"getsocketname()"),Vo.forEach(t),Oi=f(Ye," 등을 호출하여 적절한 로컬 주소를 확인할 수 있음."),Ye.forEach(t),Xe.forEach(t),Q.forEach(t),sl.forEach(t),Qe.forEach(t),ki=v(fl),U=o(fl,"LI",{});var vl=r(U);re=o(vl,"P",{});var Xo=r(re);Bi=f(Xo,"어플리케이션 동작"),Xo.forEach(t),wi=v(vl),ae=o(vl,"P",{});var Yo=r(ae);Fi=f(Yo,"WebRTC를 사용하는 애플리케이션이 잘못 동작하지 않게끔, 다음과 같은 가이드라인을 제공함."),Yo.forEach(t),Mi=v(vl),K=o(vl,"UL",{});var $e=r(K);fe=o($e,"LI",{});var $o=r(fe);qi=f($o,"모드 3 및 4를 지원하기 위해서는 UDP 및 TCP 연결을 모두 지원하는 TURN 서버를 배포해야 함."),$o.forEach(t),yi=v($e),se=o($e,"LI",{});var go=r(se);Zi=f(go,"어플리케이션은 host candidate의 존재 유무를 확인하여 모든 ICE candidates에 접근할 수 없는 경우를 감지할 수 있어야 함. host candidate가 없다면 모드 3 및 4를 사용중인 경우임."),go.forEach(t),$e.forEach(t),vl.forEach(t),fl.forEach(t),Be=v(e),we=o(e,"BR",{}),Fe=o(e,"BR",{}),this.h()},h(){E(pl,"class","icon icon-link"),E(W,"aria-hidden","true"),E(W,"tabindex","-1"),E(W,"href","#개요"),E(h,"id","개요"),E(_l,"class","icon icon-link"),E(D,"aria-hidden","true"),E(D,"tabindex","-1"),E(D,"href","#원리"),E(m,"id","원리"),E(Gl,"class","icon icon-link"),E(A,"aria-hidden","true"),E(A,"tabindex","-1"),E(A,"href","#구현-가이드"),E(H,"id","구현-가이드")},m(e,p){T(e,n,p),l(n,ge),T(e,pe,p),T(e,h,p),l(h,W),l(W,pl),l(h,lt),T(e,Te,p),T(e,V,p),l(V,et),T(e,Ee,p),T(e,X,p),l(X,tt),T(e,_e,p),T(e,N,p),l(N,Tl),l(Tl,it),l(N,ot),l(N,El),l(El,rt),T(e,de,p),T(e,Re,p),T(e,ce,p),T(e,Pe,p),T(e,m,p),l(m,D),l(D,_l),l(m,at),T(e,ue,p),T(e,Y,p),l(Y,ft),T(e,be,p),T(e,_,p),l(_,w),l(w,dl),l(dl,st),l(w,vt),l(w,Rl),l(Rl,cl),l(cl,pt),l(_,Tt),l(_,Pl),l(Pl,ul),l(ul,Et),l(_,_t),l(_,bl),l(bl,Il),l(Il,dt),l(_,Rt),l(_,Cl),l(Cl,Ll),l(Ll,ct),T(e,Ie,p),T(e,$,p),l($,Pt),T(e,Ce,p),T(e,d,p),l(d,F),l(F,Ul),l(Ul,ut),l(F,bt),l(F,u),l(u,nl),l(nl,It),l(u,Ct),l(u,hl),l(hl,Lt),l(u,Ut),l(u,Wl),l(Wl,nt),l(d,ht),l(d,M),l(M,Nl),l(Nl,Wt),l(M,Nt),l(M,b),l(b,ml),l(ml,mt),l(b,Dt),l(b,Dl),l(Dl,St),l(b,xt),l(b,Sl),l(Sl,Ht),l(d,At),l(d,q),l(q,xl),l(xl,Ot),l(q,kt),l(q,I),l(I,Hl),l(Hl,Bt),l(I,wt),l(I,Al),l(Al,Ft),l(I,Mt),l(I,Ol),l(Ol,qt),l(d,yt),l(d,y),l(y,kl),l(kl,Zt),l(y,jt),l(y,C),l(C,Bl),l(Bl,zt),l(C,Gt),l(C,wl),l(wl,Jt),l(C,Kt),l(C,Fl),l(Fl,Qt),T(e,Le,p),T(e,Ue,p),T(e,ne,p),T(e,S,p),l(S,Vt),l(S,Ml),l(Ml,Xt),l(S,Yt),T(e,he,p),T(e,R,p),l(R,ql),l(ql,$t),l(R,gt),l(R,yl),l(yl,li),l(R,ei),l(R,Zl),l(Zl,ti),T(e,We,p),T(e,Ne,p),T(e,me,p),T(e,g,p),l(g,ii),T(e,De,p),T(e,x,p),l(x,jl),l(jl,oi),l(x,ri),l(x,zl),l(zl,ai),T(e,Se,p),T(e,xe,p),T(e,He,p),T(e,Ae,p),T(e,H,p),l(H,A),l(A,Gl),l(H,fi),T(e,Oe,p),T(e,ll,p),l(ll,si),T(e,ke,p),T(e,c,p),l(c,Z),l(Z,Jl),l(Jl,vi),l(Z,pi),l(Z,Kl),l(Kl,O),l(O,Ti),l(O,Ql),l(Ql,Ei),l(O,_i),l(O,Vl),l(Vl,Xl),l(Xl,di),l(c,Ri),l(c,j),l(j,Yl),l(Yl,ci),l(j,Pi),l(j,L),l(L,el),l(el,ui),l(el,z),l(z,$l),l($l,bi),l(z,Ii),l(z,gl),l(gl,Ci),l(L,Li),l(L,le),l(le,Ui),l(L,ni),l(L,P),l(P,hi),l(P,ee),l(ee,Wi),l(P,Ni),l(P,te),l(te,mi),l(P,Di),l(P,G),l(G,ie),l(ie,Si),l(G,xi),l(G,J),l(J,Hi),l(J,oe),l(oe,Ai),l(J,Oi),l(c,ki),l(c,U),l(U,re),l(re,Bi),l(U,wi),l(U,ae),l(ae,Fi),l(U,Mi),l(U,K),l(K,fe),l(fe,qi),l(K,yi),l(K,se),l(se,Zi),T(e,Be,p),T(e,we,p),T(e,Fe,p)},p:Ki,i:Ki,o:Ki,d(e){e&&t(n),e&&t(pe),e&&t(h),e&&t(Te),e&&t(V),e&&t(Ee),e&&t(X),e&&t(_e),e&&t(N),e&&t(de),e&&t(Re),e&&t(ce),e&&t(Pe),e&&t(m),e&&t(ue),e&&t(Y),e&&t(be),e&&t(_),e&&t(Ie),e&&t($),e&&t(Ce),e&&t(d),e&&t(Le),e&&t(Ue),e&&t(ne),e&&t(S),e&&t(he),e&&t(R),e&&t(We),e&&t(Ne),e&&t(me),e&&t(g),e&&t(De),e&&t(x),e&&t(Se),e&&t(xe),e&&t(He),e&&t(Ae),e&&t(H),e&&t(Oe),e&&t(ll),e&&t(ke),e&&t(c),e&&t(Be),e&&t(we),e&&t(Fe)}}}const ar={title:"RFC8836: Congestion Control Requirements for Interactive Real-Time Media 정리",date:"2023-04-17T00:00:00.000Z",excerpt:"RFC8836을 정리해보았습니다",categories:["WebRTC","논문정리"],coverImage:"/post_img/Networking/WebRTC/cover.png",coverWidth:16,coverHeight:9,indexed:!0,exposed:!0};class fr extends er{constructor(n){super(),tr(this,n,null,or,ir,{})}}export{fr as default,ar as metadata};
