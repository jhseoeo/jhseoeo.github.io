import{S as nn,i as en,s as tn,k as p,q as i,a as r,l,m as o,r as c,h as s,c as u,n as k,U as pn,b as e,E as t,M as Os}from"./index.d78780bf.js";function ln(Ks){let v,Ba,sa,_,d,W,Ja,na,ea,ta,w,Ua,pa,R,Qs=`<code class="language-go"><span class="token keyword">func</span> <span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token keyword">func</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token builtin">error</span>
<span class="token keyword">func</span> <span class="token punctuation">(</span>TIn<span class="token punctuation">)</span> <span class="token builtin">error</span>
<span class="token keyword">func</span> <span class="token punctuation">(</span>context<span class="token punctuation">.</span>Context<span class="token punctuation">)</span> <span class="token builtin">error</span>
<span class="token keyword">func</span> <span class="token punctuation">(</span>context<span class="token punctuation">.</span>Context<span class="token punctuation">,</span> TIn<span class="token punctuation">)</span> <span class="token builtin">error</span>
<span class="token keyword">func</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">(</span>TOut<span class="token punctuation">,</span> <span class="token builtin">error</span><span class="token punctuation">)</span>
<span class="token keyword">func</span> <span class="token punctuation">(</span>context<span class="token punctuation">.</span>Context<span class="token punctuation">)</span> <span class="token punctuation">(</span>TOut<span class="token punctuation">,</span> <span class="token builtin">error</span><span class="token punctuation">)</span>
<span class="token keyword">func</span> <span class="token punctuation">(</span>context<span class="token punctuation">.</span>Context<span class="token punctuation">,</span> TIn<span class="token punctuation">)</span> <span class="token punctuation">(</span>TOut<span class="token punctuation">,</span> <span class="token builtin">error</span><span class="token punctuation">)</span></code>`,la,E,Wa,q,qa,Za,oa,f,ja,Z,za,Ka,j,Qa,Va,ia,m,Xa,z,Ya,ha,K,ga,as,ca,$,y,Rs,ra,G,ss,ua,ka,fa,b,ns,Q,es,ts,V,ps,ls,ma,I,os,X,is,cs,ba,va,_a,da,L,P,Y,rs,Ea,Ia,La,F,us,Pa,M,ks,Ca,A,Vs=`<code class="language-text">.
├── build
├── internal
│   ├── application
│   │   └── ...
│   ├── cmd
│   │   ├── Function-A
│   │   │   ├── main.go
│   │   │   └── main_test.go
│   │   ├── Function-B
│   │   │   ├── main.go
│   │   │   └── main_test.go
│   │   └── Function-C
│   │       ├── main.go
│   │       └── main_test.go
│   ├── domain
│   │   ├── model
│   │   └── service
│   ├── infrastructure
│   │   └── ...
│   └── interface
│       ├── dto
│       │   ├── request
│       │   └── response
│       └── handler
├── scripts
│   ├── deploy.sh
│   └── ...
├── go.mod
├── go.sum
├── .gitignore
└── ...</code>`,Ta,D,h,fs,ms,Oa,H,bs,Ra,Aa,Da,Na,C,T,g,vs,xa,wa,$a,S,_s,ya,N,Xs=`<code class="language-sh"><span class="token comment"># 파라미터 체크</span>
<span class="token keyword">if</span> <span class="token punctuation">[</span> <span class="token variable">$#</span> <span class="token parameter variable">-ne</span> <span class="token number">1</span> <span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token keyword">then</span>
  <span class="token builtin class-name">echo</span> <span class="token string">"Usage: <span class="token variable">$0</span> &lt;function name>"</span>
  <span class="token builtin class-name">exit</span> <span class="token number">1</span>
<span class="token keyword">fi</span>

<span class="token comment"># 변수 설정</span>
<span class="token assign-left variable">PROJECT_DIR</span><span class="token operator">=</span><span class="token string">"$(cd "<span class="token variable"><span class="token variable">$(</span><span class="token function">dirname</span> <span class="token string">"<span class="token variable">$0</span>"</span><span class="token variable">)</span></span>"</span> <span class="token operator">&amp;&amp;</span> <span class="token builtin class-name">pwd</span><span class="token punctuation">)</span>/<span class="token punctuation">..</span><span class="token string">"
FUNCTION_NAME="</span><span class="token variable">$1</span><span class="token string">"
LAMBDA_NAME="</span><span class="token variable">$FUNCTION_NAME</span><span class="token string">"
BIN_FILE="</span><span class="token variable">$PROJECT_DIR</span>/build/<span class="token variable">$FUNCTION_NAME</span><span class="token string">"
ZIP_FILE="</span><span class="token variable">$PROJECT_DIR</span>/build/function-<span class="token variable">$FUNCTION_NAME</span>.zip<span class="token string">"
PROFILE="</span><span class="token comment">#</span><span class="token comment">#프로필##"</span>

<span class="token comment"># 디렉토리명(함수명) 검사</span>
<span class="token keyword">if</span> <span class="token punctuation">[</span> <span class="token operator">!</span> <span class="token parameter variable">-d</span> <span class="token string">"<span class="token variable">$PROJECT_DIR</span>/internal/cmd/<span class="token variable">$FUNCTION_NAME</span>"</span> <span class="token punctuation">]</span><span class="token punctuation">;</span> <span class="token keyword">then</span>
  <span class="token builtin class-name">echo</span> <span class="token string">"The directory '<span class="token variable">$FUNCTION_NAME</span>' does not exist."</span>
  <span class="token builtin class-name">return</span> <span class="token number">1</span>
<span class="token keyword">fi</span>

<span class="token comment"># 빌드</span>
<span class="token builtin class-name">cd</span> <span class="token string">"<span class="token variable">$PROJECT_DIR</span>"</span> <span class="token operator">||</span> <span class="token builtin class-name">exit</span> <span class="token number">1</span>
<span class="token function">rm</span> <span class="token parameter variable">-f</span> <span class="token string">"<span class="token variable">$BIN_FILE</span>"</span> <span class="token string">"<span class="token variable">$ZIP_FILE</span>"</span>
<span class="token assign-left variable">GOOS</span><span class="token operator">=</span>linux <span class="token assign-left variable">GOARCH</span><span class="token operator">=</span>amd64 <span class="token assign-left variable">CGO_ENABLED</span><span class="token operator">=</span><span class="token number">0</span> go build <span class="token parameter variable">-o</span> <span class="token string">"<span class="token variable">$PROJECT_DIR</span>/build/<span class="token variable">$FUNCTION_NAME</span>"</span> <span class="token parameter variable">-C</span> <span class="token string">"<span class="token variable">$PROJECT_DIR</span>/internal/cmd/<span class="token variable">$FUNCTION_NAME</span>"</span> <span class="token string">"./..."</span>
<span class="token function">mv</span> <span class="token string">"<span class="token variable">$BIN_FILE</span>"</span> <span class="token string">"<span class="token variable">$PROJECT_DIR</span>/build/main"</span>
<span class="token function">zip</span> <span class="token parameter variable">-r</span> <span class="token parameter variable">-j</span> <span class="token string">"<span class="token variable">$ZIP_FILE</span>"</span> <span class="token string">"<span class="token variable">$PROJECT_DIR</span>/build/main"</span>
<span class="token function">rm</span> <span class="token parameter variable">-f</span> <span class="token string">"<span class="token variable">$PROJECT_DIR</span>/build/main"</span>
aws lambda update-function-code <span class="token punctuation"></span>
    --function-name <span class="token string">"<span class="token variable">$LAMBDA_NAME</span>"</span> <span class="token punctuation"></span>
    --zip-file <span class="token string">"fileb://<span class="token variable">$ZIP_FILE</span>"</span> <span class="token punctuation"></span>
    <span class="token parameter variable">--profile</span> <span class="token variable">$PROFILE</span></code>`,Ga,O,ds,aa,Es,Is,Fa,x,Ys='<code class="language-bash">./scripts/deploy.sh Function-A</code>';return{c(){v=p("p"),Ba=i("개인프로젝트를 하며 Lambda를 쓰게 되었고, 열심히 공부한 Golang으로 작성하게 되었다. 그 과정에서 겪은 여러 시행착오와 알게 된 것들을 정리해보려고 한다."),sa=r(),_=p("h2"),d=p("a"),W=p("span"),Ja=i("Handler 함수의 signature"),na=r(),ea=p("hr"),ta=r(),w=p("p"),Ua=i("Lambda 함수를 작성할 때, Handler 함수의 유효한 signature는 몇 가지가 있다."),pa=r(),R=p("pre"),la=r(),E=p("p"),Wa=i("위 signature는 모두 유효한 형태이다. "),q=p("code"),qa=i("func (context.Context, TIn) (TOut, error)"),Za=i("의 형태가 가장 이상적인 형태라고 볼 수 있다."),oa=r(),f=p("p"),ja=i("이 때 "),Z=p("code"),za=i("TIn"),Ka=i("과 "),j=p("code"),Qa=i("TOut"),Va=i("은 Lambda 함수의 event 및 response의 타입을 의미하며, 입력 및 출력 값이 알아서 unmarshal 및 marshal 된다."),ia=r(),m=p("p"),Xa=i("event로 어떤 데이터가 올지 모르는 경우 "),z=p("code"),Ya=i("interface{}"),ha=i("로 놓을 수 있다. 이 때는 "),K=p("code"),ga=i("map[string]interface{}"),as=i(`로 unmarshal 되는데, 데이터 구조를 대략적으로 확인할 수 있다.
거기다가 ChatGPT한테 golang struct 형태로 바꿔달라 하면 바꿔준다!`),ca=r(),$=p("p"),y=p("img"),ra=r(),G=p("p"),ss=i("오오 GPT는 신이야"),ua=r(),ka=p("br"),fa=r(),b=p("p"),ns=i("한편 Lambda 함수의 Invoke 조건을 API Gateway로 한 경우 Response의 데이터타입은 "),Q=p("code"),es=i("interface{}"),ts=i(`로 놓을 수 없다.
이게 Invoke 조건이 다를 때는 어떤지 잘 모르겠는데, API Gateway로 Invoke할 때는
Response 타입이 `),V=p("code"),ps=i("interface{}"),ls=i("이면 Lambda 함수가 실행되지 않는다. 이 때 로그상에 아무런 에러 메시지도 뜨지 않기 때문에 찾기가 힘들다."),ma=r(),I=p("p"),os=i("나의 경우 Golang이 Polymorphism을 지원하지 않고, 리턴 타입에 제네릭을 끼워넣기도 애매해서 핸들러의 리턴 타입을 "),X=p("code"),is=i("interface{}"),cs=i(`로 뒀었는데 갑자기 안됐었다.
이거 때문인 줄도 모르고 한참을 해맸다 ㅂㄷㅂㄷ..`),ba=r(),va=p("br"),_a=p("br"),da=r(),L=p("h2"),P=p("a"),Y=p("span"),rs=i("코드 중복을 줄이기 위한 패키지 구조"),Ea=r(),Ia=p("hr"),La=r(),F=p("p"),us=i(`API Gateway와 연결된 Lambda 함수의 경우, endpoint 및 method당 한 개의 Lambda 함수를 만드는 것이 일반적이다.
그 외에도 cronjob이나 S3 event 등 여러 용도와 목적으로 Lambda 함수가 만들어지다 보면 Lambda 함수의 개수가 꽤 많아질 수 있다.`),Pa=r(),M=p("p"),ks=i(`이 때 코드를 재활용하지 않고 각 Lambda 함수를 작성하면 코드가 엄청나게 중복된다.
이를 방지하기 위해 코드를 재활용할 수 있는 패키지 구조는 다음과 같다.`),Ca=r(),A=p("pre"),Ta=r(),D=p("p"),h=p("em"),fs=i("cmd"),ms=i(` 폴더 외에는 모두 DDD(Domain Driven Design) 패턴의 구조를 따른다.
cmd 폴더 안에는 각 Lambda 함수의 main 함수가 작성되어 있으며, 의존성 주입을 통해 각 Lambda 함수의 동작이 결정되기 때문에 코드 중복을 줄일 수 있다.`),Oa=r(),H=p("p"),bs=i("아마 다른 마이크로서비스 아키텍처에서도 비슷한 패턴을 사용할 수 있을 것이다."),Ra=r(),Aa=p("br"),Da=p("br"),Na=r(),C=p("h2"),T=p("a"),g=p("span"),vs=i("빌드 및 배포"),xa=r(),wa=p("hr"),$a=r(),S=p("p"),_s=i(`Lambda 함수가 많아진다는 것은 빌드 및 배포를 해야 할 대상이 많아진다는 것을 의미한다.
일일이 명령어를 하나씩 입력해가며 빌드 및 배포 과정을 거치는 것은 매우 비효율적이다.
위의 디렉토리 구조를 사용한다고 가정하고, 간단한 쉘 스크립트를 작성하여 빌드 및 배포 과정을 명령어 한 줄로 실행할 수 있도록 하자.`),ya=r(),N=p("pre"),Ga=r(),O=p("p"),ds=i("예를 들어 "),aa=p("em"),Es=i("Function-A"),Is=i("라는 Lambda 함수를 빌드 및 배포하고 싶다면, 다음과 같이 실행하면 된다."),Fa=r(),x=p("pre"),this.h()},l(a){v=l(a,"P",{});var n=o(v);Ba=c(n,"개인프로젝트를 하며 Lambda를 쓰게 되었고, 열심히 공부한 Golang으로 작성하게 되었다. 그 과정에서 겪은 여러 시행착오와 알게 된 것들을 정리해보려고 한다."),n.forEach(s),sa=u(a),_=l(a,"H2",{id:!0});var Ls=o(_);d=l(Ls,"A",{"aria-hidden":!0,tabindex:!0,href:!0});var As=o(d);W=l(As,"SPAN",{class:!0}),o(W).forEach(s),As.forEach(s),Ja=c(Ls,"Handler 함수의 signature"),Ls.forEach(s),na=u(a),ea=l(a,"HR",{}),ta=u(a),w=l(a,"P",{});var Ds=o(w);Ua=c(Ds,"Lambda 함수를 작성할 때, Handler 함수의 유효한 signature는 몇 가지가 있다."),Ds.forEach(s),pa=u(a),R=l(a,"PRE",{class:!0});var hs=o(R);hs.forEach(s),la=u(a),E=l(a,"P",{});var Ma=o(E);Wa=c(Ma,"위 signature는 모두 유효한 형태이다. "),q=l(Ma,"CODE",{});var Ns=o(q);qa=c(Ns,"func (context.Context, TIn) (TOut, error)"),Ns.forEach(s),Za=c(Ma,"의 형태가 가장 이상적인 형태라고 볼 수 있다."),Ma.forEach(s),oa=u(a),f=l(a,"P",{});var B=o(f);ja=c(B,"이 때 "),Z=l(B,"CODE",{});var xs=o(Z);za=c(xs,"TIn"),xs.forEach(s),Ka=c(B,"과 "),j=l(B,"CODE",{});var ws=o(j);Qa=c(ws,"TOut"),ws.forEach(s),Va=c(B,"은 Lambda 함수의 event 및 response의 타입을 의미하며, 입력 및 출력 값이 알아서 unmarshal 및 marshal 된다."),B.forEach(s),ia=u(a),m=l(a,"P",{});var J=o(m);Xa=c(J,"event로 어떤 데이터가 올지 모르는 경우 "),z=l(J,"CODE",{});var $s=o(z);Ya=c($s,"interface{}"),$s.forEach(s),ha=c(J,"로 놓을 수 있다. 이 때는 "),K=l(J,"CODE",{});var ys=o(K);ga=c(ys,"map[string]interface{}"),ys.forEach(s),as=c(J,`로 unmarshal 되는데, 데이터 구조를 대략적으로 확인할 수 있다.
거기다가 ChatGPT한테 golang struct 형태로 바꿔달라 하면 바꿔준다!`),J.forEach(s),ca=u(a),$=l(a,"P",{});var Gs=o($);y=l(Gs,"IMG",{src:!0,alt:!0}),Gs.forEach(s),ra=u(a),G=l(a,"P",{});var Fs=o(G);ss=c(Fs,"오오 GPT는 신이야"),Fs.forEach(s),ua=u(a),ka=l(a,"BR",{}),fa=u(a),b=l(a,"P",{});var U=o(b);ns=c(U,"한편 Lambda 함수의 Invoke 조건을 API Gateway로 한 경우 Response의 데이터타입은 "),Q=l(U,"CODE",{});var Ms=o(Q);es=c(Ms,"interface{}"),Ms.forEach(s),ts=c(U,`로 놓을 수 없다.
이게 Invoke 조건이 다를 때는 어떤지 잘 모르겠는데, API Gateway로 Invoke할 때는
Response 타입이 `),V=l(U,"CODE",{});var Hs=o(V);ps=c(Hs,"interface{}"),Hs.forEach(s),ls=c(U,"이면 Lambda 함수가 실행되지 않는다. 이 때 로그상에 아무런 에러 메시지도 뜨지 않기 때문에 찾기가 힘들다."),U.forEach(s),ma=u(a),I=l(a,"P",{});var Ha=o(I);os=c(Ha,"나의 경우 Golang이 Polymorphism을 지원하지 않고, 리턴 타입에 제네릭을 끼워넣기도 애매해서 핸들러의 리턴 타입을 "),X=l(Ha,"CODE",{});var Ss=o(X);is=c(Ss,"interface{}"),Ss.forEach(s),cs=c(Ha,`로 뒀었는데 갑자기 안됐었다.
이거 때문인 줄도 모르고 한참을 해맸다 ㅂㄷㅂㄷ..`),Ha.forEach(s),ba=u(a),va=l(a,"BR",{}),_a=l(a,"BR",{}),da=u(a),L=l(a,"H2",{id:!0});var Ps=o(L);P=l(Ps,"A",{"aria-hidden":!0,tabindex:!0,href:!0});var Bs=o(P);Y=l(Bs,"SPAN",{class:!0}),o(Y).forEach(s),Bs.forEach(s),rs=c(Ps,"코드 중복을 줄이기 위한 패키지 구조"),Ps.forEach(s),Ea=u(a),Ia=l(a,"HR",{}),La=u(a),F=l(a,"P",{});var Js=o(F);us=c(Js,`API Gateway와 연결된 Lambda 함수의 경우, endpoint 및 method당 한 개의 Lambda 함수를 만드는 것이 일반적이다.
그 외에도 cronjob이나 S3 event 등 여러 용도와 목적으로 Lambda 함수가 만들어지다 보면 Lambda 함수의 개수가 꽤 많아질 수 있다.`),Js.forEach(s),Pa=u(a),M=l(a,"P",{});var Us=o(M);ks=c(Us,`이 때 코드를 재활용하지 않고 각 Lambda 함수를 작성하면 코드가 엄청나게 중복된다.
이를 방지하기 위해 코드를 재활용할 수 있는 패키지 구조는 다음과 같다.`),Us.forEach(s),Ca=u(a),A=l(a,"PRE",{class:!0});var gs=o(A);gs.forEach(s),Ta=u(a),D=l(a,"P",{});var Cs=o(D);h=l(Cs,"EM",{});var Ws=o(h);fs=c(Ws,"cmd"),Ws.forEach(s),ms=c(Cs,` 폴더 외에는 모두 DDD(Domain Driven Design) 패턴의 구조를 따른다.
cmd 폴더 안에는 각 Lambda 함수의 main 함수가 작성되어 있으며, 의존성 주입을 통해 각 Lambda 함수의 동작이 결정되기 때문에 코드 중복을 줄일 수 있다.`),Cs.forEach(s),Oa=u(a),H=l(a,"P",{});var qs=o(H);bs=c(qs,"아마 다른 마이크로서비스 아키텍처에서도 비슷한 패턴을 사용할 수 있을 것이다."),qs.forEach(s),Ra=u(a),Aa=l(a,"BR",{}),Da=l(a,"BR",{}),Na=u(a),C=l(a,"H2",{id:!0});var Ts=o(C);T=l(Ts,"A",{"aria-hidden":!0,tabindex:!0,href:!0});var Zs=o(T);g=l(Zs,"SPAN",{class:!0}),o(g).forEach(s),Zs.forEach(s),vs=c(Ts,"빌드 및 배포"),Ts.forEach(s),xa=u(a),wa=l(a,"HR",{}),$a=u(a),S=l(a,"P",{});var js=o(S);_s=c(js,`Lambda 함수가 많아진다는 것은 빌드 및 배포를 해야 할 대상이 많아진다는 것을 의미한다.
일일이 명령어를 하나씩 입력해가며 빌드 및 배포 과정을 거치는 것은 매우 비효율적이다.
위의 디렉토리 구조를 사용한다고 가정하고, 간단한 쉘 스크립트를 작성하여 빌드 및 배포 과정을 명령어 한 줄로 실행할 수 있도록 하자.`),js.forEach(s),ya=u(a),N=l(a,"PRE",{class:!0});var an=o(N);an.forEach(s),Ga=u(a),O=l(a,"P",{});var Sa=o(O);ds=c(Sa,"예를 들어 "),aa=l(Sa,"EM",{});var zs=o(aa);Es=c(zs,"Function-A"),zs.forEach(s),Is=c(Sa,"라는 Lambda 함수를 빌드 및 배포하고 싶다면, 다음과 같이 실행하면 된다."),Sa.forEach(s),Fa=u(a),x=l(a,"PRE",{class:!0});var sn=o(x);sn.forEach(s),this.h()},h(){k(W,"class","icon icon-link"),k(d,"aria-hidden","true"),k(d,"tabindex","-1"),k(d,"href","#handler-함수의-signature"),k(_,"id","handler-함수의-signature"),k(R,"class","language-go"),pn(y.src,Rs="/post_img/Cloud/AWS/Lambda_with_Golang/1.png")||k(y,"src",Rs),k(y,"alt","사진"),k(Y,"class","icon icon-link"),k(P,"aria-hidden","true"),k(P,"tabindex","-1"),k(P,"href","#코드-중복을-줄이기-위한-패키지-구조"),k(L,"id","코드-중복을-줄이기-위한-패키지-구조"),k(A,"class","language-text"),k(g,"class","icon icon-link"),k(T,"aria-hidden","true"),k(T,"tabindex","-1"),k(T,"href","#빌드-및-배포"),k(C,"id","빌드-및-배포"),k(N,"class","language-sh"),k(x,"class","language-bash")},m(a,n){e(a,v,n),t(v,Ba),e(a,sa,n),e(a,_,n),t(_,d),t(d,W),t(_,Ja),e(a,na,n),e(a,ea,n),e(a,ta,n),e(a,w,n),t(w,Ua),e(a,pa,n),e(a,R,n),R.innerHTML=Qs,e(a,la,n),e(a,E,n),t(E,Wa),t(E,q),t(q,qa),t(E,Za),e(a,oa,n),e(a,f,n),t(f,ja),t(f,Z),t(Z,za),t(f,Ka),t(f,j),t(j,Qa),t(f,Va),e(a,ia,n),e(a,m,n),t(m,Xa),t(m,z),t(z,Ya),t(m,ha),t(m,K),t(K,ga),t(m,as),e(a,ca,n),e(a,$,n),t($,y),e(a,ra,n),e(a,G,n),t(G,ss),e(a,ua,n),e(a,ka,n),e(a,fa,n),e(a,b,n),t(b,ns),t(b,Q),t(Q,es),t(b,ts),t(b,V),t(V,ps),t(b,ls),e(a,ma,n),e(a,I,n),t(I,os),t(I,X),t(X,is),t(I,cs),e(a,ba,n),e(a,va,n),e(a,_a,n),e(a,da,n),e(a,L,n),t(L,P),t(P,Y),t(L,rs),e(a,Ea,n),e(a,Ia,n),e(a,La,n),e(a,F,n),t(F,us),e(a,Pa,n),e(a,M,n),t(M,ks),e(a,Ca,n),e(a,A,n),A.innerHTML=Vs,e(a,Ta,n),e(a,D,n),t(D,h),t(h,fs),t(D,ms),e(a,Oa,n),e(a,H,n),t(H,bs),e(a,Ra,n),e(a,Aa,n),e(a,Da,n),e(a,Na,n),e(a,C,n),t(C,T),t(T,g),t(C,vs),e(a,xa,n),e(a,wa,n),e(a,$a,n),e(a,S,n),t(S,_s),e(a,ya,n),e(a,N,n),N.innerHTML=Xs,e(a,Ga,n),e(a,O,n),t(O,ds),t(O,aa),t(aa,Es),t(O,Is),e(a,Fa,n),e(a,x,n),x.innerHTML=Ys},p:Os,i:Os,o:Os,d(a){a&&s(v),a&&s(sa),a&&s(_),a&&s(na),a&&s(ea),a&&s(ta),a&&s(w),a&&s(pa),a&&s(R),a&&s(la),a&&s(E),a&&s(oa),a&&s(f),a&&s(ia),a&&s(m),a&&s(ca),a&&s($),a&&s(ra),a&&s(G),a&&s(ua),a&&s(ka),a&&s(fa),a&&s(b),a&&s(ma),a&&s(I),a&&s(ba),a&&s(va),a&&s(_a),a&&s(da),a&&s(L),a&&s(Ea),a&&s(Ia),a&&s(La),a&&s(F),a&&s(Pa),a&&s(M),a&&s(Ca),a&&s(A),a&&s(Ta),a&&s(D),a&&s(Oa),a&&s(H),a&&s(Ra),a&&s(Aa),a&&s(Da),a&&s(Na),a&&s(C),a&&s(xa),a&&s(wa),a&&s($a),a&&s(S),a&&s(ya),a&&s(N),a&&s(Ga),a&&s(O),a&&s(Fa),a&&s(x)}}}const cn={title:"AWS Lambda 함수를 Golang으로 작성할 때 알아두면 좋은 것들",date:"2023-10-23",excerpt:"AWS Lambda Golang으로 함수를 만들어 보며 알게 된 것들",categories:["AWS Lambda","Golang"],coverImage:"/post_img/Cloud/AWS/Lambda_with_Golang/cover.png",coverWidth:16,coverHeight:9,indexed:!0,exposed:!0};class rn extends nn{constructor(v){super(),en(this,v,null,ln,tn,{})}}export{rn as default,cn as metadata};
