import{S as Hi,i as qi,s as $i,k as t,q as l,a as p,y as Oi,l as o,m as s,r as c,h as n,c as u,z as wi,n as d,b as i,E as e,A as Li,g as Ci,d as Di,B as xi}from"./index.d78780bf.js";import{H as Mi}from"./Highlight.1019e7a6.js";import{I as Ui}from"./Image.605b14b5.js";function Wi(gt){let k;return{c(){k=l("메모리 모델")},l(I){k=c(I,"메모리 모델")},m(I,He){i(I,k,He)},d(I){I&&n(k)}}}function Ni(gt){let k,I,He,qe,eo,Ka,W,no,N,ao,Qa,$e,to,ga,Me,oo,et,nt,at,tt,T,X,hn,so,ot,st,lt,Y,V,kn,En,lo,ct,D,v,co,vn,ro,io,_n,po,uo,mn,fo,ho,ko,bn,Eo,vo,yn,_o,rt,Z,j,On,wn,mo,it,x,be,Ln,bo,yo,ye,Cn,Oo,wo,Dn,Lo,Co,xn,_,Do,Pn,xo,Po,Bn,Bo,Ro,Rn,Ao,Io,So,An,In,zo,pt,F,J,Sn,zn,Go,ut,P,Gn,Ho,qo,E,Hn,$o,Mo,qn,Uo,Wo,$n,No,To,Mn,Xo,Yo,Vo,f,Un,Zo,jo,Wn,Fo,Jo,Nn,Ko,Qo,Tn,go,es,Xn,ns,as,dt,Ue,ts,ft,ht,kt,Et,K,Q,Yn,os,vt,We,ss,_t,g,ee,Vn,ls,mt,Ne,S,cs,Zn,rs,is,jn,ps,us,bt,ne,ae,Fn,ds,yt,Te,m,z,fs,Jn,hs,ks,Kn,Es,vs,_s,Qn,Oe,ms,gn,bs,ys,Os,Xe,Pi=`<code class="language-go">a <span class="token operator">:=</span> <span class="token string">"Before goroutine"</span>
<span class="token keyword">go</span> <span class="token keyword">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span> fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span> <span class="token punctuation">&#125;</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token keyword">select</span><span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span></code>`,ws,ea,na,Ls,Ot,te,oe,aa,Cs,wt,B,ta,oa,Ds,xs,we,sa,Ps,Bs,la,ca,Rs,As,G,Le,Is,ra,Ss,zs,Gs,Ye,Bi=`<code class="language-go">  <span class="token keyword">var</span> x <span class="token builtin">int</span>
  ch <span class="token operator">:=</span> <span class="token function">make</span><span class="token punctuation">(</span><span class="token keyword">chan</span> <span class="token builtin">int</span><span class="token punctuation">)</span>
  <span class="token keyword">go</span> <span class="token keyword">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
    ch <span class="token operator">&lt;-</span> <span class="token number">0</span>
    fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span>
  <span class="token punctuation">&#125;</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
  x <span class="token operator">=</span> <span class="token number">1</span>
  <span class="token operator">&lt;-</span>ch
  <span class="token keyword">select</span><span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span></code>`,Hs,b,Ce,ia,qs,$s,pa,Ms,Us,De,ua,Ws,Ns,da,Ts,Xs,xe,fa,Ys,Vs,ha,Zs,js,se,Fs,ka,Js,Ks,Ea,Qs,Lt,le,ce,va,gs,Ct,Ve,H,_a,el,nl,Pe,ma,al,tl,Be,ol,ba,sl,ll,cl,Ze,Ri=`<code class="language-go"><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
  <span class="token keyword">var</span> m sync<span class="token punctuation">.</span>Mutex
  <span class="token keyword">var</span> a <span class="token builtin">int</span>
  done <span class="token operator">:=</span> <span class="token function">make</span><span class="token punctuation">(</span><span class="token keyword">chan</span> <span class="token keyword">struct</span><span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span>
  m<span class="token punctuation">.</span><span class="token function">Lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span>

  <span class="token keyword">go</span> <span class="token keyword">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
      m<span class="token punctuation">.</span><span class="token function">Lock</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
      fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span>
      m<span class="token punctuation">.</span><span class="token function">Unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
      <span class="token function">close</span><span class="token punctuation">(</span>done<span class="token punctuation">)</span>
  <span class="token punctuation">&#125;</span><span class="token punctuation">(</span><span class="token punctuation">)</span>

  <span class="token keyword">go</span> <span class="token keyword">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
      a <span class="token operator">=</span> <span class="token number">1</span>
      m<span class="token punctuation">.</span><span class="token function">Unlock</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
  <span class="token punctuation">&#125;</span>

  <span class="token operator">&lt;-</span>done

<span class="token punctuation">&#125;</span></code>`,Dt,re,ie,ya,rl,xt,R,Oa,je,wa,il,pl,ul,La,Ca,dl,fl,Re,Da,hl,kl,Fe,Ai=`<code class="language-go">  <span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
      <span class="token keyword">var</span> i <span class="token builtin">int</span>
      <span class="token keyword">var</span> v atomic<span class="token punctuation">.</span>Value
      done <span class="token operator">:=</span> <span class="token function">make</span><span class="token punctuation">(</span><span class="token keyword">chan</span> <span class="token keyword">struct</span><span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span>
      <span class="token keyword">go</span> <span class="token keyword">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
          i <span class="token operator">=</span> <span class="token number">1</span>
          v<span class="token punctuation">.</span><span class="token function">Store</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span>
      <span class="token punctuation">&#125;</span><span class="token punctuation">(</span><span class="token punctuation">)</span>

      <span class="token keyword">go</span> <span class="token keyword">func</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
          <span class="token keyword">for</span> <span class="token punctuation">&#123;</span>
              <span class="token keyword">if</span> val<span class="token punctuation">,</span> <span class="token boolean">_</span> <span class="token operator">:=</span> v<span class="token punctuation">.</span><span class="token function">Load</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token punctuation">(</span><span class="token builtin">int</span><span class="token punctuation">)</span><span class="token punctuation">;</span> val <span class="token operator">==</span> <span class="token number">1</span> <span class="token punctuation">&#123;</span>
                  fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span>
                  <span class="token function">close</span><span class="token punctuation">(</span>done<span class="token punctuation">)</span>
                  <span class="token keyword">return</span>
              <span class="token punctuation">&#125;</span>
          <span class="token punctuation">&#125;</span>
      <span class="token punctuation">&#125;</span><span class="token punctuation">(</span><span class="token punctuation">)</span>

      <span class="token operator">&lt;-</span>done
  <span class="token punctuation">&#125;</span></code>`,Pt,pe,ue,xa,El,Bt,A,Ae,Je,Pa,vl,_l,ml,y,q,bl,Ba,yl,Ol,Ra,wl,Ll,Cl,$,Dl,Aa,xl,Pl,Ia,Bl,Rl,Al,Sa,Il,Sl,Ke,za,zl,Gl,Hl,Ie,Qe,Ga,ql,$l,Ml,M,ge,Ha,Ul,Wl,Nl,Se,Tl,qa,Xl,Yl,Vl,O,Zl,$a,jl,Fl,Ma,Jl,Kl,Ua,Ql,gl,ec,Wa,h,Na,nc,ac,Ta,tc,oc,Xa,sc,lc,Ya,cc,rc,Va,ic,pc,Rt,At,It,St,de,fe,Za,uc,zt,Gt,Ht,w,ja,dc,fc,ze,hc,kc,Ec,qt;return N=new Mi({props:{$$slots:{default:[Wi]},$$scope:{ctx:gt}}}),ze=new Ui({props:{alt:"Effective Concurrency in Go",src:"https://learning.oreilly.com/covers/urn:orm:book:9781804619070/400w/"}}),{c(){k=t("p"),I=l(`어떤 언어든 그 언어를 딥하게 파고 제대로 이해하기 위해서는 그 언어의 메모리 모델을 이해하는 것이 중요하다고 생각한다.
그만큼 Go를 열심히 공부하는 입장으로서 Go의 메모리 모델을 이해하는 것은 필수적이다.`),He=p(),qe=t("p"),eo=l(`단일 프로세서의 성능 향상에 한계가 오면서 멀티 코어 프로세서가 등장하게 되었고, 대부분의 성능 향상은 멀티 코어 프로세서에서 동작하는 것이 대전제가 되었다.
한편 현대 컴파일러 또한 극한의 최적화를 위해 코드를 재배치하는 일이 비일비재하다.
이는 sequantial program에서는 문제가 되지 않지만, concurrent program에서는 문제가 될 수 있다.`),Ka=p(),W=t("p"),no=l("이러한 문제를 해결하기 위해서 "),Oi(N.$$.fragment),ao=l(`이 정의된다.
메모리 모델은 컴파일러 빌더가 보장해야 하고, 프로그래머가 기대할 수 있는 것들을 정의한다.
즉, 메모리 모델은 하드웨어에 대한 컴파일러 빌더의 동작이 정의된 것이라고 볼 수 있다.`),Qa=p(),$e=t("p"),to=l(`여러 고루틴에서 동시에 엑세스되는 데이터를 수정하는 프로그램은 이러한 액세스를 직렬화해야 함을 언급하며 Go의 메모리 모델 문서가 시작되는데, 이는 쉬운 일이 아니다.
동시성 프로그램의 모든 가능성을 고려하는 것은 불가능하기 때문이다.
대신 메모리 모델에 대한 인사이트를 가지고 있다면 동시성 프로그램의 문제를 해결하는 데 도움이 될 수 있다.`),ga=p(),Me=t("p"),oo=l(`물론 메모리 모델과 너무 가깝게 작성된 코드를 짜는 것은 좋지 않지만, 알고 하지 않는 것과 모르고 하지 않는 것은 차이가 있다.
Go의 메모리 모델에 대해 본격적으로 알아보자.`),et=p(),nt=t("br"),at=t("br"),tt=p(),T=t("h2"),X=t("a"),hn=t("span"),so=l("메모리 연산 순서 모델"),ot=p(),st=t("hr"),lt=p(),Y=t("h3"),V=t("a"),kn=t("span"),En=t("strong"),lo=l("Sequenced-Before Relationship"),ct=p(),D=t("ul"),v=t("li"),co=l("만약 "),vn=t("code"),ro=l("A is sequenced before B"),io=l("라면, "),_n=t("code"),po=l("A"),uo=l("가 "),mn=t("code"),fo=l("B"),ho=l("보다 먼저 실행되었음을 의미함"),ko=p(),bn=t("li"),Eo=l("하지만 Sequenced-Before Relationship은 동시성을 고려하지 않음"),vo=p(),yn=t("li"),_o=l("메모리 read 연산이 변수에 쓰여진 마지막 값을 읽는 한, 컴파일러에 의해 instruction reordering이 발생할 수 있음"),rt=p(),Z=t("h3"),j=t("a"),On=t("span"),wn=t("strong"),mo=l("Synchronized-Before Relationship"),it=p(),x=t("ul"),be=t("li"),Ln=t("p"),bo=l("일반적인 메모리 연산 외에도 동기화 메모리 작업(Synchronizing Memory Operation)이 존재함"),yo=p(),ye=t("ul"),Cn=t("li"),Oo=l("Syncrhonizing Read Operation: Mutex lock, Channel receive, atomic read, atomic compare-and-swap"),wo=p(),Dn=t("li"),Lo=l("Synchrornizing Write Operation: Mutex unlock, Channel send, Channel close, atomic write, atomic compare-and-swap"),Co=p(),xn=t("li"),_=t("p"),Do=l("만약 "),Pn=t("code"),xo=l("A is synchronized before B"),Po=l("라면, 동기화 연산 "),Bn=t("code"),Bo=l("A"),Ro=l("가 동기화 연산 "),Rn=t("code"),Ao=l("B"),Io=l("보다 먼저 실행되었음을 의미함"),So=p(),An=t("li"),In=t("p"),zo=l("Sequenced-Before Relationship이 단일 고루틴에서의 일반적인 메모리 연산 순서를 정의한다면, Synchronized-Before Relationship은 여러 고루틴에서의 메모리 연산 순서를 정의할 수 있음"),pt=p(),F=t("h3"),J=t("a"),Sn=t("span"),zn=t("strong"),Go=l("Happened-Before Relationship"),ut=p(),P=t("ul"),Gn=t("li"),Ho=l("Sequenced-Before Relationship와 Synchronized-Before Relationship의 조합"),qo=p(),E=t("li"),Hn=t("code"),$o=l("W"),Mo=l("가 메모리 쓰기 작업이고 "),qn=t("code"),Uo=l("R"),Wo=l("이 메모리 읽기 작업일 때, 만약 "),$n=t("code"),No=l("W synchronized before R"),To=l("이면, "),Mn=t("code"),Xo=l("W happened before R"),Yo=l("임"),Vo=p(),f=t("li"),Un=t("code"),Zo=l("X"),jo=l("가 메모리 쓰기 작업이고 "),Wn=t("code"),Fo=l("Y"),Jo=l("이 메모리 읽기 작업일 때, 만약 "),Nn=t("code"),Ko=l("X sequenced before W"),Qo=l("이고 "),Tn=t("code"),go=l("Y is sequenced after R"),es=l("이면, "),Xn=t("code"),ns=l("X happened before Y"),as=l("임"),dt=p(),Ue=t("p"),ts=l("만약 read 및 write 연산간 happened-before relationship을 정의할 수 없다면, 이들은 동시에 일어남."),ft=p(),ht=t("br"),kt=t("br"),Et=p(),K=t("h2"),Q=t("a"),Yn=t("span"),os=l("Golang의 동기화 모델"),vt=p(),We=t("p"),ss=l("앞선 Happened-Before Relationship을 통해 Go의 동기화 모델을 확인할 수 있음."),_t=p(),g=t("h3"),ee=t("a"),Vn=t("span"),ls=l("패키지 초기화"),mt=p(),Ne=t("ul"),S=t("li"),cs=l("패키지 A가 다른 패키지 B를 임포트한다면, 패키지 B의 "),Zn=t("code"),rs=l("init()"),is=l(" 함수가 패키지 A의 "),jn=t("code"),ps=l("init()"),us=l(" 함수보다 먼저 실행됨"),bt=p(),ne=t("h3"),ae=t("a"),Fn=t("span"),ds=l("고루틴"),yt=p(),Te=t("ul"),m=t("li"),z=t("p"),fs=l("프로그램이 고루틴을 생성할 때, "),Jn=t("code"),hs=l("go"),ks=l(" 문은 고루틴 실행 이전에 동기화됨 ("),Kn=t("code"),Es=l("go"),vs=l(" statement is synchronized before the start of goroutine’s execution)"),_s=p(),Qn=t("ul"),Oe=t("li"),ms=l("다음의 예시 코드는 항상 "),gn=t("code"),bs=l("Before goroutine"),ys=l("을 출력함"),Os=p(),Xe=t("pre"),ws=p(),ea=t("ul"),na=t("li"),Ls=l("하지만 고루팀이 종료될 때 명시적인 방식으로 통신을 하지 않는 이상, 고루틴의 종료 시점은 동기화되지 않음"),Ot=p(),te=t("h3"),oe=t("a"),aa=t("span"),Cs=l("채널"),wt=p(),B=t("ul"),ta=t("li"),oa=t("p"),Ds=l("unbuffered channel을 통해 전송되는 send 및 close 연산은 채널의 receive 연산과 동기화됨 (send or close is synchronized before the receive)"),xs=p(),we=t("li"),sa=t("p"),Ps=l("buffered channel을 통해 전송되는 send 및 close 연산은 채널의 receive 연산과 동기화됨(receive is synchronized before the send or close)"),Bs=p(),la=t("ul"),ca=t("li"),Rs=l("syncrhonized before이면 happened before임"),As=p(),G=t("li"),Le=t("p"),Is=l("다음의 예시 코드는 항상 "),ra=t("code"),Ss=l("1"),zs=l("을 출력함"),Gs=p(),Ye=t("pre"),Hs=p(),b=t("ul"),Ce=t("li"),ia=t("code"),qs=l("x = 1"),$s=l(" is sequenced before "),pa=t("code"),Ms=l("<-ch"),Us=p(),De=t("li"),ua=t("code"),Ws=l("<-ch"),Ns=l(" is synchronized before "),da=t("code"),Ts=l("ch <- 0"),Xs=p(),xe=t("li"),fa=t("code"),Ys=l("ch <- 0"),Vs=l(" is sequenced before "),ha=t("code"),Zs=l("fmt.Println(x)"),js=p(),se=t("li"),Fs=l("따라서, "),ka=t("code"),Js=l("x = 1"),Ks=l(" is happened before "),Ea=t("code"),Qs=l("fmt.Println(x)"),Lt=p(),le=t("h3"),ce=t("a"),va=t("span"),gs=l("뮤텍스"),Ct=p(),Ve=t("ul"),H=t("li"),_a=t("p"),el=l("두 고루틴 A와 B가 있을 때 A가 먼저 획득한 뮤텍스를 unlock하면 B가 뮤텍스를 lock할 수 있음."),nl=p(),Pe=t("ul"),ma=t("li"),al=l("이 때 unlock은 lock보다 먼저 동기화됨 (unlock is synchronized before the lock)"),tl=p(),Be=t("li"),ol=l("다음의 예시 코드는 항상 "),ba=t("code"),sl=l("1"),ll=l("을 출력함"),cl=p(),Ze=t("pre"),Dt=p(),re=t("h3"),ie=t("a"),ya=t("span"),rl=l("Atomic 연산"),xt=p(),R=t("ul"),Oa=t("li"),je=t("p"),wa=t("code"),il=l("sync/atomic"),pl=l(" 패키지는 저수준의 원자적 메모리 읽기/쓰기 연산을 제공함"),ul=p(),La=t("li"),Ca=t("p"),dl=l("만약 atomic write의 결과가 atomic read에서 확인된다면, atomic write는 atomic read보다 먼저 동기화됨 (atomic write is synchronized before the atomic read)"),fl=p(),Re=t("li"),Da=t("p"),hl=l("다음의 코드는 항상 1을 출력함"),kl=p(),Fe=t("pre"),Pt=p(),pe=t("h3"),ue=t("a"),xa=t("span"),El=l("Map, Once, WaitGroup"),Bt=p(),A=t("ul"),Ae=t("li"),Je=t("p"),Pa=t("code"),vl=l("sync.Map"),_l=l("은 별도로 뮤텍스 로직을 구현하지 않아도 안전하게 사용할 수 있는 thread-safe map 타입임"),ml=p(),y=t("ul"),q=t("li"),bl=l("데이터가 한번 write되지만 여러 번 read되는 경우나 여러 고루틴이 각각의 키로 접근하는 경우, 일반 "),Ba=t("code"),yl=l("map"),Ol=l("에 뮤텍스를 사용하여 구현하는 것보다 "),Ra=t("code"),wl=l("sync.Map"),Ll=l("을 사용하는 것이 더 좋은 성능을 보임"),Cl=p(),$=t("li"),Dl=l("하지만 "),Aa=t("code"),xl=l("sync.Map"),Pl=l("은 "),Ia=t("code"),Bl=l("map"),Rl=l("과 달리 타입 안정성을 보장하지 않음"),Al=p(),Sa=t("li"),Il=l("간단하게 캐시같은거 구현할 때 사용하면 좋다고 함"),Sl=p(),Ke=t("li"),za=t("code"),zl=l("sync.Map"),Gl=l("에서 어떤 read 연산이 write 연산의 결과를 확인한다면, write 연산은 read 연산보다 먼저 발생함 (write is happened before the read)"),Hl=p(),Ie=t("li"),Qe=t("p"),Ga=t("code"),ql=l("sync.Once"),$l=l("는 여러 고루틴에서 무언가를 초기화하고자 할 때 유용함"),Ml=p(),M=t("ul"),ge=t("li"),Ha=t("code"),Ul=l("sync.Once.Do()"),Wl=l("를 호출하여 함수를 넘기면 초기화가 실행됨"),Nl=p(),Se=t("li"),Tl=l("여러 고루틴에서 "),qa=t("code"),Xl=l("sync.Once.Do()"),Yl=l("를 호출하더라도, 초기화 함수는 한 번만 실행되고, 다른 고루틴에서는 초기화 함수가 실행되지 않고 block되었다가 초기화 함수가 실행된 후에 unblock됨"),Vl=p(),O=t("li"),Zl=l("한 고루틴에서 "),$a=t("code"),jl=l("sync.Once.Do()"),Fl=l("를 호출하면 다른 고루틴에서 "),Ma=t("code"),Jl=l("sync.Once.Do()"),Kl=l("가 끝나기 이전에 그 초기화 함수가 종료됨 (the completion of initialization function is happened before the return from "),Ua=t("code"),Ql=l("sync.Once.Do()"),gl=l(")"),ec=p(),Wa=t("li"),h=t("p"),Na=t("code"),nc=l("sync.WaitGroup"),ac=l("의 모든 "),Ta=t("code"),tc=l("Done()"),oc=l(" 메소드 호출은 "),Xa=t("code"),sc=l("Wait()"),lc=l(" 메소드의 반환 이전에 동기화됨 (the completion of "),Ya=t("code"),cc=l("Done()"),rc=l(" is happened before the return from "),Va=t("code"),ic=l("Wait()"),pc=l(")"),Rt=p(),At=t("br"),It=t("br"),St=p(),de=t("h2"),fe=t("a"),Za=t("span"),uc=l("References"),zt=p(),Gt=t("hr"),Ht=p(),w=t("center"),ja=t("p"),dc=l("["),fc=p(),Oi(ze.$$.fragment),hc=l(`
](https://learning.oreilly.com/library/view/effective-concurrency-in/9781804619070/)`),kc=t("br"),Ec=l(`
[Burak Serdar, 『Effective Concurrency in Go』, Packt Publishing](https://learning.oreilly.com/library/view/effective-concurrency-in/9781804619070/)`),this.h()},l(a){k=o(a,"P",{});var r=s(k);I=c(r,`어떤 언어든 그 언어를 딥하게 파고 제대로 이해하기 위해서는 그 언어의 메모리 모델을 이해하는 것이 중요하다고 생각한다.
그만큼 Go를 열심히 공부하는 입장으로서 Go의 메모리 모델을 이해하는 것은 필수적이다.`),r.forEach(n),He=u(a),qe=o(a,"P",{});var Fa=s(qe);eo=c(Fa,`단일 프로세서의 성능 향상에 한계가 오면서 멀티 코어 프로세서가 등장하게 되었고, 대부분의 성능 향상은 멀티 코어 프로세서에서 동작하는 것이 대전제가 되었다.
한편 현대 컴파일러 또한 극한의 최적화를 위해 코드를 재배치하는 일이 비일비재하다.
이는 sequantial program에서는 문제가 되지 않지만, concurrent program에서는 문제가 될 수 있다.`),Fa.forEach(n),Ka=u(a),W=o(a,"P",{});var $t=s(W);no=c($t,"이러한 문제를 해결하기 위해서 "),wi(N.$$.fragment,$t),ao=c($t,`이 정의된다.
메모리 모델은 컴파일러 빌더가 보장해야 하고, 프로그래머가 기대할 수 있는 것들을 정의한다.
즉, 메모리 모델은 하드웨어에 대한 컴파일러 빌더의 동작이 정의된 것이라고 볼 수 있다.`),$t.forEach(n),Qa=u(a),$e=o(a,"P",{});var zc=s($e);to=c(zc,`여러 고루틴에서 동시에 엑세스되는 데이터를 수정하는 프로그램은 이러한 액세스를 직렬화해야 함을 언급하며 Go의 메모리 모델 문서가 시작되는데, 이는 쉬운 일이 아니다.
동시성 프로그램의 모든 가능성을 고려하는 것은 불가능하기 때문이다.
대신 메모리 모델에 대한 인사이트를 가지고 있다면 동시성 프로그램의 문제를 해결하는 데 도움이 될 수 있다.`),zc.forEach(n),ga=u(a),Me=o(a,"P",{});var Gc=s(Me);oo=c(Gc,`물론 메모리 모델과 너무 가깝게 작성된 코드를 짜는 것은 좋지 않지만, 알고 하지 않는 것과 모르고 하지 않는 것은 차이가 있다.
Go의 메모리 모델에 대해 본격적으로 알아보자.`),Gc.forEach(n),et=u(a),nt=o(a,"BR",{}),at=o(a,"BR",{}),tt=u(a),T=o(a,"H2",{id:!0});var vc=s(T);X=o(vc,"A",{"aria-hidden":!0,tabindex:!0,href:!0});var Hc=s(X);hn=o(Hc,"SPAN",{class:!0}),s(hn).forEach(n),Hc.forEach(n),so=c(vc,"메모리 연산 순서 모델"),vc.forEach(n),ot=u(a),st=o(a,"HR",{}),lt=u(a),Y=o(a,"H3",{id:!0});var _c=s(Y);V=o(_c,"A",{"aria-hidden":!0,tabindex:!0,href:!0});var qc=s(V);kn=o(qc,"SPAN",{class:!0}),s(kn).forEach(n),qc.forEach(n),En=o(_c,"STRONG",{});var $c=s(En);lo=c($c,"Sequenced-Before Relationship"),$c.forEach(n),_c.forEach(n),ct=u(a),D=o(a,"UL",{});var en=s(D);v=o(en,"LI",{});var he=s(v);co=c(he,"만약 "),vn=o(he,"CODE",{});var Mc=s(vn);ro=c(Mc,"A is sequenced before B"),Mc.forEach(n),io=c(he,"라면, "),_n=o(he,"CODE",{});var Uc=s(_n);po=c(Uc,"A"),Uc.forEach(n),uo=c(he,"가 "),mn=o(he,"CODE",{});var Wc=s(mn);fo=c(Wc,"B"),Wc.forEach(n),ho=c(he,"보다 먼저 실행되었음을 의미함"),he.forEach(n),ko=u(en),bn=o(en,"LI",{});var Nc=s(bn);Eo=c(Nc,"하지만 Sequenced-Before Relationship은 동시성을 고려하지 않음"),Nc.forEach(n),vo=u(en),yn=o(en,"LI",{});var Tc=s(yn);_o=c(Tc,"메모리 read 연산이 변수에 쓰여진 마지막 값을 읽는 한, 컴파일러에 의해 instruction reordering이 발생할 수 있음"),Tc.forEach(n),en.forEach(n),rt=u(a),Z=o(a,"H3",{id:!0});var mc=s(Z);j=o(mc,"A",{"aria-hidden":!0,tabindex:!0,href:!0});var Xc=s(j);On=o(Xc,"SPAN",{class:!0}),s(On).forEach(n),Xc.forEach(n),wn=o(mc,"STRONG",{});var Yc=s(wn);mo=c(Yc,"Synchronized-Before Relationship"),Yc.forEach(n),mc.forEach(n),it=u(a),x=o(a,"UL",{});var nn=s(x);be=o(nn,"LI",{});var Mt=s(be);Ln=o(Mt,"P",{});var Vc=s(Ln);bo=c(Vc,"일반적인 메모리 연산 외에도 동기화 메모리 작업(Synchronizing Memory Operation)이 존재함"),Vc.forEach(n),yo=u(Mt),ye=o(Mt,"UL",{});var Ut=s(ye);Cn=o(Ut,"LI",{});var Zc=s(Cn);Oo=c(Zc,"Syncrhonizing Read Operation: Mutex lock, Channel receive, atomic read, atomic compare-and-swap"),Zc.forEach(n),wo=u(Ut),Dn=o(Ut,"LI",{});var jc=s(Dn);Lo=c(jc,"Synchrornizing Write Operation: Mutex unlock, Channel send, Channel close, atomic write, atomic compare-and-swap"),jc.forEach(n),Ut.forEach(n),Mt.forEach(n),Co=u(nn),xn=o(nn,"LI",{});var Fc=s(xn);_=o(Fc,"P",{});var ke=s(_);Do=c(ke,"만약 "),Pn=o(ke,"CODE",{});var Jc=s(Pn);xo=c(Jc,"A is synchronized before B"),Jc.forEach(n),Po=c(ke,"라면, 동기화 연산 "),Bn=o(ke,"CODE",{});var Kc=s(Bn);Bo=c(Kc,"A"),Kc.forEach(n),Ro=c(ke,"가 동기화 연산 "),Rn=o(ke,"CODE",{});var Qc=s(Rn);Ao=c(Qc,"B"),Qc.forEach(n),Io=c(ke,"보다 먼저 실행되었음을 의미함"),ke.forEach(n),Fc.forEach(n),So=u(nn),An=o(nn,"LI",{});var gc=s(An);In=o(gc,"P",{});var er=s(In);zo=c(er,"Sequenced-Before Relationship이 단일 고루틴에서의 일반적인 메모리 연산 순서를 정의한다면, Synchronized-Before Relationship은 여러 고루틴에서의 메모리 연산 순서를 정의할 수 있음"),er.forEach(n),gc.forEach(n),nn.forEach(n),pt=u(a),F=o(a,"H3",{id:!0});var bc=s(F);J=o(bc,"A",{"aria-hidden":!0,tabindex:!0,href:!0});var nr=s(J);Sn=o(nr,"SPAN",{class:!0}),s(Sn).forEach(n),nr.forEach(n),zn=o(bc,"STRONG",{});var ar=s(zn);Go=c(ar,"Happened-Before Relationship"),ar.forEach(n),bc.forEach(n),ut=u(a),P=o(a,"UL",{});var an=s(P);Gn=o(an,"LI",{});var tr=s(Gn);Ho=c(tr,"Sequenced-Before Relationship와 Synchronized-Before Relationship의 조합"),tr.forEach(n),qo=u(an),E=o(an,"LI",{});var U=s(E);Hn=o(U,"CODE",{});var or=s(Hn);$o=c(or,"W"),or.forEach(n),Mo=c(U,"가 메모리 쓰기 작업이고 "),qn=o(U,"CODE",{});var sr=s(qn);Uo=c(sr,"R"),sr.forEach(n),Wo=c(U,"이 메모리 읽기 작업일 때, 만약 "),$n=o(U,"CODE",{});var lr=s($n);No=c(lr,"W synchronized before R"),lr.forEach(n),To=c(U,"이면, "),Mn=o(U,"CODE",{});var cr=s(Mn);Xo=c(cr,"W happened before R"),cr.forEach(n),Yo=c(U,"임"),U.forEach(n),Vo=u(an),f=o(an,"LI",{});var L=s(f);Un=o(L,"CODE",{});var rr=s(Un);Zo=c(rr,"X"),rr.forEach(n),jo=c(L,"가 메모리 쓰기 작업이고 "),Wn=o(L,"CODE",{});var ir=s(Wn);Fo=c(ir,"Y"),ir.forEach(n),Jo=c(L,"이 메모리 읽기 작업일 때, 만약 "),Nn=o(L,"CODE",{});var pr=s(Nn);Ko=c(pr,"X sequenced before W"),pr.forEach(n),Qo=c(L,"이고 "),Tn=o(L,"CODE",{});var ur=s(Tn);go=c(ur,"Y is sequenced after R"),ur.forEach(n),es=c(L,"이면, "),Xn=o(L,"CODE",{});var dr=s(Xn);ns=c(dr,"X happened before Y"),dr.forEach(n),as=c(L,"임"),L.forEach(n),an.forEach(n),dt=u(a),Ue=o(a,"P",{});var fr=s(Ue);ts=c(fr,"만약 read 및 write 연산간 happened-before relationship을 정의할 수 없다면, 이들은 동시에 일어남."),fr.forEach(n),ft=u(a),ht=o(a,"BR",{}),kt=o(a,"BR",{}),Et=u(a),K=o(a,"H2",{id:!0});var yc=s(K);Q=o(yc,"A",{"aria-hidden":!0,tabindex:!0,href:!0});var hr=s(Q);Yn=o(hr,"SPAN",{class:!0}),s(Yn).forEach(n),hr.forEach(n),os=c(yc,"Golang의 동기화 모델"),yc.forEach(n),vt=u(a),We=o(a,"P",{});var kr=s(We);ss=c(kr,"앞선 Happened-Before Relationship을 통해 Go의 동기화 모델을 확인할 수 있음."),kr.forEach(n),_t=u(a),g=o(a,"H3",{id:!0});var Oc=s(g);ee=o(Oc,"A",{"aria-hidden":!0,tabindex:!0,href:!0});var Er=s(ee);Vn=o(Er,"SPAN",{class:!0}),s(Vn).forEach(n),Er.forEach(n),ls=c(Oc,"패키지 초기화"),Oc.forEach(n),mt=u(a),Ne=o(a,"UL",{});var vr=s(Ne);S=o(vr,"LI",{});var tn=s(S);cs=c(tn,"패키지 A가 다른 패키지 B를 임포트한다면, 패키지 B의 "),Zn=o(tn,"CODE",{});var _r=s(Zn);rs=c(_r,"init()"),_r.forEach(n),is=c(tn," 함수가 패키지 A의 "),jn=o(tn,"CODE",{});var mr=s(jn);ps=c(mr,"init()"),mr.forEach(n),us=c(tn," 함수보다 먼저 실행됨"),tn.forEach(n),vr.forEach(n),bt=u(a),ne=o(a,"H3",{id:!0});var wc=s(ne);ae=o(wc,"A",{"aria-hidden":!0,tabindex:!0,href:!0});var br=s(ae);Fn=o(br,"SPAN",{class:!0}),s(Fn).forEach(n),br.forEach(n),ds=c(wc,"고루틴"),wc.forEach(n),yt=u(a),Te=o(a,"UL",{});var yr=s(Te);m=o(yr,"LI",{});var Ee=s(m);z=o(Ee,"P",{});var on=s(z);fs=c(on,"프로그램이 고루틴을 생성할 때, "),Jn=o(on,"CODE",{});var Or=s(Jn);hs=c(Or,"go"),Or.forEach(n),ks=c(on," 문은 고루틴 실행 이전에 동기화됨 ("),Kn=o(on,"CODE",{});var wr=s(Kn);Es=c(wr,"go"),wr.forEach(n),vs=c(on," statement is synchronized before the start of goroutine’s execution)"),on.forEach(n),_s=u(Ee),Qn=o(Ee,"UL",{});var Lr=s(Qn);Oe=o(Lr,"LI",{});var Wt=s(Oe);ms=c(Wt,"다음의 예시 코드는 항상 "),gn=o(Wt,"CODE",{});var Cr=s(gn);bs=c(Cr,"Before goroutine"),Cr.forEach(n),ys=c(Wt,"을 출력함"),Wt.forEach(n),Lr.forEach(n),Os=u(Ee),Xe=o(Ee,"PRE",{class:!0});var Ii=s(Xe);Ii.forEach(n),ws=u(Ee),ea=o(Ee,"UL",{});var Dr=s(ea);na=o(Dr,"LI",{});var xr=s(na);Ls=c(xr,"하지만 고루팀이 종료될 때 명시적인 방식으로 통신을 하지 않는 이상, 고루틴의 종료 시점은 동기화되지 않음"),xr.forEach(n),Dr.forEach(n),Ee.forEach(n),yr.forEach(n),Ot=u(a),te=o(a,"H3",{id:!0});var Lc=s(te);oe=o(Lc,"A",{"aria-hidden":!0,tabindex:!0,href:!0});var Pr=s(oe);aa=o(Pr,"SPAN",{class:!0}),s(aa).forEach(n),Pr.forEach(n),Cs=c(Lc,"채널"),Lc.forEach(n),wt=u(a),B=o(a,"UL",{});var sn=s(B);ta=o(sn,"LI",{});var Br=s(ta);oa=o(Br,"P",{});var Rr=s(oa);Ds=c(Rr,"unbuffered channel을 통해 전송되는 send 및 close 연산은 채널의 receive 연산과 동기화됨 (send or close is synchronized before the receive)"),Rr.forEach(n),Br.forEach(n),xs=u(sn),we=o(sn,"LI",{});var Nt=s(we);sa=o(Nt,"P",{});var Ar=s(sa);Ps=c(Ar,"buffered channel을 통해 전송되는 send 및 close 연산은 채널의 receive 연산과 동기화됨(receive is synchronized before the send or close)"),Ar.forEach(n),Bs=u(Nt),la=o(Nt,"UL",{});var Ir=s(la);ca=o(Ir,"LI",{});var Sr=s(ca);Rs=c(Sr,"syncrhonized before이면 happened before임"),Sr.forEach(n),Ir.forEach(n),Nt.forEach(n),As=u(sn),G=o(sn,"LI",{});var ln=s(G);Le=o(ln,"P",{});var Tt=s(Le);Is=c(Tt,"다음의 예시 코드는 항상 "),ra=o(Tt,"CODE",{});var zr=s(ra);Ss=c(zr,"1"),zr.forEach(n),zs=c(Tt,"을 출력함"),Tt.forEach(n),Gs=u(ln),Ye=o(ln,"PRE",{class:!0});var Si=s(Ye);Si.forEach(n),Hs=u(ln),b=o(ln,"UL",{});var ve=s(b);Ce=o(ve,"LI",{});var Xt=s(Ce);ia=o(Xt,"CODE",{});var Gr=s(ia);qs=c(Gr,"x = 1"),Gr.forEach(n),$s=c(Xt," is sequenced before "),pa=o(Xt,"CODE",{});var Hr=s(pa);Ms=c(Hr,"<-ch"),Hr.forEach(n),Xt.forEach(n),Us=u(ve),De=o(ve,"LI",{});var Yt=s(De);ua=o(Yt,"CODE",{});var qr=s(ua);Ws=c(qr,"<-ch"),qr.forEach(n),Ns=c(Yt," is synchronized before "),da=o(Yt,"CODE",{});var $r=s(da);Ts=c($r,"ch <- 0"),$r.forEach(n),Yt.forEach(n),Xs=u(ve),xe=o(ve,"LI",{});var Vt=s(xe);fa=o(Vt,"CODE",{});var Mr=s(fa);Ys=c(Mr,"ch <- 0"),Mr.forEach(n),Vs=c(Vt," is sequenced before "),ha=o(Vt,"CODE",{});var Ur=s(ha);Zs=c(Ur,"fmt.Println(x)"),Ur.forEach(n),Vt.forEach(n),js=u(ve),se=o(ve,"LI",{});var Ja=s(se);Fs=c(Ja,"따라서, "),ka=o(Ja,"CODE",{});var Wr=s(ka);Js=c(Wr,"x = 1"),Wr.forEach(n),Ks=c(Ja," is happened before "),Ea=o(Ja,"CODE",{});var Nr=s(Ea);Qs=c(Nr,"fmt.Println(x)"),Nr.forEach(n),Ja.forEach(n),ve.forEach(n),ln.forEach(n),sn.forEach(n),Lt=u(a),le=o(a,"H3",{id:!0});var Cc=s(le);ce=o(Cc,"A",{"aria-hidden":!0,tabindex:!0,href:!0});var Tr=s(ce);va=o(Tr,"SPAN",{class:!0}),s(va).forEach(n),Tr.forEach(n),gs=c(Cc,"뮤텍스"),Cc.forEach(n),Ct=u(a),Ve=o(a,"UL",{});var Xr=s(Ve);H=o(Xr,"LI",{});var cn=s(H);_a=o(cn,"P",{});var Yr=s(_a);el=c(Yr,"두 고루틴 A와 B가 있을 때 A가 먼저 획득한 뮤텍스를 unlock하면 B가 뮤텍스를 lock할 수 있음."),Yr.forEach(n),nl=u(cn),Pe=o(cn,"UL",{});var Zt=s(Pe);ma=o(Zt,"LI",{});var Vr=s(ma);al=c(Vr,"이 때 unlock은 lock보다 먼저 동기화됨 (unlock is synchronized before the lock)"),Vr.forEach(n),tl=u(Zt),Be=o(Zt,"LI",{});var jt=s(Be);ol=c(jt,"다음의 예시 코드는 항상 "),ba=o(jt,"CODE",{});var Zr=s(ba);sl=c(Zr,"1"),Zr.forEach(n),ll=c(jt,"을 출력함"),jt.forEach(n),Zt.forEach(n),cl=u(cn),Ze=o(cn,"PRE",{class:!0});var zi=s(Ze);zi.forEach(n),cn.forEach(n),Xr.forEach(n),Dt=u(a),re=o(a,"H3",{id:!0});var Dc=s(re);ie=o(Dc,"A",{"aria-hidden":!0,tabindex:!0,href:!0});var jr=s(ie);ya=o(jr,"SPAN",{class:!0}),s(ya).forEach(n),jr.forEach(n),rl=c(Dc,"Atomic 연산"),Dc.forEach(n),xt=u(a),R=o(a,"UL",{});var rn=s(R);Oa=o(rn,"LI",{});var Fr=s(Oa);je=o(Fr,"P",{});var xc=s(je);wa=o(xc,"CODE",{});var Jr=s(wa);il=c(Jr,"sync/atomic"),Jr.forEach(n),pl=c(xc," 패키지는 저수준의 원자적 메모리 읽기/쓰기 연산을 제공함"),xc.forEach(n),Fr.forEach(n),ul=u(rn),La=o(rn,"LI",{});var Kr=s(La);Ca=o(Kr,"P",{});var Qr=s(Ca);dl=c(Qr,"만약 atomic write의 결과가 atomic read에서 확인된다면, atomic write는 atomic read보다 먼저 동기화됨 (atomic write is synchronized before the atomic read)"),Qr.forEach(n),Kr.forEach(n),fl=u(rn),Re=o(rn,"LI",{});var Ft=s(Re);Da=o(Ft,"P",{});var gr=s(Da);hl=c(gr,"다음의 코드는 항상 1을 출력함"),gr.forEach(n),kl=u(Ft),Fe=o(Ft,"PRE",{class:!0});var Gi=s(Fe);Gi.forEach(n),Ft.forEach(n),rn.forEach(n),Pt=u(a),pe=o(a,"H3",{id:!0});var Pc=s(pe);ue=o(Pc,"A",{"aria-hidden":!0,tabindex:!0,href:!0});var ei=s(ue);xa=o(ei,"SPAN",{class:!0}),s(xa).forEach(n),ei.forEach(n),El=c(Pc,"Map, Once, WaitGroup"),Pc.forEach(n),Bt=u(a),A=o(a,"UL",{});var pn=s(A);Ae=o(pn,"LI",{});var Jt=s(Ae);Je=o(Jt,"P",{});var Bc=s(Je);Pa=o(Bc,"CODE",{});var ni=s(Pa);vl=c(ni,"sync.Map"),ni.forEach(n),_l=c(Bc,"은 별도로 뮤텍스 로직을 구현하지 않아도 안전하게 사용할 수 있는 thread-safe map 타입임"),Bc.forEach(n),ml=u(Jt),y=o(Jt,"UL",{});var _e=s(y);q=o(_e,"LI",{});var un=s(q);bl=c(un,"데이터가 한번 write되지만 여러 번 read되는 경우나 여러 고루틴이 각각의 키로 접근하는 경우, 일반 "),Ba=o(un,"CODE",{});var ai=s(Ba);yl=c(ai,"map"),ai.forEach(n),Ol=c(un,"에 뮤텍스를 사용하여 구현하는 것보다 "),Ra=o(un,"CODE",{});var ti=s(Ra);wl=c(ti,"sync.Map"),ti.forEach(n),Ll=c(un,"을 사용하는 것이 더 좋은 성능을 보임"),un.forEach(n),Cl=u(_e),$=o(_e,"LI",{});var dn=s($);Dl=c(dn,"하지만 "),Aa=o(dn,"CODE",{});var oi=s(Aa);xl=c(oi,"sync.Map"),oi.forEach(n),Pl=c(dn,"은 "),Ia=o(dn,"CODE",{});var si=s(Ia);Bl=c(si,"map"),si.forEach(n),Rl=c(dn,"과 달리 타입 안정성을 보장하지 않음"),dn.forEach(n),Al=u(_e),Sa=o(_e,"LI",{});var li=s(Sa);Il=c(li,"간단하게 캐시같은거 구현할 때 사용하면 좋다고 함"),li.forEach(n),Sl=u(_e),Ke=o(_e,"LI",{});var Rc=s(Ke);za=o(Rc,"CODE",{});var ci=s(za);zl=c(ci,"sync.Map"),ci.forEach(n),Gl=c(Rc,"에서 어떤 read 연산이 write 연산의 결과를 확인한다면, write 연산은 read 연산보다 먼저 발생함 (write is happened before the read)"),Rc.forEach(n),_e.forEach(n),Jt.forEach(n),Hl=u(pn),Ie=o(pn,"LI",{});var Kt=s(Ie);Qe=o(Kt,"P",{});var Ac=s(Qe);Ga=o(Ac,"CODE",{});var ri=s(Ga);ql=c(ri,"sync.Once"),ri.forEach(n),$l=c(Ac,"는 여러 고루틴에서 무언가를 초기화하고자 할 때 유용함"),Ac.forEach(n),Ml=u(Kt),M=o(Kt,"UL",{});var fn=s(M);ge=o(fn,"LI",{});var Ic=s(ge);Ha=o(Ic,"CODE",{});var ii=s(Ha);Ul=c(ii,"sync.Once.Do()"),ii.forEach(n),Wl=c(Ic,"를 호출하여 함수를 넘기면 초기화가 실행됨"),Ic.forEach(n),Nl=u(fn),Se=o(fn,"LI",{});var Qt=s(Se);Tl=c(Qt,"여러 고루틴에서 "),qa=o(Qt,"CODE",{});var pi=s(qa);Xl=c(pi,"sync.Once.Do()"),pi.forEach(n),Yl=c(Qt,"를 호출하더라도, 초기화 함수는 한 번만 실행되고, 다른 고루틴에서는 초기화 함수가 실행되지 않고 block되었다가 초기화 함수가 실행된 후에 unblock됨"),Qt.forEach(n),Vl=u(fn),O=o(fn,"LI",{});var me=s(O);Zl=c(me,"한 고루틴에서 "),$a=o(me,"CODE",{});var ui=s($a);jl=c(ui,"sync.Once.Do()"),ui.forEach(n),Fl=c(me,"를 호출하면 다른 고루틴에서 "),Ma=o(me,"CODE",{});var di=s(Ma);Jl=c(di,"sync.Once.Do()"),di.forEach(n),Kl=c(me,"가 끝나기 이전에 그 초기화 함수가 종료됨 (the completion of initialization function is happened before the return from "),Ua=o(me,"CODE",{});var fi=s(Ua);Ql=c(fi,"sync.Once.Do()"),fi.forEach(n),gl=c(me,")"),me.forEach(n),fn.forEach(n),Kt.forEach(n),ec=u(pn),Wa=o(pn,"LI",{});var hi=s(Wa);h=o(hi,"P",{});var C=s(h);Na=o(C,"CODE",{});var ki=s(Na);nc=c(ki,"sync.WaitGroup"),ki.forEach(n),ac=c(C,"의 모든 "),Ta=o(C,"CODE",{});var Ei=s(Ta);tc=c(Ei,"Done()"),Ei.forEach(n),oc=c(C," 메소드 호출은 "),Xa=o(C,"CODE",{});var vi=s(Xa);sc=c(vi,"Wait()"),vi.forEach(n),lc=c(C," 메소드의 반환 이전에 동기화됨 (the completion of "),Ya=o(C,"CODE",{});var _i=s(Ya);cc=c(_i,"Done()"),_i.forEach(n),rc=c(C," is happened before the return from "),Va=o(C,"CODE",{});var mi=s(Va);ic=c(mi,"Wait()"),mi.forEach(n),pc=c(C,")"),C.forEach(n),hi.forEach(n),pn.forEach(n),Rt=u(a),At=o(a,"BR",{}),It=o(a,"BR",{}),St=u(a),de=o(a,"H2",{id:!0});var Sc=s(de);fe=o(Sc,"A",{"aria-hidden":!0,tabindex:!0,href:!0});var bi=s(fe);Za=o(bi,"SPAN",{class:!0}),s(Za).forEach(n),bi.forEach(n),uc=c(Sc,"References"),Sc.forEach(n),zt=u(a),Gt=o(a,"HR",{}),Ht=u(a),w=o(a,"CENTER",{});var Ge=s(w);ja=o(Ge,"P",{});var yi=s(ja);dc=c(yi,"["),yi.forEach(n),fc=u(Ge),wi(ze.$$.fragment,Ge),hc=c(Ge,`
](https://learning.oreilly.com/library/view/effective-concurrency-in/9781804619070/)`),kc=o(Ge,"BR",{}),Ec=c(Ge,`
[Burak Serdar, 『Effective Concurrency in Go』, Packt Publishing](https://learning.oreilly.com/library/view/effective-concurrency-in/9781804619070/)`),Ge.forEach(n),this.h()},h(){d(hn,"class","icon icon-link"),d(X,"aria-hidden","true"),d(X,"tabindex","-1"),d(X,"href","#메모리-연산-순서-모델"),d(T,"id","메모리-연산-순서-모델"),d(kn,"class","icon icon-link"),d(V,"aria-hidden","true"),d(V,"tabindex","-1"),d(V,"href","#sequenced-before-relationship"),d(Y,"id","sequenced-before-relationship"),d(On,"class","icon icon-link"),d(j,"aria-hidden","true"),d(j,"tabindex","-1"),d(j,"href","#synchronized-before-relationship"),d(Z,"id","synchronized-before-relationship"),d(Sn,"class","icon icon-link"),d(J,"aria-hidden","true"),d(J,"tabindex","-1"),d(J,"href","#happened-before-relationship"),d(F,"id","happened-before-relationship"),d(Yn,"class","icon icon-link"),d(Q,"aria-hidden","true"),d(Q,"tabindex","-1"),d(Q,"href","#golang의-동기화-모델"),d(K,"id","golang의-동기화-모델"),d(Vn,"class","icon icon-link"),d(ee,"aria-hidden","true"),d(ee,"tabindex","-1"),d(ee,"href","#패키지-초기화"),d(g,"id","패키지-초기화"),d(Fn,"class","icon icon-link"),d(ae,"aria-hidden","true"),d(ae,"tabindex","-1"),d(ae,"href","#고루틴"),d(ne,"id","고루틴"),d(Xe,"class","language-go"),d(aa,"class","icon icon-link"),d(oe,"aria-hidden","true"),d(oe,"tabindex","-1"),d(oe,"href","#채널"),d(te,"id","채널"),d(Ye,"class","language-go"),d(va,"class","icon icon-link"),d(ce,"aria-hidden","true"),d(ce,"tabindex","-1"),d(ce,"href","#뮤텍스"),d(le,"id","뮤텍스"),d(Ze,"class","language-go"),d(ya,"class","icon icon-link"),d(ie,"aria-hidden","true"),d(ie,"tabindex","-1"),d(ie,"href","#atomic-연산"),d(re,"id","atomic-연산"),d(Fe,"class","language-go"),d(xa,"class","icon icon-link"),d(ue,"aria-hidden","true"),d(ue,"tabindex","-1"),d(ue,"href","#map-once-waitgroup"),d(pe,"id","map-once-waitgroup"),d(Za,"class","icon icon-link"),d(fe,"aria-hidden","true"),d(fe,"tabindex","-1"),d(fe,"href","#references"),d(de,"id","references")},m(a,r){i(a,k,r),e(k,I),i(a,He,r),i(a,qe,r),e(qe,eo),i(a,Ka,r),i(a,W,r),e(W,no),Li(N,W,null),e(W,ao),i(a,Qa,r),i(a,$e,r),e($e,to),i(a,ga,r),i(a,Me,r),e(Me,oo),i(a,et,r),i(a,nt,r),i(a,at,r),i(a,tt,r),i(a,T,r),e(T,X),e(X,hn),e(T,so),i(a,ot,r),i(a,st,r),i(a,lt,r),i(a,Y,r),e(Y,V),e(V,kn),e(Y,En),e(En,lo),i(a,ct,r),i(a,D,r),e(D,v),e(v,co),e(v,vn),e(vn,ro),e(v,io),e(v,_n),e(_n,po),e(v,uo),e(v,mn),e(mn,fo),e(v,ho),e(D,ko),e(D,bn),e(bn,Eo),e(D,vo),e(D,yn),e(yn,_o),i(a,rt,r),i(a,Z,r),e(Z,j),e(j,On),e(Z,wn),e(wn,mo),i(a,it,r),i(a,x,r),e(x,be),e(be,Ln),e(Ln,bo),e(be,yo),e(be,ye),e(ye,Cn),e(Cn,Oo),e(ye,wo),e(ye,Dn),e(Dn,Lo),e(x,Co),e(x,xn),e(xn,_),e(_,Do),e(_,Pn),e(Pn,xo),e(_,Po),e(_,Bn),e(Bn,Bo),e(_,Ro),e(_,Rn),e(Rn,Ao),e(_,Io),e(x,So),e(x,An),e(An,In),e(In,zo),i(a,pt,r),i(a,F,r),e(F,J),e(J,Sn),e(F,zn),e(zn,Go),i(a,ut,r),i(a,P,r),e(P,Gn),e(Gn,Ho),e(P,qo),e(P,E),e(E,Hn),e(Hn,$o),e(E,Mo),e(E,qn),e(qn,Uo),e(E,Wo),e(E,$n),e($n,No),e(E,To),e(E,Mn),e(Mn,Xo),e(E,Yo),e(P,Vo),e(P,f),e(f,Un),e(Un,Zo),e(f,jo),e(f,Wn),e(Wn,Fo),e(f,Jo),e(f,Nn),e(Nn,Ko),e(f,Qo),e(f,Tn),e(Tn,go),e(f,es),e(f,Xn),e(Xn,ns),e(f,as),i(a,dt,r),i(a,Ue,r),e(Ue,ts),i(a,ft,r),i(a,ht,r),i(a,kt,r),i(a,Et,r),i(a,K,r),e(K,Q),e(Q,Yn),e(K,os),i(a,vt,r),i(a,We,r),e(We,ss),i(a,_t,r),i(a,g,r),e(g,ee),e(ee,Vn),e(g,ls),i(a,mt,r),i(a,Ne,r),e(Ne,S),e(S,cs),e(S,Zn),e(Zn,rs),e(S,is),e(S,jn),e(jn,ps),e(S,us),i(a,bt,r),i(a,ne,r),e(ne,ae),e(ae,Fn),e(ne,ds),i(a,yt,r),i(a,Te,r),e(Te,m),e(m,z),e(z,fs),e(z,Jn),e(Jn,hs),e(z,ks),e(z,Kn),e(Kn,Es),e(z,vs),e(m,_s),e(m,Qn),e(Qn,Oe),e(Oe,ms),e(Oe,gn),e(gn,bs),e(Oe,ys),e(m,Os),e(m,Xe),Xe.innerHTML=Pi,e(m,ws),e(m,ea),e(ea,na),e(na,Ls),i(a,Ot,r),i(a,te,r),e(te,oe),e(oe,aa),e(te,Cs),i(a,wt,r),i(a,B,r),e(B,ta),e(ta,oa),e(oa,Ds),e(B,xs),e(B,we),e(we,sa),e(sa,Ps),e(we,Bs),e(we,la),e(la,ca),e(ca,Rs),e(B,As),e(B,G),e(G,Le),e(Le,Is),e(Le,ra),e(ra,Ss),e(Le,zs),e(G,Gs),e(G,Ye),Ye.innerHTML=Bi,e(G,Hs),e(G,b),e(b,Ce),e(Ce,ia),e(ia,qs),e(Ce,$s),e(Ce,pa),e(pa,Ms),e(b,Us),e(b,De),e(De,ua),e(ua,Ws),e(De,Ns),e(De,da),e(da,Ts),e(b,Xs),e(b,xe),e(xe,fa),e(fa,Ys),e(xe,Vs),e(xe,ha),e(ha,Zs),e(b,js),e(b,se),e(se,Fs),e(se,ka),e(ka,Js),e(se,Ks),e(se,Ea),e(Ea,Qs),i(a,Lt,r),i(a,le,r),e(le,ce),e(ce,va),e(le,gs),i(a,Ct,r),i(a,Ve,r),e(Ve,H),e(H,_a),e(_a,el),e(H,nl),e(H,Pe),e(Pe,ma),e(ma,al),e(Pe,tl),e(Pe,Be),e(Be,ol),e(Be,ba),e(ba,sl),e(Be,ll),e(H,cl),e(H,Ze),Ze.innerHTML=Ri,i(a,Dt,r),i(a,re,r),e(re,ie),e(ie,ya),e(re,rl),i(a,xt,r),i(a,R,r),e(R,Oa),e(Oa,je),e(je,wa),e(wa,il),e(je,pl),e(R,ul),e(R,La),e(La,Ca),e(Ca,dl),e(R,fl),e(R,Re),e(Re,Da),e(Da,hl),e(Re,kl),e(Re,Fe),Fe.innerHTML=Ai,i(a,Pt,r),i(a,pe,r),e(pe,ue),e(ue,xa),e(pe,El),i(a,Bt,r),i(a,A,r),e(A,Ae),e(Ae,Je),e(Je,Pa),e(Pa,vl),e(Je,_l),e(Ae,ml),e(Ae,y),e(y,q),e(q,bl),e(q,Ba),e(Ba,yl),e(q,Ol),e(q,Ra),e(Ra,wl),e(q,Ll),e(y,Cl),e(y,$),e($,Dl),e($,Aa),e(Aa,xl),e($,Pl),e($,Ia),e(Ia,Bl),e($,Rl),e(y,Al),e(y,Sa),e(Sa,Il),e(y,Sl),e(y,Ke),e(Ke,za),e(za,zl),e(Ke,Gl),e(A,Hl),e(A,Ie),e(Ie,Qe),e(Qe,Ga),e(Ga,ql),e(Qe,$l),e(Ie,Ml),e(Ie,M),e(M,ge),e(ge,Ha),e(Ha,Ul),e(ge,Wl),e(M,Nl),e(M,Se),e(Se,Tl),e(Se,qa),e(qa,Xl),e(Se,Yl),e(M,Vl),e(M,O),e(O,Zl),e(O,$a),e($a,jl),e(O,Fl),e(O,Ma),e(Ma,Jl),e(O,Kl),e(O,Ua),e(Ua,Ql),e(O,gl),e(A,ec),e(A,Wa),e(Wa,h),e(h,Na),e(Na,nc),e(h,ac),e(h,Ta),e(Ta,tc),e(h,oc),e(h,Xa),e(Xa,sc),e(h,lc),e(h,Ya),e(Ya,cc),e(h,rc),e(h,Va),e(Va,ic),e(h,pc),i(a,Rt,r),i(a,At,r),i(a,It,r),i(a,St,r),i(a,de,r),e(de,fe),e(fe,Za),e(de,uc),i(a,zt,r),i(a,Gt,r),i(a,Ht,r),i(a,w,r),e(w,ja),e(ja,dc),e(w,fc),Li(ze,w,null),e(w,hc),e(w,kc),e(w,Ec),qt=!0},p(a,[r]){const Fa={};r&1&&(Fa.$$scope={dirty:r,ctx:a}),N.$set(Fa)},i(a){qt||(Ci(N.$$.fragment,a),Ci(ze.$$.fragment,a),qt=!0)},o(a){Di(N.$$.fragment,a),Di(ze.$$.fragment,a),qt=!1},d(a){a&&n(k),a&&n(He),a&&n(qe),a&&n(Ka),a&&n(W),xi(N),a&&n(Qa),a&&n($e),a&&n(ga),a&&n(Me),a&&n(et),a&&n(nt),a&&n(at),a&&n(tt),a&&n(T),a&&n(ot),a&&n(st),a&&n(lt),a&&n(Y),a&&n(ct),a&&n(D),a&&n(rt),a&&n(Z),a&&n(it),a&&n(x),a&&n(pt),a&&n(F),a&&n(ut),a&&n(P),a&&n(dt),a&&n(Ue),a&&n(ft),a&&n(ht),a&&n(kt),a&&n(Et),a&&n(K),a&&n(vt),a&&n(We),a&&n(_t),a&&n(g),a&&n(mt),a&&n(Ne),a&&n(bt),a&&n(ne),a&&n(yt),a&&n(Te),a&&n(Ot),a&&n(te),a&&n(wt),a&&n(B),a&&n(Lt),a&&n(le),a&&n(Ct),a&&n(Ve),a&&n(Dt),a&&n(re),a&&n(xt),a&&n(R),a&&n(Pt),a&&n(pe),a&&n(Bt),a&&n(A),a&&n(Rt),a&&n(At),a&&n(It),a&&n(St),a&&n(de),a&&n(zt),a&&n(Gt),a&&n(Ht),a&&n(w),xi(ze)}}}const Vi={title:"Go의 메모리 모델",date:"2023-08-31T00:00:00.000Z",excerpt:"Go의 메모리 모델",categories:["Golang","Concurrency in Go"],coverImage:"/post_img/Go/Concurrency in Go/cover.png",coverWidth:16,coverHeight:9,indexed:!1,exposed:!0};class Zi extends Hi{constructor(k){super(),qi(this,k,null,Ni,$i,{})}}export{Zi as default,Vi as metadata};
