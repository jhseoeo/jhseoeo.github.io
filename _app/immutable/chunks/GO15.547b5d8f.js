import{S as U6,i as W6,s as j6,k as l,a as i,q as t,y as F5,l as c,c as r,m as u,r as p,h as s,z as Z5,n as k,U as K6,b as o,E as a,A as z5,g as X5,d as Y5,B as V5}from"./index.5621e629.js";import{H as q5}from"./Highlight.2decd09b.js";function Q6(Gs){let v;return{c(){v=t("충분히 빠르고")},l(E){v=p(E,"충분히 빠르고")},m(E,x){o(E,v,x)},d(E){E&&s(v)}}}function h6(Gs){let v;return{c(){v=t("유지보수성이 좋으면서도")},l(E){v=p(E,"유지보수성이 좋으면서도")},m(E,x){o(E,v,x)},d(E){E&&s(v)}}}function g6(Gs){let v;return{c(){v=t("우리의 수요를 충족시키는")},l(E){v=p(E,"우리의 수요를 충족시키는")},m(E,x){o(E,v,x)},d(E){E&&s(v)}}}function n0(Gs){let v,E,x,ck,pl,el,ol,ll,mn,wn,Nt,uk,cl,ul,il,Aa,ik,rl,$a,rk,kl,fl,dl,Na,kk,El,Fa,fk,vl,_l,bl,yl,Pn,On,Ft,dk,ml,A,Ek,Zt,vk,_k,zt,bk,yk,Xt,mk,wk,wl,$,Pk,Yt,Ok,Tk,Vt,Dk,Ck,qt,Rk,Gk,Pl,Ss,Qy=`<code class="language-go"><span class="token keyword">func</span> <span class="token function">Min</span><span class="token punctuation">(</span>v1<span class="token punctuation">,</span> v2 <span class="token builtin">float64</span><span class="token punctuation">)</span> <span class="token builtin">float64</span> <span class="token punctuation">&#123;</span>
    <span class="token keyword">if</span> v1 <span class="token operator">&lt;</span> v2 <span class="token punctuation">&#123;</span>
        <span class="token keyword">return</span> v1
    <span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>
        <span class="token keyword">return</span> v2
    <span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span></code>`,Ol,N,Sk,Jt,Ik,Mk,Ut,Hk,Bk,Wt,Lk,xk,Tl,Is,hy=`<code class="language-go"><span class="token keyword">type</span> Node <span class="token keyword">struct</span> <span class="token punctuation">&#123;</span>
    val <span class="token operator">*</span><span class="token builtin">int</span>
    next <span class="token operator">*</span>Node
<span class="token punctuation">&#125;</span></code>`,Dl,Cl,Rl,Za,Ak,Gl,F,$k,jt,Nk,Fk,Kt,Zk,zk,Qt,Xk,Yk,Sl,za,Vk,Il,Ms,gy=`<code class="language-go"><span class="token keyword">type</span> Orderable <span class="token keyword">interface</span> <span class="token punctuation">&#123;</span>
    <span class="token function">Order</span><span class="token punctuation">(</span><span class="token keyword">interface</span><span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span> <span class="token builtin">int</span>
<span class="token punctuation">&#125;</span></code>`,Ml,Tn,qk,ht,Jk,Uk,Hl,Hs,nm=`<code class="language-go"><span class="token keyword">type</span> Tree <span class="token keyword">struct</span> <span class="token punctuation">&#123;</span>
	val         Orderable
	left<span class="token punctuation">,</span> right <span class="token operator">*</span>Tree
<span class="token punctuation">&#125;</span>

<span class="token keyword">func</span> <span class="token punctuation">(</span>t <span class="token operator">*</span>Tree<span class="token punctuation">)</span> <span class="token function">Insert</span><span class="token punctuation">(</span>val Orderable<span class="token punctuation">)</span> <span class="token operator">*</span>Tree <span class="token punctuation">&#123;</span>
	<span class="token keyword">if</span> t <span class="token operator">==</span> <span class="token boolean">nil</span> <span class="token punctuation">&#123;</span>
		<span class="token keyword">return</span> <span class="token operator">&amp;</span>Tree<span class="token punctuation">&#123;</span>val<span class="token punctuation">:</span> val<span class="token punctuation">&#125;</span>
	<span class="token punctuation">&#125;</span>

	<span class="token keyword">switch</span> comp <span class="token operator">:=</span> val<span class="token punctuation">.</span><span class="token function">Order</span><span class="token punctuation">(</span>t<span class="token punctuation">.</span>val<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">&#123;</span>
	<span class="token keyword">case</span> comp <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">:</span>
		t<span class="token punctuation">.</span>left <span class="token operator">=</span> t<span class="token punctuation">.</span>left<span class="token punctuation">.</span><span class="token function">Insert</span><span class="token punctuation">(</span>val<span class="token punctuation">)</span>
	<span class="token keyword">case</span> comp <span class="token operator">></span> <span class="token number">0</span><span class="token punctuation">:</span>
		t<span class="token punctuation">.</span>right <span class="token operator">=</span> t<span class="token punctuation">.</span>right<span class="token punctuation">.</span><span class="token function">Insert</span><span class="token punctuation">(</span>val<span class="token punctuation">)</span>
	<span class="token punctuation">&#125;</span>
	<span class="token keyword">return</span> t
<span class="token punctuation">&#125;</span></code>`,Bl,h,Wk,gt,jk,Kk,np,Qk,hk,Ll,Bs,sm=`<code class="language-go"><span class="token keyword">type</span> OrderableInt <span class="token builtin">int</span>

<span class="token keyword">func</span> <span class="token punctuation">(</span>oi OrderableInt<span class="token punctuation">)</span> <span class="token function">Order</span><span class="token punctuation">(</span>val <span class="token keyword">interface</span><span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span> <span class="token builtin">int</span> <span class="token punctuation">&#123;</span>
	<span class="token keyword">return</span> <span class="token function">int</span><span class="token punctuation">(</span>oi <span class="token operator">-</span> val<span class="token punctuation">.</span><span class="token punctuation">(</span>OrderableInt<span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token punctuation">&#125;</span>

<span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
	<span class="token keyword">var</span> it <span class="token operator">*</span>Tree
	it <span class="token operator">=</span> it<span class="token punctuation">.</span><span class="token function">Insert</span><span class="token punctuation">(</span><span class="token function">OrderableInt</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
	it <span class="token operator">=</span> it<span class="token punctuation">.</span><span class="token function">Insert</span><span class="token punctuation">(</span><span class="token function">OrderableInt</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
	<span class="token comment">// etc..</span>
<span class="token punctuation">&#125;</span></code>`,xl,g,gk,sp,nf,sf,ap,af,tf,Al,Ls,am=`<code class="language-go"><span class="token keyword">type</span> OrderableString <span class="token builtin">string</span>

<span class="token keyword">func</span> <span class="token punctuation">(</span>os OrderableString<span class="token punctuation">)</span> <span class="token function">Order</span><span class="token punctuation">(</span>val <span class="token keyword">interface</span><span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span> <span class="token builtin">int</span> <span class="token punctuation">&#123;</span>
	<span class="token keyword">return</span> strings<span class="token punctuation">.</span><span class="token function">Compare</span><span class="token punctuation">(</span><span class="token function">string</span><span class="token punctuation">(</span>os<span class="token punctuation">)</span><span class="token punctuation">,</span> val<span class="token punctuation">.</span><span class="token punctuation">(</span><span class="token builtin">string</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token punctuation">&#125;</span></code>`,$l,nn,pf,tp,ef,of,pp,lf,cf,Nl,xs,tm=`<code class="language-go"><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
	<span class="token keyword">var</span> it <span class="token operator">*</span>Tree
	it <span class="token operator">=</span> it<span class="token punctuation">.</span><span class="token function">Insert</span><span class="token punctuation">(</span><span class="token function">OrderableInt</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
	it <span class="token operator">=</span> it<span class="token punctuation">.</span><span class="token function">Insert</span><span class="token punctuation">(</span><span class="token function">OrderableInt</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
	it <span class="token operator">=</span> it<span class="token punctuation">.</span><span class="token function">Insert</span><span class="token punctuation">(</span><span class="token function">OrderableString</span><span class="token punctuation">(</span><span class="token string">"Nope!"</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token punctuation">&#125;</span></code>`,Fl,D,uf,ep,rf,kf,op,ff,df,lp,Ef,vf,cp,_f,bf,Zl,As,pm=`<code class="language-text">$ go run tree-non-generics.go
panic: interface conversion: interface &#123;&#125; is main.OrderableInt, not string</code>`,zl,Xa,yf,Xl,Yl,Vl,Ya,mf,ql,O,wf,up,Pf,Of,ip,Tf,Df,rp,Cf,Rf,kp,Gf,Sf,fp,If,Mf,Jl,Dn,Hf,dp,Bf,Lf,Ul,Wl,jl,Kl,Cn,Rn,Ep,xf,Ql,hl,gl,Va,Af,nc,qa,$f,sc,$s,em=`<code class="language-go"><span class="token keyword">type</span> Stack<span class="token punctuation">[</span>T any<span class="token punctuation">]</span> <span class="token keyword">struct</span> <span class="token punctuation">&#123;</span>
	vals <span class="token punctuation">[</span><span class="token punctuation">]</span>T
<span class="token punctuation">&#125;</span>

<span class="token keyword">func</span> <span class="token punctuation">(</span>s <span class="token operator">*</span>Stack<span class="token punctuation">[</span>T<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token function">Push</span><span class="token punctuation">(</span>val T<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
	s<span class="token punctuation">.</span>vals <span class="token operator">=</span> <span class="token function">append</span><span class="token punctuation">(</span>s<span class="token punctuation">.</span>vals<span class="token punctuation">,</span> val<span class="token punctuation">)</span>
<span class="token punctuation">&#125;</span>

<span class="token keyword">func</span> <span class="token punctuation">(</span>s <span class="token operator">*</span>Stack<span class="token punctuation">[</span>T<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token function">Pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">(</span>T<span class="token punctuation">,</span> <span class="token builtin">bool</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
	<span class="token keyword">if</span> <span class="token function">len</span><span class="token punctuation">(</span>s<span class="token punctuation">.</span>vals<span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token number">0</span> <span class="token punctuation">&#123;</span>
		<span class="token keyword">var</span> zero T
		<span class="token keyword">return</span> zero<span class="token punctuation">,</span> <span class="token boolean">false</span>
	<span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>
		top <span class="token operator">:=</span> s<span class="token punctuation">.</span>vals<span class="token punctuation">[</span><span class="token function">len</span><span class="token punctuation">(</span>s<span class="token punctuation">.</span>vals<span class="token punctuation">)</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span>
		s<span class="token punctuation">.</span>vals <span class="token operator">=</span> s<span class="token punctuation">.</span>vals<span class="token punctuation">[</span><span class="token punctuation">:</span><span class="token function">len</span><span class="token punctuation">(</span>s<span class="token punctuation">.</span>vals<span class="token punctuation">)</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span>
		<span class="token keyword">return</span> top<span class="token punctuation">,</span> <span class="token boolean">true</span>
	<span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span></code>`,ac,Ja,Nf,tc,Z,z,vp,Ff,Zf,_p,zf,Xf,bp,Yf,Vf,yp,qf,Jf,Uf,B,Wf,mp,jf,Kf,wp,Qf,hf,Pp,gf,n1,Op,s1,a1,t1,m,p1,Tp,e1,o1,Dp,l1,c1,Cp,u1,i1,Rp,r1,k1,Gp,f1,d1,Sp,E1,v1,_1,w,b1,Ip,y1,m1,Mp,w1,P1,Hp,O1,T1,Bp,D1,C1,Lp,R1,G1,xp,S1,I1,pc,ec,oc,Ua,M1,lc,Ns,om=`<code class="language-go"><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
	<span class="token keyword">var</span> intStack Stack<span class="token punctuation">[</span><span class="token builtin">int</span><span class="token punctuation">]</span>
	intStack<span class="token punctuation">.</span><span class="token function">Push</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span>
	intStack<span class="token punctuation">.</span><span class="token function">Push</span><span class="token punctuation">(</span><span class="token number">12</span><span class="token punctuation">)</span>
	intStack<span class="token punctuation">.</span><span class="token function">Push</span><span class="token punctuation">(</span><span class="token number">14</span><span class="token punctuation">)</span>
	v<span class="token punctuation">,</span> ok <span class="token operator">:=</span> intStack<span class="token punctuation">.</span><span class="token function">Pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
	fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>v<span class="token punctuation">,</span> ok<span class="token punctuation">)</span>
<span class="token punctuation">&#125;</span></code>`,cc,X,H1,Ap,B1,L1,$p,x1,A1,Np,$1,N1,uc,Gn,F1,Fp,Z1,z1,ic,Fs,lm='<code class="language-go">intStack<span class="token punctuation">.</span><span class="token function">Push</span><span class="token punctuation">(</span><span class="token string">"nope"</span><span class="token punctuation">)</span></code>',rc,Wa,X1,kc,Zs,cm=`<code class="language-text">$ go run generic-stack.go
./generic-stack.go:31:16: cannot use "nope" (untyped string constant) as int value in argument to intStack.Push</code>`,fc,dc,Ec,Sn,Y1,Zp,V1,q1,vc,zs,um=`<code class="language-go"><span class="token keyword">func</span> <span class="token punctuation">(</span>s <span class="token operator">*</span>Stack<span class="token punctuation">[</span>T<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token function">Contains</span><span class="token punctuation">(</span>val T<span class="token punctuation">)</span> <span class="token builtin">bool</span> <span class="token punctuation">&#123;</span>
	<span class="token keyword">for</span> <span class="token boolean">_</span><span class="token punctuation">,</span> v <span class="token operator">:=</span> <span class="token keyword">range</span> s<span class="token punctuation">.</span>vals <span class="token punctuation">&#123;</span>
		<span class="token keyword">if</span> v <span class="token operator">==</span> val <span class="token punctuation">&#123;</span>
			<span class="token keyword">return</span> <span class="token boolean">true</span>
		<span class="token punctuation">&#125;</span>
	<span class="token punctuation">&#125;</span>
	<span class="token keyword">return</span> <span class="token boolean">false</span>
<span class="token punctuation">&#125;</span></code>`,_c,ja,J1,bc,Xs,im=`<code class="language-text">$ go run generic-stack.go
./generic-stack.go:26:6: invalid operation: v == val (type parameter T is not comparable with ==)</code>`,yc,P,zp,U1,W1,Xp,j1,K1,Yp,Q1,h1,Vp,g1,n2,qp,s2,a2,Jp,t2,p2,mc,y,e2,Up,o2,l2,Wp,c2,u2,jp,i2,r2,Kp,k2,f2,Qp,d2,E2,hp,v2,_2,wc,Ys,rm=`<code class="language-go"><span class="token keyword">type</span> Stack<span class="token punctuation">[</span>T comparable<span class="token punctuation">]</span> <span class="token keyword">struct</span> <span class="token punctuation">&#123;</span>
	vals <span class="token punctuation">[</span><span class="token punctuation">]</span>T
<span class="token punctuation">&#125;</span></code>`,Pc,In,b2,gp,y2,m2,Oc,Vs,km=`<code class="language-go"><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
	<span class="token keyword">var</span> intStack Stack<span class="token punctuation">[</span><span class="token builtin">int</span><span class="token punctuation">]</span>
	intStack<span class="token punctuation">.</span><span class="token function">Push</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span>
	intStack<span class="token punctuation">.</span><span class="token function">Push</span><span class="token punctuation">(</span><span class="token number">12</span><span class="token punctuation">)</span>
	intStack<span class="token punctuation">.</span><span class="token function">Push</span><span class="token punctuation">(</span><span class="token number">14</span><span class="token punctuation">)</span>
	<span class="token comment">//intStack.Push("nope") // this occurs error</span>
	fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>intStack<span class="token punctuation">.</span><span class="token function">Contains</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
	fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>intStack<span class="token punctuation">.</span><span class="token function">Contains</span><span class="token punctuation">(</span><span class="token number">20</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token punctuation">&#125;</span></code>`,Tc,Ka,w2,Dc,qs,fm=`<code class="language-text">$ go run generic-stack.go
true
false</code>`,Cc,Qa,P2,Rc,Gc,Sc,Ic,Mn,Hn,ne,O2,Mc,Hc,Bc,ha,T2,Lc,Js,dm=`<code class="language-go"><span class="token keyword">func</span> Map<span class="token punctuation">[</span>T1<span class="token punctuation">,</span> T2 any<span class="token punctuation">]</span><span class="token punctuation">(</span>s <span class="token punctuation">[</span><span class="token punctuation">]</span>T1<span class="token punctuation">,</span> f <span class="token keyword">func</span><span class="token punctuation">(</span>T1<span class="token punctuation">)</span> T2<span class="token punctuation">)</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>T2 <span class="token punctuation">&#123;</span>
	r <span class="token operator">:=</span> <span class="token function">make</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span>T2<span class="token punctuation">,</span> <span class="token function">len</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">)</span>
	<span class="token keyword">for</span> i<span class="token punctuation">,</span> v <span class="token operator">:=</span> <span class="token keyword">range</span> s <span class="token punctuation">&#123;</span>
		r<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">f</span><span class="token punctuation">(</span>v<span class="token punctuation">)</span>
	<span class="token punctuation">&#125;</span>
	<span class="token keyword">return</span> r
<span class="token punctuation">&#125;</span>

<span class="token keyword">func</span> Filter<span class="token punctuation">[</span>T any<span class="token punctuation">]</span><span class="token punctuation">(</span>s <span class="token punctuation">[</span><span class="token punctuation">]</span>T<span class="token punctuation">,</span> f <span class="token keyword">func</span><span class="token punctuation">(</span>T<span class="token punctuation">)</span> <span class="token builtin">bool</span><span class="token punctuation">)</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>T <span class="token punctuation">&#123;</span>
	<span class="token keyword">var</span> r <span class="token punctuation">[</span><span class="token punctuation">]</span>T
	<span class="token keyword">for</span> <span class="token boolean">_</span><span class="token punctuation">,</span> v <span class="token operator">:=</span> <span class="token keyword">range</span> s <span class="token punctuation">&#123;</span>
		<span class="token keyword">if</span> <span class="token function">f</span><span class="token punctuation">(</span>v<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
			r <span class="token operator">=</span> <span class="token function">append</span><span class="token punctuation">(</span>r<span class="token punctuation">,</span> v<span class="token punctuation">)</span>
		<span class="token punctuation">&#125;</span>
	<span class="token punctuation">&#125;</span>
	<span class="token keyword">return</span> r
<span class="token punctuation">&#125;</span>

<span class="token keyword">func</span> Reduce<span class="token punctuation">[</span>T1<span class="token punctuation">,</span> T2 any<span class="token punctuation">]</span><span class="token punctuation">(</span>s <span class="token punctuation">[</span><span class="token punctuation">]</span>T1<span class="token punctuation">,</span> f <span class="token keyword">func</span><span class="token punctuation">(</span>T2<span class="token punctuation">,</span> T1<span class="token punctuation">)</span> T2<span class="token punctuation">,</span> initial T2<span class="token punctuation">)</span> T2 <span class="token punctuation">&#123;</span>
	r <span class="token operator">:=</span> initial
	<span class="token keyword">for</span> <span class="token boolean">_</span><span class="token punctuation">,</span> v <span class="token operator">:=</span> <span class="token keyword">range</span> s <span class="token punctuation">&#123;</span>
		r <span class="token operator">=</span> <span class="token function">f</span><span class="token punctuation">(</span>r<span class="token punctuation">,</span> v<span class="token punctuation">)</span>
	<span class="token punctuation">&#125;</span>
	<span class="token keyword">return</span> v
<span class="token punctuation">&#125;</span></code>`,xc,Y,D2,se,C2,R2,ae,G2,S2,te,I2,M2,Ac,ga,H2,$c,Us,Em=`<code class="language-go"><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
	words <span class="token operator">:=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token builtin">string</span><span class="token punctuation">&#123;</span><span class="token string">"One"</span><span class="token punctuation">,</span> <span class="token string">"Potato"</span><span class="token punctuation">,</span> <span class="token string">"Two"</span><span class="token punctuation">,</span> <span class="token string">"Potato"</span><span class="token punctuation">&#125;</span>

	filtered <span class="token operator">:=</span> <span class="token function">Filter</span><span class="token punctuation">(</span>words<span class="token punctuation">,</span> <span class="token keyword">func</span><span class="token punctuation">(</span>s <span class="token builtin">string</span><span class="token punctuation">)</span> <span class="token builtin">bool</span> <span class="token punctuation">&#123;</span>
		<span class="token keyword">return</span> s <span class="token operator">!=</span> <span class="token string">"Potato"</span>
	<span class="token punctuation">&#125;</span><span class="token punctuation">)</span>
	fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>filtered<span class="token punctuation">)</span>

	lengths <span class="token operator">:=</span> <span class="token function">Map</span><span class="token punctuation">(</span>filtered<span class="token punctuation">,</span> <span class="token keyword">func</span><span class="token punctuation">(</span>s <span class="token builtin">string</span><span class="token punctuation">)</span> <span class="token builtin">int</span> <span class="token punctuation">&#123;</span>
		<span class="token keyword">return</span> <span class="token function">len</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span>
	<span class="token punctuation">&#125;</span><span class="token punctuation">)</span>
	fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>lengths<span class="token punctuation">)</span>

	sum <span class="token operator">:=</span> <span class="token function">Reduce</span><span class="token punctuation">(</span>lengths<span class="token punctuation">,</span> <span class="token keyword">func</span><span class="token punctuation">(</span>acc <span class="token builtin">int</span><span class="token punctuation">,</span> cur <span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token builtin">int</span> <span class="token punctuation">&#123;</span>
		<span class="token keyword">return</span> acc <span class="token operator">+</span> cur
	<span class="token punctuation">&#125;</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span>
	fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>sum<span class="token punctuation">)</span>
<span class="token punctuation">&#125;</span></code>`,Nc,nt,B2,Fc,Ws,vm=`<code class="language-text">$ go run map_filter_reduce.go
[One Two]
[3 3]
6</code>`,Zc,zc,Xc,Yc,Bn,Ln,pe,L2,Vc,qc,Jc,Q,ee,x2,A2,oe,$2,N2,le,F2,Z2,Uc,js,_m=`<code class="language-go"><span class="token keyword">type</span> Pair<span class="token punctuation">[</span>T fmt<span class="token punctuation">.</span>Stringer<span class="token punctuation">]</span> <span class="token keyword">struct</span> <span class="token punctuation">&#123;</span>
	Val1 T
	Val2 T
<span class="token punctuation">&#125;</span></code>`,Wc,st,z2,jc,Ks,bm=`<code class="language-go"><span class="token keyword">type</span> Differ<span class="token punctuation">[</span>T any<span class="token punctuation">]</span> <span class="token keyword">interface</span> <span class="token punctuation">&#123;</span>
	fmt<span class="token punctuation">.</span>Stringer
	<span class="token function">Diff</span><span class="token punctuation">(</span>T<span class="token punctuation">)</span> <span class="token builtin">float64</span>
<span class="token punctuation">&#125;</span></code>`,Kc,C,X2,ce,Y2,V2,ue,q2,J2,ie,U2,W2,re,j2,K2,Qc,xn,Q2,ke,h2,g2,hc,Qs,ym=`<code class="language-go"><span class="token keyword">func</span> FindCloser<span class="token punctuation">[</span>T Differ<span class="token punctuation">[</span>T<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">(</span>pair1<span class="token punctuation">,</span> pair2 Pair<span class="token punctuation">[</span>T<span class="token punctuation">]</span><span class="token punctuation">)</span> Pair<span class="token punctuation">[</span>T<span class="token punctuation">]</span> <span class="token punctuation">&#123;</span>
	d1 <span class="token operator">:=</span> pair1<span class="token punctuation">.</span>Val1<span class="token punctuation">.</span><span class="token function">Diff</span><span class="token punctuation">(</span>pair1<span class="token punctuation">.</span>Val2<span class="token punctuation">)</span>
	d2 <span class="token operator">:=</span> pair2<span class="token punctuation">.</span>Val1<span class="token punctuation">.</span><span class="token function">Diff</span><span class="token punctuation">(</span>pair2<span class="token punctuation">.</span>Val2<span class="token punctuation">)</span>
	<span class="token keyword">if</span> d1 <span class="token operator">&lt;</span> d2 <span class="token punctuation">&#123;</span>
		<span class="token keyword">return</span> pair1
	<span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>
		<span class="token keyword">return</span> pair2
	<span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span></code>`,gc,d,fe,nd,sd,de,ad,td,Ee,pd,ed,ve,od,ld,_e,cd,ud,be,id,rd,ye,kd,fd,me,dd,Ed,we,vd,_d,nu,su,au,An,bd,Pe,yd,md,tu,hs,mm=`<code class="language-go"><span class="token keyword">type</span> Point2D <span class="token keyword">struct</span> <span class="token punctuation">&#123;</span>
	X<span class="token punctuation">,</span> Y <span class="token builtin">int</span>
<span class="token punctuation">&#125;</span>

<span class="token keyword">func</span> <span class="token punctuation">(</span>p2 Point2D<span class="token punctuation">)</span> <span class="token function">String</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token builtin">string</span> <span class="token punctuation">&#123;</span>
	<span class="token keyword">return</span> fmt<span class="token punctuation">.</span><span class="token function">Sprintf</span><span class="token punctuation">(</span><span class="token string">"(%d, %d)"</span><span class="token punctuation">,</span> p2<span class="token punctuation">.</span>X<span class="token punctuation">,</span> p2<span class="token punctuation">.</span>Y<span class="token punctuation">)</span>
<span class="token punctuation">&#125;</span>

<span class="token keyword">func</span> <span class="token punctuation">(</span>p2 Point2D<span class="token punctuation">)</span> <span class="token function">Diff</span><span class="token punctuation">(</span>from Point2D<span class="token punctuation">)</span> <span class="token builtin">float64</span> <span class="token punctuation">&#123;</span>
	x <span class="token operator">:=</span> p2<span class="token punctuation">.</span>X <span class="token operator">-</span> from<span class="token punctuation">.</span>X
	y <span class="token operator">:=</span> p2<span class="token punctuation">.</span>Y <span class="token operator">-</span> from<span class="token punctuation">.</span>Y
	<span class="token keyword">return</span> math<span class="token punctuation">.</span><span class="token function">Sqrt</span><span class="token punctuation">(</span><span class="token function">float64</span><span class="token punctuation">(</span>x<span class="token operator">*</span>x<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token function">float64</span><span class="token punctuation">(</span>y<span class="token operator">*</span>y<span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token punctuation">&#125;</span>

<span class="token keyword">type</span> Point3D <span class="token keyword">struct</span> <span class="token punctuation">&#123;</span>
	X<span class="token punctuation">,</span> Y<span class="token punctuation">,</span> Z <span class="token builtin">int</span>
<span class="token punctuation">&#125;</span>

<span class="token keyword">func</span> <span class="token punctuation">(</span>p3 Point3D<span class="token punctuation">)</span> <span class="token function">String</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token builtin">string</span> <span class="token punctuation">&#123;</span>
	<span class="token keyword">return</span> fmt<span class="token punctuation">.</span><span class="token function">Sprintf</span><span class="token punctuation">(</span><span class="token string">"(%d, %d, %d)"</span><span class="token punctuation">,</span> p3<span class="token punctuation">.</span>X<span class="token punctuation">,</span> p3<span class="token punctuation">.</span>Y<span class="token punctuation">,</span> p3<span class="token punctuation">.</span>Z<span class="token punctuation">)</span>
<span class="token punctuation">&#125;</span>

<span class="token keyword">func</span> <span class="token punctuation">(</span>p3 Point3D<span class="token punctuation">)</span> <span class="token function">Diff</span><span class="token punctuation">(</span>from Point3D<span class="token punctuation">)</span> <span class="token builtin">float64</span> <span class="token punctuation">&#123;</span>
	x <span class="token operator">:=</span> p3<span class="token punctuation">.</span>X <span class="token operator">-</span> from<span class="token punctuation">.</span>X
	y <span class="token operator">:=</span> p3<span class="token punctuation">.</span>Y <span class="token operator">-</span> from<span class="token punctuation">.</span>Y
	z <span class="token operator">:=</span> p3<span class="token punctuation">.</span>Z <span class="token operator">-</span> from<span class="token punctuation">.</span>Z
	<span class="token keyword">return</span> math<span class="token punctuation">.</span><span class="token function">Sqrt</span><span class="token punctuation">(</span><span class="token function">float64</span><span class="token punctuation">(</span>x<span class="token operator">*</span>x<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token function">float64</span><span class="token punctuation">(</span>y<span class="token operator">*</span>y<span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token function">float64</span><span class="token punctuation">(</span>z<span class="token operator">*</span>z<span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token punctuation">&#125;</span></code>`,pu,at,wd,eu,gs,wm=`<code class="language-go"><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
	pair2Da <span class="token operator">:=</span> Pair<span class="token punctuation">[</span>Point2D<span class="token punctuation">]</span><span class="token punctuation">&#123;</span>Point2D<span class="token punctuation">&#123;</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">&#125;</span><span class="token punctuation">,</span> Point2D<span class="token punctuation">&#123;</span><span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span>
	pair2Db <span class="token operator">:=</span> Pair<span class="token punctuation">[</span>Point2D<span class="token punctuation">]</span><span class="token punctuation">&#123;</span>Point2D<span class="token punctuation">&#123;</span><span class="token number">10</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">&#125;</span><span class="token punctuation">,</span> Point2D<span class="token punctuation">&#123;</span><span class="token number">15</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span>
	closer <span class="token operator">:=</span> <span class="token function">FindCloser</span><span class="token punctuation">(</span>pair2Da<span class="token punctuation">,</span> pair2Db<span class="token punctuation">)</span>
	fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>closer<span class="token punctuation">)</span>

	pair3Da <span class="token operator">:=</span> Pair<span class="token punctuation">[</span>Point3D<span class="token punctuation">]</span><span class="token punctuation">&#123;</span>Point3D<span class="token punctuation">&#123;</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">&#125;</span><span class="token punctuation">,</span> Point3D<span class="token punctuation">&#123;</span><span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span>
	pair3Db <span class="token operator">:=</span> Pair<span class="token punctuation">[</span>Point3D<span class="token punctuation">]</span><span class="token punctuation">&#123;</span>Point3D<span class="token punctuation">&#123;</span><span class="token number">10</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">&#125;</span><span class="token punctuation">,</span> Point3D<span class="token punctuation">&#123;</span><span class="token number">11</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span>
	closer2 <span class="token operator">:=</span> <span class="token function">FindCloser</span><span class="token punctuation">(</span>pair3Da<span class="token punctuation">,</span> pair3Db<span class="token punctuation">)</span>
	fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>closer2<span class="token punctuation">)</span>
<span class="token punctuation">&#125;</span></code>`,ou,tt,Pd,lu,na,Pm=`<code class="language-text">$ go run generic-interface.go
&#123;(1, 1) (5, 5)&#125;
&#123;(10, 10, 10) (11, 5, 0)&#125;</code>`,cu,uu,iu,ru,$n,Nn,Oe,Od,ku,fu,du,T,Td,Te,Dd,Cd,De,Rd,Gd,Ce,Sd,Id,Re,Md,Hd,Ge,Bd,Ld,Eu,sa,Om=`<code class="language-go"><span class="token keyword">type</span> BuiltInOrdered <span class="token keyword">interface</span> <span class="token punctuation">&#123;</span>
	<span class="token builtin">string</span> <span class="token operator">|</span> <span class="token builtin">int</span> <span class="token operator">|</span> <span class="token builtin">int8</span> <span class="token operator">|</span> <span class="token builtin">int16</span> <span class="token operator">|</span> <span class="token builtin">int32</span> <span class="token operator">|</span> <span class="token builtin">int64</span> <span class="token operator">|</span> <span class="token builtin">float32</span> <span class="token operator">|</span> <span class="token builtin">float64</span> <span class="token operator">|</span>
		<span class="token builtin">uint</span> <span class="token operator">|</span> <span class="token builtin">uint8</span> <span class="token operator">|</span> <span class="token builtin">uint16</span> <span class="token operator">|</span> <span class="token builtin">uint32</span> <span class="token operator">|</span> <span class="token builtin">uint64</span> <span class="token operator">|</span> <span class="token builtin">uintptr</span>
<span class="token punctuation">&#125;</span></code>`,vu,f,xd,Se,Ad,$d,Ie,Nd,Fd,Me,Zd,zd,He,Xd,Yd,Be,Vd,qd,Le,Jd,Ud,xe,Wd,jd,Ae,Kd,Qd,$e,hd,gd,_u,sn,n3,Ne,s3,a3,Fe,t3,p3,bu,aa,Tm=`<code class="language-go"><span class="token keyword">func</span> Min<span class="token punctuation">[</span>T BuiltInOrdered<span class="token punctuation">]</span><span class="token punctuation">(</span>v1<span class="token punctuation">,</span> v2 T<span class="token punctuation">)</span> T <span class="token punctuation">&#123;</span>
	<span class="token keyword">if</span> v1 <span class="token operator">&lt;</span> v2 <span class="token punctuation">&#123;</span>
		<span class="token keyword">return</span> v1
	<span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>
		<span class="token keyword">return</span> v2
	<span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span>

<span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
	a <span class="token operator">:=</span> <span class="token number">10</span>
	b <span class="token operator">:=</span> <span class="token number">20</span>
	fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token function">Min</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> b<span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token punctuation">&#125;</span></code>`,yu,an,e3,Ze,o3,l3,ze,c3,u3,mu,ta,Dm=`<code class="language-go"><span class="token keyword">var</span> myA MyInt <span class="token operator">=</span> <span class="token number">10</span>
<span class="token keyword">var</span> myB MyInt <span class="token operator">=</span> <span class="token number">20</span>
fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token function">Min</span><span class="token punctuation">(</span>myA<span class="token punctuation">,</span> myB<span class="token punctuation">)</span><span class="token punctuation">)</span></code>`,wu,pt,i3,Pu,pa,Cm=`<code class="language-text">$ go run type_terms.go
./type_terms.go:27:17: MyInt does not implement BuiltInOrdered (possibly missing ~ for int in constraint BuiltInOrdered)</code>`,Ou,Fn,r3,Xe,k3,f3,Tu,ea,Rm=`<code class="language-go"><span class="token comment">// by putting ~ before type term, it works when the type parameter is a equivalent user-defined type</span>
<span class="token keyword">type</span> BuiltInOrdered <span class="token keyword">interface</span> <span class="token punctuation">&#123;</span>
	~<span class="token builtin">string</span> <span class="token operator">|</span> ~<span class="token builtin">int</span> <span class="token operator">|</span> ~<span class="token builtin">int8</span> <span class="token operator">|</span> ~<span class="token builtin">int16</span> <span class="token operator">|</span> ~<span class="token builtin">int32</span> <span class="token operator">|</span> ~<span class="token builtin">int64</span> <span class="token operator">|</span> ~<span class="token builtin">float32</span> <span class="token operator">|</span> ~<span class="token builtin">float64</span> <span class="token operator">|</span>
		~<span class="token builtin">uint</span> <span class="token operator">|</span> ~<span class="token builtin">uint8</span> <span class="token operator">|</span> ~<span class="token builtin">uint16</span> <span class="token operator">|</span> ~<span class="token builtin">uint32</span> <span class="token operator">|</span> ~<span class="token builtin">uint64</span> <span class="token operator">|</span> ~<span class="token builtin">uintptr</span>
<span class="token punctuation">&#125;</span></code>`,Du,et,d3,Cu,oa,Gm=`<code class="language-go"><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
	a <span class="token operator">:=</span> <span class="token number">10</span>
	b <span class="token operator">:=</span> <span class="token number">20</span>
	fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token function">Min</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span> b<span class="token punctuation">)</span><span class="token punctuation">)</span>

	<span class="token comment">// this occurs an error</span>
	<span class="token keyword">var</span> myA MyInt <span class="token operator">=</span> <span class="token number">10</span>
	<span class="token keyword">var</span> myB MyInt <span class="token operator">=</span> <span class="token number">20</span>
	fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token function">Min</span><span class="token punctuation">(</span>myA<span class="token punctuation">,</span> myB<span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token punctuation">&#125;</span></code>`,Ru,Gu,Su,Zn,E3,Ye,v3,_3,Iu,la,Sm=`<code class="language-go"><span class="token keyword">type</span> PrintableInt <span class="token keyword">interface</span> <span class="token punctuation">&#123;</span>
	~<span class="token builtin">int</span>
	<span class="token function">String</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token builtin">string</span>
<span class="token punctuation">&#125;</span></code>`,Mu,R,b3,Ve,y3,m3,qe,w3,P3,Je,O3,T3,Ue,D3,C3,Hu,ca,Im=`<code class="language-go"><span class="token keyword">type</span> ImpossiblePrintableInt <span class="token keyword">interface</span> <span class="token punctuation">&#123;</span>
	<span class="token builtin">int</span>
	<span class="token function">String</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token builtin">string</span>
<span class="token punctuation">&#125;</span>

<span class="token keyword">type</span> ImpossibleStruct<span class="token punctuation">[</span>T ImpossiblePrintableInt<span class="token punctuation">]</span> <span class="token keyword">struct</span> <span class="token punctuation">&#123;</span>
	val T
<span class="token punctuation">&#125;</span>

<span class="token keyword">type</span> MyInt <span class="token builtin">int</span>

<span class="token keyword">func</span> <span class="token punctuation">(</span>mi MyInt<span class="token punctuation">)</span> <span class="token function">String</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token builtin">string</span> <span class="token punctuation">&#123;</span>
	<span class="token keyword">return</span> fmt<span class="token punctuation">.</span><span class="token function">Sprint</span><span class="token punctuation">(</span>mi<span class="token punctuation">)</span>
<span class="token punctuation">&#125;</span></code>`,Bu,zn,R3,We,G3,S3,Lu,ot,I3,xu,ua,Mm=`<code class="language-go"><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
	s <span class="token operator">:=</span> ImpossibleStruct<span class="token punctuation">[</span><span class="token builtin">int</span><span class="token punctuation">]</span><span class="token punctuation">&#123;</span><span class="token number">10</span><span class="token punctuation">&#125;</span>
	s2 <span class="token operator">:=</span> ImpossibleStruct<span class="token punctuation">[</span>MyInt<span class="token punctuation">]</span><span class="token punctuation">&#123;</span><span class="token number">10</span><span class="token punctuation">&#125;</span>
	fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>s<span class="token punctuation">.</span>val<span class="token punctuation">,</span> s2<span class="token punctuation">.</span>val<span class="token punctuation">)</span>
<span class="token punctuation">&#125;</span></code>`,Au,ia,je,M3,H3,$u,ra,Hm=`<code class="language-text">$ go run impossible_interface.go
./impossible_interface.go:26:24: int does not implement ImpossiblePrintableInt (missing String method)
./impossible_interface.go:27:25: MyInt does not implement ImpossiblePrintableInt (possibly missing ~ for int in constraint ImpossiblePrintableInt)</code>`,Nu,lt,B3,Fu,Zu,zu,Xu,Xn,Yn,Ke,L3,Yu,Vu,qu,G,x3,Qe,A3,$3,he,N3,F3,ge,Z3,z3,no,X3,Y3,Ju,ct,V3,Uu,ka,Bm=`<code class="language-go"><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
	<span class="token keyword">var</span> a <span class="token builtin">int</span> <span class="token operator">=</span> <span class="token number">10</span>
	<span class="token comment">//b1 := Convert(a) // occurs error</span>
	b2 <span class="token operator">:=</span> Convert<span class="token punctuation">[</span><span class="token builtin">int</span><span class="token punctuation">,</span> <span class="token builtin">int64</span><span class="token punctuation">]</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span>
	<span class="token comment">//var b3 int64 = Convert(a) // occurs error</span>

	fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>b2<span class="token punctuation">)</span>
<span class="token punctuation">&#125;</span></code>`,Wu,V,q3,so,J3,U3,ao,W3,j3,to,K3,Q3,ju,Ku,Qu,hu,Vn,qn,po,h3,gu,ni,si,Jn,g3,eo,nE,sE,ai,tn,aE,oo,tE,pE,lo,eE,oE,ti,fa,Lm=`<code class="language-go"><span class="token keyword">type</span> BuiltInOrdered <span class="token keyword">interface</span> <span class="token punctuation">&#123;</span>
	~<span class="token builtin">string</span> <span class="token operator">|</span> ~<span class="token builtin">int</span> <span class="token operator">|</span> ~<span class="token builtin">int8</span> <span class="token operator">|</span> ~<span class="token builtin">int16</span> <span class="token operator">|</span> ~<span class="token builtin">int32</span> <span class="token operator">|</span> ~<span class="token builtin">int64</span> <span class="token operator">|</span> ~<span class="token builtin">float32</span> <span class="token operator">|</span> ~<span class="token builtin">float64</span> <span class="token operator">|</span>
		~<span class="token builtin">uint</span> <span class="token operator">|</span> ~<span class="token builtin">uint8</span> <span class="token operator">|</span> ~<span class="token builtin">uint16</span> <span class="token operator">|</span> ~<span class="token builtin">uint32</span> <span class="token operator">|</span> ~<span class="token builtin">uint64</span> <span class="token operator">|</span> ~<span class="token builtin">uintptr</span>
<span class="token punctuation">&#125;</span>

<span class="token keyword">type</span> Integer <span class="token keyword">interface</span> <span class="token punctuation">&#123;</span>
	<span class="token builtin">int</span> <span class="token operator">|</span> <span class="token builtin">int8</span> <span class="token operator">|</span> <span class="token builtin">int16</span> <span class="token operator">|</span> <span class="token builtin">int32</span> <span class="token operator">|</span> <span class="token builtin">int64</span> <span class="token operator">|</span>
		<span class="token builtin">uint</span> <span class="token operator">|</span> <span class="token builtin">uint8</span> <span class="token operator">|</span> <span class="token builtin">uint16</span> <span class="token operator">|</span> <span class="token builtin">uint32</span> <span class="token operator">|</span> <span class="token builtin">uint64</span>
<span class="token punctuation">&#125;</span></code>`,pi,da,co,lE,cE,ei,Un,uE,uo,iE,rE,oi,Ea,xm=`<code class="language-go"><span class="token comment">// Invaliid!</span>
<span class="token keyword">func</span> PlusOneThousand<span class="token punctuation">[</span>T Integer<span class="token punctuation">]</span><span class="token punctuation">(</span>in T<span class="token punctuation">)</span> T <span class="token punctuation">&#123;</span>
	<span class="token keyword">return</span> in <span class="token operator">+</span> <span class="token number">1000</span>
<span class="token punctuation">&#125;</span>

<span class="token comment">// Valid!</span>
<span class="token keyword">func</span> PlusOneHundred<span class="token punctuation">[</span>T Integer<span class="token punctuation">]</span><span class="token punctuation">(</span>in T<span class="token punctuation">)</span> T <span class="token punctuation">&#123;</span>
	<span class="token keyword">return</span> in <span class="token operator">+</span> <span class="token number">100</span>
<span class="token punctuation">&#125;</span></code>`,li,va,io,kE,fE,ci,_a,Am=`<code class="language-text">$ go run cannot_type_inference.go
./cannot_type_inference.go:16:14: cannot convert 1000 (untyped int constant) to T</code>`,ui,Wn,dE,ro,EE,vE,ii,ri,ki,fi,jn,Kn,ko,_E,di,Ei,vi,ut,bE,_i,ba,$m='<code class="language-go"><span class="token keyword">type</span> OrderableFunc<span class="token punctuation">[</span>T any<span class="token punctuation">]</span> <span class="token keyword">func</span><span class="token punctuation">(</span>t1<span class="token punctuation">,</span> t2 T<span class="token punctuation">)</span> <span class="token builtin">int</span></code>',bi,pn,yE,fo,mE,wE,Eo,PE,OE,yi,ya,Nm=`<code class="language-go"><span class="token keyword">type</span> Tree<span class="token punctuation">[</span>T any<span class="token punctuation">]</span> <span class="token keyword">struct</span> <span class="token punctuation">&#123;</span>
	f    OrderableFunc<span class="token punctuation">[</span>T<span class="token punctuation">]</span>
	root <span class="token operator">*</span>Node<span class="token punctuation">[</span>T<span class="token punctuation">]</span>
<span class="token punctuation">&#125;</span>

<span class="token keyword">type</span> Node<span class="token punctuation">[</span>T any<span class="token punctuation">]</span> <span class="token keyword">struct</span> <span class="token punctuation">&#123;</span>
	val         T
	left<span class="token punctuation">,</span> right <span class="token operator">*</span>Node<span class="token punctuation">[</span>T<span class="token punctuation">]</span>
<span class="token punctuation">&#125;</span></code>`,mi,ma,vo,TE,DE,wi,wa,Fm=`<code class="language-go"><span class="token keyword">func</span> NewTree<span class="token punctuation">[</span>T any<span class="token punctuation">]</span><span class="token punctuation">(</span>f OrderableFunc<span class="token punctuation">[</span>T<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">*</span>Tree<span class="token punctuation">[</span>T<span class="token punctuation">]</span> <span class="token punctuation">&#123;</span>
	<span class="token keyword">return</span> <span class="token operator">&amp;</span>Tree<span class="token punctuation">[</span>T<span class="token punctuation">]</span><span class="token punctuation">&#123;</span>
		f<span class="token punctuation">:</span> f<span class="token punctuation">,</span>
	<span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span></code>`,Pi,Oi,Ti,_n,_o,CE,RE,bo,GE,SE,Di,Pa,Zm=`<code class="language-go"><span class="token keyword">func</span> <span class="token punctuation">(</span>n <span class="token operator">*</span>Node<span class="token punctuation">[</span>T<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token function">Add</span><span class="token punctuation">(</span>f OrderableFunc<span class="token punctuation">[</span>T<span class="token punctuation">]</span><span class="token punctuation">,</span> v T<span class="token punctuation">)</span> <span class="token operator">*</span>Node<span class="token punctuation">[</span>T<span class="token punctuation">]</span> <span class="token punctuation">&#123;</span>
	<span class="token keyword">if</span> n <span class="token operator">==</span> <span class="token boolean">nil</span> <span class="token punctuation">&#123;</span>
		<span class="token keyword">return</span> <span class="token operator">&amp;</span>Node<span class="token punctuation">[</span>T<span class="token punctuation">]</span><span class="token punctuation">&#123;</span>val<span class="token punctuation">:</span> v<span class="token punctuation">&#125;</span>
	<span class="token punctuation">&#125;</span>
	<span class="token keyword">switch</span> r <span class="token operator">:=</span> <span class="token function">f</span><span class="token punctuation">(</span>v<span class="token punctuation">,</span> n<span class="token punctuation">.</span>val<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">&#123;</span>
	<span class="token keyword">case</span> r <span class="token operator">&lt;=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">:</span>
		n<span class="token punctuation">.</span>left <span class="token operator">=</span> n<span class="token punctuation">.</span>left<span class="token punctuation">.</span><span class="token function">Add</span><span class="token punctuation">(</span>f<span class="token punctuation">,</span> v<span class="token punctuation">)</span>
	<span class="token keyword">case</span> r <span class="token operator">>=</span> <span class="token number">1</span><span class="token punctuation">:</span>
		n<span class="token punctuation">.</span>right <span class="token operator">=</span> n<span class="token punctuation">.</span>right<span class="token punctuation">.</span><span class="token function">Add</span><span class="token punctuation">(</span>f<span class="token punctuation">,</span> v<span class="token punctuation">)</span>
	<span class="token punctuation">&#125;</span>
	<span class="token keyword">return</span> n
<span class="token punctuation">&#125;</span>

<span class="token keyword">func</span> <span class="token punctuation">(</span>n <span class="token operator">*</span>Node<span class="token punctuation">[</span>T<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token function">Contains</span><span class="token punctuation">(</span>f OrderableFunc<span class="token punctuation">[</span>T<span class="token punctuation">]</span><span class="token punctuation">,</span> v T<span class="token punctuation">)</span> <span class="token builtin">bool</span> <span class="token punctuation">&#123;</span>
	<span class="token keyword">if</span> n <span class="token operator">==</span> <span class="token boolean">nil</span> <span class="token punctuation">&#123;</span>
		<span class="token keyword">return</span> <span class="token boolean">false</span>
	<span class="token punctuation">&#125;</span>
	<span class="token keyword">switch</span> r <span class="token operator">:=</span> <span class="token function">f</span><span class="token punctuation">(</span>v<span class="token punctuation">,</span> n<span class="token punctuation">.</span>val<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token punctuation">&#123;</span>
	<span class="token keyword">case</span> r <span class="token operator">&lt;=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">:</span>
		<span class="token keyword">return</span> n<span class="token punctuation">.</span>left<span class="token punctuation">.</span><span class="token function">Contains</span><span class="token punctuation">(</span>f<span class="token punctuation">,</span> v<span class="token punctuation">)</span>
	<span class="token keyword">case</span> r <span class="token operator">>=</span> <span class="token number">1</span><span class="token punctuation">:</span>
		<span class="token keyword">return</span> n<span class="token punctuation">.</span>right<span class="token punctuation">.</span><span class="token function">Contains</span><span class="token punctuation">(</span>f<span class="token punctuation">,</span> v<span class="token punctuation">)</span>
	<span class="token punctuation">&#125;</span>
	<span class="token keyword">return</span> <span class="token boolean">true</span>
<span class="token punctuation">&#125;</span></code>`,Ci,en,IE,yo,ME,HE,mo,BE,LE,Ri,Oa,zm=`<code class="language-go"><span class="token keyword">type</span> BuiltInOrdered <span class="token keyword">interface</span> <span class="token punctuation">&#123;</span>
	~<span class="token builtin">string</span> <span class="token operator">|</span> ~<span class="token builtin">int</span> <span class="token operator">|</span> ~<span class="token builtin">int8</span> <span class="token operator">|</span> ~<span class="token builtin">int16</span> <span class="token operator">|</span> ~<span class="token builtin">int32</span> <span class="token operator">|</span> ~<span class="token builtin">int64</span> <span class="token operator">|</span> ~<span class="token builtin">float32</span> <span class="token operator">|</span> ~<span class="token builtin">float64</span> <span class="token operator">|</span>
		~<span class="token builtin">uint</span> <span class="token operator">|</span> ~<span class="token builtin">uint8</span> <span class="token operator">|</span> ~<span class="token builtin">uint16</span> <span class="token operator">|</span> ~<span class="token builtin">uint32</span> <span class="token operator">|</span> ~<span class="token builtin">uint64</span> <span class="token operator">|</span> ~<span class="token builtin">uintptr</span>
<span class="token punctuation">&#125;</span>

<span class="token keyword">func</span> BuiltInOrderable<span class="token punctuation">[</span>T BuiltInOrdered<span class="token punctuation">]</span><span class="token punctuation">(</span>t1<span class="token punctuation">,</span> t2 T<span class="token punctuation">)</span> <span class="token builtin">int</span> <span class="token punctuation">&#123;</span>
	<span class="token keyword">if</span> t1 <span class="token operator">&lt;</span> t2 <span class="token punctuation">&#123;</span>
		<span class="token keyword">return</span> <span class="token operator">-</span><span class="token number">1</span>
	<span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token keyword">if</span> t1 <span class="token operator">></span> t2 <span class="token punctuation">&#123;</span>
		<span class="token keyword">return</span> <span class="token number">1</span>
	<span class="token punctuation">&#125;</span> <span class="token keyword">else</span> <span class="token punctuation">&#123;</span>
		<span class="token keyword">return</span> <span class="token number">0</span>
	<span class="token punctuation">&#125;</span>
<span class="token punctuation">&#125;</span></code>`,Gi,on,xE,wo,AE,$E,Po,NE,FE,Si,Ta,Xm=`<code class="language-go"><span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
	t1 <span class="token operator">:=</span> <span class="token function">NewTree</span><span class="token punctuation">(</span>BuiltInOrderable<span class="token punctuation">[</span><span class="token builtin">int</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
	t1<span class="token punctuation">.</span><span class="token function">Add</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span>
	t1<span class="token punctuation">.</span><span class="token function">Add</span><span class="token punctuation">(</span><span class="token number">30</span><span class="token punctuation">)</span>
	t1<span class="token punctuation">.</span><span class="token function">Add</span><span class="token punctuation">(</span><span class="token number">15</span><span class="token punctuation">)</span>
	fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>t1<span class="token punctuation">.</span><span class="token function">Contains</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
	fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>t1<span class="token punctuation">.</span><span class="token function">Contains</span><span class="token punctuation">(</span><span class="token number">40</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token punctuation">&#125;</span></code>`,Ii,Mi,Hi,Qn,ZE,Oo,zE,XE,Bi,Da,Ym=`<code class="language-go"><span class="token keyword">type</span> Person <span class="token keyword">struct</span> <span class="token punctuation">&#123;</span>
	Name <span class="token builtin">string</span>
	Age  <span class="token builtin">int</span>
<span class="token punctuation">&#125;</span>

<span class="token keyword">func</span> <span class="token function">OrderPeople</span><span class="token punctuation">(</span>p1<span class="token punctuation">,</span> p2 Person<span class="token punctuation">)</span> <span class="token builtin">int</span> <span class="token punctuation">&#123;</span>
	out <span class="token operator">:=</span> strings<span class="token punctuation">.</span><span class="token function">Compare</span><span class="token punctuation">(</span>p1<span class="token punctuation">.</span>Name<span class="token punctuation">,</span> p2<span class="token punctuation">.</span>Name<span class="token punctuation">)</span>
	<span class="token keyword">if</span> out <span class="token operator">==</span> <span class="token number">0</span> <span class="token punctuation">&#123;</span>
		out <span class="token operator">=</span> p1<span class="token punctuation">.</span>Age <span class="token operator">-</span> p2<span class="token punctuation">.</span>Age
	<span class="token punctuation">&#125;</span>
	<span class="token keyword">return</span> out
<span class="token punctuation">&#125;</span></code>`,Li,q,YE,To,VE,qE,Do,JE,UE,Co,WE,jE,xi,Ca,Vm=`<code class="language-go">t2 <span class="token operator">:=</span> <span class="token function">NewTree</span><span class="token punctuation">(</span>OrderPeople<span class="token punctuation">)</span>
t2<span class="token punctuation">.</span><span class="token function">Add</span><span class="token punctuation">(</span>Person<span class="token punctuation">&#123;</span><span class="token string">"Bob"</span><span class="token punctuation">,</span> <span class="token number">30</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span>
t2<span class="token punctuation">.</span><span class="token function">Add</span><span class="token punctuation">(</span>Person<span class="token punctuation">&#123;</span><span class="token string">"James"</span><span class="token punctuation">,</span> <span class="token number">30</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span>
t2<span class="token punctuation">.</span><span class="token function">Add</span><span class="token punctuation">(</span>Person<span class="token punctuation">&#123;</span><span class="token string">"Bob"</span><span class="token punctuation">,</span> <span class="token number">50</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span>
fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>t2<span class="token punctuation">.</span><span class="token function">Contains</span><span class="token punctuation">(</span>Person<span class="token punctuation">&#123;</span><span class="token string">"Bob"</span><span class="token punctuation">,</span> <span class="token number">30</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>t2<span class="token punctuation">.</span><span class="token function">Contains</span><span class="token punctuation">(</span>Person<span class="token punctuation">&#123;</span><span class="token string">"Fred"</span><span class="token punctuation">,</span> <span class="token number">20</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">)</span></code>`,Ai,it,KE,$i,Ra,qm=`<code class="language-go"><span class="token keyword">func</span> <span class="token punctuation">(</span>p Person<span class="token punctuation">)</span> <span class="token function">Order</span><span class="token punctuation">(</span>other Person<span class="token punctuation">)</span> <span class="token builtin">int</span> <span class="token punctuation">&#123;</span>
	out <span class="token operator">:=</span> strings<span class="token punctuation">.</span><span class="token function">Compare</span><span class="token punctuation">(</span>p<span class="token punctuation">.</span>Name<span class="token punctuation">,</span> other<span class="token punctuation">.</span>Name<span class="token punctuation">)</span>
	<span class="token keyword">if</span> out <span class="token operator">==</span> <span class="token number">0</span> <span class="token punctuation">&#123;</span>
		out <span class="token operator">=</span> p<span class="token punctuation">.</span>Age <span class="token operator">-</span> other<span class="token punctuation">.</span>Age
	<span class="token punctuation">&#125;</span>
	<span class="token keyword">return</span> out
<span class="token punctuation">&#125;</span></code>`,Ni,ln,QE,Ro,hE,gE,Go,nv,sv,Fi,Ga,Jm=`<code class="language-go">t2 <span class="token operator">:=</span> <span class="token function">NewTree</span><span class="token punctuation">(</span>Person<span class="token punctuation">.</span>Order<span class="token punctuation">)</span>
t2<span class="token punctuation">.</span><span class="token function">Add</span><span class="token punctuation">(</span>Person<span class="token punctuation">&#123;</span><span class="token string">"Bob"</span><span class="token punctuation">,</span> <span class="token number">30</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span>
t2<span class="token punctuation">.</span><span class="token function">Add</span><span class="token punctuation">(</span>Person<span class="token punctuation">&#123;</span><span class="token string">"James"</span><span class="token punctuation">,</span> <span class="token number">30</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span>
t2<span class="token punctuation">.</span><span class="token function">Add</span><span class="token punctuation">(</span>Person<span class="token punctuation">&#123;</span><span class="token string">"Bob"</span><span class="token punctuation">,</span> <span class="token number">50</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span>
fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>t2<span class="token punctuation">.</span><span class="token function">Contains</span><span class="token punctuation">(</span>Person<span class="token punctuation">&#123;</span><span class="token string">"Bob"</span><span class="token punctuation">,</span> <span class="token number">30</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>t2<span class="token punctuation">.</span><span class="token function">Contains</span><span class="token punctuation">(</span>Person<span class="token punctuation">&#123;</span><span class="token string">"Fred"</span><span class="token punctuation">,</span> <span class="token number">20</span><span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">)</span></code>`,Zi,zi,Xi,Yi,hn,gn,So,av,Vi,qi,Ji,rt,tv,Ui,cn,pv,Io,ev,ov,Mo,lv,cv,Wi,ns,uv,Ho,iv,rv,ji,J,kv,Bo,fv,dv,Lo,Ev,vv,xo,_v,bv,Ki,Sa,Um=`<code class="language-go"><span class="token keyword">type</span> FunctionalSlice<span class="token punctuation">[</span>T any<span class="token punctuation">]</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>T

<span class="token keyword">func</span> <span class="token punctuation">(</span>fs FunctionalSlice<span class="token punctuation">[</span>T<span class="token punctuation">]</span><span class="token punctuation">)</span> Map<span class="token punctuation">[</span>E any<span class="token punctuation">]</span><span class="token punctuation">(</span>f <span class="token keyword">func</span><span class="token punctuation">(</span>T<span class="token punctuation">)</span> E<span class="token punctuation">)</span> FunctionalSlice<span class="token punctuation">[</span>E<span class="token punctuation">]</span> <span class="token punctuation">&#123;</span>
	out <span class="token operator">:=</span> <span class="token function">make</span><span class="token punctuation">(</span>FunctionalSlice<span class="token punctuation">[</span>E<span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token function">len</span><span class="token punctuation">(</span>fs<span class="token punctuation">)</span><span class="token punctuation">)</span>
	<span class="token keyword">for</span> i<span class="token punctuation">,</span> v <span class="token operator">:=</span> <span class="token keyword">range</span> fs <span class="token punctuation">&#123;</span>
		out<span class="token punctuation">[</span>i<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">f</span><span class="token punctuation">(</span>v<span class="token punctuation">)</span>
	<span class="token punctuation">&#125;</span>
	<span class="token keyword">return</span> out
<span class="token punctuation">&#125;</span>

<span class="token keyword">func</span> <span class="token punctuation">(</span>fs FunctionalSlice<span class="token punctuation">[</span>T<span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token function">Filter</span><span class="token punctuation">(</span>f <span class="token keyword">func</span><span class="token punctuation">(</span>T<span class="token punctuation">)</span> <span class="token builtin">bool</span><span class="token punctuation">)</span> FunctionalSlice<span class="token punctuation">[</span>T<span class="token punctuation">]</span> <span class="token punctuation">&#123;</span>
	<span class="token keyword">var</span> out <span class="token punctuation">[</span><span class="token punctuation">]</span>T
	<span class="token keyword">for</span> <span class="token boolean">_</span><span class="token punctuation">,</span> v <span class="token operator">:=</span> <span class="token keyword">range</span> fs <span class="token punctuation">&#123;</span>
		<span class="token keyword">if</span> <span class="token function">f</span><span class="token punctuation">(</span>v<span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
			out <span class="token operator">=</span> <span class="token function">append</span><span class="token punctuation">(</span>out<span class="token punctuation">,</span> v<span class="token punctuation">)</span>
		<span class="token punctuation">&#125;</span>
	<span class="token punctuation">&#125;</span>
	<span class="token keyword">return</span> out
<span class="token punctuation">&#125;</span>

<span class="token keyword">func</span> <span class="token punctuation">(</span>fs FunctionalSlice<span class="token punctuation">[</span>T<span class="token punctuation">]</span><span class="token punctuation">)</span> Reduce<span class="token punctuation">[</span>E any<span class="token punctuation">]</span><span class="token punctuation">(</span>f <span class="token keyword">func</span><span class="token punctuation">(</span>E<span class="token punctuation">,</span> T<span class="token punctuation">)</span> E<span class="token punctuation">,</span> start E<span class="token punctuation">)</span> E <span class="token punctuation">&#123;</span>
	out <span class="token operator">:=</span> start
	<span class="token keyword">for</span> <span class="token boolean">_</span><span class="token punctuation">,</span> v <span class="token operator">:=</span> <span class="token keyword">range</span> fs <span class="token punctuation">&#123;</span>
		out <span class="token operator">=</span> <span class="token function">f</span><span class="token punctuation">(</span>out<span class="token punctuation">,</span> v<span class="token punctuation">)</span>
	<span class="token punctuation">&#125;</span>
	<span class="token keyword">return</span> out
<span class="token punctuation">&#125;</span></code>`,Qi,kt,yv,hi,Ia,Wm=`<code class="language-go">words <span class="token operator">=</span> FunctionalSlice<span class="token punctuation">[</span><span class="token builtin">string</span><span class="token punctuation">]</span><span class="token punctuation">&#123;</span><span class="token string">"One"</span><span class="token punctuation">,</span> <span class="token string">"Potato"</span><span class="token punctuation">,</span> <span class="token string">"Two"</span><span class="token punctuation">,</span> <span class="token string">"Potato"</span><span class="token punctuation">&#125;</span>
sum <span class="token operator">:=</span> words<span class="token punctuation">.</span><span class="token function">Filter</span><span class="token punctuation">(</span><span class="token keyword">func</span><span class="token punctuation">(</span>s <span class="token builtin">string</span><span class="token punctuation">)</span> <span class="token builtin">bool</span> <span class="token punctuation">&#123;</span>
	<span class="token keyword">return</span> s <span class="token operator">!=</span> <span class="token string">"Potato"</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">Map</span><span class="token punctuation">(</span><span class="token keyword">func</span><span class="token punctuation">(</span>s <span class="token builtin">string</span><span class="token punctuation">)</span> <span class="token builtin">int</span> <span class="token punctuation">&#123;</span>
	<span class="token keyword">return</span> <span class="token function">len</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span>
<span class="token punctuation">&#125;</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">Reduce</span><span class="token punctuation">(</span><span class="token keyword">func</span><span class="token punctuation">(</span>acc<span class="token punctuation">,</span> cur <span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token builtin">int</span> <span class="token punctuation">&#123;</span>
	<span class="token keyword">return</span> acc <span class="token operator">+</span> cur
<span class="token punctuation">&#125;</span><span class="token punctuation">)</span></code>`,gi,ft,mv,nr,dt,wv,sr,Et,Pv,ar,un,Ao,Ma,Ov,Tv,Dv,Cv,$o,No,Rv,Gv,Fo,Zo,Sv,tr,pr,er,or,ss,as,zo,Iv,lr,cr,ur,U,Mv,Xo,Hv,Bv,Yo,Lv,xv,Vo,Av,$v,ir,vt,Nv,rr,_t,Fv,kr,W,Zv,ts,zv,ps,Xv,es,Yv,fr,dr,Er,vr,os,ls,qo,Vv,_r,br,yr,S,qv,Jo,Jv,Uv,Uo,Wv,jv,Wo,Kv,Qv,jo,hv,gv,mr,cs,n5,Ko,s5,a5,wr,us,t5,Qo,p5,e5,Pr,is,o5,ho,l5,c5,Or,Tr,Dr,Cr,rs,ks,go,u5,Rr,Gr,Sr,bt,i5,Ir,yt,r5,Mr,fs,k5,Ha,f5,d5,Hr,mt,E5,Br,wt,v5,Lr,xr,Ar,$r,ds,Es,nl,_5,Nr,Fr,Zr,Pt,bn,Ba,Ot,J5,b5,y5,m5,La,w5,zr;return ts=new q5({props:{color:"red",$$slots:{default:[Q6]},$$scope:{ctx:Gs}}}),ps=new q5({props:{color:"green",$$slots:{default:[h6]},$$scope:{ctx:Gs}}}),es=new q5({props:{color:"blue",$$slots:{default:[g6]},$$scope:{ctx:Gs}}}),{c(){v=l("br"),E=i(),x=l("p"),ck=t("본 글은 Golang을 공부하며 주요 내용이라 생각되는 것들을 기록해둔 자료이며, Ubuntu 22.04 LTS 기준으로 작성되었습니다."),pl=i(),el=l("br"),ol=l("br"),ll=i(),mn=l("h2"),wn=l("a"),Nt=l("span"),uk=t("Introduction"),cl=i(),ul=l("hr"),il=i(),Aa=l("p"),ik=t("드디어 Golang의 마지막 챕터에 왔다. 아이 신난다!"),rl=i(),$a=l("p"),rk=t("개인적으로 Go의 사용성 증대의 마지막 열쇠같은 역할을 한 게 제네릭의 추가라고 생각한다. 내가 Go를 배울까 말까 하다가 결국 배우려고 했던 기점이 바로 이 제네릭의 추가이기도 하다. 그만큼 제네릭이 가져다주는 이점은 매우 크다!"),kl=i(),fl=l("br"),dl=i(),Na=l("p"),kk=t("Go에는 다소 느리긴 하지만 새로운 기능이 계속 추가되고 있다. 초기 릴리즈인 1.0과 비교했을 때, 지금의 Go에 이르기까지 세 가지 중요한 변화가 있었다. 각각 1.7의 컨텍스트, 1.11의 모듈, 그리고 1.13의 error wrapping이다."),El=i(),Fa=l("p"),fk=t(`그리고 다음의 큰 변화는 Go 1.18에 있다. 바로 타입 파라미터의 도입, 즉 제네릭이 도입된 것이다!
이번 챕터에서는 제네릭이 할 수 있는 일, 없는 일을 알아보고 제네릭을 통해 낡은 패턴들을 대체해볼 것이다.`),vl=i(),_l=l("br"),bl=l("br"),yl=i(),Pn=l("h2"),On=l("a"),Ft=l("span"),dk=t("Advantages of Generics"),ml=i(),A=l("p"),Ek=t(`Go는 정적 타입 언어로, 파라미터와 변수의 타입이 컴파일할 때 결정됨을 의미한다.
내장 타입(map, slice, channel)과 함수(`),Zt=l("code"),vk=t("len()"),_k=t(", "),zt=l("code"),bk=t("cap()"),yk=t(", "),Xt=l("code"),mk=t("make()"),wk=t(")는 다양한 concrete type의 값을 수용하거나 반환할 수 있었지만, Go 1.18 이전에는 사용자 정의 타입이나 함수는 허용되지 않았다."),wl=i(),$=l("p"),Pk=t(`만약 코드가 실행될 때까지 타입이 확인되지 않는 동적 타입 언어에 친숙하다면 제네릭에 대한 문제가 무엇인지, 또는 제네릭이 무엇인지조차도 다소 불분명할 수 있다. 이들을 “타입 파라미터”라고 생각하는게 좋을 듯 하다.
우리는 함수가 호출될 때 타입이 지정된 파라미터를 갖는 함수를 작성하는 것이 편하다. 이를테면 아래 코드의 함수 `),Yt=l("code"),Ok=t("Min()"),Tk=t("에서는 파라미터로 두 개의 "),Vt=l("code"),Dk=t("float64"),Ck=t(" 타입을, 그리고 반환형으로 "),qt=l("code"),Rk=t("float64"),Gk=t("타입을 명시하였다."),Pl=i(),Ss=l("pre"),Ol=i(),N=l("p"),Sk=t("마찬가지로 구조체를 선언할 때 필드의 타입을 명시하여 구조체를 생성한다. 아래 예제의 "),Jt=l("code"),Ik=t("Node"),Mk=t("는 "),Ut=l("code"),Hk=t("int"),Bk=t("와 "),Wt=l("code"),Lk=t("*Node"),xk=t("타입의 필드를 갖는다."),Tl=i(),Is=l("pre"),Dl=i(),Cl=l("br"),Rl=i(),Za=l("p"),Ak=t("하지만 파라미터나 구조체의 필드의 특정 유형이 사용될 때까지 명시되지 않은 상태로 함수 또는 구조체를 작성하는 것이 좋을 때도 있다."),Gl=i(),F=l("p"),$k=t("가령 "),jt=l("code"),Nk=t("int"),Fk=t(" 타입에 대한 바이너리 서치 트리 구조체를 작성한다고 해보자. 이때 "),Kt=l("code"),Zk=t("float64"),zk=t("나 "),Qt=l("code"),Xk=t("string"),Yk=t(`에서도 동일하게 동작하며 type safety를 만족하는 구조체를 원할 수도 있다.
가장 먼저 떠오르는 방법은 각각의 타입에 대해 여러 개의 구조체를 작성하는 것이다. 하지만 이 방법은 너무 중복성이 심하고 오류가 발생하기 쉽다.`),Sl=i(),za=l("p"),Vk=t("Go에 제네릭이 없었을 때 중복된 코드를 사용하지 않는 유일한 방법은, 값의 대소를 비교하는 방법이 명시된 인터페이스를 사용하는 방법이였다."),Il=i(),Ms=l("pre"),Ml=i(),Tn=l("p"),qk=t("이 인터페이스를 사용하여, 다음과 같이 "),ht=l("code"),Jk=t("Tree"),Uk=t("를 작성할 수 있다."),Hl=i(),Hs=l("pre"),Bl=i(),h=l("p"),Wk=t("그리고 아래와 같이 "),gt=l("code"),jk=t("OrderableInt"),Kk=t(" 타입을 선언하여 "),np=l("code"),Qk=t("int"),hk=t(" 값을 사용할 수 있다."),Ll=i(),Bs=l("pre"),xl=i(),g=l("p"),gk=t(`이 코드는 제대로 동작하지만, 컴파일러가 데이터 구조에 삽입된 값이 모두 동일한지 확인할 수 없다는 문제가 있다.
가령, 아래와 같이 `),sp=l("code"),nf=t("OrderableString"),sf=t(" 타입을 선언하고 "),ap=l("code"),af=t("Order()"),tf=t(" 메소드를 작성한다."),Al=i(),Ls=l("pre"),$l=i(),nn=l("p"),pf=t("그리고 "),tp=l("code"),ef=t("string"),of=t("을 동일한 "),pp=l("code"),lf=t("Tree"),cf=t("에 집어넣는다."),Nl=i(),xs=l("pre"),Fl=i(),D=l("p"),uf=t(`이 코드는 컴파일은 문제 없이 잘 된다.
`),ep=l("code"),rf=t("Order()"),kf=t(" 메소드는 "),op=l("code"),ff=t("interface{}"),df=t(" 파라미터를 사용하여 전달된 값을 나타낸다. 이미 "),lp=l("code"),Ef=t("OrderableInt"),vf=t("가 포함된 트리에 "),cp=l("code"),_f=t("OrderableString"),bf=t("을 삽입해도 컴파일러가 에러를 잡아주지 않는다. 따라서 프로그램을 실행하면 아래와 같은 panic이 발생한다."),Zl=i(),As=l("pre"),zl=i(),Xa=l("p"),yf=t("다시 말해 컴파일 타임의 type safety 검사가 무효화되므로, Go의 가장 큰 장점 중 하나를 잃는 셈이다."),Xl=i(),Yl=l("br"),Vl=i(),Ya=l("p"),mf=t("하지만 Go에 제네릭이 등장했다! 이제 이러한 고민 없이 여러 타입에 호환되면서도 컴파일 타임에 오류를 찾을 수 있는 코드를 작성할 수 있게 되었다. 실제 코드는 조금 있다가 짜볼 것이다."),ql=i(),O=l("p"),wf=t(`제네릭이 없는 데이터 구조는 매우 불편하지만, 실질적인 한계는 함수 작성에 있다.
제네릭이 원래 Go의 일부가 아니였기 때문에, Go의 표준 라이브러리에는 몇 가지 특이한(그리고 좀 불편한) 점이 있다.
가령 `),up=l("code"),Pf=t("math.Max()"),Of=t(", "),ip=l("code"),Tf=t("math.Min()"),Df=t(", "),rp=l("code"),Cf=t("math.Mod"),Rf=t(" 등의 함수는 각 타입에 대해 여러 함수를 만들기보다는, "),kp=l("code"),Gf=t("float64"),Sf=t(` 타입 하나만 파라미터로 둔다.
이는 `),fp=l("code"),If=t("float64"),Mf=t("가 웬만한 산술 타입들을 다 커버할 수 있을 만큼 표현 범위가 충분히 크기 때문이다."),Jl=i(),Dn=l("p"),Hf=t(`제네릭 없이는 인터페이스별로 지정된 변수의 새로운 인스턴스를 만들 수 없으며, concrete type이 같은 두 파라미터를 동일한 인터페이스 타입이 되도록 명시할 수 없다.
또한 제네릭이 없으면 컴파일 타임의 type safety를 포기해야 하거나, 성능을 포기하고 reflection을 사용해야만 특정 타입의 slice를 처리할 수 있다. (`),dp=l("code"),Bf=t("sort.Slice()"),Lf=t("가 이렇게 설계되었다.)"),Ul=i(),Wl=l("br"),jl=l("br"),Kl=i(),Cn=l("h2"),Rn=l("a"),Ep=l("span"),xf=t("Generics in Go"),Ql=i(),hl=l("hr"),gl=i(),Va=l("p"),Af=t("Go가 처음 발표된 이래로 제네릭이 추가되어야 한다는 많은 요구가 있었다. 하지만 Go는 빠른 컴파일, 코드의 가독성, 빠른 성능을 강조하며, 제네릭이 포함되면 이 세 장점을 잃을 수밖에 없었다고 한다. 하지만 10년 가량 이 문제를 연구한 끝에 Go 개발팀은 방법을 찾아냈다고 한다."),nc=i(),qa=l("p"),$f=t("자료구조인 스택의 예제로, Go에서 제네릭이 어떻게 동작하는지 확인해 보자."),sc=i(),$s=l("pre"),ac=i(),Ja=l("p"),Nf=t("이 코드엔 몇 가지 주목할 점이 있다."),tc=i(),Z=l("ol"),z=l("li"),vp=l("code"),Ff=t("Stack"),Zf=t(" 타입 선언시 "),_p=l("code"),zf=t("[T any]"),Xf=t(`라고 명시해주었다. 대괄호 안에 타입 파라미터가 배치되며, 마치 일반적인 파라미터처럼 타입명이 먼저 오고, 타입 제약조건이 나중에 온다.
타입 파라미터의 이름으로는 아무 것이나 사용할 수 있지만, 대문자를 사용하는 것이 일반적이다.
그리고 `),bp=l("code"),Yf=t("Stack"),Vf=t(" 안에서 "),yp=l("code"),qf=t("[]T"),Jf=t("로 주어진 타입의 slice를 선언한 것을 확인할 수 있다."),Uf=i(),B=l("li"),Wf=t("타입 파라미터로 올 수 있는 타입은 인터페이스를 사용하여 명시할 수 있다. 위 예제에서는 새로운 키워드인 "),mp=l("code"),jf=t("any"),Kf=t("가 사용되었는데, 사실 "),wp=l("code"),Qf=t("any"),hf=t("는 "),Pp=l("code"),gf=t("interface{}"),n1=t(`와 완전히 동일하다!
Go 1.18 이후의 버전을 사용한다면 `),Op=l("code"),s1=t("interface{}"),a1=t(" 대신 any를 써도 되지만 그건 backward compatibility가 보장되지 않으니 그러지 말도록 하자."),t1=i(),m=l("li"),p1=t("메소드 선언부를 보면, "),Tp=l("code"),e1=t("vals"),o1=t("를 선언할 때 "),Dp=l("code"),l1=t("T"),c1=t("를 썼던 것처럼 파라미터 "),Cp=l("code"),u1=t("val"),i1=t("의 타입 자리에 타입 파라미터 "),Rp=l("code"),r1=t("T"),k1=t("가 들어간다. 또한 Receiver 부분에서 "),Gp=l("code"),f1=t("Stack"),d1=t(" 대신 "),Sp=l("code"),E1=t("Stack[T]"),v1=t("를 참조하였다."),_1=i(),w=l("li"),b1=t("제네릭을 사용하면 Zero value를 다루기가 살짝 까다로워진다. 이를테면 "),Ip=l("code"),y1=t("Pop()"),m1=t(" 메소드에서 Zero value로 "),Mp=l("code"),w1=t("nil"),P1=t(" 같은 걸 막 반환할 수가 없는게, 만약 타입이 "),Hp=l("code"),O1=t("int"),T1=t("라면 "),Bp=l("code"),D1=t("nil"),C1=t(`이 Zero value가 아니기 때문이다.
따라서 Zero value를 얻기 위해 변수를 `),Lp=l("code"),R1=t("var"),G1=t("로 선언하고 이를 반환한다. 정의상 "),xp=l("code"),S1=t("var"),I1=t("는 다른 값이 할당되지 않으면 변수를 항상 zero value로 초기화하기 때문이다."),pc=i(),ec=l("br"),oc=i(),Ua=l("p"),M1=t("제네릭 타입을 사용하는 것은 제네릭이 아닌 버전을 사용하는 것과 크게 다르지 않다."),lc=i(),Ns=l("pre"),cc=i(),X=l("p"),H1=t("유일한 차이점은 "),Ap=l("code"),B1=t("Stack"),L1=t(" 타입의 변수를 선언할 때, 타입에 "),$p=l("code"),x1=t("Stack[int]"),A1=t("와 같이 타입 정보 "),Np=l("code"),$1=t("int"),N1=t("를 대괄호로 묶어 함께 선언하였다는 점이다."),uc=i(),Gn=l("p"),F1=t("만약 이 예제에서 다음과 같이 문자열을 "),Fp=l("code"),Z1=t("intStack"),z1=t("에 집어넣는다고 하면, 컴파일러가 감지할 것이다."),ic=i(),Fs=l("pre"),rc=i(),Wa=l("p"),X1=t("이 라인을 넣고 컴파일 하면 다음과 같은 에러가 발생한다."),kc=i(),Zs=l("pre"),fc=i(),dc=l("br"),Ec=i(),Sn=l("p"),Y1=t("스택에 값이 존재하는지를 반환하는 메소드를 위 예제의 "),Zp=l("code"),V1=t("Stack"),q1=t("에 새로 추가해보자."),vc=i(),zs=l("pre"),_c=i(),ja=l("p"),J1=t("하지만 이 메소드를 추가하면 컴파일되지 않는다."),bc=i(),Xs=l("pre"),yc=i(),P=l("p"),zp=l("code"),U1=t("interface{}"),W1=t("가 어떠한 정보도 제공하지 않듯, "),Xp=l("code"),j1=t("any"),K1=t("도 마찬가지이다. "),Yp=l("code"),Q1=t("any"),h1=t("는 정보를 저장하고 찾을 때, 그 타입이 어떤 타입인가에 대한 정보밖에는 알려주지 못한다. 이를테면 "),Vp=l("code"),g1=t("=="),n2=t(`를 사용할 수 있는 타입인지에 대한 정보는 알려줄 수 없다!
그래서 `),qp=l("code"),s2=t("=="),a2=t("를 사용하기 위해서는 "),Jp=l("code"),t2=t("any"),p2=t("가 아닌 다른 타입을 사용해야 한다."),mc=i(),y=l("p"),e2=t("대부분의 concrete type은 "),Up=l("code"),o2=t("!="),l2=t(" 또는 "),Wp=l("code"),c2=t("=="),u2=t("로 비교가 가능하기 때문에, Go에는 비교가 가능한 타입들을 나타낼 수 있는 인터페이스인 "),jp=l("code"),i2=t("comparable"),r2=t("이라는 키워드가 정의되어 있다. 다음과 같이 "),Kp=l("code"),k2=t("Stack"),f2=t("의 정의에서 "),Qp=l("code"),d2=t("any"),E2=t("를 "),hp=l("code"),v2=t("comparable"),_2=t("로 바꿔보자."),wc=i(),Ys=l("pre"),Pc=i(),In=l("p"),b2=t("이제 "),gp=l("code"),y2=t("Contains()"),m2=t(" 메소드를 사용할 수 있다."),Oc=i(),Vs=l("pre"),Tc=i(),Ka=l("p"),w2=t("실행 결과는 다음과 같다."),Dc=i(),qs=l("pre"),Cc=i(),Qa=l("p"),P2=t(`차후 제네릭을 이용해 바이너리 트리를 만드는 방법을 알아볼 것이다.
이에 앞서 제네릭 함수, 제네릭이 인터페이스와 함께 동작하는 방식, type terms와 같은 다른 추가 개념도 다뤄볼 것이다.`),Rc=i(),Gc=l("br"),Sc=l("br"),Ic=i(),Mn=l("h2"),Hn=l("a"),ne=l("span"),O2=t("Generic Functions"),Mc=i(),Hc=l("hr"),Bc=i(),ha=l("p"),T2=t("제네릭으로 함수도 작성할 수 있다. 앞서 언급했듯 모든 타입에 호환되는 map, reduce, filter를 제네릭 없이 구현하기는 다소 어렵지만, 이제 제네릭이 있으니 뚝딱 만들 수 있다."),Lc=i(),Js=l("pre"),xc=i(),Y=l("p"),D2=t("함수 이름과 파라미터 사이에 타입 파라미터를 배치하면 된다. "),se=l("code"),C2=t("Map()"),R2=t("과 "),ae=l("code"),G2=t("Reduce()"),S2=t("는 두 개의 타입 파라미터가 필요하며, "),te=l("code"),I2=t("Filter()"),M2=t("는 한 개면 된다."),Ac=i(),ga=l("p"),H2=t("이렇게 정의한 세 함수는 다음과 같이 사용할 수 있다."),$c=i(),Us=l("pre"),Nc=i(),nt=l("p"),B2=t("실행 결과는 다음과 같다."),Fc=i(),Ws=l("pre"),Zc=i(),zc=l("br"),Xc=l("br"),Yc=i(),Bn=l("h2"),Ln=l("a"),pe=l("span"),L2=t("Generics and Interfaces"),Vc=i(),qc=l("hr"),Jc=i(),Q=l("p"),ee=l("code"),x2=t("any"),A2=t("나 "),oe=l("code"),$2=t("comparable"),N2=t(`뿐만 아니라 모든 인터페이스를 타입 제약조건으로 사용할 수 있다.
이를테면, `),le=l("code"),F2=t("fmt.Stringer"),Z2=t(`를 구현하는 동일한 타입의 필드 두 개를 가진 타입을 만들고 싶다고 가정해보자.
제네릭을 사용하면 컴파일 타임에 이를 적용할 수 있다.`),Uc=i(),js=l("pre"),Wc=i(),st=l("p"),z2=t("또한 타입 파라미터를 인터페이스에도 사용할 수 있다."),jc=i(),Ks=l("pre"),Kc=i(),C=l("p"),X2=t("위의 "),ce=l("code"),Y2=t("Differ"),V2=t("는 "),ue=l("code"),q2=t("fmt.Stringer"),J2=t("를 임베드하며, 지정된 타입의 값과 비교하여 "),ie=l("code"),U2=t("float64"),W2=t("를 반환하는 "),re=l("code"),j2=t("Diff()"),K2=t(" 메소드를 포함하는 인터페이스이다."),Qc=i(),xn=l("p"),Q2=t(`이 두 타입을 이용하여 비교 함수를 작성해보자.
함수는 두 개의 `),ke=l("code"),h2=t("Pair"),g2=t(" 인스턴스를 파라미터로 받고"),hc=i(),Qs=l("pre"),gc=i(),d=l("p"),fe=l("code"),nd=t("FindCloser"),sd=t("는 "),de=l("code"),ad=t("Differ"),td=t(" 인터페이스를 충족시키는 필드가 있는 "),Ee=l("code"),pd=t("Pair"),ed=t(` 인스턴스를 받는다.
`),ve=l("code"),od=t("Pair"),ld=t("는 두 필드의 타입이 같고 "),_e=l("code"),cd=t("fmt.Stringer"),ud=t(" 인터페이스를 충족시켜야 한다. 만약 "),be=l("code"),id=t("Pair"),rd=t(" 인스턴스의 필드가 "),ye=l("code"),kd=t("Differ"),fd=t("를 충족시키지 않으면, "),me=l("code"),dd=t("Pair"),Ed=t(" 인스턴스로 "),we=l("code"),vd=t("FindCloser"),_d=t("를 사용하는 것을 컴파일러가 막을 것이다."),nu=i(),su=l("br"),au=i(),An=l("p"),bd=t("이제 "),Pe=l("code"),yd=t("Differ"),md=t(" 인터페이스를 충족시키는 몇 개의 타입들을 정의해보자."),tu=i(),hs=l("pre"),pu=i(),at=l("p"),wd=t("이들을 사용하는 코드는 이렇게 작성할 수 있다."),eu=i(),gs=l("pre"),ou=i(),tt=l("p"),Pd=t("그리고 실행하면 다음과 같은 결과를 얻는다."),lu=i(),na=l("pre"),cu=i(),uu=l("br"),iu=l("br"),ru=i(),$n=l("h2"),Nn=l("a"),Oe=l("span"),Od=t("Type Terms"),ku=i(),fu=l("hr"),du=i(),T=l("p"),Td=t(`제네릭을 사용하기 위해서는 연산자를 나타내줘야 한다.
가령 `),Te=l("code"),Dd=t("Min()"),Cd=t(" 함수의 제네릭 버전을 작성한다고 하면, "),De=l("code"),Rd=t("<"),Gd=t("나 "),Ce=l("code"),Sd=t(">"),Id=t(`와 같은 비교 연산자를 사용할 수 있어야 함을 나타내는 제약조건을 명시할 수 있어야 한다.
Go에서는 인터페이스 안에 한 개 이상의 `),Re=l("code"),Md=t("type term"),Hd=t("이 명시된, "),Ge=l("em"),Bd=t("type element"),Ld=t("를 사용한다."),Eu=i(),sa=l("pre"),vu=i(),f=l("p"),xd=t("위 예제는 인터페이스를 임베딩하는 것처럼 concrete type의 목록을 "),Se=l("code"),Ad=t("|"),$d=t(`로 구분하여 나열하였다. 이 타입 목록은 타입 파라미터로 할당될 수 있으며, 목록의 타입이 지원하는 연산자를 사용할 수 있음을 나타낸다.
이때 목록의 타입에서 `),Ie=l("strong"),Nd=t("모두"),Fd=t(" 사용할 수 있는 연산자만 사용 가능하다. 따라서 위 예제에서는 "),Me=l("code"),Zd=t("=="),zd=t(", "),He=l("code"),Xd=t("!="),Yd=t(", "),Be=l("code"),Vd=t(">"),qd=t(", "),Le=l("code"),Jd=t("<"),Ud=t(", "),xe=l("code"),Wd=t(">="),jd=t(", "),Ae=l("code"),Kd=t("<="),Qd=t(", "),$e=l("code"),hd=t("+"),gd=t(` 등이 사용 가능 연산자일 것이다.
주의해야 할 점은, type element에 concrete type의 type term이 있는 인터페이스는 오직 타입 파라미터로 사용된 영역에서만 사용할 수 있다. 얘네를 그 밖의 변수, 필드, 리턴 값, 파라미터로 사용하게 되면 컴파일 에러가 발생한다.`),_u=i(),sn=l("p"),n3=t("이제 알건 다 알았으니 "),Ne=l("code"),s3=t("BuiltInOrdered"),a3=t(" 를 사용하여 "),Fe=l("code"),t3=t("Min()"),p3=t("을 제네릭으로 작성해보자."),bu=i(),aa=l("pre"),yu=i(),an=l("p"),e3=t("기본적으로 type term은 정확히 매칭된다. 만약 "),Ze=l("code"),o3=t("BuiltInOrdered"),l3=t("에 명시된 type term 중 하나를 사용자 정의 타입으로 재선언한 후 그 인스턴스로 "),ze=l("code"),c3=t("Min()"),u3=t("을 호출하면, 에러가 발생한다."),mu=i(),ta=l("pre"),wu=i(),pt=l("p"),i3=t("위 예제를 실행하면 다음과 같은 에러가 발생한다."),Pu=i(),pa=l("pre"),Ou=i(),Fn=l("p"),r3=t("에러 메시지를 보면 이 문제의 해결법을 알려준다! 만약 type term의 타입이 사용자 정의 타입에 대해서도 동작하게 하고 싶다면, type term 앞에 "),Xe=l("code"),k3=t("~"),f3=t("를 붙이면 된다."),Tu=i(),ea=l("pre"),Du=i(),et=l("p"),d3=t("이제 다시 실행해보면 문제 없이 동작함을 확인할 수 있다."),Cu=i(),oa=l("pre"),Ru=i(),Gu=l("br"),Su=i(),Zn=l("p"),E3=t(`타입 파라미터로 사용되는 인터페이스가 type element와 메소드를 모두 가질 수 있다.
이를테면 어떤 타입이 int와 동등하면서 `),Ye=l("code"),v3=t("String()"),_3=t(" 문자열 메소드가 있어야 충족시킬 수 있는 인터페이스는 다음과 같이 선언할 수 있다."),Iu=i(),la=l("pre"),Mu=i(),R=l("p"),b3=t(`하지만 Go의 컴파일러는 실질적으로 충족시키는 게 불가능한 인터페이스도 만들 수 있다는 점을 주의해야 한다.
이를테면 위 예제에서 `),Ve=l("code"),y3=t("~int"),m3=t("가 아니라 "),qe=l("code"),w3=t("int"),P3=t("라고 적고 작성한다면, 어떠한 타입도 "),Je=l("code"),O3=t("PrintableInt"),T3=t(" 인터페이스를 충족시킬 수 없기 때문이다. ("),Ue=l("code"),D3=t("int"),C3=t("는 메소드가 없다)"),Hu=i(),ca=l("pre"),Bu=i(),zn=l("p"),R3=t("컴파일러 관점에서 볼 때, 위 코드의 "),We=l("code"),G3=t("ImpossiblePrintableInt"),S3=t("는 아무런 문제가 없다. 즉, 불가능한 인터페이스를 선언할 때 컴파일러가 에러를 잡아주지는 못한다."),Lu=i(),ot=l("p"),I3=t("하지만, 이를 사용하려고 할 때 에러를 잡아줄 수는 있다. 불가능한 타입 파라미터를 사용하여 함수나 타입을 선언한다면 컴파일러가 이를 감지하여 컴파일 에러를 발생시킨다."),xu=i(),ua=l("pre"),Au=i(),ia=l("p"),je=l("code"),M3=t("ImpossibleStruct"),H3=t(" 인스턴스를 만드려고 할 때, 다음과 같은 에러가 발생한다."),$u=i(),ra=l("pre"),Nu=i(),lt=l("p"),B3=t(`type term은 int나 string같은 원시 타입 뿐 아니라 slice, map, array, 또한 채널, 구조체, 함수까지도 가능하다.
따라서 타입 파라미터가 특정한 concrete type과 동등하며 한 개 이상의 메소드를 가질 때 type term을 사용하면 유용할 것이다.`),Fu=i(),Zu=l("br"),zu=l("br"),Xu=i(),Xn=l("h2"),Yn=l("a"),Ke=l("span"),L3=t("Type Inference and Generics"),Yu=i(),Vu=l("hr"),qu=i(),G=l("p"),x3=t("Go는 "),Qe=l("code"),A3=t(":="),$3=t(" 연산자를 사용할 때 타입 추론을 지원하며, 마찬가지로 제네릭 함수에서도 호출을 단순화하기 위해 타입 추론을 사용한다. 위 예의 "),he=l("code"),N3=t("Map"),F3=t(", "),ge=l("code"),Z3=t("Filter"),z3=t(", "),no=l("code"),X3=t("Reduce"),Y3=t("를 사용할 때 이를 확인할 수 있다."),Ju=i(),ct=l("p"),V3=t("하지만 특정 상황에서는 타입 추론을 할 수 없으며(타입 파라미터가 리턴값으로만 사용된 경우 등), 그런 경우에는 타입이 반드시 명시되어야 한다. 다음의 예제는 타입 추론을 할 수 없는 경우의 코드이다."),Uu=i(),ka=l("pre"),Wu=i(),V=l("p"),q3=t("주석 처리한 "),so=l("code"),J3=t("b1"),U3=t("은 타입 추론이 불가능하며, 변수의 타입을 명시한 "),ao=l("code"),W3=t("b3"),j3=t("도 오류가 발생한다. 즉 "),to=l("code"),K3=t("b2"),Q3=t("처럼 타입 파라미터를 직접 명시해주어야 한다."),ju=i(),Ku=l("br"),Qu=l("br"),hu=i(),Vn=l("h2"),qn=l("a"),po=l("span"),h3=t("Type Elements Limit Constants"),gu=i(),ni=l("hr"),si=i(),Jn=l("p"),g3=t("type element는 제네릭 타입의 변수에 할당될 수 있는 상수를 지정할 수도 있다. 연산자와 마찬가지로, 상수는 type element에 존재하는 "),eo=l("strong"),nE=t("모든"),sE=t(" type term에 대해 유효해야 한다."),ai=i(),tn=l("p"),aE=t("위에서 "),oo=l("code"),tE=t("BuiltInOrdered"),pE=t("와 "),lo=l("code"),eE=t("Integer"),oE=t("의 정의를 다시 보자."),ti=i(),fa=l("pre"),pi=i(),da=l("p"),co=l("code"),lE=t("BuiltInOrdered"),cE=t("에 명시된 모든 type term을 만족시키는 상수는 존재하지 않는다. 따라서 이 제네릭 타입에는 상수를 할당할 수 없다."),ei=i(),Un=l("p"),uE=t("한편, "),uo=l("code"),iE=t("Integer"),rE=t("의 경우 할당 가능한 범위의 상수가 존재한다. (0~127일 것이다) 하지만 그 범위를 벗어난 수를 할당하려고 하면 에러가 발생한다."),oi=i(),Ea=l("pre"),li=i(),va=l("p"),io=l("code"),kE=t("PlusOneThousand()"),fE=t("를 컴파일하려 하면 아래와 같은 에러가 발생한다."),ci=i(),_a=l("pre"),ui=i(),Wn=l("p"),dE=t("원인은 명백하다. 1000이 8비트 정수 범위를 벗어났기 때문이다. 반면 "),ro=l("code"),EE=t("PlusOneHundred()"),vE=t("은 문제 없이 컴파일된다."),ii=i(),ri=l("br"),ki=l("br"),fi=i(),jn=l("h2"),Kn=l("a"),ko=l("span"),_E=t("Generic Functions + Generic Data Structures"),di=i(),Ei=l("hr"),vi=i(),ut=l("p"),bE=t("다시 바이너리 트리 예제로 돌아와보자. 이제 우리가 배운 것들을 이용하여 모든 concrete type에 적합한 단일 바이너리 트리 타입을 작성해볼 것이다. 이 때 두 값을 비교하고 순서를 알려주는 제네릭 함수가 바이너리 트리에 필요하다는 것을 알아야 한다."),_i=i(),ba=l("pre"),bi=i(),pn=l("p"),yE=t("그렇다면 트리의 구현이 약간 달라진다. 먼저, 트리를 "),fo=l("code"),mE=t("Node"),wE=t("와 "),Eo=l("code"),PE=t("Tree"),OE=t(" 두 개의 타입으로 나눠야 한다."),yi=i(),ya=l("pre"),mi=i(),ma=l("p"),vo=l("code"),TE=t("Tree"),DE=t(" 인스턴스를 생성하는 생성자 함수도 작성해준다."),wi=i(),wa=l("pre"),Pi=i(),Oi=l("br"),Ti=i(),_n=l("p"),_o=l("code"),CE=t("Tree"),RE=t("의 메소드는 간단하다. 실제 작업을 하는 "),bo=l("code"),GE=t("Node"),SE=t("의 메소드를 호출해주기만 하면 된다."),Di=i(),Pa=l("pre"),Ci=i(),en=l("p"),IE=t("이제 "),yo=l("code"),ME=t("OrderedFunc"),HE=t("에 대응하는 함수가 필요하다. "),mo=l("code"),BE=t("BuiltInOrdered"),LE=t("를 활용하여 모든 원시 타입이 지원되는 함수를 작성할 수 있다."),Ri=i(),Oa=l("pre"),Gi=i(),on=l("p"),xE=t("선언한 "),wo=l("code"),AE=t("BuiltInOrderable"),$E=t("를 "),Po=l("code"),NE=t("Tree"),FE=t("와 함께 사용한 코드는 다음과 같다."),Si=i(),Ta=l("pre"),Ii=i(),Mi=l("br"),Hi=i(),Qn=l("p"),ZE=t("구조체를 정의하여 "),Oo=l("code"),zE=t("Tree"),XE=t(`에 집어넣을 수도 있다.
그러면 정렬 함수를 어떻게 작성하는지가 관건일 듯 하다. 우선 다음과 같이 함수를 작성하는 방법이 있다.`),Bi=i(),Da=l("pre"),Li=i(),q=l("p"),YE=t("함수 "),To=l("code"),VE=t("OrderPeople()"),qE=t("를 생성 함수에 넘겨주면 "),Do=l("code"),JE=t("Person"),UE=t("의 "),Co=l("code"),WE=t("Tree"),jE=t("를 만들 수 있다."),xi=i(),Ca=l("pre"),Ai=i(),it=l("p"),KE=t("함수를 넘기는 대신 메소드를 넘길 수도 있다. 사실상 메소드도 함수의 일종이라 크게 놀라운 사실은 아니다."),$i=i(),Ra=l("pre"),Ni=i(),ln=l("p"),QE=t("마찬가지로 "),Ro=l("code"),hE=t("Order()"),gE=t("의 method expression을 "),Go=l("code"),nv=t("Tree"),sv=t("의 생성 함수에 넘겨주면 된다."),Fi=i(),Ga=l("pre"),Zi=i(),zi=l("br"),Xi=l("br"),Yi=i(),hn=l("h2"),gn=l("a"),So=l("span"),av=t("Things That Are Left Out"),Vi=i(),qi=l("hr"),Ji=i(),rt=l("p"),tv=t(`Go는 작은 언어를 지향하며, 일반적으로 다른 언어에 존재하는 제네릭 관련 기능이 Go에는 포함되지 않은 경우가 많다.
이 단락에서는 Go 제네릭의 초기 구현에 없었던 기능들을 소개하고자 한다.`),Ui=i(),cn=l("p"),pv=t(`사용자 정의 타입과 기본 타입 둘 다 사용할 수 있는 단일 트리를 만들 수 있었지만, Python, Ruby, C++ 등은 이 문제를 다르게 해결한다.
바로 이를 통해 사용자 정의 타입이 연산자에 대한 동작을 지정할 수 있는 연산자 오버로딩이다.
하지만 Go에는 이 기능이 없기 때문에 사용자 정의 컨테이너 타입에 `),Io=l("code"),ev=t("range"),ov=t("를 통해 이터레이트하거나 "),Mo=l("code"),lv=t("[]"),cv=t("를 통해 인덱싱할 수 없다."),Wi=i(),ns=l("p"),uv=t(`Go가 연산자 오버로딩을 지원하지 않는 이유가 있다.
우선 Go에는 연산자가 매우 많다. Go는 연산자 오버로딩 말고도 함수나 메소드의 오버로딩도 지원하지 않으며, 다른 타입에 대해 다른 연산자의 기능을 지정하는 방법이 필요하다.
무엇보다 연산자 오버로딩은 개발자가 코드를 읽고 기호의 정확한 의미를 떠올리기 힘들게 한다. 이를테면 C++의 `),Ho=l("code"),iv=t("<<"),rv=t(" 기호는 “bitwise shift left”와 “write value”의 두 가지 의미가 있다. Go는 이러한 가독성 문제를 회피하려 하는 것이다."),ji=i(),J=l("p"),kv=t("Go의 초기 제네릭 구현에서 제외된 또 다른 유용한 기능은 메소드에 대한 추가 타입 파라미터이다. 즉, 메소드는 타입 파라미터를 가질 수 없다. "),Bo=l("code"),fv=t("Map"),dv=t(", "),Lo=l("code"),Ev=t("Filter"),vv=t(", "),xo=l("code"),_v=t("Reduce"),bv=t(" 함수를 되돌아보면, 다음과 같은 메소드로 구현된다면 유용할 것이라고 생각할 수 있다."),Ki=i(),Sa=l("pre"),Qi=i(),kt=l("p"),yv=t("그렇다면 위 메소드는 다음과 같이 사용할 수 있을 것이다."),hi=i(),Ia=l("pre"),gi=i(),ft=l("p"),mv=t(`함수형 프로그래밍 애호가들에겐 아쉽겠지만(ㅠㅠ) Go에서는 이러한 코드가 작동하지 않는다.
메소드의 호출 체인을 만드는 대신, 함수 호출을 중첩하거나 함수를 한 번에 하나씩 호출하고 중간 값을 변수에 할당하는 식으로 가독성이 더 좋은 방법을 사용해야 한다.`),nr=i(),dt=l("p"),wv=t(`또한 가변적인 타입 파라미터도 존재하지 않는다. 가령, 우리가 Reflection에서 다뤘던 주제 중에는 기존 함수의 시간을 재는 wrapper 함수를 작성하는 문제도 있었다. 이러한 경우는 제네릭으로 처리할 수 없기 때문에, 여전히 Reflection으로 처리해주어야 한다.
타입 파라미터를 사용할 때마다 각각의 필요한 타입의 이름을 명시적으로 제공해야 하므로, 타입이 다른 파라미터의 개수로 함수를 나타낼 수 없다.`),sr=i(),Et=l("p"),Pv=t("이외에도 Go의 제네릭에는 다음과 같은 기능들이 제외되었다."),ar=i(),un=l("ul"),Ao=l("li"),Ma=l("p"),Ov=t("Specialization"),Tv=l("br"),Dv=t(`
함수 또는 메소드는 제네릭 버전 외에 하나 이상의 타입별로 오버로드되지 않는다. 다시 말하지만, Go에는 오버로드가 없다.`),Cv=i(),$o=l("li"),No=l("p"),Rv=t(`Currying
다른 제네릭 함수나 타입에 따라, 타입 파라미터 중 일부를 지정하여 함수나 타입을 부분적으로 인스턴스화할 수 없다.`),Gv=i(),Fo=l("li"),Zo=l("p"),Sv=t(`Metaprogramming
컴파일시 실행되는 코드를 지정하여 런타임에 실행되는 코드를 생성할 수 없다.`),tr=i(),pr=l("br"),er=l("br"),or=i(),ss=l("h2"),as=l("a"),zo=l("span"),Iv=t("Idiomatic Go and Generics"),lr=i(),cr=l("hr"),ur=i(),U=l("p"),Mv=t("Go에 제네릭이 추가됨으로써, 기존의 이상적인 코드가 분명히 바뀌었다. 이제 "),Xo=l("code"),Hv=t("float64"),Bv=t("로 불특정 산술 타입을 나타내지 않을 것이다. 또한 함수나 자료구조에서 명시되지 않은 타입을 나타낼 때 "),Yo=l("code"),Lv=t("interface{}"),xv=t(" 대신 "),Vo=l("code"),Av=t("any"),$v=t(`를 사용하여야 한다.
이제 함수 하나로 다양한 타입의 slice를 처리할 수 있다.`),ir=i(),vt=l("p"),Nv=t("하지만 지금 당장 모든 코드를 타입 파라미터를 사용하게끔 변경할 필요가 없다. 새로운 디자인 패턴이 만들어지더라도 오래된 코드는 동작한다."),rr=i(),_t=l("p"),Fv=t("제네릭의 성능을 판단하기에는 하직 조금 이르다. Go 1.18의 컴파일러는 이전 버전에 비해 느려졌지만, 이후 릴리즈에서 해결될 문제로 예상된다. 이미 현재 런타임 문제에 관한 연구가 진행되고 있다. 요컨대 향후 버전에서 제네릭이 다듬어질수록 런타임 성능도 개선될 것이다."),kr=i(),W=l("p"),Zv=t("목표는 항상 "),F5(ts.$$.fragment),zv=i(),F5(ps.$$.fragment),Xv=i(),F5(es.$$.fragment),Yv=t(" 코드를 작성하는 것이다."),fr=i(),dr=l("br"),Er=l("br"),vr=i(),os=l("h2"),ls=l("a"),qo=l("span"),Vv=t("Further Features Unlocked"),_r=i(),br=l("hr"),yr=i(),S=l("p"),qv=t("Go 1.18에 제네릭이 처음 출시되었을 때, 여러 논란이 있었다. 새로운 식별자인 "),Jo=l("code"),Jv=t("any"),Uv=t("와 "),Uo=l("code"),Wv=t("comparable"),jv=t(`이 도입되었지만, 표준 라이브러리의 API는 제네릭을 사용하지 않는다.
기존에 `),Wo=l("code"),Kv=t("interface{}"),Qv=t("를 사용하던 API가 "),jo=l("code"),hv=t("any"),gv=t("로 바뀐 것 외엔 실질적인 변화는 없다"),mr=i(),cs=l("p"),n5=t("이후 버전의 표준 라이브러리에서는 일반적인 경우의 타입들을 분류하는 새로운 인터페이스("),Ko=l("code"),s5=t("Orderable"),a5=t(`같은), 새로운 타입(set, tree, 정렬된 map 등), 새로운 함수가 추가될 것으로 보인다.
이러한 것들을 직접 작성하여 쓰는 것도 좋지만, 표준 라이브러리가 업데이트되면 교체하는 것을 고려해보자.`),wr=i(),us=l("p"),t5=t("제네릭은 차후 추가될 기능들의 기본이 될 수 있다. 한가지 가능성은 "),Qo=l("em"),p5=t("sum type"),e5=t(`이다.
type element가 타입 파라미터를 대체할 수 있는 타입을 명시하는 데 사용되듯, 인터페이스의 파라미터에도 사용될 수 있을 것이다.`),Pr=i(),is=l("p"),o5=t("오늘날 Go는 특정 필드가 단일 값이거나, 아니면 값의 list인지 확실히 처리할 수 없는 종류의 JSON을 처리하는 데 문제가 있다. 만약 "),ho=l("code"),l5=t("sum type"),c5=t(`이 추가된다면, 필드가 문자열인지, 또는 문자열의 slice인지 명시하는 인터페이스를 생성할 수 있을 것이다.
그러면 type switch를 사용하여 모든 유효한 타입을 열거함으로써 type safety를 향상시킬 수 있을 것이다.
이렇게 허용할 한정된 종류의 타입만 명시하는 기능은 Rust나 Swift등 현대 언어에서 enum을 통해 sum types을 사용한다.
현재 Go의 enum 기능은 다소 약하기 때문에, 괜찮은 방법일지라도 아이디어가 평가되고 연구되기까지는 다소 시간이 걸릴 것이다.`),Or=i(),Tr=l("br"),Dr=l("br"),Cr=i(),rs=l("h2"),ks=l("a"),go=l("span"),u5=t("후기"),Rr=i(),Gr=l("hr"),Sr=i(),bt=l("p"),i5=t("이제야 기본적인 Go의 내용이 끝났다."),Ir=i(),yt=l("p"),r5=t("학업때문에 Go를 잠깐 놓았던 기간을 제외하면, 이 책 내용 끝내는 데만 대략 4개월이 걸린 셈이다. 아무리 원서 읽고 번역하고 블로그에 기록까지 하면서 하는 거라 해도, 다소 오래 걸린 감이 있다."),Mr=i(),fs=l("p"),k5=t("어떤 프로그래밍 언어를 가장 잘 하는 방법은 그 언어로 아무 토이프로젝트나 해보며 이것저것 부딛혀보는 것이라고들 한다. 전적으로 동의하는 바이고 자바스크립트도 그렇게 배웠지만, Go는 중간에 한 프로젝트라고는 "),Ha=l("a"),f5=t("WebRTC 시그널링 서버"),d5=t(" 하나 만든것 말곤 없다. 이것도 사실상 인터페이스를 사용하지 않은 거라 도움이 엄청 많이 됐을것같진 않다. 아무래도 이것저것 더 많이 해봐야 할것 같다."),Hr=i(),mt=l("p"),E5=t(`Go를 배운 이유가 자바가 싫어서도 있고, MSA에 가장 적합한 언어라고 여겨진다는 점도 있었다.
이렇듯 배움의 시작점이 된 건 다소 별거 아닌 이유였지만, 배우면 배울수록 매력적인 언어라고 느꼈다! 물론 배워야 할 게 아직도 산더미지만 ㅠ`),Br=i(),wt=l("p"),v5=t("Go의 동시성 패턴이나 분산처리 패턴같은 것도 좀 배워두고 싶은데, 이런 것들은 뭔가 필요성이 느껴질 때 배워야하는 내용들인 것 같다. 그래서 지금은 그러한 필요성을 느끼기 위해, 뭔가 프로젝트같은 것들을 해보려 한다. 학기가 시작해서 프로젝트에 쏟을 시간이 얼마나 될지는 모르겠지만.."),Lr=i(),xr=l("br"),Ar=l("br"),$r=i(),ds=l("h2"),Es=l("a"),nl=l("span"),_5=t("References"),Nr=i(),Fr=l("hr"),Zr=i(),Pt=l("center"),bn=l("p"),Ba=l("a"),Ot=l("img"),b5=i(),y5=l("br"),m5=i(),La=l("a"),w5=t("Jon Bodner, 『Learning Go』, O’Reilly Media, Inc."),this.h()},l(n){v=c(n,"BR",{}),E=r(n),x=c(n,"P",{});var e=u(x);ck=p(e,"본 글은 Golang을 공부하며 주요 내용이라 생각되는 것들을 기록해둔 자료이며, Ubuntu 22.04 LTS 기준으로 작성되었습니다."),e.forEach(s),pl=r(n),el=c(n,"BR",{}),ol=c(n,"BR",{}),ll=r(n),mn=c(n,"H2",{id:!0});var Tt=u(mn);wn=c(Tt,"A",{"aria-hidden":!0,tabindex:!0,href:!0});var sl=u(wn);Nt=c(sl,"SPAN",{class:!0}),u(Nt).forEach(s),sl.forEach(s),uk=p(Tt,"Introduction"),Tt.forEach(s),cl=r(n),ul=c(n,"HR",{}),il=r(n),Aa=c(n,"P",{});var al=u(Aa);ik=p(al,"드디어 Golang의 마지막 챕터에 왔다. 아이 신난다!"),al.forEach(s),rl=r(n),$a=c(n,"P",{});var U5=u($a);rk=p(U5,"개인적으로 Go의 사용성 증대의 마지막 열쇠같은 역할을 한 게 제네릭의 추가라고 생각한다. 내가 Go를 배울까 말까 하다가 결국 배우려고 했던 기점이 바로 이 제네릭의 추가이기도 하다. 그만큼 제네릭이 가져다주는 이점은 매우 크다!"),U5.forEach(s),kl=r(n),fl=c(n,"BR",{}),dl=r(n),Na=c(n,"P",{});var W5=u(Na);kk=p(W5,"Go에는 다소 느리긴 하지만 새로운 기능이 계속 추가되고 있다. 초기 릴리즈인 1.0과 비교했을 때, 지금의 Go에 이르기까지 세 가지 중요한 변화가 있었다. 각각 1.7의 컨텍스트, 1.11의 모듈, 그리고 1.13의 error wrapping이다."),W5.forEach(s),El=r(n),Fa=c(n,"P",{});var j5=u(Fa);fk=p(j5,`그리고 다음의 큰 변화는 Go 1.18에 있다. 바로 타입 파라미터의 도입, 즉 제네릭이 도입된 것이다!
이번 챕터에서는 제네릭이 할 수 있는 일, 없는 일을 알아보고 제네릭을 통해 낡은 패턴들을 대체해볼 것이다.`),j5.forEach(s),vl=r(n),_l=c(n,"BR",{}),bl=c(n,"BR",{}),yl=r(n),Pn=c(n,"H2",{id:!0});var P5=u(Pn);On=c(P5,"A",{"aria-hidden":!0,tabindex:!0,href:!0});var K5=u(On);Ft=c(K5,"SPAN",{class:!0}),u(Ft).forEach(s),K5.forEach(s),dk=p(P5,"Advantages of Generics"),P5.forEach(s),ml=r(n),A=c(n,"P",{});var vs=u(A);Ek=p(vs,`Go는 정적 타입 언어로, 파라미터와 변수의 타입이 컴파일할 때 결정됨을 의미한다.
내장 타입(map, slice, channel)과 함수(`),Zt=c(vs,"CODE",{});var Q5=u(Zt);vk=p(Q5,"len()"),Q5.forEach(s),_k=p(vs,", "),zt=c(vs,"CODE",{});var h5=u(zt);bk=p(h5,"cap()"),h5.forEach(s),yk=p(vs,", "),Xt=c(vs,"CODE",{});var g5=u(Xt);mk=p(g5,"make()"),g5.forEach(s),wk=p(vs,")는 다양한 concrete type의 값을 수용하거나 반환할 수 있었지만, Go 1.18 이전에는 사용자 정의 타입이나 함수는 허용되지 않았다."),vs.forEach(s),wl=r(n),$=c(n,"P",{});var _s=u($);Pk=p(_s,`만약 코드가 실행될 때까지 타입이 확인되지 않는 동적 타입 언어에 친숙하다면 제네릭에 대한 문제가 무엇인지, 또는 제네릭이 무엇인지조차도 다소 불분명할 수 있다. 이들을 “타입 파라미터”라고 생각하는게 좋을 듯 하다.
우리는 함수가 호출될 때 타입이 지정된 파라미터를 갖는 함수를 작성하는 것이 편하다. 이를테면 아래 코드의 함수 `),Yt=c(_s,"CODE",{});var n4=u(Yt);Ok=p(n4,"Min()"),n4.forEach(s),Tk=p(_s,"에서는 파라미터로 두 개의 "),Vt=c(_s,"CODE",{});var s4=u(Vt);Dk=p(s4,"float64"),s4.forEach(s),Ck=p(_s," 타입을, 그리고 반환형으로 "),qt=c(_s,"CODE",{});var a4=u(qt);Rk=p(a4,"float64"),a4.forEach(s),Gk=p(_s,"타입을 명시하였다."),_s.forEach(s),Pl=r(n),Ss=c(n,"PRE",{class:!0});var jm=u(Ss);jm.forEach(s),Ol=r(n),N=c(n,"P",{});var bs=u(N);Sk=p(bs,"마찬가지로 구조체를 선언할 때 필드의 타입을 명시하여 구조체를 생성한다. 아래 예제의 "),Jt=c(bs,"CODE",{});var t4=u(Jt);Ik=p(t4,"Node"),t4.forEach(s),Mk=p(bs,"는 "),Ut=c(bs,"CODE",{});var p4=u(Ut);Hk=p(p4,"int"),p4.forEach(s),Bk=p(bs,"와 "),Wt=c(bs,"CODE",{});var e4=u(Wt);Lk=p(e4,"*Node"),e4.forEach(s),xk=p(bs,"타입의 필드를 갖는다."),bs.forEach(s),Tl=r(n),Is=c(n,"PRE",{class:!0});var Km=u(Is);Km.forEach(s),Dl=r(n),Cl=c(n,"BR",{}),Rl=r(n),Za=c(n,"P",{});var o4=u(Za);Ak=p(o4,"하지만 파라미터나 구조체의 필드의 특정 유형이 사용될 때까지 명시되지 않은 상태로 함수 또는 구조체를 작성하는 것이 좋을 때도 있다."),o4.forEach(s),Gl=r(n),F=c(n,"P",{});var ys=u(F);$k=p(ys,"가령 "),jt=c(ys,"CODE",{});var l4=u(jt);Nk=p(l4,"int"),l4.forEach(s),Fk=p(ys," 타입에 대한 바이너리 서치 트리 구조체를 작성한다고 해보자. 이때 "),Kt=c(ys,"CODE",{});var c4=u(Kt);Zk=p(c4,"float64"),c4.forEach(s),zk=p(ys,"나 "),Qt=c(ys,"CODE",{});var u4=u(Qt);Xk=p(u4,"string"),u4.forEach(s),Yk=p(ys,`에서도 동일하게 동작하며 type safety를 만족하는 구조체를 원할 수도 있다.
가장 먼저 떠오르는 방법은 각각의 타입에 대해 여러 개의 구조체를 작성하는 것이다. 하지만 이 방법은 너무 중복성이 심하고 오류가 발생하기 쉽다.`),ys.forEach(s),Sl=r(n),za=c(n,"P",{});var i4=u(za);Vk=p(i4,"Go에 제네릭이 없었을 때 중복된 코드를 사용하지 않는 유일한 방법은, 값의 대소를 비교하는 방법이 명시된 인터페이스를 사용하는 방법이였다."),i4.forEach(s),Il=r(n),Ms=c(n,"PRE",{class:!0});var Qm=u(Ms);Qm.forEach(s),Ml=r(n),Tn=c(n,"P",{});var Xr=u(Tn);qk=p(Xr,"이 인터페이스를 사용하여, 다음과 같이 "),ht=c(Xr,"CODE",{});var r4=u(ht);Jk=p(r4,"Tree"),r4.forEach(s),Uk=p(Xr,"를 작성할 수 있다."),Xr.forEach(s),Hl=r(n),Hs=c(n,"PRE",{class:!0});var hm=u(Hs);hm.forEach(s),Bl=r(n),h=c(n,"P",{});var Dt=u(h);Wk=p(Dt,"그리고 아래와 같이 "),gt=c(Dt,"CODE",{});var k4=u(gt);jk=p(k4,"OrderableInt"),k4.forEach(s),Kk=p(Dt," 타입을 선언하여 "),np=c(Dt,"CODE",{});var f4=u(np);Qk=p(f4,"int"),f4.forEach(s),hk=p(Dt," 값을 사용할 수 있다."),Dt.forEach(s),Ll=r(n),Bs=c(n,"PRE",{class:!0});var gm=u(Bs);gm.forEach(s),xl=r(n),g=c(n,"P",{});var Ct=u(g);gk=p(Ct,`이 코드는 제대로 동작하지만, 컴파일러가 데이터 구조에 삽입된 값이 모두 동일한지 확인할 수 없다는 문제가 있다.
가령, 아래와 같이 `),sp=c(Ct,"CODE",{});var d4=u(sp);nf=p(d4,"OrderableString"),d4.forEach(s),sf=p(Ct," 타입을 선언하고 "),ap=c(Ct,"CODE",{});var E4=u(ap);af=p(E4,"Order()"),E4.forEach(s),tf=p(Ct," 메소드를 작성한다."),Ct.forEach(s),Al=r(n),Ls=c(n,"PRE",{class:!0});var n6=u(Ls);n6.forEach(s),$l=r(n),nn=c(n,"P",{});var Rt=u(nn);pf=p(Rt,"그리고 "),tp=c(Rt,"CODE",{});var v4=u(tp);ef=p(v4,"string"),v4.forEach(s),of=p(Rt,"을 동일한 "),pp=c(Rt,"CODE",{});var _4=u(pp);lf=p(_4,"Tree"),_4.forEach(s),cf=p(Rt,"에 집어넣는다."),Rt.forEach(s),Nl=r(n),xs=c(n,"PRE",{class:!0});var s6=u(xs);s6.forEach(s),Fl=r(n),D=c(n,"P",{});var rn=u(D);uf=p(rn,`이 코드는 컴파일은 문제 없이 잘 된다.
`),ep=c(rn,"CODE",{});var b4=u(ep);rf=p(b4,"Order()"),b4.forEach(s),kf=p(rn," 메소드는 "),op=c(rn,"CODE",{});var y4=u(op);ff=p(y4,"interface{}"),y4.forEach(s),df=p(rn," 파라미터를 사용하여 전달된 값을 나타낸다. 이미 "),lp=c(rn,"CODE",{});var m4=u(lp);Ef=p(m4,"OrderableInt"),m4.forEach(s),vf=p(rn,"가 포함된 트리에 "),cp=c(rn,"CODE",{});var w4=u(cp);_f=p(w4,"OrderableString"),w4.forEach(s),bf=p(rn,"을 삽입해도 컴파일러가 에러를 잡아주지 않는다. 따라서 프로그램을 실행하면 아래와 같은 panic이 발생한다."),rn.forEach(s),Zl=r(n),As=c(n,"PRE",{class:!0});var a6=u(As);a6.forEach(s),zl=r(n),Xa=c(n,"P",{});var P4=u(Xa);yf=p(P4,"다시 말해 컴파일 타임의 type safety 검사가 무효화되므로, Go의 가장 큰 장점 중 하나를 잃는 셈이다."),P4.forEach(s),Xl=r(n),Yl=c(n,"BR",{}),Vl=r(n),Ya=c(n,"P",{});var O4=u(Ya);mf=p(O4,"하지만 Go에 제네릭이 등장했다! 이제 이러한 고민 없이 여러 타입에 호환되면서도 컴파일 타임에 오류를 찾을 수 있는 코드를 작성할 수 있게 되었다. 실제 코드는 조금 있다가 짜볼 것이다."),O4.forEach(s),ql=r(n),O=c(n,"P",{});var j=u(O);wf=p(j,`제네릭이 없는 데이터 구조는 매우 불편하지만, 실질적인 한계는 함수 작성에 있다.
제네릭이 원래 Go의 일부가 아니였기 때문에, Go의 표준 라이브러리에는 몇 가지 특이한(그리고 좀 불편한) 점이 있다.
가령 `),up=c(j,"CODE",{});var T4=u(up);Pf=p(T4,"math.Max()"),T4.forEach(s),Of=p(j,", "),ip=c(j,"CODE",{});var D4=u(ip);Tf=p(D4,"math.Min()"),D4.forEach(s),Df=p(j,", "),rp=c(j,"CODE",{});var C4=u(rp);Cf=p(C4,"math.Mod"),C4.forEach(s),Rf=p(j," 등의 함수는 각 타입에 대해 여러 함수를 만들기보다는, "),kp=c(j,"CODE",{});var R4=u(kp);Gf=p(R4,"float64"),R4.forEach(s),Sf=p(j,` 타입 하나만 파라미터로 둔다.
이는 `),fp=c(j,"CODE",{});var G4=u(fp);If=p(G4,"float64"),G4.forEach(s),Mf=p(j,"가 웬만한 산술 타입들을 다 커버할 수 있을 만큼 표현 범위가 충분히 크기 때문이다."),j.forEach(s),Jl=r(n),Dn=c(n,"P",{});var Yr=u(Dn);Hf=p(Yr,`제네릭 없이는 인터페이스별로 지정된 변수의 새로운 인스턴스를 만들 수 없으며, concrete type이 같은 두 파라미터를 동일한 인터페이스 타입이 되도록 명시할 수 없다.
또한 제네릭이 없으면 컴파일 타임의 type safety를 포기해야 하거나, 성능을 포기하고 reflection을 사용해야만 특정 타입의 slice를 처리할 수 있다. (`),dp=c(Yr,"CODE",{});var S4=u(dp);Bf=p(S4,"sort.Slice()"),S4.forEach(s),Lf=p(Yr,"가 이렇게 설계되었다.)"),Yr.forEach(s),Ul=r(n),Wl=c(n,"BR",{}),jl=c(n,"BR",{}),Kl=r(n),Cn=c(n,"H2",{id:!0});var O5=u(Cn);Rn=c(O5,"A",{"aria-hidden":!0,tabindex:!0,href:!0});var I4=u(Rn);Ep=c(I4,"SPAN",{class:!0}),u(Ep).forEach(s),I4.forEach(s),xf=p(O5,"Generics in Go"),O5.forEach(s),Ql=r(n),hl=c(n,"HR",{}),gl=r(n),Va=c(n,"P",{});var M4=u(Va);Af=p(M4,"Go가 처음 발표된 이래로 제네릭이 추가되어야 한다는 많은 요구가 있었다. 하지만 Go는 빠른 컴파일, 코드의 가독성, 빠른 성능을 강조하며, 제네릭이 포함되면 이 세 장점을 잃을 수밖에 없었다고 한다. 하지만 10년 가량 이 문제를 연구한 끝에 Go 개발팀은 방법을 찾아냈다고 한다."),M4.forEach(s),nc=r(n),qa=c(n,"P",{});var H4=u(qa);$f=p(H4,"자료구조인 스택의 예제로, Go에서 제네릭이 어떻게 동작하는지 확인해 보자."),H4.forEach(s),sc=r(n),$s=c(n,"PRE",{class:!0});var t6=u($s);t6.forEach(s),ac=r(n),Ja=c(n,"P",{});var B4=u(Ja);Nf=p(B4,"이 코드엔 몇 가지 주목할 점이 있다."),B4.forEach(s),tc=r(n),Z=c(n,"OL",{});var ms=u(Z);z=c(ms,"LI",{});var yn=u(z);vp=c(yn,"CODE",{});var L4=u(vp);Ff=p(L4,"Stack"),L4.forEach(s),Zf=p(yn," 타입 선언시 "),_p=c(yn,"CODE",{});var x4=u(_p);zf=p(x4,"[T any]"),x4.forEach(s),Xf=p(yn,`라고 명시해주었다. 대괄호 안에 타입 파라미터가 배치되며, 마치 일반적인 파라미터처럼 타입명이 먼저 오고, 타입 제약조건이 나중에 온다.
타입 파라미터의 이름으로는 아무 것이나 사용할 수 있지만, 대문자를 사용하는 것이 일반적이다.
그리고 `),bp=c(yn,"CODE",{});var A4=u(bp);Yf=p(A4,"Stack"),A4.forEach(s),Vf=p(yn," 안에서 "),yp=c(yn,"CODE",{});var $4=u(yp);qf=p($4,"[]T"),$4.forEach(s),Jf=p(yn,"로 주어진 타입의 slice를 선언한 것을 확인할 수 있다."),yn.forEach(s),Uf=r(ms),B=c(ms,"LI",{});var kn=u(B);Wf=p(kn,"타입 파라미터로 올 수 있는 타입은 인터페이스를 사용하여 명시할 수 있다. 위 예제에서는 새로운 키워드인 "),mp=c(kn,"CODE",{});var N4=u(mp);jf=p(N4,"any"),N4.forEach(s),Kf=p(kn,"가 사용되었는데, 사실 "),wp=c(kn,"CODE",{});var F4=u(wp);Qf=p(F4,"any"),F4.forEach(s),hf=p(kn,"는 "),Pp=c(kn,"CODE",{});var Z4=u(Pp);gf=p(Z4,"interface{}"),Z4.forEach(s),n1=p(kn,`와 완전히 동일하다!
Go 1.18 이후의 버전을 사용한다면 `),Op=c(kn,"CODE",{});var z4=u(Op);s1=p(z4,"interface{}"),z4.forEach(s),a1=p(kn," 대신 any를 써도 되지만 그건 backward compatibility가 보장되지 않으니 그러지 말도록 하자."),kn.forEach(s),t1=r(ms),m=c(ms,"LI",{});var I=u(m);p1=p(I,"메소드 선언부를 보면, "),Tp=c(I,"CODE",{});var X4=u(Tp);e1=p(X4,"vals"),X4.forEach(s),o1=p(I,"를 선언할 때 "),Dp=c(I,"CODE",{});var Y4=u(Dp);l1=p(Y4,"T"),Y4.forEach(s),c1=p(I,"를 썼던 것처럼 파라미터 "),Cp=c(I,"CODE",{});var V4=u(Cp);u1=p(V4,"val"),V4.forEach(s),i1=p(I,"의 타입 자리에 타입 파라미터 "),Rp=c(I,"CODE",{});var q4=u(Rp);r1=p(q4,"T"),q4.forEach(s),k1=p(I,"가 들어간다. 또한 Receiver 부분에서 "),Gp=c(I,"CODE",{});var J4=u(Gp);f1=p(J4,"Stack"),J4.forEach(s),d1=p(I," 대신 "),Sp=c(I,"CODE",{});var U4=u(Sp);E1=p(U4,"Stack[T]"),U4.forEach(s),v1=p(I,"를 참조하였다."),I.forEach(s),_1=r(ms),w=c(ms,"LI",{});var M=u(w);b1=p(M,"제네릭을 사용하면 Zero value를 다루기가 살짝 까다로워진다. 이를테면 "),Ip=c(M,"CODE",{});var W4=u(Ip);y1=p(W4,"Pop()"),W4.forEach(s),m1=p(M," 메소드에서 Zero value로 "),Mp=c(M,"CODE",{});var j4=u(Mp);w1=p(j4,"nil"),j4.forEach(s),P1=p(M," 같은 걸 막 반환할 수가 없는게, 만약 타입이 "),Hp=c(M,"CODE",{});var K4=u(Hp);O1=p(K4,"int"),K4.forEach(s),T1=p(M,"라면 "),Bp=c(M,"CODE",{});var Q4=u(Bp);D1=p(Q4,"nil"),Q4.forEach(s),C1=p(M,`이 Zero value가 아니기 때문이다.
따라서 Zero value를 얻기 위해 변수를 `),Lp=c(M,"CODE",{});var h4=u(Lp);R1=p(h4,"var"),h4.forEach(s),G1=p(M,"로 선언하고 이를 반환한다. 정의상 "),xp=c(M,"CODE",{});var g4=u(xp);S1=p(g4,"var"),g4.forEach(s),I1=p(M,"는 다른 값이 할당되지 않으면 변수를 항상 zero value로 초기화하기 때문이다."),M.forEach(s),ms.forEach(s),pc=r(n),ec=c(n,"BR",{}),oc=r(n),Ua=c(n,"P",{});var n_=u(Ua);M1=p(n_,"제네릭 타입을 사용하는 것은 제네릭이 아닌 버전을 사용하는 것과 크게 다르지 않다."),n_.forEach(s),lc=r(n),Ns=c(n,"PRE",{class:!0});var p6=u(Ns);p6.forEach(s),cc=r(n),X=c(n,"P",{});var ws=u(X);H1=p(ws,"유일한 차이점은 "),Ap=c(ws,"CODE",{});var s_=u(Ap);B1=p(s_,"Stack"),s_.forEach(s),L1=p(ws," 타입의 변수를 선언할 때, 타입에 "),$p=c(ws,"CODE",{});var a_=u($p);x1=p(a_,"Stack[int]"),a_.forEach(s),A1=p(ws,"와 같이 타입 정보 "),Np=c(ws,"CODE",{});var t_=u(Np);$1=p(t_,"int"),t_.forEach(s),N1=p(ws,"를 대괄호로 묶어 함께 선언하였다는 점이다."),ws.forEach(s),uc=r(n),Gn=c(n,"P",{});var Vr=u(Gn);F1=p(Vr,"만약 이 예제에서 다음과 같이 문자열을 "),Fp=c(Vr,"CODE",{});var p_=u(Fp);Z1=p(p_,"intStack"),p_.forEach(s),z1=p(Vr,"에 집어넣는다고 하면, 컴파일러가 감지할 것이다."),Vr.forEach(s),ic=r(n),Fs=c(n,"PRE",{class:!0});var e6=u(Fs);e6.forEach(s),rc=r(n),Wa=c(n,"P",{});var e_=u(Wa);X1=p(e_,"이 라인을 넣고 컴파일 하면 다음과 같은 에러가 발생한다."),e_.forEach(s),kc=r(n),Zs=c(n,"PRE",{class:!0});var o6=u(Zs);o6.forEach(s),fc=r(n),dc=c(n,"BR",{}),Ec=r(n),Sn=c(n,"P",{});var qr=u(Sn);Y1=p(qr,"스택에 값이 존재하는지를 반환하는 메소드를 위 예제의 "),Zp=c(qr,"CODE",{});var o_=u(Zp);V1=p(o_,"Stack"),o_.forEach(s),q1=p(qr,"에 새로 추가해보자."),qr.forEach(s),vc=r(n),zs=c(n,"PRE",{class:!0});var l6=u(zs);l6.forEach(s),_c=r(n),ja=c(n,"P",{});var l_=u(ja);J1=p(l_,"하지만 이 메소드를 추가하면 컴파일되지 않는다."),l_.forEach(s),bc=r(n),Xs=c(n,"PRE",{class:!0});var c6=u(Xs);c6.forEach(s),yc=r(n),P=c(n,"P",{});var L=u(P);zp=c(L,"CODE",{});var c_=u(zp);U1=p(c_,"interface{}"),c_.forEach(s),W1=p(L,"가 어떠한 정보도 제공하지 않듯, "),Xp=c(L,"CODE",{});var u_=u(Xp);j1=p(u_,"any"),u_.forEach(s),K1=p(L,"도 마찬가지이다. "),Yp=c(L,"CODE",{});var i_=u(Yp);Q1=p(i_,"any"),i_.forEach(s),h1=p(L,"는 정보를 저장하고 찾을 때, 그 타입이 어떤 타입인가에 대한 정보밖에는 알려주지 못한다. 이를테면 "),Vp=c(L,"CODE",{});var r_=u(Vp);g1=p(r_,"=="),r_.forEach(s),n2=p(L,`를 사용할 수 있는 타입인지에 대한 정보는 알려줄 수 없다!
그래서 `),qp=c(L,"CODE",{});var k_=u(qp);s2=p(k_,"=="),k_.forEach(s),a2=p(L,"를 사용하기 위해서는 "),Jp=c(L,"CODE",{});var f_=u(Jp);t2=p(f_,"any"),f_.forEach(s),p2=p(L,"가 아닌 다른 타입을 사용해야 한다."),L.forEach(s),mc=r(n),y=c(n,"P",{});var H=u(y);e2=p(H,"대부분의 concrete type은 "),Up=c(H,"CODE",{});var d_=u(Up);o2=p(d_,"!="),d_.forEach(s),l2=p(H," 또는 "),Wp=c(H,"CODE",{});var E_=u(Wp);c2=p(E_,"=="),E_.forEach(s),u2=p(H,"로 비교가 가능하기 때문에, Go에는 비교가 가능한 타입들을 나타낼 수 있는 인터페이스인 "),jp=c(H,"CODE",{});var v_=u(jp);i2=p(v_,"comparable"),v_.forEach(s),r2=p(H,"이라는 키워드가 정의되어 있다. 다음과 같이 "),Kp=c(H,"CODE",{});var __=u(Kp);k2=p(__,"Stack"),__.forEach(s),f2=p(H,"의 정의에서 "),Qp=c(H,"CODE",{});var b_=u(Qp);d2=p(b_,"any"),b_.forEach(s),E2=p(H,"를 "),hp=c(H,"CODE",{});var y_=u(hp);v2=p(y_,"comparable"),y_.forEach(s),_2=p(H,"로 바꿔보자."),H.forEach(s),wc=r(n),Ys=c(n,"PRE",{class:!0});var u6=u(Ys);u6.forEach(s),Pc=r(n),In=c(n,"P",{});var Jr=u(In);b2=p(Jr,"이제 "),gp=c(Jr,"CODE",{});var m_=u(gp);y2=p(m_,"Contains()"),m_.forEach(s),m2=p(Jr," 메소드를 사용할 수 있다."),Jr.forEach(s),Oc=r(n),Vs=c(n,"PRE",{class:!0});var i6=u(Vs);i6.forEach(s),Tc=r(n),Ka=c(n,"P",{});var w_=u(Ka);w2=p(w_,"실행 결과는 다음과 같다."),w_.forEach(s),Dc=r(n),qs=c(n,"PRE",{class:!0});var r6=u(qs);r6.forEach(s),Cc=r(n),Qa=c(n,"P",{});var P_=u(Qa);P2=p(P_,`차후 제네릭을 이용해 바이너리 트리를 만드는 방법을 알아볼 것이다.
이에 앞서 제네릭 함수, 제네릭이 인터페이스와 함께 동작하는 방식, type terms와 같은 다른 추가 개념도 다뤄볼 것이다.`),P_.forEach(s),Rc=r(n),Gc=c(n,"BR",{}),Sc=c(n,"BR",{}),Ic=r(n),Mn=c(n,"H2",{id:!0});var T5=u(Mn);Hn=c(T5,"A",{"aria-hidden":!0,tabindex:!0,href:!0});var O_=u(Hn);ne=c(O_,"SPAN",{class:!0}),u(ne).forEach(s),O_.forEach(s),O2=p(T5,"Generic Functions"),T5.forEach(s),Mc=r(n),Hc=c(n,"HR",{}),Bc=r(n),ha=c(n,"P",{});var T_=u(ha);T2=p(T_,"제네릭으로 함수도 작성할 수 있다. 앞서 언급했듯 모든 타입에 호환되는 map, reduce, filter를 제네릭 없이 구현하기는 다소 어렵지만, 이제 제네릭이 있으니 뚝딱 만들 수 있다."),T_.forEach(s),Lc=r(n),Js=c(n,"PRE",{class:!0});var k6=u(Js);k6.forEach(s),xc=r(n),Y=c(n,"P",{});var Ps=u(Y);D2=p(Ps,"함수 이름과 파라미터 사이에 타입 파라미터를 배치하면 된다. "),se=c(Ps,"CODE",{});var D_=u(se);C2=p(D_,"Map()"),D_.forEach(s),R2=p(Ps,"과 "),ae=c(Ps,"CODE",{});var C_=u(ae);G2=p(C_,"Reduce()"),C_.forEach(s),S2=p(Ps,"는 두 개의 타입 파라미터가 필요하며, "),te=c(Ps,"CODE",{});var R_=u(te);I2=p(R_,"Filter()"),R_.forEach(s),M2=p(Ps,"는 한 개면 된다."),Ps.forEach(s),Ac=r(n),ga=c(n,"P",{});var G_=u(ga);H2=p(G_,"이렇게 정의한 세 함수는 다음과 같이 사용할 수 있다."),G_.forEach(s),$c=r(n),Us=c(n,"PRE",{class:!0});var f6=u(Us);f6.forEach(s),Nc=r(n),nt=c(n,"P",{});var S_=u(nt);B2=p(S_,"실행 결과는 다음과 같다."),S_.forEach(s),Fc=r(n),Ws=c(n,"PRE",{class:!0});var d6=u(Ws);d6.forEach(s),Zc=r(n),zc=c(n,"BR",{}),Xc=c(n,"BR",{}),Yc=r(n),Bn=c(n,"H2",{id:!0});var D5=u(Bn);Ln=c(D5,"A",{"aria-hidden":!0,tabindex:!0,href:!0});var I_=u(Ln);pe=c(I_,"SPAN",{class:!0}),u(pe).forEach(s),I_.forEach(s),L2=p(D5,"Generics and Interfaces"),D5.forEach(s),Vc=r(n),qc=c(n,"HR",{}),Jc=r(n),Q=c(n,"P",{});var xa=u(Q);ee=c(xa,"CODE",{});var M_=u(ee);x2=p(M_,"any"),M_.forEach(s),A2=p(xa,"나 "),oe=c(xa,"CODE",{});var H_=u(oe);$2=p(H_,"comparable"),H_.forEach(s),N2=p(xa,`뿐만 아니라 모든 인터페이스를 타입 제약조건으로 사용할 수 있다.
이를테면, `),le=c(xa,"CODE",{});var B_=u(le);F2=p(B_,"fmt.Stringer"),B_.forEach(s),Z2=p(xa,`를 구현하는 동일한 타입의 필드 두 개를 가진 타입을 만들고 싶다고 가정해보자.
제네릭을 사용하면 컴파일 타임에 이를 적용할 수 있다.`),xa.forEach(s),Uc=r(n),js=c(n,"PRE",{class:!0});var E6=u(js);E6.forEach(s),Wc=r(n),st=c(n,"P",{});var L_=u(st);z2=p(L_,"또한 타입 파라미터를 인터페이스에도 사용할 수 있다."),L_.forEach(s),jc=r(n),Ks=c(n,"PRE",{class:!0});var v6=u(Ks);v6.forEach(s),Kc=r(n),C=c(n,"P",{});var fn=u(C);X2=p(fn,"위의 "),ce=c(fn,"CODE",{});var x_=u(ce);Y2=p(x_,"Differ"),x_.forEach(s),V2=p(fn,"는 "),ue=c(fn,"CODE",{});var A_=u(ue);q2=p(A_,"fmt.Stringer"),A_.forEach(s),J2=p(fn,"를 임베드하며, 지정된 타입의 값과 비교하여 "),ie=c(fn,"CODE",{});var $_=u(ie);U2=p($_,"float64"),$_.forEach(s),W2=p(fn,"를 반환하는 "),re=c(fn,"CODE",{});var N_=u(re);j2=p(N_,"Diff()"),N_.forEach(s),K2=p(fn," 메소드를 포함하는 인터페이스이다."),fn.forEach(s),Qc=r(n),xn=c(n,"P",{});var Ur=u(xn);Q2=p(Ur,`이 두 타입을 이용하여 비교 함수를 작성해보자.
함수는 두 개의 `),ke=c(Ur,"CODE",{});var F_=u(ke);h2=p(F_,"Pair"),F_.forEach(s),g2=p(Ur," 인스턴스를 파라미터로 받고"),Ur.forEach(s),hc=r(n),Qs=c(n,"PRE",{class:!0});var _6=u(Qs);_6.forEach(s),gc=r(n),d=c(n,"P",{});var b=u(d);fe=c(b,"CODE",{});var Z_=u(fe);nd=p(Z_,"FindCloser"),Z_.forEach(s),sd=p(b,"는 "),de=c(b,"CODE",{});var z_=u(de);ad=p(z_,"Differ"),z_.forEach(s),td=p(b," 인터페이스를 충족시키는 필드가 있는 "),Ee=c(b,"CODE",{});var X_=u(Ee);pd=p(X_,"Pair"),X_.forEach(s),ed=p(b,` 인스턴스를 받는다.
`),ve=c(b,"CODE",{});var Y_=u(ve);od=p(Y_,"Pair"),Y_.forEach(s),ld=p(b,"는 두 필드의 타입이 같고 "),_e=c(b,"CODE",{});var V_=u(_e);cd=p(V_,"fmt.Stringer"),V_.forEach(s),ud=p(b," 인터페이스를 충족시켜야 한다. 만약 "),be=c(b,"CODE",{});var q_=u(be);id=p(q_,"Pair"),q_.forEach(s),rd=p(b," 인스턴스의 필드가 "),ye=c(b,"CODE",{});var J_=u(ye);kd=p(J_,"Differ"),J_.forEach(s),fd=p(b,"를 충족시키지 않으면, "),me=c(b,"CODE",{});var U_=u(me);dd=p(U_,"Pair"),U_.forEach(s),Ed=p(b," 인스턴스로 "),we=c(b,"CODE",{});var W_=u(we);vd=p(W_,"FindCloser"),W_.forEach(s),_d=p(b,"를 사용하는 것을 컴파일러가 막을 것이다."),b.forEach(s),nu=r(n),su=c(n,"BR",{}),au=r(n),An=c(n,"P",{});var Wr=u(An);bd=p(Wr,"이제 "),Pe=c(Wr,"CODE",{});var j_=u(Pe);yd=p(j_,"Differ"),j_.forEach(s),md=p(Wr," 인터페이스를 충족시키는 몇 개의 타입들을 정의해보자."),Wr.forEach(s),tu=r(n),hs=c(n,"PRE",{class:!0});var b6=u(hs);b6.forEach(s),pu=r(n),at=c(n,"P",{});var K_=u(at);wd=p(K_,"이들을 사용하는 코드는 이렇게 작성할 수 있다."),K_.forEach(s),eu=r(n),gs=c(n,"PRE",{class:!0});var y6=u(gs);y6.forEach(s),ou=r(n),tt=c(n,"P",{});var Q_=u(tt);Pd=p(Q_,"그리고 실행하면 다음과 같은 결과를 얻는다."),Q_.forEach(s),lu=r(n),na=c(n,"PRE",{class:!0});var m6=u(na);m6.forEach(s),cu=r(n),uu=c(n,"BR",{}),iu=c(n,"BR",{}),ru=r(n),$n=c(n,"H2",{id:!0});var C5=u($n);Nn=c(C5,"A",{"aria-hidden":!0,tabindex:!0,href:!0});var h_=u(Nn);Oe=c(h_,"SPAN",{class:!0}),u(Oe).forEach(s),h_.forEach(s),Od=p(C5,"Type Terms"),C5.forEach(s),ku=r(n),fu=c(n,"HR",{}),du=r(n),T=c(n,"P",{});var K=u(T);Td=p(K,`제네릭을 사용하기 위해서는 연산자를 나타내줘야 한다.
가령 `),Te=c(K,"CODE",{});var g_=u(Te);Dd=p(g_,"Min()"),g_.forEach(s),Cd=p(K," 함수의 제네릭 버전을 작성한다고 하면, "),De=c(K,"CODE",{});var nb=u(De);Rd=p(nb,"<"),nb.forEach(s),Gd=p(K,"나 "),Ce=c(K,"CODE",{});var sb=u(Ce);Sd=p(sb,">"),sb.forEach(s),Id=p(K,`와 같은 비교 연산자를 사용할 수 있어야 함을 나타내는 제약조건을 명시할 수 있어야 한다.
Go에서는 인터페이스 안에 한 개 이상의 `),Re=c(K,"CODE",{});var ab=u(Re);Md=p(ab,"type term"),ab.forEach(s),Hd=p(K,"이 명시된, "),Ge=c(K,"EM",{});var tb=u(Ge);Bd=p(tb,"type element"),tb.forEach(s),Ld=p(K,"를 사용한다."),K.forEach(s),Eu=r(n),sa=c(n,"PRE",{class:!0});var w6=u(sa);w6.forEach(s),vu=r(n),f=c(n,"P",{});var _=u(f);xd=p(_,"위 예제는 인터페이스를 임베딩하는 것처럼 concrete type의 목록을 "),Se=c(_,"CODE",{});var pb=u(Se);Ad=p(pb,"|"),pb.forEach(s),$d=p(_,`로 구분하여 나열하였다. 이 타입 목록은 타입 파라미터로 할당될 수 있으며, 목록의 타입이 지원하는 연산자를 사용할 수 있음을 나타낸다.
이때 목록의 타입에서 `),Ie=c(_,"STRONG",{});var eb=u(Ie);Nd=p(eb,"모두"),eb.forEach(s),Fd=p(_," 사용할 수 있는 연산자만 사용 가능하다. 따라서 위 예제에서는 "),Me=c(_,"CODE",{});var ob=u(Me);Zd=p(ob,"=="),ob.forEach(s),zd=p(_,", "),He=c(_,"CODE",{});var lb=u(He);Xd=p(lb,"!="),lb.forEach(s),Yd=p(_,", "),Be=c(_,"CODE",{});var cb=u(Be);Vd=p(cb,">"),cb.forEach(s),qd=p(_,", "),Le=c(_,"CODE",{});var ub=u(Le);Jd=p(ub,"<"),ub.forEach(s),Ud=p(_,", "),xe=c(_,"CODE",{});var ib=u(xe);Wd=p(ib,">="),ib.forEach(s),jd=p(_,", "),Ae=c(_,"CODE",{});var rb=u(Ae);Kd=p(rb,"<="),rb.forEach(s),Qd=p(_,", "),$e=c(_,"CODE",{});var kb=u($e);hd=p(kb,"+"),kb.forEach(s),gd=p(_,` 등이 사용 가능 연산자일 것이다.
주의해야 할 점은, type element에 concrete type의 type term이 있는 인터페이스는 오직 타입 파라미터로 사용된 영역에서만 사용할 수 있다. 얘네를 그 밖의 변수, 필드, 리턴 값, 파라미터로 사용하게 되면 컴파일 에러가 발생한다.`),_.forEach(s),_u=r(n),sn=c(n,"P",{});var Gt=u(sn);n3=p(Gt,"이제 알건 다 알았으니 "),Ne=c(Gt,"CODE",{});var fb=u(Ne);s3=p(fb,"BuiltInOrdered"),fb.forEach(s),a3=p(Gt," 를 사용하여 "),Fe=c(Gt,"CODE",{});var db=u(Fe);t3=p(db,"Min()"),db.forEach(s),p3=p(Gt,"을 제네릭으로 작성해보자."),Gt.forEach(s),bu=r(n),aa=c(n,"PRE",{class:!0});var P6=u(aa);P6.forEach(s),yu=r(n),an=c(n,"P",{});var St=u(an);e3=p(St,"기본적으로 type term은 정확히 매칭된다. 만약 "),Ze=c(St,"CODE",{});var Eb=u(Ze);o3=p(Eb,"BuiltInOrdered"),Eb.forEach(s),l3=p(St,"에 명시된 type term 중 하나를 사용자 정의 타입으로 재선언한 후 그 인스턴스로 "),ze=c(St,"CODE",{});var vb=u(ze);c3=p(vb,"Min()"),vb.forEach(s),u3=p(St,"을 호출하면, 에러가 발생한다."),St.forEach(s),mu=r(n),ta=c(n,"PRE",{class:!0});var O6=u(ta);O6.forEach(s),wu=r(n),pt=c(n,"P",{});var _b=u(pt);i3=p(_b,"위 예제를 실행하면 다음과 같은 에러가 발생한다."),_b.forEach(s),Pu=r(n),pa=c(n,"PRE",{class:!0});var T6=u(pa);T6.forEach(s),Ou=r(n),Fn=c(n,"P",{});var jr=u(Fn);r3=p(jr,"에러 메시지를 보면 이 문제의 해결법을 알려준다! 만약 type term의 타입이 사용자 정의 타입에 대해서도 동작하게 하고 싶다면, type term 앞에 "),Xe=c(jr,"CODE",{});var bb=u(Xe);k3=p(bb,"~"),bb.forEach(s),f3=p(jr,"를 붙이면 된다."),jr.forEach(s),Tu=r(n),ea=c(n,"PRE",{class:!0});var D6=u(ea);D6.forEach(s),Du=r(n),et=c(n,"P",{});var yb=u(et);d3=p(yb,"이제 다시 실행해보면 문제 없이 동작함을 확인할 수 있다."),yb.forEach(s),Cu=r(n),oa=c(n,"PRE",{class:!0});var C6=u(oa);C6.forEach(s),Ru=r(n),Gu=c(n,"BR",{}),Su=r(n),Zn=c(n,"P",{});var Kr=u(Zn);E3=p(Kr,`타입 파라미터로 사용되는 인터페이스가 type element와 메소드를 모두 가질 수 있다.
이를테면 어떤 타입이 int와 동등하면서 `),Ye=c(Kr,"CODE",{});var mb=u(Ye);v3=p(mb,"String()"),mb.forEach(s),_3=p(Kr," 문자열 메소드가 있어야 충족시킬 수 있는 인터페이스는 다음과 같이 선언할 수 있다."),Kr.forEach(s),Iu=r(n),la=c(n,"PRE",{class:!0});var R6=u(la);R6.forEach(s),Mu=r(n),R=c(n,"P",{});var dn=u(R);b3=p(dn,`하지만 Go의 컴파일러는 실질적으로 충족시키는 게 불가능한 인터페이스도 만들 수 있다는 점을 주의해야 한다.
이를테면 위 예제에서 `),Ve=c(dn,"CODE",{});var wb=u(Ve);y3=p(wb,"~int"),wb.forEach(s),m3=p(dn,"가 아니라 "),qe=c(dn,"CODE",{});var Pb=u(qe);w3=p(Pb,"int"),Pb.forEach(s),P3=p(dn,"라고 적고 작성한다면, 어떠한 타입도 "),Je=c(dn,"CODE",{});var Ob=u(Je);O3=p(Ob,"PrintableInt"),Ob.forEach(s),T3=p(dn," 인터페이스를 충족시킬 수 없기 때문이다. ("),Ue=c(dn,"CODE",{});var Tb=u(Ue);D3=p(Tb,"int"),Tb.forEach(s),C3=p(dn,"는 메소드가 없다)"),dn.forEach(s),Hu=r(n),ca=c(n,"PRE",{class:!0});var G6=u(ca);G6.forEach(s),Bu=r(n),zn=c(n,"P",{});var Qr=u(zn);R3=p(Qr,"컴파일러 관점에서 볼 때, 위 코드의 "),We=c(Qr,"CODE",{});var Db=u(We);G3=p(Db,"ImpossiblePrintableInt"),Db.forEach(s),S3=p(Qr,"는 아무런 문제가 없다. 즉, 불가능한 인터페이스를 선언할 때 컴파일러가 에러를 잡아주지는 못한다."),Qr.forEach(s),Lu=r(n),ot=c(n,"P",{});var Cb=u(ot);I3=p(Cb,"하지만, 이를 사용하려고 할 때 에러를 잡아줄 수는 있다. 불가능한 타입 파라미터를 사용하여 함수나 타입을 선언한다면 컴파일러가 이를 감지하여 컴파일 에러를 발생시킨다."),Cb.forEach(s),xu=r(n),ua=c(n,"PRE",{class:!0});var S6=u(ua);S6.forEach(s),Au=r(n),ia=c(n,"P",{});var R5=u(ia);je=c(R5,"CODE",{});var Rb=u(je);M3=p(Rb,"ImpossibleStruct"),Rb.forEach(s),H3=p(R5," 인스턴스를 만드려고 할 때, 다음과 같은 에러가 발생한다."),R5.forEach(s),$u=r(n),ra=c(n,"PRE",{class:!0});var I6=u(ra);I6.forEach(s),Nu=r(n),lt=c(n,"P",{});var Gb=u(lt);B3=p(Gb,`type term은 int나 string같은 원시 타입 뿐 아니라 slice, map, array, 또한 채널, 구조체, 함수까지도 가능하다.
따라서 타입 파라미터가 특정한 concrete type과 동등하며 한 개 이상의 메소드를 가질 때 type term을 사용하면 유용할 것이다.`),Gb.forEach(s),Fu=r(n),Zu=c(n,"BR",{}),zu=c(n,"BR",{}),Xu=r(n),Xn=c(n,"H2",{id:!0});var G5=u(Xn);Yn=c(G5,"A",{"aria-hidden":!0,tabindex:!0,href:!0});var Sb=u(Yn);Ke=c(Sb,"SPAN",{class:!0}),u(Ke).forEach(s),Sb.forEach(s),L3=p(G5,"Type Inference and Generics"),G5.forEach(s),Yu=r(n),Vu=c(n,"HR",{}),qu=r(n),G=c(n,"P",{});var En=u(G);x3=p(En,"Go는 "),Qe=c(En,"CODE",{});var Ib=u(Qe);A3=p(Ib,":="),Ib.forEach(s),$3=p(En," 연산자를 사용할 때 타입 추론을 지원하며, 마찬가지로 제네릭 함수에서도 호출을 단순화하기 위해 타입 추론을 사용한다. 위 예의 "),he=c(En,"CODE",{});var Mb=u(he);N3=p(Mb,"Map"),Mb.forEach(s),F3=p(En,", "),ge=c(En,"CODE",{});var Hb=u(ge);Z3=p(Hb,"Filter"),Hb.forEach(s),z3=p(En,", "),no=c(En,"CODE",{});var Bb=u(no);X3=p(Bb,"Reduce"),Bb.forEach(s),Y3=p(En,"를 사용할 때 이를 확인할 수 있다."),En.forEach(s),Ju=r(n),ct=c(n,"P",{});var Lb=u(ct);V3=p(Lb,"하지만 특정 상황에서는 타입 추론을 할 수 없으며(타입 파라미터가 리턴값으로만 사용된 경우 등), 그런 경우에는 타입이 반드시 명시되어야 한다. 다음의 예제는 타입 추론을 할 수 없는 경우의 코드이다."),Lb.forEach(s),Uu=r(n),ka=c(n,"PRE",{class:!0});var M6=u(ka);M6.forEach(s),Wu=r(n),V=c(n,"P",{});var Os=u(V);q3=p(Os,"주석 처리한 "),so=c(Os,"CODE",{});var xb=u(so);J3=p(xb,"b1"),xb.forEach(s),U3=p(Os,"은 타입 추론이 불가능하며, 변수의 타입을 명시한 "),ao=c(Os,"CODE",{});var Ab=u(ao);W3=p(Ab,"b3"),Ab.forEach(s),j3=p(Os,"도 오류가 발생한다. 즉 "),to=c(Os,"CODE",{});var $b=u(to);K3=p($b,"b2"),$b.forEach(s),Q3=p(Os,"처럼 타입 파라미터를 직접 명시해주어야 한다."),Os.forEach(s),ju=r(n),Ku=c(n,"BR",{}),Qu=c(n,"BR",{}),hu=r(n),Vn=c(n,"H2",{id:!0});var S5=u(Vn);qn=c(S5,"A",{"aria-hidden":!0,tabindex:!0,href:!0});var Nb=u(qn);po=c(Nb,"SPAN",{class:!0}),u(po).forEach(s),Nb.forEach(s),h3=p(S5,"Type Elements Limit Constants"),S5.forEach(s),gu=r(n),ni=c(n,"HR",{}),si=r(n),Jn=c(n,"P",{});var hr=u(Jn);g3=p(hr,"type element는 제네릭 타입의 변수에 할당될 수 있는 상수를 지정할 수도 있다. 연산자와 마찬가지로, 상수는 type element에 존재하는 "),eo=c(hr,"STRONG",{});var Fb=u(eo);nE=p(Fb,"모든"),Fb.forEach(s),sE=p(hr," type term에 대해 유효해야 한다."),hr.forEach(s),ai=r(n),tn=c(n,"P",{});var It=u(tn);aE=p(It,"위에서 "),oo=c(It,"CODE",{});var Zb=u(oo);tE=p(Zb,"BuiltInOrdered"),Zb.forEach(s),pE=p(It,"와 "),lo=c(It,"CODE",{});var zb=u(lo);eE=p(zb,"Integer"),zb.forEach(s),oE=p(It,"의 정의를 다시 보자."),It.forEach(s),ti=r(n),fa=c(n,"PRE",{class:!0});var H6=u(fa);H6.forEach(s),pi=r(n),da=c(n,"P",{});var I5=u(da);co=c(I5,"CODE",{});var Xb=u(co);lE=p(Xb,"BuiltInOrdered"),Xb.forEach(s),cE=p(I5,"에 명시된 모든 type term을 만족시키는 상수는 존재하지 않는다. 따라서 이 제네릭 타입에는 상수를 할당할 수 없다."),I5.forEach(s),ei=r(n),Un=c(n,"P",{});var gr=u(Un);uE=p(gr,"한편, "),uo=c(gr,"CODE",{});var Yb=u(uo);iE=p(Yb,"Integer"),Yb.forEach(s),rE=p(gr,"의 경우 할당 가능한 범위의 상수가 존재한다. (0~127일 것이다) 하지만 그 범위를 벗어난 수를 할당하려고 하면 에러가 발생한다."),gr.forEach(s),oi=r(n),Ea=c(n,"PRE",{class:!0});var B6=u(Ea);B6.forEach(s),li=r(n),va=c(n,"P",{});var M5=u(va);io=c(M5,"CODE",{});var Vb=u(io);kE=p(Vb,"PlusOneThousand()"),Vb.forEach(s),fE=p(M5,"를 컴파일하려 하면 아래와 같은 에러가 발생한다."),M5.forEach(s),ci=r(n),_a=c(n,"PRE",{class:!0});var L6=u(_a);L6.forEach(s),ui=r(n),Wn=c(n,"P",{});var nk=u(Wn);dE=p(nk,"원인은 명백하다. 1000이 8비트 정수 범위를 벗어났기 때문이다. 반면 "),ro=c(nk,"CODE",{});var qb=u(ro);EE=p(qb,"PlusOneHundred()"),qb.forEach(s),vE=p(nk,"은 문제 없이 컴파일된다."),nk.forEach(s),ii=r(n),ri=c(n,"BR",{}),ki=c(n,"BR",{}),fi=r(n),jn=c(n,"H2",{id:!0});var H5=u(jn);Kn=c(H5,"A",{"aria-hidden":!0,tabindex:!0,href:!0});var Jb=u(Kn);ko=c(Jb,"SPAN",{class:!0}),u(ko).forEach(s),Jb.forEach(s),_E=p(H5,"Generic Functions + Generic Data Structures"),H5.forEach(s),di=r(n),Ei=c(n,"HR",{}),vi=r(n),ut=c(n,"P",{});var Ub=u(ut);bE=p(Ub,"다시 바이너리 트리 예제로 돌아와보자. 이제 우리가 배운 것들을 이용하여 모든 concrete type에 적합한 단일 바이너리 트리 타입을 작성해볼 것이다. 이 때 두 값을 비교하고 순서를 알려주는 제네릭 함수가 바이너리 트리에 필요하다는 것을 알아야 한다."),Ub.forEach(s),_i=r(n),ba=c(n,"PRE",{class:!0});var x6=u(ba);x6.forEach(s),bi=r(n),pn=c(n,"P",{});var Mt=u(pn);yE=p(Mt,"그렇다면 트리의 구현이 약간 달라진다. 먼저, 트리를 "),fo=c(Mt,"CODE",{});var Wb=u(fo);mE=p(Wb,"Node"),Wb.forEach(s),wE=p(Mt,"와 "),Eo=c(Mt,"CODE",{});var jb=u(Eo);PE=p(jb,"Tree"),jb.forEach(s),OE=p(Mt," 두 개의 타입으로 나눠야 한다."),Mt.forEach(s),yi=r(n),ya=c(n,"PRE",{class:!0});var A6=u(ya);A6.forEach(s),mi=r(n),ma=c(n,"P",{});var B5=u(ma);vo=c(B5,"CODE",{});var Kb=u(vo);TE=p(Kb,"Tree"),Kb.forEach(s),DE=p(B5," 인스턴스를 생성하는 생성자 함수도 작성해준다."),B5.forEach(s),wi=r(n),wa=c(n,"PRE",{class:!0});var $6=u(wa);$6.forEach(s),Pi=r(n),Oi=c(n,"BR",{}),Ti=r(n),_n=c(n,"P",{});var tl=u(_n);_o=c(tl,"CODE",{});var Qb=u(_o);CE=p(Qb,"Tree"),Qb.forEach(s),RE=p(tl,"의 메소드는 간단하다. 실제 작업을 하는 "),bo=c(tl,"CODE",{});var hb=u(bo);GE=p(hb,"Node"),hb.forEach(s),SE=p(tl,"의 메소드를 호출해주기만 하면 된다."),tl.forEach(s),Di=r(n),Pa=c(n,"PRE",{class:!0});var N6=u(Pa);N6.forEach(s),Ci=r(n),en=c(n,"P",{});var Ht=u(en);IE=p(Ht,"이제 "),yo=c(Ht,"CODE",{});var gb=u(yo);ME=p(gb,"OrderedFunc"),gb.forEach(s),HE=p(Ht,"에 대응하는 함수가 필요하다. "),mo=c(Ht,"CODE",{});var ny=u(mo);BE=p(ny,"BuiltInOrdered"),ny.forEach(s),LE=p(Ht,"를 활용하여 모든 원시 타입이 지원되는 함수를 작성할 수 있다."),Ht.forEach(s),Ri=r(n),Oa=c(n,"PRE",{class:!0});var F6=u(Oa);F6.forEach(s),Gi=r(n),on=c(n,"P",{});var Bt=u(on);xE=p(Bt,"선언한 "),wo=c(Bt,"CODE",{});var sy=u(wo);AE=p(sy,"BuiltInOrderable"),sy.forEach(s),$E=p(Bt,"를 "),Po=c(Bt,"CODE",{});var ay=u(Po);NE=p(ay,"Tree"),ay.forEach(s),FE=p(Bt,"와 함께 사용한 코드는 다음과 같다."),Bt.forEach(s),Si=r(n),Ta=c(n,"PRE",{class:!0});var Z6=u(Ta);Z6.forEach(s),Ii=r(n),Mi=c(n,"BR",{}),Hi=r(n),Qn=c(n,"P",{});var sk=u(Qn);ZE=p(sk,"구조체를 정의하여 "),Oo=c(sk,"CODE",{});var ty=u(Oo);zE=p(ty,"Tree"),ty.forEach(s),XE=p(sk,`에 집어넣을 수도 있다.
그러면 정렬 함수를 어떻게 작성하는지가 관건일 듯 하다. 우선 다음과 같이 함수를 작성하는 방법이 있다.`),sk.forEach(s),Bi=r(n),Da=c(n,"PRE",{class:!0});var z6=u(Da);z6.forEach(s),Li=r(n),q=c(n,"P",{});var Ts=u(q);YE=p(Ts,"함수 "),To=c(Ts,"CODE",{});var py=u(To);VE=p(py,"OrderPeople()"),py.forEach(s),qE=p(Ts,"를 생성 함수에 넘겨주면 "),Do=c(Ts,"CODE",{});var ey=u(Do);JE=p(ey,"Person"),ey.forEach(s),UE=p(Ts,"의 "),Co=c(Ts,"CODE",{});var oy=u(Co);WE=p(oy,"Tree"),oy.forEach(s),jE=p(Ts,"를 만들 수 있다."),Ts.forEach(s),xi=r(n),Ca=c(n,"PRE",{class:!0});var X6=u(Ca);X6.forEach(s),Ai=r(n),it=c(n,"P",{});var ly=u(it);KE=p(ly,"함수를 넘기는 대신 메소드를 넘길 수도 있다. 사실상 메소드도 함수의 일종이라 크게 놀라운 사실은 아니다."),ly.forEach(s),$i=r(n),Ra=c(n,"PRE",{class:!0});var Y6=u(Ra);Y6.forEach(s),Ni=r(n),ln=c(n,"P",{});var Lt=u(ln);QE=p(Lt,"마찬가지로 "),Ro=c(Lt,"CODE",{});var cy=u(Ro);hE=p(cy,"Order()"),cy.forEach(s),gE=p(Lt,"의 method expression을 "),Go=c(Lt,"CODE",{});var uy=u(Go);nv=p(uy,"Tree"),uy.forEach(s),sv=p(Lt,"의 생성 함수에 넘겨주면 된다."),Lt.forEach(s),Fi=r(n),Ga=c(n,"PRE",{class:!0});var V6=u(Ga);V6.forEach(s),Zi=r(n),zi=c(n,"BR",{}),Xi=c(n,"BR",{}),Yi=r(n),hn=c(n,"H2",{id:!0});var L5=u(hn);gn=c(L5,"A",{"aria-hidden":!0,tabindex:!0,href:!0});var iy=u(gn);So=c(iy,"SPAN",{class:!0}),u(So).forEach(s),iy.forEach(s),av=p(L5,"Things That Are Left Out"),L5.forEach(s),Vi=r(n),qi=c(n,"HR",{}),Ji=r(n),rt=c(n,"P",{});var ry=u(rt);tv=p(ry,`Go는 작은 언어를 지향하며, 일반적으로 다른 언어에 존재하는 제네릭 관련 기능이 Go에는 포함되지 않은 경우가 많다.
이 단락에서는 Go 제네릭의 초기 구현에 없었던 기능들을 소개하고자 한다.`),ry.forEach(s),Ui=r(n),cn=c(n,"P",{});var xt=u(cn);pv=p(xt,`사용자 정의 타입과 기본 타입 둘 다 사용할 수 있는 단일 트리를 만들 수 있었지만, Python, Ruby, C++ 등은 이 문제를 다르게 해결한다.
바로 이를 통해 사용자 정의 타입이 연산자에 대한 동작을 지정할 수 있는 연산자 오버로딩이다.
하지만 Go에는 이 기능이 없기 때문에 사용자 정의 컨테이너 타입에 `),Io=c(xt,"CODE",{});var ky=u(Io);ev=p(ky,"range"),ky.forEach(s),ov=p(xt,"를 통해 이터레이트하거나 "),Mo=c(xt,"CODE",{});var fy=u(Mo);lv=p(fy,"[]"),fy.forEach(s),cv=p(xt,"를 통해 인덱싱할 수 없다."),xt.forEach(s),Wi=r(n),ns=c(n,"P",{});var ak=u(ns);uv=p(ak,`Go가 연산자 오버로딩을 지원하지 않는 이유가 있다.
우선 Go에는 연산자가 매우 많다. Go는 연산자 오버로딩 말고도 함수나 메소드의 오버로딩도 지원하지 않으며, 다른 타입에 대해 다른 연산자의 기능을 지정하는 방법이 필요하다.
무엇보다 연산자 오버로딩은 개발자가 코드를 읽고 기호의 정확한 의미를 떠올리기 힘들게 한다. 이를테면 C++의 `),Ho=c(ak,"CODE",{});var dy=u(Ho);iv=p(dy,"<<"),dy.forEach(s),rv=p(ak," 기호는 “bitwise shift left”와 “write value”의 두 가지 의미가 있다. Go는 이러한 가독성 문제를 회피하려 하는 것이다."),ak.forEach(s),ji=r(n),J=c(n,"P",{});var Ds=u(J);kv=p(Ds,"Go의 초기 제네릭 구현에서 제외된 또 다른 유용한 기능은 메소드에 대한 추가 타입 파라미터이다. 즉, 메소드는 타입 파라미터를 가질 수 없다. "),Bo=c(Ds,"CODE",{});var Ey=u(Bo);fv=p(Ey,"Map"),Ey.forEach(s),dv=p(Ds,", "),Lo=c(Ds,"CODE",{});var vy=u(Lo);Ev=p(vy,"Filter"),vy.forEach(s),vv=p(Ds,", "),xo=c(Ds,"CODE",{});var _y=u(xo);_v=p(_y,"Reduce"),_y.forEach(s),bv=p(Ds," 함수를 되돌아보면, 다음과 같은 메소드로 구현된다면 유용할 것이라고 생각할 수 있다."),Ds.forEach(s),Ki=r(n),Sa=c(n,"PRE",{class:!0});var q6=u(Sa);q6.forEach(s),Qi=r(n),kt=c(n,"P",{});var by=u(kt);yv=p(by,"그렇다면 위 메소드는 다음과 같이 사용할 수 있을 것이다."),by.forEach(s),hi=r(n),Ia=c(n,"PRE",{class:!0});var J6=u(Ia);J6.forEach(s),gi=r(n),ft=c(n,"P",{});var yy=u(ft);mv=p(yy,`함수형 프로그래밍 애호가들에겐 아쉽겠지만(ㅠㅠ) Go에서는 이러한 코드가 작동하지 않는다.
메소드의 호출 체인을 만드는 대신, 함수 호출을 중첩하거나 함수를 한 번에 하나씩 호출하고 중간 값을 변수에 할당하는 식으로 가독성이 더 좋은 방법을 사용해야 한다.`),yy.forEach(s),nr=r(n),dt=c(n,"P",{});var my=u(dt);wv=p(my,`또한 가변적인 타입 파라미터도 존재하지 않는다. 가령, 우리가 Reflection에서 다뤘던 주제 중에는 기존 함수의 시간을 재는 wrapper 함수를 작성하는 문제도 있었다. 이러한 경우는 제네릭으로 처리할 수 없기 때문에, 여전히 Reflection으로 처리해주어야 한다.
타입 파라미터를 사용할 때마다 각각의 필요한 타입의 이름을 명시적으로 제공해야 하므로, 타입이 다른 파라미터의 개수로 함수를 나타낼 수 없다.`),my.forEach(s),sr=r(n),Et=c(n,"P",{});var wy=u(Et);Pv=p(wy,"이외에도 Go의 제네릭에는 다음과 같은 기능들이 제외되었다."),wy.forEach(s),ar=r(n),un=c(n,"UL",{});var At=u(un);Ao=c(At,"LI",{});var Py=u(Ao);Ma=c(Py,"P",{});var tk=u(Ma);Ov=p(tk,"Specialization"),Tv=c(tk,"BR",{}),Dv=p(tk,`
함수 또는 메소드는 제네릭 버전 외에 하나 이상의 타입별로 오버로드되지 않는다. 다시 말하지만, Go에는 오버로드가 없다.`),tk.forEach(s),Py.forEach(s),Cv=r(At),$o=c(At,"LI",{});var Oy=u($o);No=c(Oy,"P",{});var Ty=u(No);Rv=p(Ty,`Currying
다른 제네릭 함수나 타입에 따라, 타입 파라미터 중 일부를 지정하여 함수나 타입을 부분적으로 인스턴스화할 수 없다.`),Ty.forEach(s),Oy.forEach(s),Gv=r(At),Fo=c(At,"LI",{});var Dy=u(Fo);Zo=c(Dy,"P",{});var Cy=u(Zo);Sv=p(Cy,`Metaprogramming
컴파일시 실행되는 코드를 지정하여 런타임에 실행되는 코드를 생성할 수 없다.`),Cy.forEach(s),Dy.forEach(s),At.forEach(s),tr=r(n),pr=c(n,"BR",{}),er=c(n,"BR",{}),or=r(n),ss=c(n,"H2",{id:!0});var x5=u(ss);as=c(x5,"A",{"aria-hidden":!0,tabindex:!0,href:!0});var Ry=u(as);zo=c(Ry,"SPAN",{class:!0}),u(zo).forEach(s),Ry.forEach(s),Iv=p(x5,"Idiomatic Go and Generics"),x5.forEach(s),lr=r(n),cr=c(n,"HR",{}),ur=r(n),U=c(n,"P",{});var Cs=u(U);Mv=p(Cs,"Go에 제네릭이 추가됨으로써, 기존의 이상적인 코드가 분명히 바뀌었다. 이제 "),Xo=c(Cs,"CODE",{});var Gy=u(Xo);Hv=p(Gy,"float64"),Gy.forEach(s),Bv=p(Cs,"로 불특정 산술 타입을 나타내지 않을 것이다. 또한 함수나 자료구조에서 명시되지 않은 타입을 나타낼 때 "),Yo=c(Cs,"CODE",{});var Sy=u(Yo);Lv=p(Sy,"interface{}"),Sy.forEach(s),xv=p(Cs," 대신 "),Vo=c(Cs,"CODE",{});var Iy=u(Vo);Av=p(Iy,"any"),Iy.forEach(s),$v=p(Cs,`를 사용하여야 한다.
이제 함수 하나로 다양한 타입의 slice를 처리할 수 있다.`),Cs.forEach(s),ir=r(n),vt=c(n,"P",{});var My=u(vt);Nv=p(My,"하지만 지금 당장 모든 코드를 타입 파라미터를 사용하게끔 변경할 필요가 없다. 새로운 디자인 패턴이 만들어지더라도 오래된 코드는 동작한다."),My.forEach(s),rr=r(n),_t=c(n,"P",{});var Hy=u(_t);Fv=p(Hy,"제네릭의 성능을 판단하기에는 하직 조금 이르다. Go 1.18의 컴파일러는 이전 버전에 비해 느려졌지만, 이후 릴리즈에서 해결될 문제로 예상된다. 이미 현재 런타임 문제에 관한 연구가 진행되고 있다. 요컨대 향후 버전에서 제네릭이 다듬어질수록 런타임 성능도 개선될 것이다."),Hy.forEach(s),kr=r(n),W=c(n,"P",{});var Rs=u(W);Zv=p(Rs,"목표는 항상 "),Z5(ts.$$.fragment,Rs),zv=r(Rs),Z5(ps.$$.fragment,Rs),Xv=r(Rs),Z5(es.$$.fragment,Rs),Yv=p(Rs," 코드를 작성하는 것이다."),Rs.forEach(s),fr=r(n),dr=c(n,"BR",{}),Er=c(n,"BR",{}),vr=r(n),os=c(n,"H2",{id:!0});var A5=u(os);ls=c(A5,"A",{"aria-hidden":!0,tabindex:!0,href:!0});var By=u(ls);qo=c(By,"SPAN",{class:!0}),u(qo).forEach(s),By.forEach(s),Vv=p(A5,"Further Features Unlocked"),A5.forEach(s),_r=r(n),br=c(n,"HR",{}),yr=r(n),S=c(n,"P",{});var vn=u(S);qv=p(vn,"Go 1.18에 제네릭이 처음 출시되었을 때, 여러 논란이 있었다. 새로운 식별자인 "),Jo=c(vn,"CODE",{});var Ly=u(Jo);Jv=p(Ly,"any"),Ly.forEach(s),Uv=p(vn,"와 "),Uo=c(vn,"CODE",{});var xy=u(Uo);Wv=p(xy,"comparable"),xy.forEach(s),jv=p(vn,`이 도입되었지만, 표준 라이브러리의 API는 제네릭을 사용하지 않는다.
기존에 `),Wo=c(vn,"CODE",{});var Ay=u(Wo);Kv=p(Ay,"interface{}"),Ay.forEach(s),Qv=p(vn,"를 사용하던 API가 "),jo=c(vn,"CODE",{});var $y=u(jo);hv=p($y,"any"),$y.forEach(s),gv=p(vn,"로 바뀐 것 외엔 실질적인 변화는 없다"),vn.forEach(s),mr=r(n),cs=c(n,"P",{});var pk=u(cs);n5=p(pk,"이후 버전의 표준 라이브러리에서는 일반적인 경우의 타입들을 분류하는 새로운 인터페이스("),Ko=c(pk,"CODE",{});var Ny=u(Ko);s5=p(Ny,"Orderable"),Ny.forEach(s),a5=p(pk,`같은), 새로운 타입(set, tree, 정렬된 map 등), 새로운 함수가 추가될 것으로 보인다.
이러한 것들을 직접 작성하여 쓰는 것도 좋지만, 표준 라이브러리가 업데이트되면 교체하는 것을 고려해보자.`),pk.forEach(s),wr=r(n),us=c(n,"P",{});var ek=u(us);t5=p(ek,"제네릭은 차후 추가될 기능들의 기본이 될 수 있다. 한가지 가능성은 "),Qo=c(ek,"EM",{});var Fy=u(Qo);p5=p(Fy,"sum type"),Fy.forEach(s),e5=p(ek,`이다.
type element가 타입 파라미터를 대체할 수 있는 타입을 명시하는 데 사용되듯, 인터페이스의 파라미터에도 사용될 수 있을 것이다.`),ek.forEach(s),Pr=r(n),is=c(n,"P",{});var ok=u(is);o5=p(ok,"오늘날 Go는 특정 필드가 단일 값이거나, 아니면 값의 list인지 확실히 처리할 수 없는 종류의 JSON을 처리하는 데 문제가 있다. 만약 "),ho=c(ok,"CODE",{});var Zy=u(ho);l5=p(Zy,"sum type"),Zy.forEach(s),c5=p(ok,`이 추가된다면, 필드가 문자열인지, 또는 문자열의 slice인지 명시하는 인터페이스를 생성할 수 있을 것이다.
그러면 type switch를 사용하여 모든 유효한 타입을 열거함으로써 type safety를 향상시킬 수 있을 것이다.
이렇게 허용할 한정된 종류의 타입만 명시하는 기능은 Rust나 Swift등 현대 언어에서 enum을 통해 sum types을 사용한다.
현재 Go의 enum 기능은 다소 약하기 때문에, 괜찮은 방법일지라도 아이디어가 평가되고 연구되기까지는 다소 시간이 걸릴 것이다.`),ok.forEach(s),Or=r(n),Tr=c(n,"BR",{}),Dr=c(n,"BR",{}),Cr=r(n),rs=c(n,"H2",{id:!0});var $5=u(rs);ks=c($5,"A",{"aria-hidden":!0,tabindex:!0,href:!0});var zy=u(ks);go=c(zy,"SPAN",{class:!0}),u(go).forEach(s),zy.forEach(s),u5=p($5,"후기"),$5.forEach(s),Rr=r(n),Gr=c(n,"HR",{}),Sr=r(n),bt=c(n,"P",{});var Xy=u(bt);i5=p(Xy,"이제야 기본적인 Go의 내용이 끝났다."),Xy.forEach(s),Ir=r(n),yt=c(n,"P",{});var Yy=u(yt);r5=p(Yy,"학업때문에 Go를 잠깐 놓았던 기간을 제외하면, 이 책 내용 끝내는 데만 대략 4개월이 걸린 셈이다. 아무리 원서 읽고 번역하고 블로그에 기록까지 하면서 하는 거라 해도, 다소 오래 걸린 감이 있다."),Yy.forEach(s),Mr=r(n),fs=c(n,"P",{});var lk=u(fs);k5=p(lk,"어떤 프로그래밍 언어를 가장 잘 하는 방법은 그 언어로 아무 토이프로젝트나 해보며 이것저것 부딛혀보는 것이라고들 한다. 전적으로 동의하는 바이고 자바스크립트도 그렇게 배웠지만, Go는 중간에 한 프로젝트라고는 "),Ha=c(lk,"A",{href:!0,rel:!0});var Vy=u(Ha);f5=p(Vy,"WebRTC 시그널링 서버"),Vy.forEach(s),d5=p(lk," 하나 만든것 말곤 없다. 이것도 사실상 인터페이스를 사용하지 않은 거라 도움이 엄청 많이 됐을것같진 않다. 아무래도 이것저것 더 많이 해봐야 할것 같다."),lk.forEach(s),Hr=r(n),mt=c(n,"P",{});var qy=u(mt);E5=p(qy,`Go를 배운 이유가 자바가 싫어서도 있고, MSA에 가장 적합한 언어라고 여겨진다는 점도 있었다.
이렇듯 배움의 시작점이 된 건 다소 별거 아닌 이유였지만, 배우면 배울수록 매력적인 언어라고 느꼈다! 물론 배워야 할 게 아직도 산더미지만 ㅠ`),qy.forEach(s),Br=r(n),wt=c(n,"P",{});var Jy=u(wt);v5=p(Jy,"Go의 동시성 패턴이나 분산처리 패턴같은 것도 좀 배워두고 싶은데, 이런 것들은 뭔가 필요성이 느껴질 때 배워야하는 내용들인 것 같다. 그래서 지금은 그러한 필요성을 느끼기 위해, 뭔가 프로젝트같은 것들을 해보려 한다. 학기가 시작해서 프로젝트에 쏟을 시간이 얼마나 될지는 모르겠지만.."),Jy.forEach(s),Lr=r(n),xr=c(n,"BR",{}),Ar=c(n,"BR",{}),$r=r(n),ds=c(n,"H2",{id:!0});var N5=u(ds);Es=c(N5,"A",{"aria-hidden":!0,tabindex:!0,href:!0});var Uy=u(Es);nl=c(Uy,"SPAN",{class:!0}),u(nl).forEach(s),Uy.forEach(s),_5=p(N5,"References"),N5.forEach(s),Nr=r(n),Fr=c(n,"HR",{}),Zr=r(n),Pt=c(n,"CENTER",{});var Wy=u(Pt);bn=c(Wy,"P",{});var $t=u(bn);Ba=c($t,"A",{href:!0,rel:!0});var jy=u(Ba);Ot=c(jy,"IMG",{src:!0,alt:!0}),jy.forEach(s),b5=r($t),y5=c($t,"BR",{}),m5=r($t),La=c($t,"A",{href:!0,rel:!0});var Ky=u(La);w5=p(Ky,"Jon Bodner, 『Learning Go』, O’Reilly Media, Inc."),Ky.forEach(s),$t.forEach(s),Wy.forEach(s),this.h()},h(){k(Nt,"class","icon icon-link"),k(wn,"aria-hidden","true"),k(wn,"tabindex","-1"),k(wn,"href","#introduction"),k(mn,"id","introduction"),k(Ft,"class","icon icon-link"),k(On,"aria-hidden","true"),k(On,"tabindex","-1"),k(On,"href","#advantages-of-generics"),k(Pn,"id","advantages-of-generics"),k(Ss,"class","language-go"),k(Is,"class","language-go"),k(Ms,"class","language-go"),k(Hs,"class","language-go"),k(Bs,"class","language-go"),k(Ls,"class","language-go"),k(xs,"class","language-go"),k(As,"class","language-text"),k(Ep,"class","icon icon-link"),k(Rn,"aria-hidden","true"),k(Rn,"tabindex","-1"),k(Rn,"href","#generics-in-go"),k(Cn,"id","generics-in-go"),k($s,"class","language-go"),k(Ns,"class","language-go"),k(Fs,"class","language-go"),k(Zs,"class","language-text"),k(zs,"class","language-go"),k(Xs,"class","language-text"),k(Ys,"class","language-go"),k(Vs,"class","language-go"),k(qs,"class","language-text"),k(ne,"class","icon icon-link"),k(Hn,"aria-hidden","true"),k(Hn,"tabindex","-1"),k(Hn,"href","#generic-functions"),k(Mn,"id","generic-functions"),k(Js,"class","language-go"),k(Us,"class","language-go"),k(Ws,"class","language-text"),k(pe,"class","icon icon-link"),k(Ln,"aria-hidden","true"),k(Ln,"tabindex","-1"),k(Ln,"href","#generics-and-interfaces"),k(Bn,"id","generics-and-interfaces"),k(js,"class","language-go"),k(Ks,"class","language-go"),k(Qs,"class","language-go"),k(hs,"class","language-go"),k(gs,"class","language-go"),k(na,"class","language-text"),k(Oe,"class","icon icon-link"),k(Nn,"aria-hidden","true"),k(Nn,"tabindex","-1"),k(Nn,"href","#type-terms"),k($n,"id","type-terms"),k(sa,"class","language-go"),k(aa,"class","language-go"),k(ta,"class","language-go"),k(pa,"class","language-text"),k(ea,"class","language-go"),k(oa,"class","language-go"),k(la,"class","language-go"),k(ca,"class","language-go"),k(ua,"class","language-go"),k(ra,"class","language-text"),k(Ke,"class","icon icon-link"),k(Yn,"aria-hidden","true"),k(Yn,"tabindex","-1"),k(Yn,"href","#type-inference-and-generics"),k(Xn,"id","type-inference-and-generics"),k(ka,"class","language-go"),k(po,"class","icon icon-link"),k(qn,"aria-hidden","true"),k(qn,"tabindex","-1"),k(qn,"href","#type-elements-limit-constants"),k(Vn,"id","type-elements-limit-constants"),k(fa,"class","language-go"),k(Ea,"class","language-go"),k(_a,"class","language-text"),k(ko,"class","icon icon-link"),k(Kn,"aria-hidden","true"),k(Kn,"tabindex","-1"),k(Kn,"href","#generic-functions--generic-data-structures"),k(jn,"id","generic-functions--generic-data-structures"),k(ba,"class","language-go"),k(ya,"class","language-go"),k(wa,"class","language-go"),k(Pa,"class","language-go"),k(Oa,"class","language-go"),k(Ta,"class","language-go"),k(Da,"class","language-go"),k(Ca,"class","language-go"),k(Ra,"class","language-go"),k(Ga,"class","language-go"),k(So,"class","icon icon-link"),k(gn,"aria-hidden","true"),k(gn,"tabindex","-1"),k(gn,"href","#things-that-are-left-out"),k(hn,"id","things-that-are-left-out"),k(Sa,"class","language-go"),k(Ia,"class","language-go"),k(zo,"class","icon icon-link"),k(as,"aria-hidden","true"),k(as,"tabindex","-1"),k(as,"href","#idiomatic-go-and-generics"),k(ss,"id","idiomatic-go-and-generics"),k(qo,"class","icon icon-link"),k(ls,"aria-hidden","true"),k(ls,"tabindex","-1"),k(ls,"href","#further-features-unlocked"),k(os,"id","further-features-unlocked"),k(go,"class","icon icon-link"),k(ks,"aria-hidden","true"),k(ks,"tabindex","-1"),k(ks,"href","#후기"),k(rs,"id","후기"),k(Ha,"href","http://localhost:5173/posts/post/Networking/WebRTC/many%20to%20many%20signaling%20server"),k(Ha,"rel","nofollow"),k(nl,"class","icon icon-link"),k(Es,"aria-hidden","true"),k(Es,"tabindex","-1"),k(Es,"href","#references"),k(ds,"id","references"),K6(Ot.src,J5="https://learning.oreilly.com/covers/urn:orm:book:9781492077206/400w/")||k(Ot,"src",J5),k(Ot,"alt","Learning Go Book Cover"),k(Ba,"href","https://learning.oreilly.com/library/view/learning-go/9781492077206/"),k(Ba,"rel","nofollow"),k(La,"href","https://learning.oreilly.com/library/view/learning-go/9781492077206/"),k(La,"rel","nofollow")},m(n,e){o(n,v,e),o(n,E,e),o(n,x,e),a(x,ck),o(n,pl,e),o(n,el,e),o(n,ol,e),o(n,ll,e),o(n,mn,e),a(mn,wn),a(wn,Nt),a(mn,uk),o(n,cl,e),o(n,ul,e),o(n,il,e),o(n,Aa,e),a(Aa,ik),o(n,rl,e),o(n,$a,e),a($a,rk),o(n,kl,e),o(n,fl,e),o(n,dl,e),o(n,Na,e),a(Na,kk),o(n,El,e),o(n,Fa,e),a(Fa,fk),o(n,vl,e),o(n,_l,e),o(n,bl,e),o(n,yl,e),o(n,Pn,e),a(Pn,On),a(On,Ft),a(Pn,dk),o(n,ml,e),o(n,A,e),a(A,Ek),a(A,Zt),a(Zt,vk),a(A,_k),a(A,zt),a(zt,bk),a(A,yk),a(A,Xt),a(Xt,mk),a(A,wk),o(n,wl,e),o(n,$,e),a($,Pk),a($,Yt),a(Yt,Ok),a($,Tk),a($,Vt),a(Vt,Dk),a($,Ck),a($,qt),a(qt,Rk),a($,Gk),o(n,Pl,e),o(n,Ss,e),Ss.innerHTML=Qy,o(n,Ol,e),o(n,N,e),a(N,Sk),a(N,Jt),a(Jt,Ik),a(N,Mk),a(N,Ut),a(Ut,Hk),a(N,Bk),a(N,Wt),a(Wt,Lk),a(N,xk),o(n,Tl,e),o(n,Is,e),Is.innerHTML=hy,o(n,Dl,e),o(n,Cl,e),o(n,Rl,e),o(n,Za,e),a(Za,Ak),o(n,Gl,e),o(n,F,e),a(F,$k),a(F,jt),a(jt,Nk),a(F,Fk),a(F,Kt),a(Kt,Zk),a(F,zk),a(F,Qt),a(Qt,Xk),a(F,Yk),o(n,Sl,e),o(n,za,e),a(za,Vk),o(n,Il,e),o(n,Ms,e),Ms.innerHTML=gy,o(n,Ml,e),o(n,Tn,e),a(Tn,qk),a(Tn,ht),a(ht,Jk),a(Tn,Uk),o(n,Hl,e),o(n,Hs,e),Hs.innerHTML=nm,o(n,Bl,e),o(n,h,e),a(h,Wk),a(h,gt),a(gt,jk),a(h,Kk),a(h,np),a(np,Qk),a(h,hk),o(n,Ll,e),o(n,Bs,e),Bs.innerHTML=sm,o(n,xl,e),o(n,g,e),a(g,gk),a(g,sp),a(sp,nf),a(g,sf),a(g,ap),a(ap,af),a(g,tf),o(n,Al,e),o(n,Ls,e),Ls.innerHTML=am,o(n,$l,e),o(n,nn,e),a(nn,pf),a(nn,tp),a(tp,ef),a(nn,of),a(nn,pp),a(pp,lf),a(nn,cf),o(n,Nl,e),o(n,xs,e),xs.innerHTML=tm,o(n,Fl,e),o(n,D,e),a(D,uf),a(D,ep),a(ep,rf),a(D,kf),a(D,op),a(op,ff),a(D,df),a(D,lp),a(lp,Ef),a(D,vf),a(D,cp),a(cp,_f),a(D,bf),o(n,Zl,e),o(n,As,e),As.innerHTML=pm,o(n,zl,e),o(n,Xa,e),a(Xa,yf),o(n,Xl,e),o(n,Yl,e),o(n,Vl,e),o(n,Ya,e),a(Ya,mf),o(n,ql,e),o(n,O,e),a(O,wf),a(O,up),a(up,Pf),a(O,Of),a(O,ip),a(ip,Tf),a(O,Df),a(O,rp),a(rp,Cf),a(O,Rf),a(O,kp),a(kp,Gf),a(O,Sf),a(O,fp),a(fp,If),a(O,Mf),o(n,Jl,e),o(n,Dn,e),a(Dn,Hf),a(Dn,dp),a(dp,Bf),a(Dn,Lf),o(n,Ul,e),o(n,Wl,e),o(n,jl,e),o(n,Kl,e),o(n,Cn,e),a(Cn,Rn),a(Rn,Ep),a(Cn,xf),o(n,Ql,e),o(n,hl,e),o(n,gl,e),o(n,Va,e),a(Va,Af),o(n,nc,e),o(n,qa,e),a(qa,$f),o(n,sc,e),o(n,$s,e),$s.innerHTML=em,o(n,ac,e),o(n,Ja,e),a(Ja,Nf),o(n,tc,e),o(n,Z,e),a(Z,z),a(z,vp),a(vp,Ff),a(z,Zf),a(z,_p),a(_p,zf),a(z,Xf),a(z,bp),a(bp,Yf),a(z,Vf),a(z,yp),a(yp,qf),a(z,Jf),a(Z,Uf),a(Z,B),a(B,Wf),a(B,mp),a(mp,jf),a(B,Kf),a(B,wp),a(wp,Qf),a(B,hf),a(B,Pp),a(Pp,gf),a(B,n1),a(B,Op),a(Op,s1),a(B,a1),a(Z,t1),a(Z,m),a(m,p1),a(m,Tp),a(Tp,e1),a(m,o1),a(m,Dp),a(Dp,l1),a(m,c1),a(m,Cp),a(Cp,u1),a(m,i1),a(m,Rp),a(Rp,r1),a(m,k1),a(m,Gp),a(Gp,f1),a(m,d1),a(m,Sp),a(Sp,E1),a(m,v1),a(Z,_1),a(Z,w),a(w,b1),a(w,Ip),a(Ip,y1),a(w,m1),a(w,Mp),a(Mp,w1),a(w,P1),a(w,Hp),a(Hp,O1),a(w,T1),a(w,Bp),a(Bp,D1),a(w,C1),a(w,Lp),a(Lp,R1),a(w,G1),a(w,xp),a(xp,S1),a(w,I1),o(n,pc,e),o(n,ec,e),o(n,oc,e),o(n,Ua,e),a(Ua,M1),o(n,lc,e),o(n,Ns,e),Ns.innerHTML=om,o(n,cc,e),o(n,X,e),a(X,H1),a(X,Ap),a(Ap,B1),a(X,L1),a(X,$p),a($p,x1),a(X,A1),a(X,Np),a(Np,$1),a(X,N1),o(n,uc,e),o(n,Gn,e),a(Gn,F1),a(Gn,Fp),a(Fp,Z1),a(Gn,z1),o(n,ic,e),o(n,Fs,e),Fs.innerHTML=lm,o(n,rc,e),o(n,Wa,e),a(Wa,X1),o(n,kc,e),o(n,Zs,e),Zs.innerHTML=cm,o(n,fc,e),o(n,dc,e),o(n,Ec,e),o(n,Sn,e),a(Sn,Y1),a(Sn,Zp),a(Zp,V1),a(Sn,q1),o(n,vc,e),o(n,zs,e),zs.innerHTML=um,o(n,_c,e),o(n,ja,e),a(ja,J1),o(n,bc,e),o(n,Xs,e),Xs.innerHTML=im,o(n,yc,e),o(n,P,e),a(P,zp),a(zp,U1),a(P,W1),a(P,Xp),a(Xp,j1),a(P,K1),a(P,Yp),a(Yp,Q1),a(P,h1),a(P,Vp),a(Vp,g1),a(P,n2),a(P,qp),a(qp,s2),a(P,a2),a(P,Jp),a(Jp,t2),a(P,p2),o(n,mc,e),o(n,y,e),a(y,e2),a(y,Up),a(Up,o2),a(y,l2),a(y,Wp),a(Wp,c2),a(y,u2),a(y,jp),a(jp,i2),a(y,r2),a(y,Kp),a(Kp,k2),a(y,f2),a(y,Qp),a(Qp,d2),a(y,E2),a(y,hp),a(hp,v2),a(y,_2),o(n,wc,e),o(n,Ys,e),Ys.innerHTML=rm,o(n,Pc,e),o(n,In,e),a(In,b2),a(In,gp),a(gp,y2),a(In,m2),o(n,Oc,e),o(n,Vs,e),Vs.innerHTML=km,o(n,Tc,e),o(n,Ka,e),a(Ka,w2),o(n,Dc,e),o(n,qs,e),qs.innerHTML=fm,o(n,Cc,e),o(n,Qa,e),a(Qa,P2),o(n,Rc,e),o(n,Gc,e),o(n,Sc,e),o(n,Ic,e),o(n,Mn,e),a(Mn,Hn),a(Hn,ne),a(Mn,O2),o(n,Mc,e),o(n,Hc,e),o(n,Bc,e),o(n,ha,e),a(ha,T2),o(n,Lc,e),o(n,Js,e),Js.innerHTML=dm,o(n,xc,e),o(n,Y,e),a(Y,D2),a(Y,se),a(se,C2),a(Y,R2),a(Y,ae),a(ae,G2),a(Y,S2),a(Y,te),a(te,I2),a(Y,M2),o(n,Ac,e),o(n,ga,e),a(ga,H2),o(n,$c,e),o(n,Us,e),Us.innerHTML=Em,o(n,Nc,e),o(n,nt,e),a(nt,B2),o(n,Fc,e),o(n,Ws,e),Ws.innerHTML=vm,o(n,Zc,e),o(n,zc,e),o(n,Xc,e),o(n,Yc,e),o(n,Bn,e),a(Bn,Ln),a(Ln,pe),a(Bn,L2),o(n,Vc,e),o(n,qc,e),o(n,Jc,e),o(n,Q,e),a(Q,ee),a(ee,x2),a(Q,A2),a(Q,oe),a(oe,$2),a(Q,N2),a(Q,le),a(le,F2),a(Q,Z2),o(n,Uc,e),o(n,js,e),js.innerHTML=_m,o(n,Wc,e),o(n,st,e),a(st,z2),o(n,jc,e),o(n,Ks,e),Ks.innerHTML=bm,o(n,Kc,e),o(n,C,e),a(C,X2),a(C,ce),a(ce,Y2),a(C,V2),a(C,ue),a(ue,q2),a(C,J2),a(C,ie),a(ie,U2),a(C,W2),a(C,re),a(re,j2),a(C,K2),o(n,Qc,e),o(n,xn,e),a(xn,Q2),a(xn,ke),a(ke,h2),a(xn,g2),o(n,hc,e),o(n,Qs,e),Qs.innerHTML=ym,o(n,gc,e),o(n,d,e),a(d,fe),a(fe,nd),a(d,sd),a(d,de),a(de,ad),a(d,td),a(d,Ee),a(Ee,pd),a(d,ed),a(d,ve),a(ve,od),a(d,ld),a(d,_e),a(_e,cd),a(d,ud),a(d,be),a(be,id),a(d,rd),a(d,ye),a(ye,kd),a(d,fd),a(d,me),a(me,dd),a(d,Ed),a(d,we),a(we,vd),a(d,_d),o(n,nu,e),o(n,su,e),o(n,au,e),o(n,An,e),a(An,bd),a(An,Pe),a(Pe,yd),a(An,md),o(n,tu,e),o(n,hs,e),hs.innerHTML=mm,o(n,pu,e),o(n,at,e),a(at,wd),o(n,eu,e),o(n,gs,e),gs.innerHTML=wm,o(n,ou,e),o(n,tt,e),a(tt,Pd),o(n,lu,e),o(n,na,e),na.innerHTML=Pm,o(n,cu,e),o(n,uu,e),o(n,iu,e),o(n,ru,e),o(n,$n,e),a($n,Nn),a(Nn,Oe),a($n,Od),o(n,ku,e),o(n,fu,e),o(n,du,e),o(n,T,e),a(T,Td),a(T,Te),a(Te,Dd),a(T,Cd),a(T,De),a(De,Rd),a(T,Gd),a(T,Ce),a(Ce,Sd),a(T,Id),a(T,Re),a(Re,Md),a(T,Hd),a(T,Ge),a(Ge,Bd),a(T,Ld),o(n,Eu,e),o(n,sa,e),sa.innerHTML=Om,o(n,vu,e),o(n,f,e),a(f,xd),a(f,Se),a(Se,Ad),a(f,$d),a(f,Ie),a(Ie,Nd),a(f,Fd),a(f,Me),a(Me,Zd),a(f,zd),a(f,He),a(He,Xd),a(f,Yd),a(f,Be),a(Be,Vd),a(f,qd),a(f,Le),a(Le,Jd),a(f,Ud),a(f,xe),a(xe,Wd),a(f,jd),a(f,Ae),a(Ae,Kd),a(f,Qd),a(f,$e),a($e,hd),a(f,gd),o(n,_u,e),o(n,sn,e),a(sn,n3),a(sn,Ne),a(Ne,s3),a(sn,a3),a(sn,Fe),a(Fe,t3),a(sn,p3),o(n,bu,e),o(n,aa,e),aa.innerHTML=Tm,o(n,yu,e),o(n,an,e),a(an,e3),a(an,Ze),a(Ze,o3),a(an,l3),a(an,ze),a(ze,c3),a(an,u3),o(n,mu,e),o(n,ta,e),ta.innerHTML=Dm,o(n,wu,e),o(n,pt,e),a(pt,i3),o(n,Pu,e),o(n,pa,e),pa.innerHTML=Cm,o(n,Ou,e),o(n,Fn,e),a(Fn,r3),a(Fn,Xe),a(Xe,k3),a(Fn,f3),o(n,Tu,e),o(n,ea,e),ea.innerHTML=Rm,o(n,Du,e),o(n,et,e),a(et,d3),o(n,Cu,e),o(n,oa,e),oa.innerHTML=Gm,o(n,Ru,e),o(n,Gu,e),o(n,Su,e),o(n,Zn,e),a(Zn,E3),a(Zn,Ye),a(Ye,v3),a(Zn,_3),o(n,Iu,e),o(n,la,e),la.innerHTML=Sm,o(n,Mu,e),o(n,R,e),a(R,b3),a(R,Ve),a(Ve,y3),a(R,m3),a(R,qe),a(qe,w3),a(R,P3),a(R,Je),a(Je,O3),a(R,T3),a(R,Ue),a(Ue,D3),a(R,C3),o(n,Hu,e),o(n,ca,e),ca.innerHTML=Im,o(n,Bu,e),o(n,zn,e),a(zn,R3),a(zn,We),a(We,G3),a(zn,S3),o(n,Lu,e),o(n,ot,e),a(ot,I3),o(n,xu,e),o(n,ua,e),ua.innerHTML=Mm,o(n,Au,e),o(n,ia,e),a(ia,je),a(je,M3),a(ia,H3),o(n,$u,e),o(n,ra,e),ra.innerHTML=Hm,o(n,Nu,e),o(n,lt,e),a(lt,B3),o(n,Fu,e),o(n,Zu,e),o(n,zu,e),o(n,Xu,e),o(n,Xn,e),a(Xn,Yn),a(Yn,Ke),a(Xn,L3),o(n,Yu,e),o(n,Vu,e),o(n,qu,e),o(n,G,e),a(G,x3),a(G,Qe),a(Qe,A3),a(G,$3),a(G,he),a(he,N3),a(G,F3),a(G,ge),a(ge,Z3),a(G,z3),a(G,no),a(no,X3),a(G,Y3),o(n,Ju,e),o(n,ct,e),a(ct,V3),o(n,Uu,e),o(n,ka,e),ka.innerHTML=Bm,o(n,Wu,e),o(n,V,e),a(V,q3),a(V,so),a(so,J3),a(V,U3),a(V,ao),a(ao,W3),a(V,j3),a(V,to),a(to,K3),a(V,Q3),o(n,ju,e),o(n,Ku,e),o(n,Qu,e),o(n,hu,e),o(n,Vn,e),a(Vn,qn),a(qn,po),a(Vn,h3),o(n,gu,e),o(n,ni,e),o(n,si,e),o(n,Jn,e),a(Jn,g3),a(Jn,eo),a(eo,nE),a(Jn,sE),o(n,ai,e),o(n,tn,e),a(tn,aE),a(tn,oo),a(oo,tE),a(tn,pE),a(tn,lo),a(lo,eE),a(tn,oE),o(n,ti,e),o(n,fa,e),fa.innerHTML=Lm,o(n,pi,e),o(n,da,e),a(da,co),a(co,lE),a(da,cE),o(n,ei,e),o(n,Un,e),a(Un,uE),a(Un,uo),a(uo,iE),a(Un,rE),o(n,oi,e),o(n,Ea,e),Ea.innerHTML=xm,o(n,li,e),o(n,va,e),a(va,io),a(io,kE),a(va,fE),o(n,ci,e),o(n,_a,e),_a.innerHTML=Am,o(n,ui,e),o(n,Wn,e),a(Wn,dE),a(Wn,ro),a(ro,EE),a(Wn,vE),o(n,ii,e),o(n,ri,e),o(n,ki,e),o(n,fi,e),o(n,jn,e),a(jn,Kn),a(Kn,ko),a(jn,_E),o(n,di,e),o(n,Ei,e),o(n,vi,e),o(n,ut,e),a(ut,bE),o(n,_i,e),o(n,ba,e),ba.innerHTML=$m,o(n,bi,e),o(n,pn,e),a(pn,yE),a(pn,fo),a(fo,mE),a(pn,wE),a(pn,Eo),a(Eo,PE),a(pn,OE),o(n,yi,e),o(n,ya,e),ya.innerHTML=Nm,o(n,mi,e),o(n,ma,e),a(ma,vo),a(vo,TE),a(ma,DE),o(n,wi,e),o(n,wa,e),wa.innerHTML=Fm,o(n,Pi,e),o(n,Oi,e),o(n,Ti,e),o(n,_n,e),a(_n,_o),a(_o,CE),a(_n,RE),a(_n,bo),a(bo,GE),a(_n,SE),o(n,Di,e),o(n,Pa,e),Pa.innerHTML=Zm,o(n,Ci,e),o(n,en,e),a(en,IE),a(en,yo),a(yo,ME),a(en,HE),a(en,mo),a(mo,BE),a(en,LE),o(n,Ri,e),o(n,Oa,e),Oa.innerHTML=zm,o(n,Gi,e),o(n,on,e),a(on,xE),a(on,wo),a(wo,AE),a(on,$E),a(on,Po),a(Po,NE),a(on,FE),o(n,Si,e),o(n,Ta,e),Ta.innerHTML=Xm,o(n,Ii,e),o(n,Mi,e),o(n,Hi,e),o(n,Qn,e),a(Qn,ZE),a(Qn,Oo),a(Oo,zE),a(Qn,XE),o(n,Bi,e),o(n,Da,e),Da.innerHTML=Ym,o(n,Li,e),o(n,q,e),a(q,YE),a(q,To),a(To,VE),a(q,qE),a(q,Do),a(Do,JE),a(q,UE),a(q,Co),a(Co,WE),a(q,jE),o(n,xi,e),o(n,Ca,e),Ca.innerHTML=Vm,o(n,Ai,e),o(n,it,e),a(it,KE),o(n,$i,e),o(n,Ra,e),Ra.innerHTML=qm,o(n,Ni,e),o(n,ln,e),a(ln,QE),a(ln,Ro),a(Ro,hE),a(ln,gE),a(ln,Go),a(Go,nv),a(ln,sv),o(n,Fi,e),o(n,Ga,e),Ga.innerHTML=Jm,o(n,Zi,e),o(n,zi,e),o(n,Xi,e),o(n,Yi,e),o(n,hn,e),a(hn,gn),a(gn,So),a(hn,av),o(n,Vi,e),o(n,qi,e),o(n,Ji,e),o(n,rt,e),a(rt,tv),o(n,Ui,e),o(n,cn,e),a(cn,pv),a(cn,Io),a(Io,ev),a(cn,ov),a(cn,Mo),a(Mo,lv),a(cn,cv),o(n,Wi,e),o(n,ns,e),a(ns,uv),a(ns,Ho),a(Ho,iv),a(ns,rv),o(n,ji,e),o(n,J,e),a(J,kv),a(J,Bo),a(Bo,fv),a(J,dv),a(J,Lo),a(Lo,Ev),a(J,vv),a(J,xo),a(xo,_v),a(J,bv),o(n,Ki,e),o(n,Sa,e),Sa.innerHTML=Um,o(n,Qi,e),o(n,kt,e),a(kt,yv),o(n,hi,e),o(n,Ia,e),Ia.innerHTML=Wm,o(n,gi,e),o(n,ft,e),a(ft,mv),o(n,nr,e),o(n,dt,e),a(dt,wv),o(n,sr,e),o(n,Et,e),a(Et,Pv),o(n,ar,e),o(n,un,e),a(un,Ao),a(Ao,Ma),a(Ma,Ov),a(Ma,Tv),a(Ma,Dv),a(un,Cv),a(un,$o),a($o,No),a(No,Rv),a(un,Gv),a(un,Fo),a(Fo,Zo),a(Zo,Sv),o(n,tr,e),o(n,pr,e),o(n,er,e),o(n,or,e),o(n,ss,e),a(ss,as),a(as,zo),a(ss,Iv),o(n,lr,e),o(n,cr,e),o(n,ur,e),o(n,U,e),a(U,Mv),a(U,Xo),a(Xo,Hv),a(U,Bv),a(U,Yo),a(Yo,Lv),a(U,xv),a(U,Vo),a(Vo,Av),a(U,$v),o(n,ir,e),o(n,vt,e),a(vt,Nv),o(n,rr,e),o(n,_t,e),a(_t,Fv),o(n,kr,e),o(n,W,e),a(W,Zv),z5(ts,W,null),a(W,zv),z5(ps,W,null),a(W,Xv),z5(es,W,null),a(W,Yv),o(n,fr,e),o(n,dr,e),o(n,Er,e),o(n,vr,e),o(n,os,e),a(os,ls),a(ls,qo),a(os,Vv),o(n,_r,e),o(n,br,e),o(n,yr,e),o(n,S,e),a(S,qv),a(S,Jo),a(Jo,Jv),a(S,Uv),a(S,Uo),a(Uo,Wv),a(S,jv),a(S,Wo),a(Wo,Kv),a(S,Qv),a(S,jo),a(jo,hv),a(S,gv),o(n,mr,e),o(n,cs,e),a(cs,n5),a(cs,Ko),a(Ko,s5),a(cs,a5),o(n,wr,e),o(n,us,e),a(us,t5),a(us,Qo),a(Qo,p5),a(us,e5),o(n,Pr,e),o(n,is,e),a(is,o5),a(is,ho),a(ho,l5),a(is,c5),o(n,Or,e),o(n,Tr,e),o(n,Dr,e),o(n,Cr,e),o(n,rs,e),a(rs,ks),a(ks,go),a(rs,u5),o(n,Rr,e),o(n,Gr,e),o(n,Sr,e),o(n,bt,e),a(bt,i5),o(n,Ir,e),o(n,yt,e),a(yt,r5),o(n,Mr,e),o(n,fs,e),a(fs,k5),a(fs,Ha),a(Ha,f5),a(fs,d5),o(n,Hr,e),o(n,mt,e),a(mt,E5),o(n,Br,e),o(n,wt,e),a(wt,v5),o(n,Lr,e),o(n,xr,e),o(n,Ar,e),o(n,$r,e),o(n,ds,e),a(ds,Es),a(Es,nl),a(ds,_5),o(n,Nr,e),o(n,Fr,e),o(n,Zr,e),o(n,Pt,e),a(Pt,bn),a(bn,Ba),a(Ba,Ot),a(bn,b5),a(bn,y5),a(bn,m5),a(bn,La),a(La,w5),zr=!0},p(n,[e]){const Tt={};e&1&&(Tt.$$scope={dirty:e,ctx:n}),ts.$set(Tt);const sl={};e&1&&(sl.$$scope={dirty:e,ctx:n}),ps.$set(sl);const al={};e&1&&(al.$$scope={dirty:e,ctx:n}),es.$set(al)},i(n){zr||(X5(ts.$$.fragment,n),X5(ps.$$.fragment,n),X5(es.$$.fragment,n),zr=!0)},o(n){Y5(ts.$$.fragment,n),Y5(ps.$$.fragment,n),Y5(es.$$.fragment,n),zr=!1},d(n){n&&s(v),n&&s(E),n&&s(x),n&&s(pl),n&&s(el),n&&s(ol),n&&s(ll),n&&s(mn),n&&s(cl),n&&s(ul),n&&s(il),n&&s(Aa),n&&s(rl),n&&s($a),n&&s(kl),n&&s(fl),n&&s(dl),n&&s(Na),n&&s(El),n&&s(Fa),n&&s(vl),n&&s(_l),n&&s(bl),n&&s(yl),n&&s(Pn),n&&s(ml),n&&s(A),n&&s(wl),n&&s($),n&&s(Pl),n&&s(Ss),n&&s(Ol),n&&s(N),n&&s(Tl),n&&s(Is),n&&s(Dl),n&&s(Cl),n&&s(Rl),n&&s(Za),n&&s(Gl),n&&s(F),n&&s(Sl),n&&s(za),n&&s(Il),n&&s(Ms),n&&s(Ml),n&&s(Tn),n&&s(Hl),n&&s(Hs),n&&s(Bl),n&&s(h),n&&s(Ll),n&&s(Bs),n&&s(xl),n&&s(g),n&&s(Al),n&&s(Ls),n&&s($l),n&&s(nn),n&&s(Nl),n&&s(xs),n&&s(Fl),n&&s(D),n&&s(Zl),n&&s(As),n&&s(zl),n&&s(Xa),n&&s(Xl),n&&s(Yl),n&&s(Vl),n&&s(Ya),n&&s(ql),n&&s(O),n&&s(Jl),n&&s(Dn),n&&s(Ul),n&&s(Wl),n&&s(jl),n&&s(Kl),n&&s(Cn),n&&s(Ql),n&&s(hl),n&&s(gl),n&&s(Va),n&&s(nc),n&&s(qa),n&&s(sc),n&&s($s),n&&s(ac),n&&s(Ja),n&&s(tc),n&&s(Z),n&&s(pc),n&&s(ec),n&&s(oc),n&&s(Ua),n&&s(lc),n&&s(Ns),n&&s(cc),n&&s(X),n&&s(uc),n&&s(Gn),n&&s(ic),n&&s(Fs),n&&s(rc),n&&s(Wa),n&&s(kc),n&&s(Zs),n&&s(fc),n&&s(dc),n&&s(Ec),n&&s(Sn),n&&s(vc),n&&s(zs),n&&s(_c),n&&s(ja),n&&s(bc),n&&s(Xs),n&&s(yc),n&&s(P),n&&s(mc),n&&s(y),n&&s(wc),n&&s(Ys),n&&s(Pc),n&&s(In),n&&s(Oc),n&&s(Vs),n&&s(Tc),n&&s(Ka),n&&s(Dc),n&&s(qs),n&&s(Cc),n&&s(Qa),n&&s(Rc),n&&s(Gc),n&&s(Sc),n&&s(Ic),n&&s(Mn),n&&s(Mc),n&&s(Hc),n&&s(Bc),n&&s(ha),n&&s(Lc),n&&s(Js),n&&s(xc),n&&s(Y),n&&s(Ac),n&&s(ga),n&&s($c),n&&s(Us),n&&s(Nc),n&&s(nt),n&&s(Fc),n&&s(Ws),n&&s(Zc),n&&s(zc),n&&s(Xc),n&&s(Yc),n&&s(Bn),n&&s(Vc),n&&s(qc),n&&s(Jc),n&&s(Q),n&&s(Uc),n&&s(js),n&&s(Wc),n&&s(st),n&&s(jc),n&&s(Ks),n&&s(Kc),n&&s(C),n&&s(Qc),n&&s(xn),n&&s(hc),n&&s(Qs),n&&s(gc),n&&s(d),n&&s(nu),n&&s(su),n&&s(au),n&&s(An),n&&s(tu),n&&s(hs),n&&s(pu),n&&s(at),n&&s(eu),n&&s(gs),n&&s(ou),n&&s(tt),n&&s(lu),n&&s(na),n&&s(cu),n&&s(uu),n&&s(iu),n&&s(ru),n&&s($n),n&&s(ku),n&&s(fu),n&&s(du),n&&s(T),n&&s(Eu),n&&s(sa),n&&s(vu),n&&s(f),n&&s(_u),n&&s(sn),n&&s(bu),n&&s(aa),n&&s(yu),n&&s(an),n&&s(mu),n&&s(ta),n&&s(wu),n&&s(pt),n&&s(Pu),n&&s(pa),n&&s(Ou),n&&s(Fn),n&&s(Tu),n&&s(ea),n&&s(Du),n&&s(et),n&&s(Cu),n&&s(oa),n&&s(Ru),n&&s(Gu),n&&s(Su),n&&s(Zn),n&&s(Iu),n&&s(la),n&&s(Mu),n&&s(R),n&&s(Hu),n&&s(ca),n&&s(Bu),n&&s(zn),n&&s(Lu),n&&s(ot),n&&s(xu),n&&s(ua),n&&s(Au),n&&s(ia),n&&s($u),n&&s(ra),n&&s(Nu),n&&s(lt),n&&s(Fu),n&&s(Zu),n&&s(zu),n&&s(Xu),n&&s(Xn),n&&s(Yu),n&&s(Vu),n&&s(qu),n&&s(G),n&&s(Ju),n&&s(ct),n&&s(Uu),n&&s(ka),n&&s(Wu),n&&s(V),n&&s(ju),n&&s(Ku),n&&s(Qu),n&&s(hu),n&&s(Vn),n&&s(gu),n&&s(ni),n&&s(si),n&&s(Jn),n&&s(ai),n&&s(tn),n&&s(ti),n&&s(fa),n&&s(pi),n&&s(da),n&&s(ei),n&&s(Un),n&&s(oi),n&&s(Ea),n&&s(li),n&&s(va),n&&s(ci),n&&s(_a),n&&s(ui),n&&s(Wn),n&&s(ii),n&&s(ri),n&&s(ki),n&&s(fi),n&&s(jn),n&&s(di),n&&s(Ei),n&&s(vi),n&&s(ut),n&&s(_i),n&&s(ba),n&&s(bi),n&&s(pn),n&&s(yi),n&&s(ya),n&&s(mi),n&&s(ma),n&&s(wi),n&&s(wa),n&&s(Pi),n&&s(Oi),n&&s(Ti),n&&s(_n),n&&s(Di),n&&s(Pa),n&&s(Ci),n&&s(en),n&&s(Ri),n&&s(Oa),n&&s(Gi),n&&s(on),n&&s(Si),n&&s(Ta),n&&s(Ii),n&&s(Mi),n&&s(Hi),n&&s(Qn),n&&s(Bi),n&&s(Da),n&&s(Li),n&&s(q),n&&s(xi),n&&s(Ca),n&&s(Ai),n&&s(it),n&&s($i),n&&s(Ra),n&&s(Ni),n&&s(ln),n&&s(Fi),n&&s(Ga),n&&s(Zi),n&&s(zi),n&&s(Xi),n&&s(Yi),n&&s(hn),n&&s(Vi),n&&s(qi),n&&s(Ji),n&&s(rt),n&&s(Ui),n&&s(cn),n&&s(Wi),n&&s(ns),n&&s(ji),n&&s(J),n&&s(Ki),n&&s(Sa),n&&s(Qi),n&&s(kt),n&&s(hi),n&&s(Ia),n&&s(gi),n&&s(ft),n&&s(nr),n&&s(dt),n&&s(sr),n&&s(Et),n&&s(ar),n&&s(un),n&&s(tr),n&&s(pr),n&&s(er),n&&s(or),n&&s(ss),n&&s(lr),n&&s(cr),n&&s(ur),n&&s(U),n&&s(ir),n&&s(vt),n&&s(rr),n&&s(_t),n&&s(kr),n&&s(W),V5(ts),V5(ps),V5(es),n&&s(fr),n&&s(dr),n&&s(Er),n&&s(vr),n&&s(os),n&&s(_r),n&&s(br),n&&s(yr),n&&s(S),n&&s(mr),n&&s(cs),n&&s(wr),n&&s(us),n&&s(Pr),n&&s(is),n&&s(Or),n&&s(Tr),n&&s(Dr),n&&s(Cr),n&&s(rs),n&&s(Rr),n&&s(Gr),n&&s(Sr),n&&s(bt),n&&s(Ir),n&&s(yt),n&&s(Mr),n&&s(fs),n&&s(Hr),n&&s(mt),n&&s(Br),n&&s(wt),n&&s(Lr),n&&s(xr),n&&s(Ar),n&&s($r),n&&s(ds),n&&s(Nr),n&&s(Fr),n&&s(Zr),n&&s(Pt)}}}const t0={title:"Generics in Go",date:"2023-03-01T00:00:00.000Z",excerpt:"'Learning Go'를 읽고, Go의 제네릭 프로그래밍에 대해 알아보았습니다",categories:["Golang","Basic Golang"],coverImage:"/post_img/Go/Golang_basics/cover.png",coverWidth:16,coverHeight:9,indexed:!1,exposed:!0};class p0 extends U6{constructor(v){super(),W6(this,v,null,n0,j6,{})}}export{p0 as default,t0 as metadata};
